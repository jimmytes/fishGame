(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS((exports, module) => {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events2() {
    }
    if (Object.create) {
      Events2.prototype = Object.create(null);
      if (!new Events2().__proto__)
        prefix = false;
    }
    function EE(fn, context4, once) {
      this.fn = fn;
      this.context = context4;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context4, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context4 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events2();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context4) {
      return addListener(this, event, fn, context4, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context4) {
      return addListener(this, event, fn, context4, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context4 && listeners[i2].context !== context4) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if (typeof module !== "undefined") {
      module.exports = EventEmitter2;
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS((exports, module) => {
    module.exports = parse2;
    var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0};
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse2(path2) {
      var data = [];
      path2.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length[type]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length[type])
            throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length[type])));
        }
      });
      return data;
    }
    var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number);
      return numbers ? numbers.map(Number) : [];
    }
  });

  // node_modules/pixi.js/lib/environment-browser/browserAll.mjs
  var require_browserAll = __commonJS(() => {
  });

  // node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
  var require_webworkerAll = __commonJS(() => {
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var require_WebGPURenderer = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      WebGPURenderer: () => WebGPURenderer
    });
    var DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuUboSystem,
      GpuEncoderSystem,
      GpuDeviceSystem,
      GpuLimitsSystem,
      GpuBufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    var DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
    var DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    var systems = [];
    var renderPipes = [];
    var renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    var WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var require_WebGLRenderer = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      WebGLRenderer: () => WebGLRenderer
    });
    var DefaultWebGLSystems = [
      ...SharedSystems,
      GlUboSystem,
      GlBackBufferSystem,
      GlContextSystem,
      GlLimitsSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    var DefaultWebGLPipes = [...SharedRenderPipes];
    var DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    var systems = [];
    var renderPipes = [];
    var renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    var WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl",
          type: RendererType.WEBGL,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  });

  // node_modules/matter-js/build/matter.js
  var require_matter = __commonJS((exports, module) => {
    /*!
     * matter-js 0.20.0 by @liabru
     * http://brm.io/matter-js/
     * License MIT
     * 
     * The MIT License (MIT)
     * 
     * Copyright (c) Liam Brummitt and contributors.
     * 
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     * 
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Matter", [], factory);
      else if (typeof exports === "object")
        exports["Matter"] = factory();
      else
        root["Matter"] = factory();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {enumerable: true, get: getter});
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, {value: "Module"});
          }
          Object.defineProperty(exports2, "__esModule", {value: true});
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", {enumerable: true, value});
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 20);
      }([
        function(module2, exports2) {
          var Common = {};
          module2.exports = Common;
          (function() {
            Common._baseDelta = 1e3 / 60;
            Common._nextId = 0;
            Common._seed = 0;
            Common._nowStartTime = +new Date();
            Common._warnedOnce = {};
            Common._decomp = null;
            Common.extend = function(obj, deep) {
              var argsStart, args, deepClone;
              if (typeof deep === "boolean") {
                argsStart = 2;
                deepClone = deep;
              } else {
                argsStart = 1;
                deepClone = true;
              }
              for (var i2 = argsStart; i2 < arguments.length; i2++) {
                var source3 = arguments[i2];
                if (source3) {
                  for (var prop in source3) {
                    if (deepClone && source3[prop] && source3[prop].constructor === Object) {
                      if (!obj[prop] || obj[prop].constructor === Object) {
                        obj[prop] = obj[prop] || {};
                        Common.extend(obj[prop], deepClone, source3[prop]);
                      } else {
                        obj[prop] = source3[prop];
                      }
                    } else {
                      obj[prop] = source3[prop];
                    }
                  }
                }
              }
              return obj;
            };
            Common.clone = function(obj, deep) {
              return Common.extend({}, deep, obj);
            };
            Common.keys = function(obj) {
              if (Object.keys)
                return Object.keys(obj);
              var keys = [];
              for (var key in obj)
                keys.push(key);
              return keys;
            };
            Common.values = function(obj) {
              var values = [];
              if (Object.keys) {
                var keys = Object.keys(obj);
                for (var i2 = 0; i2 < keys.length; i2++) {
                  values.push(obj[keys[i2]]);
                }
                return values;
              }
              for (var key in obj)
                values.push(obj[key]);
              return values;
            };
            Common.get = function(obj, path2, begin3, end) {
              path2 = path2.split(".").slice(begin3, end);
              for (var i2 = 0; i2 < path2.length; i2 += 1) {
                obj = obj[path2[i2]];
              }
              return obj;
            };
            Common.set = function(obj, path2, val, begin3, end) {
              var parts = path2.split(".").slice(begin3, end);
              Common.get(obj, path2, 0, -1)[parts[parts.length - 1]] = val;
              return val;
            };
            Common.shuffle = function(array) {
              for (var i2 = array.length - 1; i2 > 0; i2--) {
                var j2 = Math.floor(Common.random() * (i2 + 1));
                var temp = array[i2];
                array[i2] = array[j2];
                array[j2] = temp;
              }
              return array;
            };
            Common.choose = function(choices) {
              return choices[Math.floor(Common.random() * choices.length)];
            };
            Common.isElement = function(obj) {
              if (typeof HTMLElement !== "undefined") {
                return obj instanceof HTMLElement;
              }
              return !!(obj && obj.nodeType && obj.nodeName);
            };
            Common.isArray = function(obj) {
              return Object.prototype.toString.call(obj) === "[object Array]";
            };
            Common.isFunction = function(obj) {
              return typeof obj === "function";
            };
            Common.isPlainObject = function(obj) {
              return typeof obj === "object" && obj.constructor === Object;
            };
            Common.isString = function(obj) {
              return toString.call(obj) === "[object String]";
            };
            Common.clamp = function(value, min, max) {
              if (value < min)
                return min;
              if (value > max)
                return max;
              return value;
            };
            Common.sign = function(value) {
              return value < 0 ? -1 : 1;
            };
            Common.now = function() {
              if (typeof window !== "undefined" && window.performance) {
                if (window.performance.now) {
                  return window.performance.now();
                } else if (window.performance.webkitNow) {
                  return window.performance.webkitNow();
                }
              }
              if (Date.now) {
                return Date.now();
              }
              return new Date() - Common._nowStartTime;
            };
            Common.random = function(min, max) {
              min = typeof min !== "undefined" ? min : 0;
              max = typeof max !== "undefined" ? max : 1;
              return min + _seededRandom() * (max - min);
            };
            var _seededRandom = function() {
              Common._seed = (Common._seed * 9301 + 49297) % 233280;
              return Common._seed / 233280;
            };
            Common.colorToNumber = function(colorString) {
              colorString = colorString.replace("#", "");
              if (colorString.length == 3) {
                colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
              }
              return parseInt(colorString, 16);
            };
            Common.logLevel = 1;
            Common.log = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.info = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.warn = function() {
              if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
              }
            };
            Common.warnOnce = function() {
              var message = Array.prototype.slice.call(arguments).join(" ");
              if (!Common._warnedOnce[message]) {
                Common.warn(message);
                Common._warnedOnce[message] = true;
              }
            };
            Common.deprecated = function(obj, prop, warning) {
              obj[prop] = Common.chain(function() {
                Common.warnOnce("\u{1F505} deprecated \u{1F505}", warning);
              }, obj[prop]);
            };
            Common.nextId = function() {
              return Common._nextId++;
            };
            Common.indexOf = function(haystack, needle) {
              if (haystack.indexOf)
                return haystack.indexOf(needle);
              for (var i2 = 0; i2 < haystack.length; i2++) {
                if (haystack[i2] === needle)
                  return i2;
              }
              return -1;
            };
            Common.map = function(list, func) {
              if (list.map) {
                return list.map(func);
              }
              var mapped = [];
              for (var i2 = 0; i2 < list.length; i2 += 1) {
                mapped.push(func(list[i2]));
              }
              return mapped;
            };
            Common.topologicalSort = function(graph) {
              var result = [], visited = [], temp = [];
              for (var node in graph) {
                if (!visited[node] && !temp[node]) {
                  Common._topologicalSort(node, visited, temp, graph, result);
                }
              }
              return result;
            };
            Common._topologicalSort = function(node, visited, temp, graph, result) {
              var neighbors = graph[node] || [];
              temp[node] = true;
              for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
                var neighbor = neighbors[i2];
                if (temp[neighbor]) {
                  continue;
                }
                if (!visited[neighbor]) {
                  Common._topologicalSort(neighbor, visited, temp, graph, result);
                }
              }
              temp[node] = false;
              visited[node] = true;
              result.push(node);
            };
            Common.chain = function() {
              var funcs = [];
              for (var i2 = 0; i2 < arguments.length; i2 += 1) {
                var func = arguments[i2];
                if (func._chained) {
                  funcs.push.apply(funcs, func._chained);
                } else {
                  funcs.push(func);
                }
              }
              var chain = function() {
                var lastResult, args = new Array(arguments.length);
                for (var i3 = 0, l2 = arguments.length; i3 < l2; i3++) {
                  args[i3] = arguments[i3];
                }
                for (i3 = 0; i3 < funcs.length; i3 += 1) {
                  var result = funcs[i3].apply(lastResult, args);
                  if (typeof result !== "undefined") {
                    lastResult = result;
                  }
                }
                return lastResult;
              };
              chain._chained = funcs;
              return chain;
            };
            Common.chainPathBefore = function(base, path2, func) {
              return Common.set(base, path2, Common.chain(func, Common.get(base, path2)));
            };
            Common.chainPathAfter = function(base, path2, func) {
              return Common.set(base, path2, Common.chain(Common.get(base, path2), func));
            };
            Common.setDecomp = function(decomp) {
              Common._decomp = decomp;
            };
            Common.getDecomp = function() {
              var decomp = Common._decomp;
              try {
                if (!decomp && typeof window !== "undefined") {
                  decomp = window.decomp;
                }
                if (!decomp && typeof global !== "undefined") {
                  decomp = global.decomp;
                }
              } catch (e2) {
                decomp = null;
              }
              return decomp;
            };
          })();
        },
        function(module2, exports2) {
          var Bounds2 = {};
          module2.exports = Bounds2;
          (function() {
            Bounds2.create = function(vertices) {
              var bounds = {
                min: {x: 0, y: 0},
                max: {x: 0, y: 0}
              };
              if (vertices)
                Bounds2.update(bounds, vertices);
              return bounds;
            };
            Bounds2.update = function(bounds, vertices, velocity) {
              bounds.min.x = Infinity;
              bounds.max.x = -Infinity;
              bounds.min.y = Infinity;
              bounds.max.y = -Infinity;
              for (var i2 = 0; i2 < vertices.length; i2++) {
                var vertex4 = vertices[i2];
                if (vertex4.x > bounds.max.x)
                  bounds.max.x = vertex4.x;
                if (vertex4.x < bounds.min.x)
                  bounds.min.x = vertex4.x;
                if (vertex4.y > bounds.max.y)
                  bounds.max.y = vertex4.y;
                if (vertex4.y < bounds.min.y)
                  bounds.min.y = vertex4.y;
              }
              if (velocity) {
                if (velocity.x > 0) {
                  bounds.max.x += velocity.x;
                } else {
                  bounds.min.x += velocity.x;
                }
                if (velocity.y > 0) {
                  bounds.max.y += velocity.y;
                } else {
                  bounds.min.y += velocity.y;
                }
              }
            };
            Bounds2.contains = function(bounds, point) {
              return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
            };
            Bounds2.overlaps = function(boundsA, boundsB) {
              return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
            };
            Bounds2.translate = function(bounds, vector) {
              bounds.min.x += vector.x;
              bounds.max.x += vector.x;
              bounds.min.y += vector.y;
              bounds.max.y += vector.y;
            };
            Bounds2.shift = function(bounds, position) {
              var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
              bounds.min.x = position.x;
              bounds.max.x = position.x + deltaX;
              bounds.min.y = position.y;
              bounds.max.y = position.y + deltaY;
            };
          })();
        },
        function(module2, exports2) {
          var Vector = {};
          module2.exports = Vector;
          (function() {
            Vector.create = function(x2, y2) {
              return {x: x2 || 0, y: y2 || 0};
            };
            Vector.clone = function(vector) {
              return {x: vector.x, y: vector.y};
            };
            Vector.magnitude = function(vector) {
              return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
            };
            Vector.magnitudeSquared = function(vector) {
              return vector.x * vector.x + vector.y * vector.y;
            };
            Vector.rotate = function(vector, angle, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output)
                output = {};
              var x2 = vector.x * cos - vector.y * sin;
              output.y = vector.x * sin + vector.y * cos;
              output.x = x2;
              return output;
            };
            Vector.rotateAbout = function(vector, angle, point, output) {
              var cos = Math.cos(angle), sin = Math.sin(angle);
              if (!output)
                output = {};
              var x2 = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
              output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
              output.x = x2;
              return output;
            };
            Vector.normalise = function(vector) {
              var magnitude = Vector.magnitude(vector);
              if (magnitude === 0)
                return {x: 0, y: 0};
              return {x: vector.x / magnitude, y: vector.y / magnitude};
            };
            Vector.dot = function(vectorA, vectorB) {
              return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
            };
            Vector.cross = function(vectorA, vectorB) {
              return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
            };
            Vector.cross3 = function(vectorA, vectorB, vectorC) {
              return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
            };
            Vector.add = function(vectorA, vectorB, output) {
              if (!output)
                output = {};
              output.x = vectorA.x + vectorB.x;
              output.y = vectorA.y + vectorB.y;
              return output;
            };
            Vector.sub = function(vectorA, vectorB, output) {
              if (!output)
                output = {};
              output.x = vectorA.x - vectorB.x;
              output.y = vectorA.y - vectorB.y;
              return output;
            };
            Vector.mult = function(vector, scalar) {
              return {x: vector.x * scalar, y: vector.y * scalar};
            };
            Vector.div = function(vector, scalar) {
              return {x: vector.x / scalar, y: vector.y / scalar};
            };
            Vector.perp = function(vector, negate) {
              negate = negate === true ? -1 : 1;
              return {x: negate * -vector.y, y: negate * vector.x};
            };
            Vector.neg = function(vector) {
              return {x: -vector.x, y: -vector.y};
            };
            Vector.angle = function(vectorA, vectorB) {
              return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
            };
            Vector._temp = [
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create(),
              Vector.create()
            ];
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Vertices = {};
          module2.exports = Vertices;
          var Vector = __webpack_require__(2);
          var Common = __webpack_require__(0);
          (function() {
            Vertices.create = function(points, body) {
              var vertices = [];
              for (var i2 = 0; i2 < points.length; i2++) {
                var point = points[i2], vertex4 = {
                  x: point.x,
                  y: point.y,
                  index: i2,
                  body,
                  isInternal: false
                };
                vertices.push(vertex4);
              }
              return vertices;
            };
            Vertices.fromPath = function(path2, body) {
              var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
              path2.replace(pathPattern, function(match, x2, y2) {
                points.push({x: parseFloat(x2), y: parseFloat(y2)});
              });
              return Vertices.create(points, body);
            };
            Vertices.centre = function(vertices) {
              var area2 = Vertices.area(vertices, true), centre = {x: 0, y: 0}, cross, temp, j2;
              for (var i2 = 0; i2 < vertices.length; i2++) {
                j2 = (i2 + 1) % vertices.length;
                cross = Vector.cross(vertices[i2], vertices[j2]);
                temp = Vector.mult(Vector.add(vertices[i2], vertices[j2]), cross);
                centre = Vector.add(centre, temp);
              }
              return Vector.div(centre, 6 * area2);
            };
            Vertices.mean = function(vertices) {
              var average = {x: 0, y: 0};
              for (var i2 = 0; i2 < vertices.length; i2++) {
                average.x += vertices[i2].x;
                average.y += vertices[i2].y;
              }
              return Vector.div(average, vertices.length);
            };
            Vertices.area = function(vertices, signed) {
              var area2 = 0, j2 = vertices.length - 1;
              for (var i2 = 0; i2 < vertices.length; i2++) {
                area2 += (vertices[j2].x - vertices[i2].x) * (vertices[j2].y + vertices[i2].y);
                j2 = i2;
              }
              if (signed)
                return area2 / 2;
              return Math.abs(area2) / 2;
            };
            Vertices.inertia = function(vertices, mass) {
              var numerator = 0, denominator = 0, v2 = vertices, cross, j2;
              for (var n2 = 0; n2 < v2.length; n2++) {
                j2 = (n2 + 1) % v2.length;
                cross = Math.abs(Vector.cross(v2[j2], v2[n2]));
                numerator += cross * (Vector.dot(v2[j2], v2[j2]) + Vector.dot(v2[j2], v2[n2]) + Vector.dot(v2[n2], v2[n2]));
                denominator += cross;
              }
              return mass / 6 * (numerator / denominator);
            };
            Vertices.translate = function(vertices, vector, scalar) {
              scalar = typeof scalar !== "undefined" ? scalar : 1;
              var verticesLength = vertices.length, translateX = vector.x * scalar, translateY = vector.y * scalar, i2;
              for (i2 = 0; i2 < verticesLength; i2++) {
                vertices[i2].x += translateX;
                vertices[i2].y += translateY;
              }
              return vertices;
            };
            Vertices.rotate = function(vertices, angle, point) {
              if (angle === 0)
                return;
              var cos = Math.cos(angle), sin = Math.sin(angle), pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex4, dx2, dy2, i2;
              for (i2 = 0; i2 < verticesLength; i2++) {
                vertex4 = vertices[i2];
                dx2 = vertex4.x - pointX;
                dy2 = vertex4.y - pointY;
                vertex4.x = pointX + (dx2 * cos - dy2 * sin);
                vertex4.y = pointY + (dx2 * sin + dy2 * cos);
              }
              return vertices;
            };
            Vertices.contains = function(vertices, point) {
              var pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex4 = vertices[verticesLength - 1], nextVertex;
              for (var i2 = 0; i2 < verticesLength; i2++) {
                nextVertex = vertices[i2];
                if ((pointX - vertex4.x) * (nextVertex.y - vertex4.y) + (pointY - vertex4.y) * (vertex4.x - nextVertex.x) > 0) {
                  return false;
                }
                vertex4 = nextVertex;
              }
              return true;
            };
            Vertices.scale = function(vertices, scaleX, scaleY, point) {
              if (scaleX === 1 && scaleY === 1)
                return vertices;
              point = point || Vertices.centre(vertices);
              var vertex4, delta;
              for (var i2 = 0; i2 < vertices.length; i2++) {
                vertex4 = vertices[i2];
                delta = Vector.sub(vertex4, point);
                vertices[i2].x = point.x + delta.x * scaleX;
                vertices[i2].y = point.y + delta.y * scaleY;
              }
              return vertices;
            };
            Vertices.chamfer = function(vertices, radius2, quality, qualityMin, qualityMax) {
              if (typeof radius2 === "number") {
                radius2 = [radius2];
              } else {
                radius2 = radius2 || [8];
              }
              quality = typeof quality !== "undefined" ? quality : -1;
              qualityMin = qualityMin || 2;
              qualityMax = qualityMax || 14;
              var newVertices = [];
              for (var i2 = 0; i2 < vertices.length; i2++) {
                var prevVertex = vertices[i2 - 1 >= 0 ? i2 - 1 : vertices.length - 1], vertex4 = vertices[i2], nextVertex = vertices[(i2 + 1) % vertices.length], currentRadius = radius2[i2 < radius2.length ? i2 : radius2.length - 1];
                if (currentRadius === 0) {
                  newVertices.push(vertex4);
                  continue;
                }
                var prevNormal = Vector.normalise({
                  x: vertex4.y - prevVertex.y,
                  y: prevVertex.x - vertex4.x
                });
                var nextNormal = Vector.normalise({
                  x: nextVertex.y - vertex4.y,
                  y: vertex4.x - nextVertex.x
                });
                var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex4, Vector.mult(midNormal, diagonalRadius));
                var precision = quality;
                if (quality === -1) {
                  precision = Math.pow(currentRadius, 0.32) * 1.75;
                }
                precision = Common.clamp(precision, qualityMin, qualityMax);
                if (precision % 2 === 1)
                  precision += 1;
                var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;
                for (var j2 = 0; j2 < precision; j2++) {
                  newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j2), scaledVertex));
                }
              }
              return newVertices;
            };
            Vertices.clockwiseSort = function(vertices) {
              var centre = Vertices.mean(vertices);
              vertices.sort(function(vertexA, vertexB) {
                return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
              });
              return vertices;
            };
            Vertices.isConvex = function(vertices) {
              var flag = 0, n2 = vertices.length, i2, j2, k2, z;
              if (n2 < 3)
                return null;
              for (i2 = 0; i2 < n2; i2++) {
                j2 = (i2 + 1) % n2;
                k2 = (i2 + 2) % n2;
                z = (vertices[j2].x - vertices[i2].x) * (vertices[k2].y - vertices[j2].y);
                z -= (vertices[j2].y - vertices[i2].y) * (vertices[k2].x - vertices[j2].x);
                if (z < 0) {
                  flag |= 1;
                } else if (z > 0) {
                  flag |= 2;
                }
                if (flag === 3) {
                  return false;
                }
              }
              if (flag !== 0) {
                return true;
              } else {
                return null;
              }
            };
            Vertices.hull = function(vertices) {
              var upper = [], lower = [], vertex4, i2;
              vertices = vertices.slice(0);
              vertices.sort(function(vertexA, vertexB) {
                var dx2 = vertexA.x - vertexB.x;
                return dx2 !== 0 ? dx2 : vertexA.y - vertexB.y;
              });
              for (i2 = 0; i2 < vertices.length; i2 += 1) {
                vertex4 = vertices[i2];
                while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex4) <= 0) {
                  lower.pop();
                }
                lower.push(vertex4);
              }
              for (i2 = vertices.length - 1; i2 >= 0; i2 -= 1) {
                vertex4 = vertices[i2];
                while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex4) <= 0) {
                  upper.pop();
                }
                upper.push(vertex4);
              }
              upper.pop();
              lower.pop();
              return upper.concat(lower);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Body = {};
          module2.exports = Body;
          var Vertices = __webpack_require__(3);
          var Vector = __webpack_require__(2);
          var Sleeping = __webpack_require__(7);
          var Common = __webpack_require__(0);
          var Bounds2 = __webpack_require__(1);
          var Axes = __webpack_require__(11);
          (function() {
            Body._timeCorrection = true;
            Body._inertiaScale = 4;
            Body._nextCollidingGroupId = 1;
            Body._nextNonCollidingGroupId = -1;
            Body._nextCategory = 1;
            Body._baseDelta = 1e3 / 60;
            Body.create = function(options) {
              var defaults2 = {
                id: Common.nextId(),
                type: "body",
                label: "Body",
                parts: [],
                plugin: {},
                angle: 0,
                vertices: Vertices.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                position: {x: 0, y: 0},
                force: {x: 0, y: 0},
                torque: 0,
                positionImpulse: {x: 0, y: 0},
                constraintImpulse: {x: 0, y: 0, angle: 0},
                totalContacts: 0,
                speed: 0,
                angularSpeed: 0,
                velocity: {x: 0, y: 0},
                angularVelocity: 0,
                isSensor: false,
                isStatic: false,
                isSleeping: false,
                motion: 0,
                sleepThreshold: 60,
                density: 1e-3,
                restitution: 0,
                friction: 0.1,
                frictionStatic: 0.5,
                frictionAir: 0.01,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                },
                slop: 0.05,
                timeScale: 1,
                render: {
                  visible: true,
                  opacity: 1,
                  strokeStyle: null,
                  fillStyle: null,
                  lineWidth: null,
                  sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                  }
                },
                events: null,
                bounds: null,
                chamfer: null,
                circleRadius: 0,
                positionPrev: null,
                anglePrev: 0,
                parent: null,
                axes: null,
                area: 0,
                mass: 0,
                inertia: 0,
                deltaTime: 1e3 / 60,
                _original: null
              };
              var body = Common.extend(defaults2, options);
              _initProperties(body, options);
              return body;
            };
            Body.nextGroup = function(isNonColliding) {
              if (isNonColliding)
                return Body._nextNonCollidingGroupId--;
              return Body._nextCollidingGroupId++;
            };
            Body.nextCategory = function() {
              Body._nextCategory = Body._nextCategory << 1;
              return Body._nextCategory;
            };
            var _initProperties = function(body, options) {
              options = options || {};
              Body.set(body, {
                bounds: body.bounds || Bounds2.create(body.vertices),
                positionPrev: body.positionPrev || Vector.clone(body.position),
                anglePrev: body.anglePrev || body.angle,
                vertices: body.vertices,
                parts: body.parts || [body],
                isStatic: body.isStatic,
                isSleeping: body.isSleeping,
                parent: body.parent || body
              });
              Vertices.rotate(body.vertices, body.angle, body.position);
              Axes.rotate(body.axes, body.angle);
              Bounds2.update(body.bounds, body.vertices, body.velocity);
              Body.set(body, {
                axes: options.axes || body.axes,
                area: options.area || body.area,
                mass: options.mass || body.mass,
                inertia: options.inertia || body.inertia
              });
              var defaultFillStyle = body.isStatic ? "#14151f" : Common.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), defaultStrokeStyle = body.isStatic ? "#555" : "#ccc", defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;
              body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
              body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
              body.render.lineWidth = body.render.lineWidth || defaultLineWidth;
              body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
              body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
            };
            Body.set = function(body, settings, value) {
              var property;
              if (typeof settings === "string") {
                property = settings;
                settings = {};
                settings[property] = value;
              }
              for (property in settings) {
                if (!Object.prototype.hasOwnProperty.call(settings, property))
                  continue;
                value = settings[property];
                switch (property) {
                  case "isStatic":
                    Body.setStatic(body, value);
                    break;
                  case "isSleeping":
                    Sleeping.set(body, value);
                    break;
                  case "mass":
                    Body.setMass(body, value);
                    break;
                  case "density":
                    Body.setDensity(body, value);
                    break;
                  case "inertia":
                    Body.setInertia(body, value);
                    break;
                  case "vertices":
                    Body.setVertices(body, value);
                    break;
                  case "position":
                    Body.setPosition(body, value);
                    break;
                  case "angle":
                    Body.setAngle(body, value);
                    break;
                  case "velocity":
                    Body.setVelocity(body, value);
                    break;
                  case "angularVelocity":
                    Body.setAngularVelocity(body, value);
                    break;
                  case "speed":
                    Body.setSpeed(body, value);
                    break;
                  case "angularSpeed":
                    Body.setAngularSpeed(body, value);
                    break;
                  case "parts":
                    Body.setParts(body, value);
                    break;
                  case "centre":
                    Body.setCentre(body, value);
                    break;
                  default:
                    body[property] = value;
                }
              }
            };
            Body.setStatic = function(body, isStatic) {
              for (var i2 = 0; i2 < body.parts.length; i2++) {
                var part = body.parts[i2];
                if (isStatic) {
                  if (!part.isStatic) {
                    part._original = {
                      restitution: part.restitution,
                      friction: part.friction,
                      mass: part.mass,
                      inertia: part.inertia,
                      density: part.density,
                      inverseMass: part.inverseMass,
                      inverseInertia: part.inverseInertia
                    };
                  }
                  part.restitution = 0;
                  part.friction = 1;
                  part.mass = part.inertia = part.density = Infinity;
                  part.inverseMass = part.inverseInertia = 0;
                  part.positionPrev.x = part.position.x;
                  part.positionPrev.y = part.position.y;
                  part.anglePrev = part.angle;
                  part.angularVelocity = 0;
                  part.speed = 0;
                  part.angularSpeed = 0;
                  part.motion = 0;
                } else if (part._original) {
                  part.restitution = part._original.restitution;
                  part.friction = part._original.friction;
                  part.mass = part._original.mass;
                  part.inertia = part._original.inertia;
                  part.density = part._original.density;
                  part.inverseMass = part._original.inverseMass;
                  part.inverseInertia = part._original.inverseInertia;
                  part._original = null;
                }
                part.isStatic = isStatic;
              }
            };
            Body.setMass = function(body, mass) {
              var moment = body.inertia / (body.mass / 6);
              body.inertia = moment * (mass / 6);
              body.inverseInertia = 1 / body.inertia;
              body.mass = mass;
              body.inverseMass = 1 / body.mass;
              body.density = body.mass / body.area;
            };
            Body.setDensity = function(body, density) {
              Body.setMass(body, density * body.area);
              body.density = density;
            };
            Body.setInertia = function(body, inertia) {
              body.inertia = inertia;
              body.inverseInertia = 1 / body.inertia;
            };
            Body.setVertices = function(body, vertices) {
              if (vertices[0].body === body) {
                body.vertices = vertices;
              } else {
                body.vertices = Vertices.create(vertices, body);
              }
              body.axes = Axes.fromVertices(body.vertices);
              body.area = Vertices.area(body.vertices);
              Body.setMass(body, body.density * body.area);
              var centre = Vertices.centre(body.vertices);
              Vertices.translate(body.vertices, centre, -1);
              Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));
              Vertices.translate(body.vertices, body.position);
              Bounds2.update(body.bounds, body.vertices, body.velocity);
            };
            Body.setParts = function(body, parts, autoHull) {
              var i2;
              parts = parts.slice(0);
              body.parts.length = 0;
              body.parts.push(body);
              body.parent = body;
              for (i2 = 0; i2 < parts.length; i2++) {
                var part = parts[i2];
                if (part !== body) {
                  part.parent = body;
                  body.parts.push(part);
                }
              }
              if (body.parts.length === 1)
                return;
              autoHull = typeof autoHull !== "undefined" ? autoHull : true;
              if (autoHull) {
                var vertices = [];
                for (i2 = 0; i2 < parts.length; i2++) {
                  vertices = vertices.concat(parts[i2].vertices);
                }
                Vertices.clockwiseSort(vertices);
                var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);
                Body.setVertices(body, hull);
                Vertices.translate(body.vertices, hullCentre);
              }
              var total = Body._totalProperties(body);
              body.area = total.area;
              body.parent = body;
              body.position.x = total.centre.x;
              body.position.y = total.centre.y;
              body.positionPrev.x = total.centre.x;
              body.positionPrev.y = total.centre.y;
              Body.setMass(body, total.mass);
              Body.setInertia(body, total.inertia);
              Body.setPosition(body, total.centre);
            };
            Body.setCentre = function(body, centre, relative) {
              if (!relative) {
                body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
                body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
                body.position.x = centre.x;
                body.position.y = centre.y;
              } else {
                body.positionPrev.x += centre.x;
                body.positionPrev.y += centre.y;
                body.position.x += centre.x;
                body.position.y += centre.y;
              }
            };
            Body.setPosition = function(body, position, updateVelocity) {
              var delta = Vector.sub(position, body.position);
              if (updateVelocity) {
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.velocity.x = delta.x;
                body.velocity.y = delta.y;
                body.speed = Vector.magnitude(delta);
              } else {
                body.positionPrev.x += delta.x;
                body.positionPrev.y += delta.y;
              }
              for (var i2 = 0; i2 < body.parts.length; i2++) {
                var part = body.parts[i2];
                part.position.x += delta.x;
                part.position.y += delta.y;
                Vertices.translate(part.vertices, delta);
                Bounds2.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.setAngle = function(body, angle, updateVelocity) {
              var delta = angle - body.angle;
              if (updateVelocity) {
                body.anglePrev = body.angle;
                body.angularVelocity = delta;
                body.angularSpeed = Math.abs(delta);
              } else {
                body.anglePrev += delta;
              }
              for (var i2 = 0; i2 < body.parts.length; i2++) {
                var part = body.parts[i2];
                part.angle += delta;
                Vertices.rotate(part.vertices, delta, body.position);
                Axes.rotate(part.axes, delta);
                Bounds2.update(part.bounds, part.vertices, body.velocity);
                if (i2 > 0) {
                  Vector.rotateAbout(part.position, delta, body.position, part.position);
                }
              }
            };
            Body.setVelocity = function(body, velocity) {
              var timeScale = body.deltaTime / Body._baseDelta;
              body.positionPrev.x = body.position.x - velocity.x * timeScale;
              body.positionPrev.y = body.position.y - velocity.y * timeScale;
              body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;
              body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;
              body.speed = Vector.magnitude(body.velocity);
            };
            Body.getVelocity = function(body) {
              var timeScale = Body._baseDelta / body.deltaTime;
              return {
                x: (body.position.x - body.positionPrev.x) * timeScale,
                y: (body.position.y - body.positionPrev.y) * timeScale
              };
            };
            Body.getSpeed = function(body) {
              return Vector.magnitude(Body.getVelocity(body));
            };
            Body.setSpeed = function(body, speed2) {
              Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed2));
            };
            Body.setAngularVelocity = function(body, velocity) {
              var timeScale = body.deltaTime / Body._baseDelta;
              body.anglePrev = body.angle - velocity * timeScale;
              body.angularVelocity = (body.angle - body.anglePrev) / timeScale;
              body.angularSpeed = Math.abs(body.angularVelocity);
            };
            Body.getAngularVelocity = function(body) {
              return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;
            };
            Body.getAngularSpeed = function(body) {
              return Math.abs(Body.getAngularVelocity(body));
            };
            Body.setAngularSpeed = function(body, speed2) {
              Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed2);
            };
            Body.translate = function(body, translation, updateVelocity) {
              Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);
            };
            Body.rotate = function(body, rotation, point, updateVelocity) {
              if (!point) {
                Body.setAngle(body, body.angle + rotation, updateVelocity);
              } else {
                var cos = Math.cos(rotation), sin = Math.sin(rotation), dx2 = body.position.x - point.x, dy2 = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx2 * cos - dy2 * sin),
                  y: point.y + (dx2 * sin + dy2 * cos)
                }, updateVelocity);
                Body.setAngle(body, body.angle + rotation, updateVelocity);
              }
            };
            Body.scale = function(body, scaleX, scaleY, point) {
              var totalArea = 0, totalInertia = 0;
              point = point || body.position;
              for (var i2 = 0; i2 < body.parts.length; i2++) {
                var part = body.parts[i2];
                Vertices.scale(part.vertices, scaleX, scaleY, point);
                part.axes = Axes.fromVertices(part.vertices);
                part.area = Vertices.area(part.vertices);
                Body.setMass(part, body.density * part.area);
                Vertices.translate(part.vertices, {x: -part.position.x, y: -part.position.y});
                Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
                Vertices.translate(part.vertices, {x: part.position.x, y: part.position.y});
                if (i2 > 0) {
                  totalArea += part.area;
                  totalInertia += part.inertia;
                }
                part.position.x = point.x + (part.position.x - point.x) * scaleX;
                part.position.y = point.y + (part.position.y - point.y) * scaleY;
                Bounds2.update(part.bounds, part.vertices, body.velocity);
              }
              if (body.parts.length > 1) {
                body.area = totalArea;
                if (!body.isStatic) {
                  Body.setMass(body, body.density * totalArea);
                  Body.setInertia(body, totalInertia);
                }
              }
              if (body.circleRadius) {
                if (scaleX === scaleY) {
                  body.circleRadius *= scaleX;
                } else {
                  body.circleRadius = null;
                }
              }
            };
            Body.update = function(body, deltaTime) {
              deltaTime = (typeof deltaTime !== "undefined" ? deltaTime : 1e3 / 60) * body.timeScale;
              var deltaTimeSquared = deltaTime * deltaTime, correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;
              var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta), velocityPrevX = (body.position.x - body.positionPrev.x) * correction, velocityPrevY = (body.position.y - body.positionPrev.y) * correction;
              body.velocity.x = velocityPrevX * frictionAir + body.force.x / body.mass * deltaTimeSquared;
              body.velocity.y = velocityPrevY * frictionAir + body.force.y / body.mass * deltaTimeSquared;
              body.positionPrev.x = body.position.x;
              body.positionPrev.y = body.position.y;
              body.position.x += body.velocity.x;
              body.position.y += body.velocity.y;
              body.deltaTime = deltaTime;
              body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
              body.anglePrev = body.angle;
              body.angle += body.angularVelocity;
              for (var i2 = 0; i2 < body.parts.length; i2++) {
                var part = body.parts[i2];
                Vertices.translate(part.vertices, body.velocity);
                if (i2 > 0) {
                  part.position.x += body.velocity.x;
                  part.position.y += body.velocity.y;
                }
                if (body.angularVelocity !== 0) {
                  Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                  Axes.rotate(part.axes, body.angularVelocity);
                  if (i2 > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                  }
                }
                Bounds2.update(part.bounds, part.vertices, body.velocity);
              }
            };
            Body.updateVelocities = function(body) {
              var timeScale = Body._baseDelta / body.deltaTime, bodyVelocity = body.velocity;
              bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;
              bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;
              body.speed = Math.sqrt(bodyVelocity.x * bodyVelocity.x + bodyVelocity.y * bodyVelocity.y);
              body.angularVelocity = (body.angle - body.anglePrev) * timeScale;
              body.angularSpeed = Math.abs(body.angularVelocity);
            };
            Body.applyForce = function(body, position, force) {
              var offset = {x: position.x - body.position.x, y: position.y - body.position.y};
              body.force.x += force.x;
              body.force.y += force.y;
              body.torque += offset.x * force.y - offset.y * force.x;
            };
            Body._totalProperties = function(body) {
              var properties = {
                mass: 0,
                area: 0,
                inertia: 0,
                centre: {x: 0, y: 0}
              };
              for (var i2 = body.parts.length === 1 ? 0 : 1; i2 < body.parts.length; i2++) {
                var part = body.parts[i2], mass = part.mass !== Infinity ? part.mass : 1;
                properties.mass += mass;
                properties.area += part.area;
                properties.inertia += part.inertia;
                properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
              }
              properties.centre = Vector.div(properties.centre, properties.mass);
              return properties;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Events2 = {};
          module2.exports = Events2;
          var Common = __webpack_require__(0);
          (function() {
            Events2.on = function(object, eventNames, callback) {
              var names = eventNames.split(" "), name;
              for (var i2 = 0; i2 < names.length; i2++) {
                name = names[i2];
                object.events = object.events || {};
                object.events[name] = object.events[name] || [];
                object.events[name].push(callback);
              }
              return callback;
            };
            Events2.off = function(object, eventNames, callback) {
              if (!eventNames) {
                object.events = {};
                return;
              }
              if (typeof eventNames === "function") {
                callback = eventNames;
                eventNames = Common.keys(object.events).join(" ");
              }
              var names = eventNames.split(" ");
              for (var i2 = 0; i2 < names.length; i2++) {
                var callbacks = object.events[names[i2]], newCallbacks = [];
                if (callback && callbacks) {
                  for (var j2 = 0; j2 < callbacks.length; j2++) {
                    if (callbacks[j2] !== callback)
                      newCallbacks.push(callbacks[j2]);
                  }
                }
                object.events[names[i2]] = newCallbacks;
              }
            };
            Events2.trigger = function(object, eventNames, event) {
              var names, name, callbacks, eventClone;
              var events = object.events;
              if (events && Common.keys(events).length > 0) {
                if (!event)
                  event = {};
                names = eventNames.split(" ");
                for (var i2 = 0; i2 < names.length; i2++) {
                  name = names[i2];
                  callbacks = events[name];
                  if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;
                    for (var j2 = 0; j2 < callbacks.length; j2++) {
                      callbacks[j2].apply(object, [eventClone]);
                    }
                  }
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Composite = {};
          module2.exports = Composite;
          var Events2 = __webpack_require__(5);
          var Common = __webpack_require__(0);
          var Bounds2 = __webpack_require__(1);
          var Body = __webpack_require__(4);
          (function() {
            Composite.create = function(options) {
              return Common.extend({
                id: Common.nextId(),
                type: "composite",
                parent: null,
                isModified: false,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {},
                cache: {
                  allBodies: null,
                  allConstraints: null,
                  allComposites: null
                }
              }, options);
            };
            Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
              composite.isModified = isModified;
              if (isModified && composite.cache) {
                composite.cache.allBodies = null;
                composite.cache.allConstraints = null;
                composite.cache.allComposites = null;
              }
              if (updateParents && composite.parent) {
                Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
              }
              if (updateChildren) {
                for (var i2 = 0; i2 < composite.composites.length; i2++) {
                  var childComposite = composite.composites[i2];
                  Composite.setModified(childComposite, isModified, updateParents, updateChildren);
                }
              }
            };
            Composite.add = function(composite, object) {
              var objects = [].concat(object);
              Events2.trigger(composite, "beforeAdd", {object});
              for (var i2 = 0; i2 < objects.length; i2++) {
                var obj = objects[i2];
                switch (obj.type) {
                  case "body":
                    if (obj.parent !== obj) {
                      Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                      break;
                    }
                    Composite.addBody(composite, obj);
                    break;
                  case "constraint":
                    Composite.addConstraint(composite, obj);
                    break;
                  case "composite":
                    Composite.addComposite(composite, obj);
                    break;
                  case "mouseConstraint":
                    Composite.addConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events2.trigger(composite, "afterAdd", {object});
              return composite;
            };
            Composite.remove = function(composite, object, deep) {
              var objects = [].concat(object);
              Events2.trigger(composite, "beforeRemove", {object});
              for (var i2 = 0; i2 < objects.length; i2++) {
                var obj = objects[i2];
                switch (obj.type) {
                  case "body":
                    Composite.removeBody(composite, obj, deep);
                    break;
                  case "constraint":
                    Composite.removeConstraint(composite, obj, deep);
                    break;
                  case "composite":
                    Composite.removeComposite(composite, obj, deep);
                    break;
                  case "mouseConstraint":
                    Composite.removeConstraint(composite, obj.constraint);
                    break;
                }
              }
              Events2.trigger(composite, "afterRemove", {object});
              return composite;
            };
            Composite.addComposite = function(compositeA, compositeB) {
              compositeA.composites.push(compositeB);
              compositeB.parent = compositeA;
              Composite.setModified(compositeA, true, true, false);
              return compositeA;
            };
            Composite.removeComposite = function(compositeA, compositeB, deep) {
              var position = Common.indexOf(compositeA.composites, compositeB);
              if (position !== -1) {
                var bodies = Composite.allBodies(compositeB);
                Composite.removeCompositeAt(compositeA, position);
                for (var i2 = 0; i2 < bodies.length; i2++) {
                  bodies[i2].sleepCounter = 0;
                }
              }
              if (deep) {
                for (var i2 = 0; i2 < compositeA.composites.length; i2++) {
                  Composite.removeComposite(compositeA.composites[i2], compositeB, true);
                }
              }
              return compositeA;
            };
            Composite.removeCompositeAt = function(composite, position) {
              composite.composites.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addBody = function(composite, body) {
              composite.bodies.push(body);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeBody = function(composite, body, deep) {
              var position = Common.indexOf(composite.bodies, body);
              if (position !== -1) {
                Composite.removeBodyAt(composite, position);
                body.sleepCounter = 0;
              }
              if (deep) {
                for (var i2 = 0; i2 < composite.composites.length; i2++) {
                  Composite.removeBody(composite.composites[i2], body, true);
                }
              }
              return composite;
            };
            Composite.removeBodyAt = function(composite, position) {
              composite.bodies.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.addConstraint = function(composite, constraint) {
              composite.constraints.push(constraint);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.removeConstraint = function(composite, constraint, deep) {
              var position = Common.indexOf(composite.constraints, constraint);
              if (position !== -1) {
                Composite.removeConstraintAt(composite, position);
              }
              if (deep) {
                for (var i2 = 0; i2 < composite.composites.length; i2++) {
                  Composite.removeConstraint(composite.composites[i2], constraint, true);
                }
              }
              return composite;
            };
            Composite.removeConstraintAt = function(composite, position) {
              composite.constraints.splice(position, 1);
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.clear = function(composite, keepStatic, deep) {
              if (deep) {
                for (var i2 = 0; i2 < composite.composites.length; i2++) {
                  Composite.clear(composite.composites[i2], keepStatic, true);
                }
              }
              if (keepStatic) {
                composite.bodies = composite.bodies.filter(function(body) {
                  return body.isStatic;
                });
              } else {
                composite.bodies.length = 0;
              }
              composite.constraints.length = 0;
              composite.composites.length = 0;
              Composite.setModified(composite, true, true, false);
              return composite;
            };
            Composite.allBodies = function(composite) {
              if (composite.cache && composite.cache.allBodies) {
                return composite.cache.allBodies;
              }
              var bodies = [].concat(composite.bodies);
              for (var i2 = 0; i2 < composite.composites.length; i2++)
                bodies = bodies.concat(Composite.allBodies(composite.composites[i2]));
              if (composite.cache) {
                composite.cache.allBodies = bodies;
              }
              return bodies;
            };
            Composite.allConstraints = function(composite) {
              if (composite.cache && composite.cache.allConstraints) {
                return composite.cache.allConstraints;
              }
              var constraints = [].concat(composite.constraints);
              for (var i2 = 0; i2 < composite.composites.length; i2++)
                constraints = constraints.concat(Composite.allConstraints(composite.composites[i2]));
              if (composite.cache) {
                composite.cache.allConstraints = constraints;
              }
              return constraints;
            };
            Composite.allComposites = function(composite) {
              if (composite.cache && composite.cache.allComposites) {
                return composite.cache.allComposites;
              }
              var composites = [].concat(composite.composites);
              for (var i2 = 0; i2 < composite.composites.length; i2++)
                composites = composites.concat(Composite.allComposites(composite.composites[i2]));
              if (composite.cache) {
                composite.cache.allComposites = composites;
              }
              return composites;
            };
            Composite.get = function(composite, id, type) {
              var objects, object;
              switch (type) {
                case "body":
                  objects = Composite.allBodies(composite);
                  break;
                case "constraint":
                  objects = Composite.allConstraints(composite);
                  break;
                case "composite":
                  objects = Composite.allComposites(composite).concat(composite);
                  break;
              }
              if (!objects)
                return null;
              object = objects.filter(function(object2) {
                return object2.id.toString() === id.toString();
              });
              return object.length === 0 ? null : object[0];
            };
            Composite.move = function(compositeA, objects, compositeB) {
              Composite.remove(compositeA, objects);
              Composite.add(compositeB, objects);
              return compositeA;
            };
            Composite.rebase = function(composite) {
              var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));
              for (var i2 = 0; i2 < objects.length; i2++) {
                objects[i2].id = Common.nextId();
              }
              return composite;
            };
            Composite.translate = function(composite, translation, recursive3) {
              var bodies = recursive3 ? Composite.allBodies(composite) : composite.bodies;
              for (var i2 = 0; i2 < bodies.length; i2++) {
                Body.translate(bodies[i2], translation);
              }
              return composite;
            };
            Composite.rotate = function(composite, rotation, point, recursive3) {
              var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive3 ? Composite.allBodies(composite) : composite.bodies;
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], dx2 = body.position.x - point.x, dy2 = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + (dx2 * cos - dy2 * sin),
                  y: point.y + (dx2 * sin + dy2 * cos)
                });
                Body.rotate(body, rotation);
              }
              return composite;
            };
            Composite.scale = function(composite, scaleX, scaleY, point, recursive3) {
              var bodies = recursive3 ? Composite.allBodies(composite) : composite.bodies;
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], dx2 = body.position.x - point.x, dy2 = body.position.y - point.y;
                Body.setPosition(body, {
                  x: point.x + dx2 * scaleX,
                  y: point.y + dy2 * scaleY
                });
                Body.scale(body, scaleX, scaleY);
              }
              return composite;
            };
            Composite.bounds = function(composite) {
              var bodies = Composite.allBodies(composite), vertices = [];
              for (var i2 = 0; i2 < bodies.length; i2 += 1) {
                var body = bodies[i2];
                vertices.push(body.bounds.min, body.bounds.max);
              }
              return Bounds2.create(vertices);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Sleeping = {};
          module2.exports = Sleeping;
          var Body = __webpack_require__(4);
          var Events2 = __webpack_require__(5);
          var Common = __webpack_require__(0);
          (function() {
            Sleeping._motionWakeThreshold = 0.18;
            Sleeping._motionSleepThreshold = 0.08;
            Sleeping._minBias = 0.9;
            Sleeping.update = function(bodies, delta) {
              var timeScale = delta / Common._baseDelta, motionSleepThreshold = Sleeping._motionSleepThreshold;
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], speed2 = Body.getSpeed(body), angularSpeed = Body.getAngularSpeed(body), motion = speed2 * speed2 + angularSpeed * angularSpeed;
                if (body.force.x !== 0 || body.force.y !== 0) {
                  Sleeping.set(body, false);
                  continue;
                }
                var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {
                  body.sleepCounter += 1;
                  if (body.sleepCounter >= body.sleepThreshold / timeScale) {
                    Sleeping.set(body, true);
                  }
                } else if (body.sleepCounter > 0) {
                  body.sleepCounter -= 1;
                }
              }
            };
            Sleeping.afterCollisions = function(pairs) {
              var motionSleepThreshold = Sleeping._motionSleepThreshold;
              for (var i2 = 0; i2 < pairs.length; i2++) {
                var pair = pairs[i2];
                if (!pair.isActive)
                  continue;
                var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
                  continue;
                if (bodyA.isSleeping || bodyB.isSleeping) {
                  var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                  if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {
                    Sleeping.set(sleepingBody, false);
                  }
                }
              }
            };
            Sleeping.set = function(body, isSleeping) {
              var wasSleeping = body.isSleeping;
              if (isSleeping) {
                body.isSleeping = true;
                body.sleepCounter = body.sleepThreshold;
                body.positionImpulse.x = 0;
                body.positionImpulse.y = 0;
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.anglePrev = body.angle;
                body.speed = 0;
                body.angularSpeed = 0;
                body.motion = 0;
                if (!wasSleeping) {
                  Events2.trigger(body, "sleepStart");
                }
              } else {
                body.isSleeping = false;
                body.sleepCounter = 0;
                if (wasSleeping) {
                  Events2.trigger(body, "sleepEnd");
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Collision = {};
          module2.exports = Collision;
          var Vertices = __webpack_require__(3);
          var Pair = __webpack_require__(9);
          (function() {
            var _supports = [];
            var _overlapAB = {
              overlap: 0,
              axis: null
            };
            var _overlapBA = {
              overlap: 0,
              axis: null
            };
            Collision.create = function(bodyA, bodyB) {
              return {
                pair: null,
                collided: false,
                bodyA,
                bodyB,
                parentA: bodyA.parent,
                parentB: bodyB.parent,
                depth: 0,
                normal: {x: 0, y: 0},
                tangent: {x: 0, y: 0},
                penetration: {x: 0, y: 0},
                supports: [null, null],
                supportCount: 0
              };
            };
            Collision.collides = function(bodyA, bodyB, pairs) {
              Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);
              if (_overlapAB.overlap <= 0) {
                return null;
              }
              Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);
              if (_overlapBA.overlap <= 0) {
                return null;
              }
              var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)], collision;
              if (!pair) {
                collision = Collision.create(bodyA, bodyB);
                collision.collided = true;
                collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
                collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
                collision.parentA = collision.bodyA.parent;
                collision.parentB = collision.bodyB.parent;
              } else {
                collision = pair.collision;
              }
              bodyA = collision.bodyA;
              bodyB = collision.bodyB;
              var minOverlap;
              if (_overlapAB.overlap < _overlapBA.overlap) {
                minOverlap = _overlapAB;
              } else {
                minOverlap = _overlapBA;
              }
              var normal = collision.normal, tangent = collision.tangent, penetration = collision.penetration, supports = collision.supports, depth = minOverlap.overlap, minAxis = minOverlap.axis, normalX = minAxis.x, normalY = minAxis.y, deltaX = bodyB.position.x - bodyA.position.x, deltaY = bodyB.position.y - bodyA.position.y;
              if (normalX * deltaX + normalY * deltaY >= 0) {
                normalX = -normalX;
                normalY = -normalY;
              }
              normal.x = normalX;
              normal.y = normalY;
              tangent.x = -normalY;
              tangent.y = normalX;
              penetration.x = normalX * depth;
              penetration.y = normalY * depth;
              collision.depth = depth;
              var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1), supportCount = 0;
              if (Vertices.contains(bodyA.vertices, supportsB[0])) {
                supports[supportCount++] = supportsB[0];
              }
              if (Vertices.contains(bodyA.vertices, supportsB[1])) {
                supports[supportCount++] = supportsB[1];
              }
              if (supportCount < 2) {
                var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);
                if (Vertices.contains(bodyB.vertices, supportsA[0])) {
                  supports[supportCount++] = supportsA[0];
                }
                if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {
                  supports[supportCount++] = supportsA[1];
                }
              }
              if (supportCount === 0) {
                supports[supportCount++] = supportsB[0];
              }
              collision.supportCount = supportCount;
              return collision;
            };
            Collision._overlapAxes = function(result, verticesA, verticesB, axes) {
              var verticesALength = verticesA.length, verticesBLength = verticesB.length, verticesAX = verticesA[0].x, verticesAY = verticesA[0].y, verticesBX = verticesB[0].x, verticesBY = verticesB[0].y, axesLength = axes.length, overlapMin = Number.MAX_VALUE, overlapAxisNumber = 0, overlap, overlapAB, overlapBA, dot, i2, j2;
              for (i2 = 0; i2 < axesLength; i2++) {
                var axis = axes[i2], axisX = axis.x, axisY = axis.y, minA = verticesAX * axisX + verticesAY * axisY, minB = verticesBX * axisX + verticesBY * axisY, maxA = minA, maxB = minB;
                for (j2 = 1; j2 < verticesALength; j2 += 1) {
                  dot = verticesA[j2].x * axisX + verticesA[j2].y * axisY;
                  if (dot > maxA) {
                    maxA = dot;
                  } else if (dot < minA) {
                    minA = dot;
                  }
                }
                for (j2 = 1; j2 < verticesBLength; j2 += 1) {
                  dot = verticesB[j2].x * axisX + verticesB[j2].y * axisY;
                  if (dot > maxB) {
                    maxB = dot;
                  } else if (dot < minB) {
                    minB = dot;
                  }
                }
                overlapAB = maxA - minB;
                overlapBA = maxB - minA;
                overlap = overlapAB < overlapBA ? overlapAB : overlapBA;
                if (overlap < overlapMin) {
                  overlapMin = overlap;
                  overlapAxisNumber = i2;
                  if (overlap <= 0) {
                    break;
                  }
                }
              }
              result.axis = axes[overlapAxisNumber];
              result.overlap = overlapMin;
            };
            Collision._findSupports = function(bodyA, bodyB, normal, direction) {
              var vertices = bodyB.vertices, verticesLength = vertices.length, bodyAPositionX = bodyA.position.x, bodyAPositionY = bodyA.position.y, normalX = normal.x * direction, normalY = normal.y * direction, vertexA = vertices[0], vertexB = vertexA, nearestDistance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y), vertexC, distance, j2;
              for (j2 = 1; j2 < verticesLength; j2 += 1) {
                vertexB = vertices[j2];
                distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);
                if (distance < nearestDistance) {
                  nearestDistance = distance;
                  vertexA = vertexB;
                }
              }
              vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];
              nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);
              vertexB = vertices[(vertexA.index + 1) % verticesLength];
              if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {
                _supports[0] = vertexA;
                _supports[1] = vertexB;
                return _supports;
              }
              _supports[0] = vertexA;
              _supports[1] = vertexC;
              return _supports;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Pair = {};
          module2.exports = Pair;
          var Contact = __webpack_require__(16);
          (function() {
            Pair.create = function(collision, timestamp) {
              var bodyA = collision.bodyA, bodyB = collision.bodyB;
              var pair = {
                id: Pair.id(bodyA, bodyB),
                bodyA,
                bodyB,
                collision,
                contacts: [Contact.create(), Contact.create()],
                contactCount: 0,
                separation: 0,
                isActive: true,
                isSensor: bodyA.isSensor || bodyB.isSensor,
                timeCreated: timestamp,
                timeUpdated: timestamp,
                inverseMass: 0,
                friction: 0,
                frictionStatic: 0,
                restitution: 0,
                slop: 0
              };
              Pair.update(pair, collision, timestamp);
              return pair;
            };
            Pair.update = function(pair, collision, timestamp) {
              var supports = collision.supports, supportCount = collision.supportCount, contacts = pair.contacts, parentA = collision.parentA, parentB = collision.parentB;
              pair.isActive = true;
              pair.timeUpdated = timestamp;
              pair.collision = collision;
              pair.separation = collision.depth;
              pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
              pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;
              pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;
              pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;
              pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;
              pair.contactCount = supportCount;
              collision.pair = pair;
              var supportA = supports[0], contactA = contacts[0], supportB = supports[1], contactB = contacts[1];
              if (contactB.vertex === supportA || contactA.vertex === supportB) {
                contacts[1] = contactA;
                contacts[0] = contactA = contactB;
                contactB = contacts[1];
              }
              contactA.vertex = supportA;
              contactB.vertex = supportB;
            };
            Pair.setActive = function(pair, isActive, timestamp) {
              if (isActive) {
                pair.isActive = true;
                pair.timeUpdated = timestamp;
              } else {
                pair.isActive = false;
                pair.contactCount = 0;
              }
            };
            Pair.id = function(bodyA, bodyB) {
              return bodyA.id < bodyB.id ? bodyA.id.toString(36) + ":" + bodyB.id.toString(36) : bodyB.id.toString(36) + ":" + bodyA.id.toString(36);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Constraint = {};
          module2.exports = Constraint;
          var Vertices = __webpack_require__(3);
          var Vector = __webpack_require__(2);
          var Sleeping = __webpack_require__(7);
          var Bounds2 = __webpack_require__(1);
          var Axes = __webpack_require__(11);
          var Common = __webpack_require__(0);
          (function() {
            Constraint._warming = 0.4;
            Constraint._torqueDampen = 1;
            Constraint._minLength = 1e-6;
            Constraint.create = function(options) {
              var constraint = options;
              if (constraint.bodyA && !constraint.pointA)
                constraint.pointA = {x: 0, y: 0};
              if (constraint.bodyB && !constraint.pointB)
                constraint.pointB = {x: 0, y: 0};
              var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
              constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
              constraint.id = constraint.id || Common.nextId();
              constraint.label = constraint.label || "Constraint";
              constraint.type = "constraint";
              constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
              constraint.damping = constraint.damping || 0;
              constraint.angularStiffness = constraint.angularStiffness || 0;
              constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
              constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
              constraint.plugin = {};
              var render3 = {
                visible: true,
                lineWidth: 2,
                strokeStyle: "#ffffff",
                type: "line",
                anchors: true
              };
              if (constraint.length === 0 && constraint.stiffness > 0.1) {
                render3.type = "pin";
                render3.anchors = false;
              } else if (constraint.stiffness < 0.9) {
                render3.type = "spring";
              }
              constraint.render = Common.extend(render3, constraint.render);
              return constraint;
            };
            Constraint.preSolveAll = function(bodies) {
              for (var i2 = 0; i2 < bodies.length; i2 += 1) {
                var body = bodies[i2], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                body.position.x += impulse.x;
                body.position.y += impulse.y;
                body.angle += impulse.angle;
              }
            };
            Constraint.solveAll = function(constraints, delta) {
              var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);
              for (var i2 = 0; i2 < constraints.length; i2 += 1) {
                var constraint = constraints[i2], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (fixedA || fixedB) {
                  Constraint.solve(constraints[i2], timeScale);
                }
              }
              for (i2 = 0; i2 < constraints.length; i2 += 1) {
                constraint = constraints[i2];
                fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                if (!fixedA && !fixedB) {
                  Constraint.solve(constraints[i2], timeScale);
                }
              }
            };
            Constraint.solve = function(constraint, timeScale) {
              var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
              if (!bodyA && !bodyB)
                return;
              if (bodyA && !bodyA.isStatic) {
                Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                constraint.angleA = bodyA.angle;
              }
              if (bodyB && !bodyB.isStatic) {
                Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                constraint.angleB = bodyB.angle;
              }
              var pointAWorld = pointA, pointBWorld = pointB;
              if (bodyA)
                pointAWorld = Vector.add(bodyA.position, pointA);
              if (bodyB)
                pointBWorld = Vector.add(bodyB.position, pointB);
              if (!pointAWorld || !pointBWorld)
                return;
              var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);
              if (currentLength < Constraint._minLength) {
                currentLength = Constraint._minLength;
              }
              var difference = (currentLength - constraint.length) / currentLength, isRigid = constraint.stiffness >= 1 || constraint.length === 0, stiffness = isRigid ? constraint.stiffness * timeScale : constraint.stiffness * timeScale * timeScale, damping = constraint.damping * timeScale, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
              if (damping > 0) {
                var zero = Vector.create();
                normal = Vector.div(delta, currentLength);
                relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);
                normalVelocity = Vector.dot(normal, relativeVelocity);
              }
              if (bodyA && !bodyA.isStatic) {
                share = bodyA.inverseMass / massTotal;
                bodyA.constraintImpulse.x -= force.x * share;
                bodyA.constraintImpulse.y -= force.y * share;
                bodyA.position.x -= force.x * share;
                bodyA.position.y -= force.y * share;
                if (damping > 0) {
                  bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;
                  bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                bodyA.constraintImpulse.angle -= torque;
                bodyA.angle -= torque;
              }
              if (bodyB && !bodyB.isStatic) {
                share = bodyB.inverseMass / massTotal;
                bodyB.constraintImpulse.x += force.x * share;
                bodyB.constraintImpulse.y += force.y * share;
                bodyB.position.x += force.x * share;
                bodyB.position.y += force.y * share;
                if (damping > 0) {
                  bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;
                  bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;
                }
                torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                bodyB.constraintImpulse.angle += torque;
                bodyB.angle += torque;
              }
            };
            Constraint.postSolveAll = function(bodies) {
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], impulse = body.constraintImpulse;
                if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                  continue;
                }
                Sleeping.set(body, false);
                for (var j2 = 0; j2 < body.parts.length; j2++) {
                  var part = body.parts[j2];
                  Vertices.translate(part.vertices, impulse);
                  if (j2 > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                  }
                  if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j2 > 0) {
                      Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                  }
                  Bounds2.update(part.bounds, part.vertices, body.velocity);
                }
                impulse.angle *= Constraint._warming;
                impulse.x *= Constraint._warming;
                impulse.y *= Constraint._warming;
              }
            };
            Constraint.pointAWorld = function(constraint) {
              return {
                x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0),
                y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0)
              };
            };
            Constraint.pointBWorld = function(constraint) {
              return {
                x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0),
                y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0)
              };
            };
            Constraint.currentLength = function(constraint) {
              var pointAX = (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0);
              var pointAY = (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0);
              var pointBX = (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0);
              var pointBY = (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0);
              var deltaX = pointAX - pointBX;
              var deltaY = pointAY - pointBY;
              return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Axes = {};
          module2.exports = Axes;
          var Vector = __webpack_require__(2);
          var Common = __webpack_require__(0);
          (function() {
            Axes.fromVertices = function(vertices) {
              var axes = {};
              for (var i2 = 0; i2 < vertices.length; i2++) {
                var j2 = (i2 + 1) % vertices.length, normal = Vector.normalise({
                  x: vertices[j2].y - vertices[i2].y,
                  y: vertices[i2].x - vertices[j2].x
                }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                gradient = gradient.toFixed(3).toString();
                axes[gradient] = normal;
              }
              return Common.values(axes);
            };
            Axes.rotate = function(axes, angle) {
              if (angle === 0)
                return;
              var cos = Math.cos(angle), sin = Math.sin(angle);
              for (var i2 = 0; i2 < axes.length; i2++) {
                var axis = axes[i2], xx;
                xx = axis.x * cos - axis.y * sin;
                axis.y = axis.x * sin + axis.y * cos;
                axis.x = xx;
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Bodies2 = {};
          module2.exports = Bodies2;
          var Vertices = __webpack_require__(3);
          var Common = __webpack_require__(0);
          var Body = __webpack_require__(4);
          var Bounds2 = __webpack_require__(1);
          var Vector = __webpack_require__(2);
          (function() {
            Bodies2.rectangle = function(x2, y2, width, height, options) {
              options = options || {};
              var rectangle = {
                label: "Rectangle Body",
                position: {x: x2, y: y2},
                vertices: Vertices.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, rectangle, options));
            };
            Bodies2.trapezoid = function(x2, y2, width, height, slope, options) {
              options = options || {};
              if (slope >= 1) {
                Common.warn("Bodies.trapezoid: slope parameter must be < 1.");
              }
              slope *= 0.5;
              var roof = (1 - slope * 2) * width;
              var x1 = width * slope, x22 = x1 + roof, x3 = x22 + x1, verticesPath;
              if (slope < 0.5) {
                verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x22 + " " + -height + " L " + x3 + " 0";
              } else {
                verticesPath = "L 0 0 L " + x22 + " " + -height + " L " + x3 + " 0";
              }
              var trapezoid = {
                label: "Trapezoid Body",
                position: {x: x2, y: y2},
                vertices: Vertices.fromPath(verticesPath)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, trapezoid, options));
            };
            Bodies2.circle = function(x2, y2, radius2, options, maxSides) {
              options = options || {};
              var circle = {
                label: "Circle Body",
                circleRadius: radius2
              };
              maxSides = maxSides || 25;
              var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius2)));
              if (sides % 2 === 1)
                sides += 1;
              return Bodies2.polygon(x2, y2, sides, radius2, Common.extend({}, circle, options));
            };
            Bodies2.polygon = function(x2, y2, sides, radius2, options) {
              options = options || {};
              if (sides < 3)
                return Bodies2.circle(x2, y2, radius2, options);
              var theta = 2 * Math.PI / sides, path2 = "", offset = theta * 0.5;
              for (var i2 = 0; i2 < sides; i2 += 1) {
                var angle = offset + i2 * theta, xx = Math.cos(angle) * radius2, yy = Math.sin(angle) * radius2;
                path2 += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
              }
              var polygon = {
                label: "Polygon Body",
                position: {x: x2, y: y2},
                vertices: Vertices.fromPath(path2)
              };
              if (options.chamfer) {
                var chamfer = options.chamfer;
                polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                delete options.chamfer;
              }
              return Body.create(Common.extend({}, polygon, options));
            };
            Bodies2.fromVertices = function(x2, y2, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {
              var decomp = Common.getDecomp(), canDecomp, body, parts, isConvex, isConcave, vertices, i2, j2, k2, v2, z;
              canDecomp = Boolean(decomp && decomp.quickDecomp);
              options = options || {};
              parts = [];
              flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
              removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
              minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
              removeDuplicatePoints = typeof removeDuplicatePoints !== "undefined" ? removeDuplicatePoints : 0.01;
              if (!Common.isArray(vertexSets[0])) {
                vertexSets = [vertexSets];
              }
              for (v2 = 0; v2 < vertexSets.length; v2 += 1) {
                vertices = vertexSets[v2];
                isConvex = Vertices.isConvex(vertices);
                isConcave = !isConvex;
                if (isConcave && !canDecomp) {
                  Common.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices.");
                }
                if (isConvex || !canDecomp) {
                  if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                  } else {
                    vertices = Vertices.hull(vertices);
                  }
                  parts.push({
                    position: {x: x2, y: y2},
                    vertices
                  });
                } else {
                  var concave = vertices.map(function(vertex4) {
                    return [vertex4.x, vertex4.y];
                  });
                  decomp.makeCCW(concave);
                  if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);
                  if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)
                    decomp.removeDuplicatePoints(concave, removeDuplicatePoints);
                  var decomposed = decomp.quickDecomp(concave);
                  for (i2 = 0; i2 < decomposed.length; i2++) {
                    var chunk = decomposed[i2];
                    var chunkVertices = chunk.map(function(vertices2) {
                      return {
                        x: vertices2[0],
                        y: vertices2[1]
                      };
                    });
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                      continue;
                    parts.push({
                      position: Vertices.centre(chunkVertices),
                      vertices: chunkVertices
                    });
                  }
                }
              }
              for (i2 = 0; i2 < parts.length; i2++) {
                parts[i2] = Body.create(Common.extend(parts[i2], options));
              }
              if (flagInternal) {
                var coincident_max_dist = 5;
                for (i2 = 0; i2 < parts.length; i2++) {
                  var partA = parts[i2];
                  for (j2 = i2 + 1; j2 < parts.length; j2++) {
                    var partB = parts[j2];
                    if (Bounds2.overlaps(partA.bounds, partB.bounds)) {
                      var pav = partA.vertices, pbv = partB.vertices;
                      for (k2 = 0; k2 < partA.vertices.length; k2++) {
                        for (z = 0; z < partB.vertices.length; z++) {
                          var da = Vector.magnitudeSquared(Vector.sub(pav[(k2 + 1) % pav.length], pbv[z])), db = Vector.magnitudeSquared(Vector.sub(pav[k2], pbv[(z + 1) % pbv.length]));
                          if (da < coincident_max_dist && db < coincident_max_dist) {
                            pav[k2].isInternal = true;
                            pbv[z].isInternal = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (parts.length > 1) {
                body = Body.create(Common.extend({parts: parts.slice(0)}, options));
                Body.setPosition(body, {x: x2, y: y2});
                return body;
              } else {
                return parts[0];
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Detector = {};
          module2.exports = Detector;
          var Common = __webpack_require__(0);
          var Collision = __webpack_require__(8);
          (function() {
            Detector.create = function(options) {
              var defaults2 = {
                bodies: [],
                collisions: [],
                pairs: null
              };
              return Common.extend(defaults2, options);
            };
            Detector.setBodies = function(detector, bodies) {
              detector.bodies = bodies.slice(0);
            };
            Detector.clear = function(detector) {
              detector.bodies = [];
              detector.collisions = [];
            };
            Detector.collisions = function(detector) {
              var pairs = detector.pairs, bodies = detector.bodies, bodiesLength = bodies.length, canCollide = Detector.canCollide, collides = Collision.collides, collisions = detector.collisions, collisionIndex = 0, i2, j2;
              bodies.sort(Detector._compareBoundsX);
              for (i2 = 0; i2 < bodiesLength; i2++) {
                var bodyA = bodies[i2], boundsA = bodyA.bounds, boundXMax = bodyA.bounds.max.x, boundYMax = bodyA.bounds.max.y, boundYMin = bodyA.bounds.min.y, bodyAStatic = bodyA.isStatic || bodyA.isSleeping, partsALength = bodyA.parts.length, partsASingle = partsALength === 1;
                for (j2 = i2 + 1; j2 < bodiesLength; j2++) {
                  var bodyB = bodies[j2], boundsB = bodyB.bounds;
                  if (boundsB.min.x > boundXMax) {
                    break;
                  }
                  if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {
                    continue;
                  }
                  if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {
                    continue;
                  }
                  if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {
                    continue;
                  }
                  var partsBLength = bodyB.parts.length;
                  if (partsASingle && partsBLength === 1) {
                    var collision = collides(bodyA, bodyB, pairs);
                    if (collision) {
                      collisions[collisionIndex++] = collision;
                    }
                  } else {
                    var partsAStart = partsALength > 1 ? 1 : 0, partsBStart = partsBLength > 1 ? 1 : 0;
                    for (var k2 = partsAStart; k2 < partsALength; k2++) {
                      var partA = bodyA.parts[k2], boundsA = partA.bounds;
                      for (var z = partsBStart; z < partsBLength; z++) {
                        var partB = bodyB.parts[z], boundsB = partB.bounds;
                        if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {
                          continue;
                        }
                        var collision = collides(partA, partB, pairs);
                        if (collision) {
                          collisions[collisionIndex++] = collision;
                        }
                      }
                    }
                  }
                }
              }
              if (collisions.length !== collisionIndex) {
                collisions.length = collisionIndex;
              }
              return collisions;
            };
            Detector.canCollide = function(filterA, filterB) {
              if (filterA.group === filterB.group && filterA.group !== 0)
                return filterA.group > 0;
              return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
            };
            Detector._compareBoundsX = function(bodyA, bodyB) {
              return bodyA.bounds.min.x - bodyB.bounds.min.x;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Mouse = {};
          module2.exports = Mouse;
          var Common = __webpack_require__(0);
          (function() {
            Mouse.create = function(element) {
              var mouse = {};
              if (!element) {
                Common.log("Mouse.create: element was undefined, defaulting to document.body", "warn");
              }
              mouse.element = element || document.body;
              mouse.absolute = {x: 0, y: 0};
              mouse.position = {x: 0, y: 0};
              mouse.mousedownPosition = {x: 0, y: 0};
              mouse.mouseupPosition = {x: 0, y: 0};
              mouse.offset = {x: 0, y: 0};
              mouse.scale = {x: 1, y: 1};
              mouse.wheelDelta = 0;
              mouse.button = -1;
              mouse.pixelRatio = parseInt(mouse.element.getAttribute("data-pixel-ratio"), 10) || 1;
              mouse.sourceEvents = {
                mousemove: null,
                mousedown: null,
                mouseup: null,
                mousewheel: null
              };
              mouse.mousemove = function(event) {
                var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                if (touches) {
                  mouse.button = 0;
                  event.preventDefault();
                }
                mouse.absolute.x = position.x;
                mouse.absolute.y = position.y;
                mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                mouse.sourceEvents.mousemove = event;
              };
              mouse.mousedown = function(event) {
                var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                if (touches) {
                  mouse.button = 0;
                  event.preventDefault();
                } else {
                  mouse.button = event.button;
                }
                mouse.absolute.x = position.x;
                mouse.absolute.y = position.y;
                mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                mouse.mousedownPosition.x = mouse.position.x;
                mouse.mousedownPosition.y = mouse.position.y;
                mouse.sourceEvents.mousedown = event;
              };
              mouse.mouseup = function(event) {
                var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;
                if (touches) {
                  event.preventDefault();
                }
                mouse.button = -1;
                mouse.absolute.x = position.x;
                mouse.absolute.y = position.y;
                mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
                mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
                mouse.mouseupPosition.x = mouse.position.x;
                mouse.mouseupPosition.y = mouse.position.y;
                mouse.sourceEvents.mouseup = event;
              };
              mouse.mousewheel = function(event) {
                mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
                event.preventDefault();
                mouse.sourceEvents.mousewheel = event;
              };
              Mouse.setElement(mouse, mouse.element);
              return mouse;
            };
            Mouse.setElement = function(mouse, element) {
              mouse.element = element;
              element.addEventListener("mousemove", mouse.mousemove, {passive: true});
              element.addEventListener("mousedown", mouse.mousedown, {passive: true});
              element.addEventListener("mouseup", mouse.mouseup, {passive: true});
              element.addEventListener("wheel", mouse.mousewheel, {passive: false});
              element.addEventListener("touchmove", mouse.mousemove, {passive: false});
              element.addEventListener("touchstart", mouse.mousedown, {passive: false});
              element.addEventListener("touchend", mouse.mouseup, {passive: false});
            };
            Mouse.clearSourceEvents = function(mouse) {
              mouse.sourceEvents.mousemove = null;
              mouse.sourceEvents.mousedown = null;
              mouse.sourceEvents.mouseup = null;
              mouse.sourceEvents.mousewheel = null;
              mouse.wheelDelta = 0;
            };
            Mouse.setOffset = function(mouse, offset) {
              mouse.offset.x = offset.x;
              mouse.offset.y = offset.y;
              mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
              mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            };
            Mouse.setScale = function(mouse, scale) {
              mouse.scale.x = scale.x;
              mouse.scale.y = scale.y;
              mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
              mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            };
            Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {
              var elementBounds = element.getBoundingClientRect(), rootNode = document.documentElement || document.body.parentNode || document.body, scrollX = window.pageXOffset !== void 0 ? window.pageXOffset : rootNode.scrollLeft, scrollY = window.pageYOffset !== void 0 ? window.pageYOffset : rootNode.scrollTop, touches = event.changedTouches, x2, y2;
              if (touches) {
                x2 = touches[0].pageX - elementBounds.left - scrollX;
                y2 = touches[0].pageY - elementBounds.top - scrollY;
              } else {
                x2 = event.pageX - elementBounds.left - scrollX;
                y2 = event.pageY - elementBounds.top - scrollY;
              }
              return {
                x: x2 / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
                y: y2 / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
              };
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Plugin = {};
          module2.exports = Plugin;
          var Common = __webpack_require__(0);
          (function() {
            Plugin._registry = {};
            Plugin.register = function(plugin) {
              if (!Plugin.isPlugin(plugin)) {
                Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
              }
              if (plugin.name in Plugin._registry) {
                var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                if (pluginVersion > registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                  Plugin._registry[plugin.name] = plugin;
                } else if (pluginVersion < registeredVersion) {
                  Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
                } else if (plugin !== registered) {
                  Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
                }
              } else {
                Plugin._registry[plugin.name] = plugin;
              }
              return plugin;
            };
            Plugin.resolve = function(dependency) {
              return Plugin._registry[Plugin.dependencyParse(dependency).name];
            };
            Plugin.toString = function(plugin) {
              return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
            };
            Plugin.isPlugin = function(obj) {
              return obj && obj.name && obj.version && obj.install;
            };
            Plugin.isUsed = function(module3, name) {
              return module3.used.indexOf(name) > -1;
            };
            Plugin.isFor = function(plugin, module3) {
              var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
              return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
            };
            Plugin.use = function(module3, plugins) {
              module3.uses = (module3.uses || []).concat(plugins || []);
              if (module3.uses.length === 0) {
                Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
                return;
              }
              var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
              for (var i2 = 0; i2 < sortedDependencies.length; i2 += 1) {
                if (sortedDependencies[i2] === module3.name) {
                  continue;
                }
                var plugin = Plugin.resolve(sortedDependencies[i2]);
                if (!plugin) {
                  status.push("\u274C " + sortedDependencies[i2]);
                  continue;
                }
                if (Plugin.isUsed(module3, plugin.name)) {
                  continue;
                }
                if (!Plugin.isFor(plugin, module3)) {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                  plugin._warned = true;
                }
                if (plugin.install) {
                  plugin.install(module3);
                } else {
                  Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                  plugin._warned = true;
                }
                if (plugin._warned) {
                  status.push("\u{1F536} " + Plugin.toString(plugin));
                  delete plugin._warned;
                } else {
                  status.push("\u2705 " + Plugin.toString(plugin));
                }
                module3.used.push(plugin.name);
              }
              if (status.length > 0) {
                Common.info(status.join("  "));
              }
            };
            Plugin.dependencies = function(module3, tracked) {
              var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
              tracked = tracked || {};
              if (name in tracked) {
                return;
              }
              module3 = Plugin.resolve(module3) || module3;
              tracked[name] = Common.map(module3.uses || [], function(dependency) {
                if (Plugin.isPlugin(dependency)) {
                  Plugin.register(dependency);
                }
                var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                  resolved._warned = true;
                  module3._warned = true;
                } else if (!resolved) {
                  Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                  module3._warned = true;
                }
                return parsed.name;
              });
              for (var i2 = 0; i2 < tracked[name].length; i2 += 1) {
                Plugin.dependencies(tracked[name][i2], tracked);
              }
              return tracked;
            };
            Plugin.dependencyParse = function(dependency) {
              if (Common.isString(dependency)) {
                var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                if (!pattern.test(dependency)) {
                  Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
                }
                return {
                  name: dependency.split("@")[0],
                  range: dependency.split("@")[1] || "*"
                };
              }
              return {
                name: dependency.name,
                range: dependency.range || dependency.version
              };
            };
            Plugin.versionParse = function(range) {
              var pattern = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
              if (!pattern.test(range)) {
                Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
              }
              var parts = pattern.exec(range);
              var major = Number(parts[4]);
              var minor = Number(parts[5]);
              var patch = Number(parts[6]);
              return {
                isRange: Boolean(parts[1] || parts[2]),
                version: parts[3],
                range,
                operator: parts[1] || parts[2] || "",
                major,
                minor,
                patch,
                parts: [major, minor, patch],
                prerelease: parts[7],
                number: major * 1e8 + minor * 1e4 + patch
              };
            };
            Plugin.versionSatisfies = function(version, range) {
              range = range || "*";
              var r2 = Plugin.versionParse(range), v2 = Plugin.versionParse(version);
              if (r2.isRange) {
                if (r2.operator === "*" || version === "*") {
                  return true;
                }
                if (r2.operator === ">") {
                  return v2.number > r2.number;
                }
                if (r2.operator === ">=") {
                  return v2.number >= r2.number;
                }
                if (r2.operator === "~") {
                  return v2.major === r2.major && v2.minor === r2.minor && v2.patch >= r2.patch;
                }
                if (r2.operator === "^") {
                  if (r2.major > 0) {
                    return v2.major === r2.major && v2.number >= r2.number;
                  }
                  if (r2.minor > 0) {
                    return v2.minor === r2.minor && v2.patch >= r2.patch;
                  }
                  return v2.patch === r2.patch;
                }
              }
              return version === range || version === "*";
            };
          })();
        },
        function(module2, exports2) {
          var Contact = {};
          module2.exports = Contact;
          (function() {
            Contact.create = function(vertex4) {
              return {
                vertex: vertex4,
                normalImpulse: 0,
                tangentImpulse: 0
              };
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Engine2 = {};
          module2.exports = Engine2;
          var Sleeping = __webpack_require__(7);
          var Resolver2 = __webpack_require__(18);
          var Detector = __webpack_require__(13);
          var Pairs = __webpack_require__(19);
          var Events2 = __webpack_require__(5);
          var Composite = __webpack_require__(6);
          var Constraint = __webpack_require__(10);
          var Common = __webpack_require__(0);
          var Body = __webpack_require__(4);
          (function() {
            Engine2._deltaMax = 1e3 / 60;
            Engine2.create = function(options) {
              options = options || {};
              var defaults2 = {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: false,
                events: [],
                plugin: {},
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 1e-3
                },
                timing: {
                  timestamp: 0,
                  timeScale: 1,
                  lastDelta: 0,
                  lastElapsed: 0,
                  lastUpdatesPerFrame: 0
                }
              };
              var engine2 = Common.extend(defaults2, options);
              engine2.world = options.world || Composite.create({label: "World"});
              engine2.pairs = options.pairs || Pairs.create();
              engine2.detector = options.detector || Detector.create();
              engine2.detector.pairs = engine2.pairs;
              engine2.grid = {buckets: []};
              engine2.world.gravity = engine2.gravity;
              engine2.broadphase = engine2.grid;
              engine2.metrics = {};
              return engine2;
            };
            Engine2.update = function(engine2, delta) {
              var startTime = Common.now();
              var world2 = engine2.world, detector = engine2.detector, pairs = engine2.pairs, timing = engine2.timing, timestamp = timing.timestamp, i2;
              if (delta > Engine2._deltaMax) {
                Common.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to", Engine2._deltaMax.toFixed(3), "ms.");
              }
              delta = typeof delta !== "undefined" ? delta : Common._baseDelta;
              delta *= timing.timeScale;
              timing.timestamp += delta;
              timing.lastDelta = delta;
              var event = {
                timestamp: timing.timestamp,
                delta
              };
              Events2.trigger(engine2, "beforeUpdate", event);
              var allBodies = Composite.allBodies(world2), allConstraints = Composite.allConstraints(world2);
              if (world2.isModified) {
                Detector.setBodies(detector, allBodies);
                Composite.setModified(world2, false, false, true);
              }
              if (engine2.enableSleeping)
                Sleeping.update(allBodies, delta);
              Engine2._bodiesApplyGravity(allBodies, engine2.gravity);
              if (delta > 0) {
                Engine2._bodiesUpdate(allBodies, delta);
              }
              Events2.trigger(engine2, "beforeSolve", event);
              Constraint.preSolveAll(allBodies);
              for (i2 = 0; i2 < engine2.constraintIterations; i2++) {
                Constraint.solveAll(allConstraints, delta);
              }
              Constraint.postSolveAll(allBodies);
              var collisions = Detector.collisions(detector);
              Pairs.update(pairs, collisions, timestamp);
              if (engine2.enableSleeping)
                Sleeping.afterCollisions(pairs.list);
              if (pairs.collisionStart.length > 0) {
                Events2.trigger(engine2, "collisionStart", {
                  pairs: pairs.collisionStart,
                  timestamp: timing.timestamp,
                  delta
                });
              }
              var positionDamping = Common.clamp(20 / engine2.positionIterations, 0, 1);
              Resolver2.preSolvePosition(pairs.list);
              for (i2 = 0; i2 < engine2.positionIterations; i2++) {
                Resolver2.solvePosition(pairs.list, delta, positionDamping);
              }
              Resolver2.postSolvePosition(allBodies);
              Constraint.preSolveAll(allBodies);
              for (i2 = 0; i2 < engine2.constraintIterations; i2++) {
                Constraint.solveAll(allConstraints, delta);
              }
              Constraint.postSolveAll(allBodies);
              Resolver2.preSolveVelocity(pairs.list);
              for (i2 = 0; i2 < engine2.velocityIterations; i2++) {
                Resolver2.solveVelocity(pairs.list, delta);
              }
              Engine2._bodiesUpdateVelocities(allBodies);
              if (pairs.collisionActive.length > 0) {
                Events2.trigger(engine2, "collisionActive", {
                  pairs: pairs.collisionActive,
                  timestamp: timing.timestamp,
                  delta
                });
              }
              if (pairs.collisionEnd.length > 0) {
                Events2.trigger(engine2, "collisionEnd", {
                  pairs: pairs.collisionEnd,
                  timestamp: timing.timestamp,
                  delta
                });
              }
              Engine2._bodiesClearForces(allBodies);
              Events2.trigger(engine2, "afterUpdate", event);
              engine2.timing.lastElapsed = Common.now() - startTime;
              return engine2;
            };
            Engine2.merge = function(engineA, engineB) {
              Common.extend(engineA, engineB);
              if (engineB.world) {
                engineA.world = engineB.world;
                Engine2.clear(engineA);
                var bodies = Composite.allBodies(engineA.world);
                for (var i2 = 0; i2 < bodies.length; i2++) {
                  var body = bodies[i2];
                  Sleeping.set(body, false);
                  body.id = Common.nextId();
                }
              }
            };
            Engine2.clear = function(engine2) {
              Pairs.clear(engine2.pairs);
              Detector.clear(engine2.detector);
            };
            Engine2._bodiesClearForces = function(bodies) {
              var bodiesLength = bodies.length;
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                var body = bodies[i2];
                body.force.x = 0;
                body.force.y = 0;
                body.torque = 0;
              }
            };
            Engine2._bodiesApplyGravity = function(bodies, gravity) {
              var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3, bodiesLength = bodies.length;
              if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                return;
              }
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                var body = bodies[i2];
                if (body.isStatic || body.isSleeping)
                  continue;
                body.force.y += body.mass * gravity.y * gravityScale;
                body.force.x += body.mass * gravity.x * gravityScale;
              }
            };
            Engine2._bodiesUpdate = function(bodies, delta) {
              var bodiesLength = bodies.length;
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                var body = bodies[i2];
                if (body.isStatic || body.isSleeping)
                  continue;
                Body.update(body, delta);
              }
            };
            Engine2._bodiesUpdateVelocities = function(bodies) {
              var bodiesLength = bodies.length;
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                Body.updateVelocities(bodies[i2]);
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Resolver2 = {};
          module2.exports = Resolver2;
          var Vertices = __webpack_require__(3);
          var Common = __webpack_require__(0);
          var Bounds2 = __webpack_require__(1);
          (function() {
            Resolver2._restingThresh = 2;
            Resolver2._restingThreshTangent = Math.sqrt(6);
            Resolver2._positionDampen = 0.9;
            Resolver2._positionWarming = 0.8;
            Resolver2._frictionNormalMultiplier = 5;
            Resolver2._frictionMaxStatic = Number.MAX_VALUE;
            Resolver2.preSolvePosition = function(pairs) {
              var i2, pair, contactCount, pairsLength = pairs.length;
              for (i2 = 0; i2 < pairsLength; i2++) {
                pair = pairs[i2];
                if (!pair.isActive)
                  continue;
                contactCount = pair.contactCount;
                pair.collision.parentA.totalContacts += contactCount;
                pair.collision.parentB.totalContacts += contactCount;
              }
            };
            Resolver2.solvePosition = function(pairs, delta, damping) {
              var i2, pair, collision, bodyA, bodyB, normal, contactShare, positionImpulse, positionDampen = Resolver2._positionDampen * (damping || 1), slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1), pairsLength = pairs.length;
              for (i2 = 0; i2 < pairsLength; i2++) {
                pair = pairs[i2];
                if (!pair.isActive || pair.isSensor)
                  continue;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                pair.separation = collision.depth + normal.x * (bodyB.positionImpulse.x - bodyA.positionImpulse.x) + normal.y * (bodyB.positionImpulse.y - bodyA.positionImpulse.y);
              }
              for (i2 = 0; i2 < pairsLength; i2++) {
                pair = pairs[i2];
                if (!pair.isActive || pair.isSensor)
                  continue;
                collision = pair.collision;
                bodyA = collision.parentA;
                bodyB = collision.parentB;
                normal = collision.normal;
                positionImpulse = pair.separation - pair.slop * slopDampen;
                if (bodyA.isStatic || bodyB.isStatic)
                  positionImpulse *= 2;
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                  contactShare = positionDampen / bodyA.totalContacts;
                  bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                  bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
                }
                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                  contactShare = positionDampen / bodyB.totalContacts;
                  bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                  bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
                }
              }
            };
            Resolver2.postSolvePosition = function(bodies) {
              var positionWarming = Resolver2._positionWarming, bodiesLength = bodies.length, verticesTranslate = Vertices.translate, boundsUpdate = Bounds2.update;
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                var body = bodies[i2], positionImpulse = body.positionImpulse, positionImpulseX = positionImpulse.x, positionImpulseY = positionImpulse.y, velocity = body.velocity;
                body.totalContacts = 0;
                if (positionImpulseX !== 0 || positionImpulseY !== 0) {
                  for (var j2 = 0; j2 < body.parts.length; j2++) {
                    var part = body.parts[j2];
                    verticesTranslate(part.vertices, positionImpulse);
                    boundsUpdate(part.bounds, part.vertices, velocity);
                    part.position.x += positionImpulseX;
                    part.position.y += positionImpulseY;
                  }
                  body.positionPrev.x += positionImpulseX;
                  body.positionPrev.y += positionImpulseY;
                  if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {
                    positionImpulse.x = 0;
                    positionImpulse.y = 0;
                  } else {
                    positionImpulse.x *= positionWarming;
                    positionImpulse.y *= positionWarming;
                  }
                }
              }
            };
            Resolver2.preSolveVelocity = function(pairs) {
              var pairsLength = pairs.length, i2, j2;
              for (i2 = 0; i2 < pairsLength; i2++) {
                var pair = pairs[i2];
                if (!pair.isActive || pair.isSensor)
                  continue;
                var contacts = pair.contacts, contactCount = pair.contactCount, collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent;
                for (j2 = 0; j2 < contactCount; j2++) {
                  var contact = contacts[j2], contactVertex = contact.vertex, normalImpulse = contact.normalImpulse, tangentImpulse = contact.tangentImpulse;
                  if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse, impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                      bodyA.positionPrev.x += impulseX * bodyA.inverseMass;
                      bodyA.positionPrev.y += impulseY * bodyA.inverseMass;
                      bodyA.anglePrev += bodyA.inverseInertia * ((contactVertex.x - bodyA.position.x) * impulseY - (contactVertex.y - bodyA.position.y) * impulseX);
                    }
                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                      bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;
                      bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;
                      bodyB.anglePrev -= bodyB.inverseInertia * ((contactVertex.x - bodyB.position.x) * impulseY - (contactVertex.y - bodyB.position.y) * impulseX);
                    }
                  }
                }
              }
            };
            Resolver2.solveVelocity = function(pairs, delta) {
              var timeScale = delta / Common._baseDelta, timeScaleSquared = timeScale * timeScale, timeScaleCubed = timeScaleSquared * timeScale, restingThresh = -Resolver2._restingThresh * timeScale, restingThreshTangent = Resolver2._restingThreshTangent, frictionNormalMultiplier = Resolver2._frictionNormalMultiplier * timeScale, frictionMaxStatic = Resolver2._frictionMaxStatic, pairsLength = pairs.length, tangentImpulse, maxFriction, i2, j2;
              for (i2 = 0; i2 < pairsLength; i2++) {
                var pair = pairs[i2];
                if (!pair.isActive || pair.isSensor)
                  continue;
                var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normalX = collision.normal.x, normalY = collision.normal.y, tangentX = collision.tangent.x, tangentY = collision.tangent.y, inverseMassTotal = pair.inverseMass, friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier, contacts = pair.contacts, contactCount = pair.contactCount, contactShare = 1 / contactCount;
                var bodyAVelocityX = bodyA.position.x - bodyA.positionPrev.x, bodyAVelocityY = bodyA.position.y - bodyA.positionPrev.y, bodyAAngularVelocity = bodyA.angle - bodyA.anglePrev, bodyBVelocityX = bodyB.position.x - bodyB.positionPrev.x, bodyBVelocityY = bodyB.position.y - bodyB.positionPrev.y, bodyBAngularVelocity = bodyB.angle - bodyB.anglePrev;
                for (j2 = 0; j2 < contactCount; j2++) {
                  var contact = contacts[j2], contactVertex = contact.vertex;
                  var offsetAX = contactVertex.x - bodyA.position.x, offsetAY = contactVertex.y - bodyA.position.y, offsetBX = contactVertex.x - bodyB.position.x, offsetBY = contactVertex.y - bodyB.position.y;
                  var velocityPointAX = bodyAVelocityX - offsetAY * bodyAAngularVelocity, velocityPointAY = bodyAVelocityY + offsetAX * bodyAAngularVelocity, velocityPointBX = bodyBVelocityX - offsetBY * bodyBAngularVelocity, velocityPointBY = bodyBVelocityY + offsetBX * bodyBAngularVelocity;
                  var relativeVelocityX = velocityPointAX - velocityPointBX, relativeVelocityY = velocityPointAY - velocityPointBY;
                  var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY, tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;
                  var normalOverlap = pair.separation + normalVelocity;
                  var normalForce = Math.min(normalOverlap, 1);
                  normalForce = normalOverlap < 0 ? 0 : normalForce;
                  var frictionLimit = normalForce * friction;
                  if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {
                    maxFriction = tangentVelocity > 0 ? tangentVelocity : -tangentVelocity;
                    tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;
                    if (tangentImpulse < -maxFriction) {
                      tangentImpulse = -maxFriction;
                    } else if (tangentImpulse > maxFriction) {
                      tangentImpulse = maxFriction;
                    }
                  } else {
                    tangentImpulse = tangentVelocity;
                    maxFriction = frictionMaxStatic;
                  }
                  var oAcN = offsetAX * normalY - offsetAY * normalX, oBcN = offsetBX * normalY - offsetBY * normalX, share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                  var normalImpulse = (1 + pair.restitution) * normalVelocity * share;
                  tangentImpulse *= share;
                  if (normalVelocity < restingThresh) {
                    contact.normalImpulse = 0;
                  } else {
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse += normalImpulse;
                    if (contact.normalImpulse > 0)
                      contact.normalImpulse = 0;
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                  }
                  if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {
                    contact.tangentImpulse = 0;
                  } else {
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse += tangentImpulse;
                    if (contact.tangentImpulse < -maxFriction)
                      contact.tangentImpulse = -maxFriction;
                    if (contact.tangentImpulse > maxFriction)
                      contact.tangentImpulse = maxFriction;
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                  }
                  var impulseX = normalX * normalImpulse + tangentX * tangentImpulse, impulseY = normalY * normalImpulse + tangentY * tangentImpulse;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulseX * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulseY * bodyA.inverseMass;
                    bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;
                    bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;
                  }
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Pairs = {};
          module2.exports = Pairs;
          var Pair = __webpack_require__(9);
          var Common = __webpack_require__(0);
          (function() {
            Pairs.create = function(options) {
              return Common.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
              }, options);
            };
            Pairs.update = function(pairs, collisions, timestamp) {
              var pairUpdate = Pair.update, pairCreate = Pair.create, pairSetActive = Pair.setActive, pairsTable = pairs.table, pairsList = pairs.list, pairsListLength = pairsList.length, pairsListIndex = pairsListLength, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collisionsLength = collisions.length, collisionStartIndex = 0, collisionEndIndex = 0, collisionActiveIndex = 0, collision, pair, i2;
              for (i2 = 0; i2 < collisionsLength; i2++) {
                collision = collisions[i2];
                pair = collision.pair;
                if (pair) {
                  if (pair.isActive) {
                    collisionActive[collisionActiveIndex++] = pair;
                  }
                  pairUpdate(pair, collision, timestamp);
                } else {
                  pair = pairCreate(collision, timestamp);
                  pairsTable[pair.id] = pair;
                  collisionStart[collisionStartIndex++] = pair;
                  pairsList[pairsListIndex++] = pair;
                }
              }
              pairsListIndex = 0;
              pairsListLength = pairsList.length;
              for (i2 = 0; i2 < pairsListLength; i2++) {
                pair = pairsList[i2];
                if (pair.timeUpdated >= timestamp) {
                  pairsList[pairsListIndex++] = pair;
                } else {
                  pairSetActive(pair, false, timestamp);
                  if (pair.collision.bodyA.sleepCounter > 0 && pair.collision.bodyB.sleepCounter > 0) {
                    pairsList[pairsListIndex++] = pair;
                  } else {
                    collisionEnd[collisionEndIndex++] = pair;
                    delete pairsTable[pair.id];
                  }
                }
              }
              if (pairsList.length !== pairsListIndex) {
                pairsList.length = pairsListIndex;
              }
              if (collisionStart.length !== collisionStartIndex) {
                collisionStart.length = collisionStartIndex;
              }
              if (collisionEnd.length !== collisionEndIndex) {
                collisionEnd.length = collisionEndIndex;
              }
              if (collisionActive.length !== collisionActiveIndex) {
                collisionActive.length = collisionActiveIndex;
              }
            };
            Pairs.clear = function(pairs) {
              pairs.table = {};
              pairs.list.length = 0;
              pairs.collisionStart.length = 0;
              pairs.collisionActive.length = 0;
              pairs.collisionEnd.length = 0;
              return pairs;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Matter3 = module2.exports = __webpack_require__(21);
          Matter3.Axes = __webpack_require__(11);
          Matter3.Bodies = __webpack_require__(12);
          Matter3.Body = __webpack_require__(4);
          Matter3.Bounds = __webpack_require__(1);
          Matter3.Collision = __webpack_require__(8);
          Matter3.Common = __webpack_require__(0);
          Matter3.Composite = __webpack_require__(6);
          Matter3.Composites = __webpack_require__(22);
          Matter3.Constraint = __webpack_require__(10);
          Matter3.Contact = __webpack_require__(16);
          Matter3.Detector = __webpack_require__(13);
          Matter3.Engine = __webpack_require__(17);
          Matter3.Events = __webpack_require__(5);
          Matter3.Grid = __webpack_require__(23);
          Matter3.Mouse = __webpack_require__(14);
          Matter3.MouseConstraint = __webpack_require__(24);
          Matter3.Pair = __webpack_require__(9);
          Matter3.Pairs = __webpack_require__(19);
          Matter3.Plugin = __webpack_require__(15);
          Matter3.Query = __webpack_require__(25);
          Matter3.Render = __webpack_require__(26);
          Matter3.Resolver = __webpack_require__(18);
          Matter3.Runner = __webpack_require__(27);
          Matter3.SAT = __webpack_require__(28);
          Matter3.Sleeping = __webpack_require__(7);
          Matter3.Svg = __webpack_require__(29);
          Matter3.Vector = __webpack_require__(2);
          Matter3.Vertices = __webpack_require__(3);
          Matter3.World = __webpack_require__(30);
          Matter3.Engine.run = Matter3.Runner.run;
          Matter3.Common.deprecated(Matter3.Engine, "run", "Engine.run \u27A4 use Matter.Runner.run(engine) instead");
        },
        function(module2, exports2, __webpack_require__) {
          var Matter3 = {};
          module2.exports = Matter3;
          var Plugin = __webpack_require__(15);
          var Common = __webpack_require__(0);
          (function() {
            Matter3.name = "matter-js";
            Matter3.version = true ? "0.20.0" : void 0;
            Matter3.uses = [];
            Matter3.used = [];
            Matter3.use = function() {
              Plugin.use(Matter3, Array.prototype.slice.call(arguments));
            };
            Matter3.before = function(path2, func) {
              path2 = path2.replace(/^Matter./, "");
              return Common.chainPathBefore(Matter3, path2, func);
            };
            Matter3.after = function(path2, func) {
              path2 = path2.replace(/^Matter./, "");
              return Common.chainPathAfter(Matter3, path2, func);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Composites = {};
          module2.exports = Composites;
          var Composite = __webpack_require__(6);
          var Constraint = __webpack_require__(10);
          var Common = __webpack_require__(0);
          var Body = __webpack_require__(4);
          var Bodies2 = __webpack_require__(12);
          var deprecated = Common.deprecated;
          (function() {
            Composites.stack = function(x2, y2, columns, rows, columnGap, rowGap, callback) {
              var stack = Composite.create({label: "Stack"}), currentX = x2, currentY = y2, lastBody, i2 = 0;
              for (var row = 0; row < rows; row++) {
                var maxHeight = 0;
                for (var column = 0; column < columns; column++) {
                  var body = callback(currentX, currentY, column, row, lastBody, i2);
                  if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                    if (bodyHeight > maxHeight)
                      maxHeight = bodyHeight;
                    Body.translate(body, {x: bodyWidth * 0.5, y: bodyHeight * 0.5});
                    currentX = body.bounds.max.x + columnGap;
                    Composite.addBody(stack, body);
                    lastBody = body;
                    i2 += 1;
                  } else {
                    currentX += columnGap;
                  }
                }
                currentY += maxHeight + rowGap;
                currentX = x2;
              }
              return stack;
            };
            Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
              var bodies = composite.bodies;
              for (var i2 = 1; i2 < bodies.length; i2++) {
                var bodyA = bodies[i2 - 1], bodyB = bodies[i2], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                var defaults2 = {
                  bodyA,
                  pointA: {x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA},
                  bodyB,
                  pointB: {x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB}
                };
                var constraint = Common.extend(defaults2, options);
                Composite.addConstraint(composite, Constraint.create(constraint));
              }
              composite.label += " Chain";
              return composite;
            };
            Composites.mesh = function(composite, columns, rows, crossBrace, options) {
              var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
              for (row = 0; row < rows; row++) {
                for (col = 1; col < columns; col++) {
                  bodyA = bodies[col - 1 + row * columns];
                  bodyB = bodies[col + row * columns];
                  Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                }
                if (row > 0) {
                  for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + (row - 1) * columns];
                    bodyB = bodies[col + row * columns];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA, bodyB}, options)));
                    if (crossBrace && col > 0) {
                      bodyC = bodies[col - 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                    }
                    if (crossBrace && col < columns - 1) {
                      bodyC = bodies[col + 1 + (row - 1) * columns];
                      Composite.addConstraint(composite, Constraint.create(Common.extend({bodyA: bodyC, bodyB}, options)));
                    }
                  }
                }
              }
              composite.label += " Mesh";
              return composite;
            };
            Composites.pyramid = function(x2, y2, columns, rows, columnGap, rowGap, callback) {
              return Composites.stack(x2, y2, columns, rows, columnGap, rowGap, function(stackX, stackY, column, row, lastBody, i2) {
                var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                if (row > actualRows)
                  return;
                row = actualRows - row;
                var start = row, end = columns - 1 - row;
                if (column < start || column > end)
                  return;
                if (i2 === 1) {
                  Body.translate(lastBody, {x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0});
                }
                var xOffset = lastBody ? column * lastBodyWidth : 0;
                return callback(x2 + xOffset + column * columnGap, stackY, column, row, lastBody, i2);
              });
            };
            Composites.newtonsCradle = function(x2, y2, number, size, length) {
              var newtonsCradle = Composite.create({label: "Newtons Cradle"});
              for (var i2 = 0; i2 < number; i2++) {
                var separation = 1.9, circle = Bodies2.circle(x2 + i2 * (size * separation), y2 + length, size, {inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1}), constraint = Constraint.create({pointA: {x: x2 + i2 * (size * separation), y: y2}, bodyB: circle});
                Composite.addBody(newtonsCradle, circle);
                Composite.addConstraint(newtonsCradle, constraint);
              }
              return newtonsCradle;
            };
            deprecated(Composites, "newtonsCradle", "Composites.newtonsCradle \u27A4 moved to newtonsCradle example");
            Composites.car = function(x2, y2, width, height, wheelSize) {
              var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
              var car = Composite.create({label: "Car"}), body = Bodies2.rectangle(x2, y2, width, height, {
                collisionFilter: {
                  group
                },
                chamfer: {
                  radius: height * 0.5
                },
                density: 2e-4
              });
              var wheelA = Bodies2.circle(x2 + wheelAOffset, y2 + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var wheelB = Bodies2.circle(x2 + wheelBOffset, y2 + wheelYOffset, wheelSize, {
                collisionFilter: {
                  group
                },
                friction: 0.8
              });
              var axelA = Constraint.create({
                bodyB: body,
                pointB: {x: wheelAOffset, y: wheelYOffset},
                bodyA: wheelA,
                stiffness: 1,
                length: 0
              });
              var axelB = Constraint.create({
                bodyB: body,
                pointB: {x: wheelBOffset, y: wheelYOffset},
                bodyA: wheelB,
                stiffness: 1,
                length: 0
              });
              Composite.addBody(car, body);
              Composite.addBody(car, wheelA);
              Composite.addBody(car, wheelB);
              Composite.addConstraint(car, axelA);
              Composite.addConstraint(car, axelB);
              return car;
            };
            deprecated(Composites, "car", "Composites.car \u27A4 moved to car example");
            Composites.softBody = function(x2, y2, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
              particleOptions = Common.extend({inertia: Infinity}, particleOptions);
              constraintOptions = Common.extend({stiffness: 0.2, render: {type: "line", anchors: false}}, constraintOptions);
              var softBody = Composites.stack(x2, y2, columns, rows, columnGap, rowGap, function(stackX, stackY) {
                return Bodies2.circle(stackX, stackY, particleRadius, particleOptions);
              });
              Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
              softBody.label = "Soft Body";
              return softBody;
            };
            deprecated(Composites, "softBody", "Composites.softBody \u27A4 moved to softBody and cloth examples");
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Grid = {};
          module2.exports = Grid;
          var Pair = __webpack_require__(9);
          var Common = __webpack_require__(0);
          var deprecated = Common.deprecated;
          (function() {
            Grid.create = function(options) {
              var defaults2 = {
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
              };
              return Common.extend(defaults2, options);
            };
            Grid.update = function(grid, bodies, engine2, forceUpdate) {
              var i2, col, row, world2 = engine2.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
              for (i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2];
                if (body.isSleeping && !forceUpdate)
                  continue;
                if (world2.bounds && (body.bounds.max.x < world2.bounds.min.x || body.bounds.min.x > world2.bounds.max.x || body.bounds.max.y < world2.bounds.min.y || body.bounds.min.y > world2.bounds.max.y))
                  continue;
                var newRegion = Grid._getRegion(grid, body);
                if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                  if (!body.region || forceUpdate)
                    body.region = newRegion;
                  var union = Grid._regionUnion(newRegion, body.region);
                  for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                      bucketId = Grid._getBucketId(col, row);
                      bucket = buckets[bucketId];
                      var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                      var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                      if (!isInsideNewRegion && isInsideOldRegion) {
                        if (isInsideOldRegion) {
                          if (bucket)
                            Grid._bucketRemoveBody(grid, bucket, body);
                        }
                      }
                      if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                        if (!bucket)
                          bucket = Grid._createBucket(buckets, bucketId);
                        Grid._bucketAddBody(grid, bucket, body);
                      }
                    }
                  }
                  body.region = newRegion;
                  gridChanged = true;
                }
              }
              if (gridChanged)
                grid.pairsList = Grid._createActivePairsList(grid);
            };
            deprecated(Grid, "update", "Grid.update \u27A4 replaced by Matter.Detector");
            Grid.clear = function(grid) {
              grid.buckets = {};
              grid.pairs = {};
              grid.pairsList = [];
            };
            deprecated(Grid, "clear", "Grid.clear \u27A4 replaced by Matter.Detector");
            Grid._regionUnion = function(regionA, regionB) {
              var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._getRegion = function(grid, body) {
              var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
              return Grid._createRegion(startCol, endCol, startRow, endRow);
            };
            Grid._createRegion = function(startCol, endCol, startRow, endRow) {
              return {
                id: startCol + "," + endCol + "," + startRow + "," + endRow,
                startCol,
                endCol,
                startRow,
                endRow
              };
            };
            Grid._getBucketId = function(column, row) {
              return "C" + column + "R" + row;
            };
            Grid._createBucket = function(buckets, bucketId) {
              var bucket = buckets[bucketId] = [];
              return bucket;
            };
            Grid._bucketAddBody = function(grid, bucket, body) {
              var gridPairs = grid.pairs, pairId = Pair.id, bucketLength = bucket.length, i2;
              for (i2 = 0; i2 < bucketLength; i2++) {
                var bodyB = bucket[i2];
                if (body.id === bodyB.id || body.isStatic && bodyB.isStatic)
                  continue;
                var id = pairId(body, bodyB), pair = gridPairs[id];
                if (pair) {
                  pair[2] += 1;
                } else {
                  gridPairs[id] = [body, bodyB, 1];
                }
              }
              bucket.push(body);
            };
            Grid._bucketRemoveBody = function(grid, bucket, body) {
              var gridPairs = grid.pairs, pairId = Pair.id, i2;
              bucket.splice(Common.indexOf(bucket, body), 1);
              var bucketLength = bucket.length;
              for (i2 = 0; i2 < bucketLength; i2++) {
                var pair = gridPairs[pairId(body, bucket[i2])];
                if (pair)
                  pair[2] -= 1;
              }
            };
            Grid._createActivePairsList = function(grid) {
              var pair, gridPairs = grid.pairs, pairKeys = Common.keys(gridPairs), pairKeysLength = pairKeys.length, pairs = [], k2;
              for (k2 = 0; k2 < pairKeysLength; k2++) {
                pair = gridPairs[pairKeys[k2]];
                if (pair[2] > 0) {
                  pairs.push(pair);
                } else {
                  delete gridPairs[pairKeys[k2]];
                }
              }
              return pairs;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var MouseConstraint = {};
          module2.exports = MouseConstraint;
          var Vertices = __webpack_require__(3);
          var Sleeping = __webpack_require__(7);
          var Mouse = __webpack_require__(14);
          var Events2 = __webpack_require__(5);
          var Detector = __webpack_require__(13);
          var Constraint = __webpack_require__(10);
          var Composite = __webpack_require__(6);
          var Common = __webpack_require__(0);
          var Bounds2 = __webpack_require__(1);
          (function() {
            MouseConstraint.create = function(engine2, options) {
              var mouse = (engine2 ? engine2.mouse : null) || (options ? options.mouse : null);
              if (!mouse) {
                if (engine2 && engine2.render && engine2.render.canvas) {
                  mouse = Mouse.create(engine2.render.canvas);
                } else if (options && options.element) {
                  mouse = Mouse.create(options.element);
                } else {
                  mouse = Mouse.create();
                  Common.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected");
                }
              }
              var constraint = Constraint.create({
                label: "Mouse Constraint",
                pointA: mouse.position,
                pointB: {x: 0, y: 0},
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                render: {
                  strokeStyle: "#90EE90",
                  lineWidth: 3
                }
              });
              var defaults2 = {
                type: "mouseConstraint",
                mouse,
                element: null,
                body: null,
                constraint,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                }
              };
              var mouseConstraint = Common.extend(defaults2, options);
              Events2.on(engine2, "beforeUpdate", function() {
                var allBodies = Composite.allBodies(engine2.world);
                MouseConstraint.update(mouseConstraint, allBodies);
                MouseConstraint._triggerEvents(mouseConstraint);
              });
              return mouseConstraint;
            };
            MouseConstraint.update = function(mouseConstraint, bodies) {
              var mouse = mouseConstraint.mouse, constraint = mouseConstraint.constraint, body = mouseConstraint.body;
              if (mouse.button === 0) {
                if (!constraint.bodyB) {
                  for (var i2 = 0; i2 < bodies.length; i2++) {
                    body = bodies[i2];
                    if (Bounds2.contains(body.bounds, mouse.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                      for (var j2 = body.parts.length > 1 ? 1 : 0; j2 < body.parts.length; j2++) {
                        var part = body.parts[j2];
                        if (Vertices.contains(part.vertices, mouse.position)) {
                          constraint.pointA = mouse.position;
                          constraint.bodyB = mouseConstraint.body = body;
                          constraint.pointB = {x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y};
                          constraint.angleB = body.angle;
                          Sleeping.set(body, false);
                          Events2.trigger(mouseConstraint, "startdrag", {mouse, body});
                          break;
                        }
                      }
                    }
                  }
                } else {
                  Sleeping.set(constraint.bodyB, false);
                  constraint.pointA = mouse.position;
                }
              } else {
                constraint.bodyB = mouseConstraint.body = null;
                constraint.pointB = null;
                if (body)
                  Events2.trigger(mouseConstraint, "enddrag", {mouse, body});
              }
            };
            MouseConstraint._triggerEvents = function(mouseConstraint) {
              var mouse = mouseConstraint.mouse, mouseEvents = mouse.sourceEvents;
              if (mouseEvents.mousemove)
                Events2.trigger(mouseConstraint, "mousemove", {mouse});
              if (mouseEvents.mousedown)
                Events2.trigger(mouseConstraint, "mousedown", {mouse});
              if (mouseEvents.mouseup)
                Events2.trigger(mouseConstraint, "mouseup", {mouse});
              Mouse.clearSourceEvents(mouse);
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Query = {};
          module2.exports = Query;
          var Vector = __webpack_require__(2);
          var Collision = __webpack_require__(8);
          var Bounds2 = __webpack_require__(1);
          var Bodies2 = __webpack_require__(12);
          var Vertices = __webpack_require__(3);
          (function() {
            Query.collides = function(body, bodies) {
              var collisions = [], bodiesLength = bodies.length, bounds = body.bounds, collides = Collision.collides, overlaps = Bounds2.overlaps;
              for (var i2 = 0; i2 < bodiesLength; i2++) {
                var bodyA = bodies[i2], partsALength = bodyA.parts.length, partsAStart = partsALength === 1 ? 0 : 1;
                if (overlaps(bodyA.bounds, bounds)) {
                  for (var j2 = partsAStart; j2 < partsALength; j2++) {
                    var part = bodyA.parts[j2];
                    if (overlaps(part.bounds, bounds)) {
                      var collision = collides(part, body);
                      if (collision) {
                        collisions.push(collision);
                        break;
                      }
                    }
                  }
                }
              }
              return collisions;
            };
            Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
              rayWidth = rayWidth || 1e-100;
              var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies2.rectangle(rayX, rayY, rayLength, rayWidth, {angle: rayAngle}), collisions = Query.collides(ray, bodies);
              for (var i2 = 0; i2 < collisions.length; i2 += 1) {
                var collision = collisions[i2];
                collision.body = collision.bodyB = collision.bodyA;
              }
              return collisions;
            };
            Query.region = function(bodies, bounds, outside) {
              var result = [];
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], overlaps = Bounds2.overlaps(body.bounds, bounds);
                if (overlaps && !outside || !overlaps && outside)
                  result.push(body);
              }
              return result;
            };
            Query.point = function(bodies, point) {
              var result = [];
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2];
                if (Bounds2.contains(body.bounds, point)) {
                  for (var j2 = body.parts.length === 1 ? 0 : 1; j2 < body.parts.length; j2++) {
                    var part = body.parts[j2];
                    if (Bounds2.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {
                      result.push(body);
                      break;
                    }
                  }
                }
              }
              return result;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Render2 = {};
          module2.exports = Render2;
          var Body = __webpack_require__(4);
          var Common = __webpack_require__(0);
          var Composite = __webpack_require__(6);
          var Bounds2 = __webpack_require__(1);
          var Events2 = __webpack_require__(5);
          var Vector = __webpack_require__(2);
          var Mouse = __webpack_require__(14);
          (function() {
            var _requestAnimationFrame, _cancelAnimationFrame;
            if (typeof window !== "undefined") {
              _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                window.setTimeout(function() {
                  callback(Common.now());
                }, 1e3 / 60);
              };
              _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
            }
            Render2._goodFps = 30;
            Render2._goodDelta = 1e3 / 60;
            Render2.create = function(options) {
              var defaults2 = {
                engine: null,
                element: null,
                canvas: null,
                mouse: null,
                frameRequestId: null,
                timing: {
                  historySize: 60,
                  delta: 0,
                  deltaHistory: [],
                  lastTime: 0,
                  lastTimestamp: 0,
                  lastElapsed: 0,
                  timestampElapsed: 0,
                  timestampElapsedHistory: [],
                  engineDeltaHistory: [],
                  engineElapsedHistory: [],
                  engineUpdatesHistory: [],
                  elapsedHistory: []
                },
                options: {
                  width: 800,
                  height: 600,
                  pixelRatio: 1,
                  background: "#14151f",
                  wireframeBackground: "#14151f",
                  wireframeStrokeStyle: "#bbb",
                  hasBounds: !!options.bounds,
                  enabled: true,
                  wireframes: true,
                  showSleeping: true,
                  showDebug: false,
                  showStats: false,
                  showPerformance: false,
                  showBounds: false,
                  showVelocity: false,
                  showCollisions: false,
                  showSeparations: false,
                  showAxes: false,
                  showPositions: false,
                  showAngleIndicator: false,
                  showIds: false,
                  showVertexNumbers: false,
                  showConvexHulls: false,
                  showInternalEdges: false,
                  showMousePosition: false
                }
              };
              var render3 = Common.extend(defaults2, options);
              if (render3.canvas) {
                render3.canvas.width = render3.options.width || render3.canvas.width;
                render3.canvas.height = render3.options.height || render3.canvas.height;
              }
              render3.mouse = options.mouse;
              render3.engine = options.engine;
              render3.canvas = render3.canvas || _createCanvas(render3.options.width, render3.options.height);
              render3.context = render3.canvas.getContext("2d");
              render3.textures = {};
              render3.bounds = render3.bounds || {
                min: {
                  x: 0,
                  y: 0
                },
                max: {
                  x: render3.canvas.width,
                  y: render3.canvas.height
                }
              };
              render3.controller = Render2;
              render3.options.showBroadphase = false;
              if (render3.options.pixelRatio !== 1) {
                Render2.setPixelRatio(render3, render3.options.pixelRatio);
              }
              if (Common.isElement(render3.element)) {
                render3.element.appendChild(render3.canvas);
              }
              return render3;
            };
            Render2.run = function(render3) {
              (function loop(time) {
                render3.frameRequestId = _requestAnimationFrame(loop);
                _updateTiming(render3, time);
                Render2.world(render3, time);
                render3.context.setTransform(render3.options.pixelRatio, 0, 0, render3.options.pixelRatio, 0, 0);
                if (render3.options.showStats || render3.options.showDebug) {
                  Render2.stats(render3, render3.context, time);
                }
                if (render3.options.showPerformance || render3.options.showDebug) {
                  Render2.performance(render3, render3.context, time);
                }
                render3.context.setTransform(1, 0, 0, 1, 0, 0);
              })();
            };
            Render2.stop = function(render3) {
              _cancelAnimationFrame(render3.frameRequestId);
            };
            Render2.setPixelRatio = function(render3, pixelRatio) {
              var options = render3.options, canvas = render3.canvas;
              if (pixelRatio === "auto") {
                pixelRatio = _getPixelRatio(canvas);
              }
              options.pixelRatio = pixelRatio;
              canvas.setAttribute("data-pixel-ratio", pixelRatio);
              canvas.width = options.width * pixelRatio;
              canvas.height = options.height * pixelRatio;
              canvas.style.width = options.width + "px";
              canvas.style.height = options.height + "px";
            };
            Render2.setSize = function(render3, width, height) {
              render3.options.width = width;
              render3.options.height = height;
              render3.bounds.max.x = render3.bounds.min.x + width;
              render3.bounds.max.y = render3.bounds.min.y + height;
              if (render3.options.pixelRatio !== 1) {
                Render2.setPixelRatio(render3, render3.options.pixelRatio);
              } else {
                render3.canvas.width = width;
                render3.canvas.height = height;
              }
            };
            Render2.lookAt = function(render3, objects, padding, center) {
              center = typeof center !== "undefined" ? center : true;
              objects = Common.isArray(objects) ? objects : [objects];
              padding = padding || {
                x: 0,
                y: 0
              };
              var bounds = {
                min: {x: Infinity, y: Infinity},
                max: {x: -Infinity, y: -Infinity}
              };
              for (var i2 = 0; i2 < objects.length; i2 += 1) {
                var object = objects[i2], min = object.bounds ? object.bounds.min : object.min || object.position || object, max = object.bounds ? object.bounds.max : object.max || object.position || object;
                if (min && max) {
                  if (min.x < bounds.min.x)
                    bounds.min.x = min.x;
                  if (max.x > bounds.max.x)
                    bounds.max.x = max.x;
                  if (min.y < bounds.min.y)
                    bounds.min.y = min.y;
                  if (max.y > bounds.max.y)
                    bounds.max.y = max.y;
                }
              }
              var width = bounds.max.x - bounds.min.x + 2 * padding.x, height = bounds.max.y - bounds.min.y + 2 * padding.y, viewHeight = render3.canvas.height, viewWidth = render3.canvas.width, outerRatio = viewWidth / viewHeight, innerRatio = width / height, scaleX = 1, scaleY = 1;
              if (innerRatio > outerRatio) {
                scaleY = innerRatio / outerRatio;
              } else {
                scaleX = outerRatio / innerRatio;
              }
              render3.options.hasBounds = true;
              render3.bounds.min.x = bounds.min.x;
              render3.bounds.max.x = bounds.min.x + width * scaleX;
              render3.bounds.min.y = bounds.min.y;
              render3.bounds.max.y = bounds.min.y + height * scaleY;
              if (center) {
                render3.bounds.min.x += width * 0.5 - width * scaleX * 0.5;
                render3.bounds.max.x += width * 0.5 - width * scaleX * 0.5;
                render3.bounds.min.y += height * 0.5 - height * scaleY * 0.5;
                render3.bounds.max.y += height * 0.5 - height * scaleY * 0.5;
              }
              render3.bounds.min.x -= padding.x;
              render3.bounds.max.x -= padding.x;
              render3.bounds.min.y -= padding.y;
              render3.bounds.max.y -= padding.y;
              if (render3.mouse) {
                Mouse.setScale(render3.mouse, {
                  x: (render3.bounds.max.x - render3.bounds.min.x) / render3.canvas.width,
                  y: (render3.bounds.max.y - render3.bounds.min.y) / render3.canvas.height
                });
                Mouse.setOffset(render3.mouse, render3.bounds.min);
              }
            };
            Render2.startViewTransform = function(render3) {
              var boundsWidth = render3.bounds.max.x - render3.bounds.min.x, boundsHeight = render3.bounds.max.y - render3.bounds.min.y, boundsScaleX = boundsWidth / render3.options.width, boundsScaleY = boundsHeight / render3.options.height;
              render3.context.setTransform(render3.options.pixelRatio / boundsScaleX, 0, 0, render3.options.pixelRatio / boundsScaleY, 0, 0);
              render3.context.translate(-render3.bounds.min.x, -render3.bounds.min.y);
            };
            Render2.endViewTransform = function(render3) {
              render3.context.setTransform(render3.options.pixelRatio, 0, 0, render3.options.pixelRatio, 0, 0);
            };
            Render2.world = function(render3, time) {
              var startTime = Common.now(), engine2 = render3.engine, world2 = engine2.world, canvas = render3.canvas, context4 = render3.context, options = render3.options, timing = render3.timing;
              var allBodies = Composite.allBodies(world2), allConstraints = Composite.allConstraints(world2), background = options.wireframes ? options.wireframeBackground : options.background, bodies = [], constraints = [], i2;
              var event = {
                timestamp: engine2.timing.timestamp
              };
              Events2.trigger(render3, "beforeRender", event);
              if (render3.currentBackground !== background)
                _applyBackground(render3, background);
              context4.globalCompositeOperation = "source-in";
              context4.fillStyle = "transparent";
              context4.fillRect(0, 0, canvas.width, canvas.height);
              context4.globalCompositeOperation = "source-over";
              if (options.hasBounds) {
                for (i2 = 0; i2 < allBodies.length; i2++) {
                  var body = allBodies[i2];
                  if (Bounds2.overlaps(body.bounds, render3.bounds))
                    bodies.push(body);
                }
                for (i2 = 0; i2 < allConstraints.length; i2++) {
                  var constraint = allConstraints[i2], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;
                  if (bodyA)
                    pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                  if (bodyB)
                    pointBWorld = Vector.add(bodyB.position, constraint.pointB);
                  if (!pointAWorld || !pointBWorld)
                    continue;
                  if (Bounds2.contains(render3.bounds, pointAWorld) || Bounds2.contains(render3.bounds, pointBWorld))
                    constraints.push(constraint);
                }
                Render2.startViewTransform(render3);
                if (render3.mouse) {
                  Mouse.setScale(render3.mouse, {
                    x: (render3.bounds.max.x - render3.bounds.min.x) / render3.options.width,
                    y: (render3.bounds.max.y - render3.bounds.min.y) / render3.options.height
                  });
                  Mouse.setOffset(render3.mouse, render3.bounds.min);
                }
              } else {
                constraints = allConstraints;
                bodies = allBodies;
                if (render3.options.pixelRatio !== 1) {
                  render3.context.setTransform(render3.options.pixelRatio, 0, 0, render3.options.pixelRatio, 0, 0);
                }
              }
              if (!options.wireframes || engine2.enableSleeping && options.showSleeping) {
                Render2.bodies(render3, bodies, context4);
              } else {
                if (options.showConvexHulls)
                  Render2.bodyConvexHulls(render3, bodies, context4);
                Render2.bodyWireframes(render3, bodies, context4);
              }
              if (options.showBounds)
                Render2.bodyBounds(render3, bodies, context4);
              if (options.showAxes || options.showAngleIndicator)
                Render2.bodyAxes(render3, bodies, context4);
              if (options.showPositions)
                Render2.bodyPositions(render3, bodies, context4);
              if (options.showVelocity)
                Render2.bodyVelocity(render3, bodies, context4);
              if (options.showIds)
                Render2.bodyIds(render3, bodies, context4);
              if (options.showSeparations)
                Render2.separations(render3, engine2.pairs.list, context4);
              if (options.showCollisions)
                Render2.collisions(render3, engine2.pairs.list, context4);
              if (options.showVertexNumbers)
                Render2.vertexNumbers(render3, bodies, context4);
              if (options.showMousePosition)
                Render2.mousePosition(render3, render3.mouse, context4);
              Render2.constraints(constraints, context4);
              if (options.hasBounds) {
                Render2.endViewTransform(render3);
              }
              Events2.trigger(render3, "afterRender", event);
              timing.lastElapsed = Common.now() - startTime;
            };
            Render2.stats = function(render3, context4, time) {
              var engine2 = render3.engine, world2 = engine2.world, bodies = Composite.allBodies(world2), parts = 0, width = 55, height = 44, x2 = 0, y2 = 0;
              for (var i2 = 0; i2 < bodies.length; i2 += 1) {
                parts += bodies[i2].parts.length;
              }
              var sections = {
                Part: parts,
                Body: bodies.length,
                Cons: Composite.allConstraints(world2).length,
                Comp: Composite.allComposites(world2).length,
                Pair: engine2.pairs.list.length
              };
              context4.fillStyle = "#0e0f19";
              context4.fillRect(x2, y2, width * 5.5, height);
              context4.font = "12px Arial";
              context4.textBaseline = "top";
              context4.textAlign = "right";
              for (var key in sections) {
                var section = sections[key];
                context4.fillStyle = "#aaa";
                context4.fillText(key, x2 + width, y2 + 8);
                context4.fillStyle = "#eee";
                context4.fillText(section, x2 + width, y2 + 26);
                x2 += width;
              }
            };
            Render2.performance = function(render3, context4) {
              var engine2 = render3.engine, timing = render3.timing, deltaHistory = timing.deltaHistory, elapsedHistory = timing.elapsedHistory, timestampElapsedHistory = timing.timestampElapsedHistory, engineDeltaHistory = timing.engineDeltaHistory, engineUpdatesHistory = timing.engineUpdatesHistory, engineElapsedHistory = timing.engineElapsedHistory, lastEngineUpdatesPerFrame = engine2.timing.lastUpdatesPerFrame, lastEngineDelta = engine2.timing.lastDelta;
              var deltaMean = _mean(deltaHistory), elapsedMean = _mean(elapsedHistory), engineDeltaMean = _mean(engineDeltaHistory), engineUpdatesMean = _mean(engineUpdatesHistory), engineElapsedMean = _mean(engineElapsedHistory), timestampElapsedMean = _mean(timestampElapsedHistory), rateMean = timestampElapsedMean / deltaMean || 0, neededUpdatesPerFrame = Math.round(deltaMean / lastEngineDelta), fps = 1e3 / deltaMean || 0;
              var graphHeight = 4, gap = 12, width = 60, height = 34, x2 = 10, y2 = 69;
              context4.fillStyle = "#0e0f19";
              context4.fillRect(0, 50, gap * 5 + width * 6 + 22, height);
              Render2.status(context4, x2, y2, width, graphHeight, deltaHistory.length, Math.round(fps) + " fps", fps / Render2._goodFps, function(i2) {
                return deltaHistory[i2] / deltaMean - 1;
              });
              Render2.status(context4, x2 + gap + width, y2, width, graphHeight, engineDeltaHistory.length, lastEngineDelta.toFixed(2) + " dt", Render2._goodDelta / lastEngineDelta, function(i2) {
                return engineDeltaHistory[i2] / engineDeltaMean - 1;
              });
              Render2.status(context4, x2 + (gap + width) * 2, y2, width, graphHeight, engineUpdatesHistory.length, lastEngineUpdatesPerFrame + " upf", Math.pow(Common.clamp(engineUpdatesMean / neededUpdatesPerFrame || 1, 0, 1), 4), function(i2) {
                return engineUpdatesHistory[i2] / engineUpdatesMean - 1;
              });
              Render2.status(context4, x2 + (gap + width) * 3, y2, width, graphHeight, engineElapsedHistory.length, engineElapsedMean.toFixed(2) + " ut", 1 - lastEngineUpdatesPerFrame * engineElapsedMean / Render2._goodFps, function(i2) {
                return engineElapsedHistory[i2] / engineElapsedMean - 1;
              });
              Render2.status(context4, x2 + (gap + width) * 4, y2, width, graphHeight, elapsedHistory.length, elapsedMean.toFixed(2) + " rt", 1 - elapsedMean / Render2._goodFps, function(i2) {
                return elapsedHistory[i2] / elapsedMean - 1;
              });
              Render2.status(context4, x2 + (gap + width) * 5, y2, width, graphHeight, timestampElapsedHistory.length, rateMean.toFixed(2) + " x", rateMean * rateMean * rateMean, function(i2) {
                return (timestampElapsedHistory[i2] / deltaHistory[i2] / rateMean || 0) - 1;
              });
            };
            Render2.status = function(context4, x2, y2, width, height, count2, label2, indicator, plotY) {
              context4.strokeStyle = "#888";
              context4.fillStyle = "#444";
              context4.lineWidth = 1;
              context4.fillRect(x2, y2 + 7, width, 1);
              context4.beginPath();
              context4.moveTo(x2, y2 + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));
              for (var i2 = 0; i2 < width; i2 += 1) {
                context4.lineTo(x2 + i2, y2 + 7 - (i2 < count2 ? height * Common.clamp(0.4 * plotY(i2), -2, 2) : 0));
              }
              context4.stroke();
              context4.fillStyle = "hsl(" + Common.clamp(25 + 95 * indicator, 0, 120) + ",100%,60%)";
              context4.fillRect(x2, y2 - 7, 4, 4);
              context4.font = "12px Arial";
              context4.textBaseline = "middle";
              context4.textAlign = "right";
              context4.fillStyle = "#eee";
              context4.fillText(label2, x2 + width, y2 - 5);
            };
            Render2.constraints = function(constraints, context4) {
              var c2 = context4;
              for (var i2 = 0; i2 < constraints.length; i2++) {
                var constraint = constraints[i2];
                if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                  continue;
                var bodyA = constraint.bodyA, bodyB = constraint.bodyB, start, end;
                if (bodyA) {
                  start = Vector.add(bodyA.position, constraint.pointA);
                } else {
                  start = constraint.pointA;
                }
                if (constraint.render.type === "pin") {
                  c2.beginPath();
                  c2.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                  c2.closePath();
                } else {
                  if (bodyB) {
                    end = Vector.add(bodyB.position, constraint.pointB);
                  } else {
                    end = constraint.pointB;
                  }
                  c2.beginPath();
                  c2.moveTo(start.x, start.y);
                  if (constraint.render.type === "spring") {
                    var delta = Vector.sub(end, start), normal = Vector.perp(Vector.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), offset;
                    for (var j2 = 1; j2 < coils; j2 += 1) {
                      offset = j2 % 2 === 0 ? 1 : -1;
                      c2.lineTo(start.x + delta.x * (j2 / coils) + normal.x * offset * 4, start.y + delta.y * (j2 / coils) + normal.y * offset * 4);
                    }
                  }
                  c2.lineTo(end.x, end.y);
                }
                if (constraint.render.lineWidth) {
                  c2.lineWidth = constraint.render.lineWidth;
                  c2.strokeStyle = constraint.render.strokeStyle;
                  c2.stroke();
                }
                if (constraint.render.anchors) {
                  c2.fillStyle = constraint.render.strokeStyle;
                  c2.beginPath();
                  c2.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                  c2.arc(end.x, end.y, 3, 0, 2 * Math.PI);
                  c2.closePath();
                  c2.fill();
                }
              }
            };
            Render2.bodies = function(render3, bodies, context4) {
              var c2 = context4, engine2 = render3.engine, options = render3.options, showInternalEdges = options.showInternalEdges || !options.wireframes, body, part, i2, k2;
              for (i2 = 0; i2 < bodies.length; i2++) {
                body = bodies[i2];
                if (!body.render.visible)
                  continue;
                for (k2 = body.parts.length > 1 ? 1 : 0; k2 < body.parts.length; k2++) {
                  part = body.parts[k2];
                  if (!part.render.visible)
                    continue;
                  if (options.showSleeping && body.isSleeping) {
                    c2.globalAlpha = 0.5 * part.render.opacity;
                  } else if (part.render.opacity !== 1) {
                    c2.globalAlpha = part.render.opacity;
                  }
                  if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    var sprite = part.render.sprite, texture = _getTexture(render3, sprite.texture);
                    c2.translate(part.position.x, part.position.y);
                    c2.rotate(part.angle);
                    c2.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);
                    c2.rotate(-part.angle);
                    c2.translate(-part.position.x, -part.position.y);
                  } else {
                    if (part.circleRadius) {
                      c2.beginPath();
                      c2.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                      c2.beginPath();
                      c2.moveTo(part.vertices[0].x, part.vertices[0].y);
                      for (var j2 = 1; j2 < part.vertices.length; j2++) {
                        if (!part.vertices[j2 - 1].isInternal || showInternalEdges) {
                          c2.lineTo(part.vertices[j2].x, part.vertices[j2].y);
                        } else {
                          c2.moveTo(part.vertices[j2].x, part.vertices[j2].y);
                        }
                        if (part.vertices[j2].isInternal && !showInternalEdges) {
                          c2.moveTo(part.vertices[(j2 + 1) % part.vertices.length].x, part.vertices[(j2 + 1) % part.vertices.length].y);
                        }
                      }
                      c2.lineTo(part.vertices[0].x, part.vertices[0].y);
                      c2.closePath();
                    }
                    if (!options.wireframes) {
                      c2.fillStyle = part.render.fillStyle;
                      if (part.render.lineWidth) {
                        c2.lineWidth = part.render.lineWidth;
                        c2.strokeStyle = part.render.strokeStyle;
                        c2.stroke();
                      }
                      c2.fill();
                    } else {
                      c2.lineWidth = 1;
                      c2.strokeStyle = render3.options.wireframeStrokeStyle;
                      c2.stroke();
                    }
                  }
                  c2.globalAlpha = 1;
                }
              }
            };
            Render2.bodyWireframes = function(render3, bodies, context4) {
              var c2 = context4, showInternalEdges = render3.options.showInternalEdges, body, part, i2, j2, k2;
              c2.beginPath();
              for (i2 = 0; i2 < bodies.length; i2++) {
                body = bodies[i2];
                if (!body.render.visible)
                  continue;
                for (k2 = body.parts.length > 1 ? 1 : 0; k2 < body.parts.length; k2++) {
                  part = body.parts[k2];
                  c2.moveTo(part.vertices[0].x, part.vertices[0].y);
                  for (j2 = 1; j2 < part.vertices.length; j2++) {
                    if (!part.vertices[j2 - 1].isInternal || showInternalEdges) {
                      c2.lineTo(part.vertices[j2].x, part.vertices[j2].y);
                    } else {
                      c2.moveTo(part.vertices[j2].x, part.vertices[j2].y);
                    }
                    if (part.vertices[j2].isInternal && !showInternalEdges) {
                      c2.moveTo(part.vertices[(j2 + 1) % part.vertices.length].x, part.vertices[(j2 + 1) % part.vertices.length].y);
                    }
                  }
                  c2.lineTo(part.vertices[0].x, part.vertices[0].y);
                }
              }
              c2.lineWidth = 1;
              c2.strokeStyle = render3.options.wireframeStrokeStyle;
              c2.stroke();
            };
            Render2.bodyConvexHulls = function(render3, bodies, context4) {
              var c2 = context4, body, part, i2, j2, k2;
              c2.beginPath();
              for (i2 = 0; i2 < bodies.length; i2++) {
                body = bodies[i2];
                if (!body.render.visible || body.parts.length === 1)
                  continue;
                c2.moveTo(body.vertices[0].x, body.vertices[0].y);
                for (j2 = 1; j2 < body.vertices.length; j2++) {
                  c2.lineTo(body.vertices[j2].x, body.vertices[j2].y);
                }
                c2.lineTo(body.vertices[0].x, body.vertices[0].y);
              }
              c2.lineWidth = 1;
              c2.strokeStyle = "rgba(255,255,255,0.2)";
              c2.stroke();
            };
            Render2.vertexNumbers = function(render3, bodies, context4) {
              var c2 = context4, i2, j2, k2;
              for (i2 = 0; i2 < bodies.length; i2++) {
                var parts = bodies[i2].parts;
                for (k2 = parts.length > 1 ? 1 : 0; k2 < parts.length; k2++) {
                  var part = parts[k2];
                  for (j2 = 0; j2 < part.vertices.length; j2++) {
                    c2.fillStyle = "rgba(255,255,255,0.2)";
                    c2.fillText(i2 + "_" + j2, part.position.x + (part.vertices[j2].x - part.position.x) * 0.8, part.position.y + (part.vertices[j2].y - part.position.y) * 0.8);
                  }
                }
              }
            };
            Render2.mousePosition = function(render3, mouse, context4) {
              var c2 = context4;
              c2.fillStyle = "rgba(255,255,255,0.8)";
              c2.fillText(mouse.position.x + "  " + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
            };
            Render2.bodyBounds = function(render3, bodies, context4) {
              var c2 = context4, engine2 = render3.engine, options = render3.options;
              c2.beginPath();
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2];
                if (body.render.visible) {
                  var parts = bodies[i2].parts;
                  for (var j2 = parts.length > 1 ? 1 : 0; j2 < parts.length; j2++) {
                    var part = parts[j2];
                    c2.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                  }
                }
              }
              if (options.wireframes) {
                c2.strokeStyle = "rgba(255,255,255,0.08)";
              } else {
                c2.strokeStyle = "rgba(0,0,0,0.1)";
              }
              c2.lineWidth = 1;
              c2.stroke();
            };
            Render2.bodyAxes = function(render3, bodies, context4) {
              var c2 = context4, engine2 = render3.engine, options = render3.options, part, i2, j2, k2;
              c2.beginPath();
              for (i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2], parts = body.parts;
                if (!body.render.visible)
                  continue;
                if (options.showAxes) {
                  for (j2 = parts.length > 1 ? 1 : 0; j2 < parts.length; j2++) {
                    part = parts[j2];
                    for (k2 = 0; k2 < part.axes.length; k2++) {
                      var axis = part.axes[k2];
                      c2.moveTo(part.position.x, part.position.y);
                      c2.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                  }
                } else {
                  for (j2 = parts.length > 1 ? 1 : 0; j2 < parts.length; j2++) {
                    part = parts[j2];
                    for (k2 = 0; k2 < part.axes.length; k2++) {
                      c2.moveTo(part.position.x, part.position.y);
                      c2.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                    }
                  }
                }
              }
              if (options.wireframes) {
                c2.strokeStyle = "indianred";
                c2.lineWidth = 1;
              } else {
                c2.strokeStyle = "rgba(255, 255, 255, 0.4)";
                c2.globalCompositeOperation = "overlay";
                c2.lineWidth = 2;
              }
              c2.stroke();
              c2.globalCompositeOperation = "source-over";
            };
            Render2.bodyPositions = function(render3, bodies, context4) {
              var c2 = context4, engine2 = render3.engine, options = render3.options, body, part, i2, k2;
              c2.beginPath();
              for (i2 = 0; i2 < bodies.length; i2++) {
                body = bodies[i2];
                if (!body.render.visible)
                  continue;
                for (k2 = 0; k2 < body.parts.length; k2++) {
                  part = body.parts[k2];
                  c2.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                  c2.closePath();
                }
              }
              if (options.wireframes) {
                c2.fillStyle = "indianred";
              } else {
                c2.fillStyle = "rgba(0,0,0,0.5)";
              }
              c2.fill();
              c2.beginPath();
              for (i2 = 0; i2 < bodies.length; i2++) {
                body = bodies[i2];
                if (body.render.visible) {
                  c2.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                  c2.closePath();
                }
              }
              c2.fillStyle = "rgba(255,165,0,0.8)";
              c2.fill();
            };
            Render2.bodyVelocity = function(render3, bodies, context4) {
              var c2 = context4;
              c2.beginPath();
              for (var i2 = 0; i2 < bodies.length; i2++) {
                var body = bodies[i2];
                if (!body.render.visible)
                  continue;
                var velocity = Body.getVelocity(body);
                c2.moveTo(body.position.x, body.position.y);
                c2.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);
              }
              c2.lineWidth = 3;
              c2.strokeStyle = "cornflowerblue";
              c2.stroke();
            };
            Render2.bodyIds = function(render3, bodies, context4) {
              var c2 = context4, i2, j2;
              for (i2 = 0; i2 < bodies.length; i2++) {
                if (!bodies[i2].render.visible)
                  continue;
                var parts = bodies[i2].parts;
                for (j2 = parts.length > 1 ? 1 : 0; j2 < parts.length; j2++) {
                  var part = parts[j2];
                  c2.font = "12px Arial";
                  c2.fillStyle = "rgba(255,255,255,0.5)";
                  c2.fillText(part.id, part.position.x + 10, part.position.y - 10);
                }
              }
            };
            Render2.collisions = function(render3, pairs, context4) {
              var c2 = context4, options = render3.options, pair, collision, corrected, bodyA, bodyB, i2, j2;
              c2.beginPath();
              for (i2 = 0; i2 < pairs.length; i2++) {
                pair = pairs[i2];
                if (!pair.isActive)
                  continue;
                collision = pair.collision;
                for (j2 = 0; j2 < pair.contactCount; j2++) {
                  var contact = pair.contacts[j2], vertex4 = contact.vertex;
                  c2.rect(vertex4.x - 1.5, vertex4.y - 1.5, 3.5, 3.5);
                }
              }
              if (options.wireframes) {
                c2.fillStyle = "rgba(255,255,255,0.7)";
              } else {
                c2.fillStyle = "orange";
              }
              c2.fill();
              c2.beginPath();
              for (i2 = 0; i2 < pairs.length; i2++) {
                pair = pairs[i2];
                if (!pair.isActive)
                  continue;
                collision = pair.collision;
                if (pair.contactCount > 0) {
                  var normalPosX = pair.contacts[0].vertex.x, normalPosY = pair.contacts[0].vertex.y;
                  if (pair.contactCount === 2) {
                    normalPosX = (pair.contacts[0].vertex.x + pair.contacts[1].vertex.x) / 2;
                    normalPosY = (pair.contacts[0].vertex.y + pair.contacts[1].vertex.y) / 2;
                  }
                  if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                    c2.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                  } else {
                    c2.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                  }
                  c2.lineTo(normalPosX, normalPosY);
                }
              }
              if (options.wireframes) {
                c2.strokeStyle = "rgba(255,165,0,0.7)";
              } else {
                c2.strokeStyle = "orange";
              }
              c2.lineWidth = 1;
              c2.stroke();
            };
            Render2.separations = function(render3, pairs, context4) {
              var c2 = context4, options = render3.options, pair, collision, corrected, bodyA, bodyB, i2, j2;
              c2.beginPath();
              for (i2 = 0; i2 < pairs.length; i2++) {
                pair = pairs[i2];
                if (!pair.isActive)
                  continue;
                collision = pair.collision;
                bodyA = collision.bodyA;
                bodyB = collision.bodyB;
                var k2 = 1;
                if (!bodyB.isStatic && !bodyA.isStatic)
                  k2 = 0.5;
                if (bodyB.isStatic)
                  k2 = 0;
                c2.moveTo(bodyB.position.x, bodyB.position.y);
                c2.lineTo(bodyB.position.x - collision.penetration.x * k2, bodyB.position.y - collision.penetration.y * k2);
                k2 = 1;
                if (!bodyB.isStatic && !bodyA.isStatic)
                  k2 = 0.5;
                if (bodyA.isStatic)
                  k2 = 0;
                c2.moveTo(bodyA.position.x, bodyA.position.y);
                c2.lineTo(bodyA.position.x + collision.penetration.x * k2, bodyA.position.y + collision.penetration.y * k2);
              }
              if (options.wireframes) {
                c2.strokeStyle = "rgba(255,165,0,0.5)";
              } else {
                c2.strokeStyle = "orange";
              }
              c2.stroke();
            };
            Render2.inspector = function(inspector, context4) {
              var engine2 = inspector.engine, selected = inspector.selected, render3 = inspector.render, options = render3.options, bounds;
              if (options.hasBounds) {
                var boundsWidth = render3.bounds.max.x - render3.bounds.min.x, boundsHeight = render3.bounds.max.y - render3.bounds.min.y, boundsScaleX = boundsWidth / render3.options.width, boundsScaleY = boundsHeight / render3.options.height;
                context4.scale(1 / boundsScaleX, 1 / boundsScaleY);
                context4.translate(-render3.bounds.min.x, -render3.bounds.min.y);
              }
              for (var i2 = 0; i2 < selected.length; i2++) {
                var item = selected[i2].data;
                context4.translate(0.5, 0.5);
                context4.lineWidth = 1;
                context4.strokeStyle = "rgba(255,165,0,0.9)";
                context4.setLineDash([1, 2]);
                switch (item.type) {
                  case "body":
                    bounds = item.bounds;
                    context4.beginPath();
                    context4.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                    context4.closePath();
                    context4.stroke();
                    break;
                  case "constraint":
                    var point = item.pointA;
                    if (item.bodyA)
                      point = item.pointB;
                    context4.beginPath();
                    context4.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                    context4.closePath();
                    context4.stroke();
                    break;
                }
                context4.setLineDash([]);
                context4.translate(-0.5, -0.5);
              }
              if (inspector.selectStart !== null) {
                context4.translate(0.5, 0.5);
                context4.lineWidth = 1;
                context4.strokeStyle = "rgba(255,165,0,0.6)";
                context4.fillStyle = "rgba(255,165,0,0.1)";
                bounds = inspector.selectBounds;
                context4.beginPath();
                context4.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
                context4.closePath();
                context4.stroke();
                context4.fill();
                context4.translate(-0.5, -0.5);
              }
              if (options.hasBounds)
                context4.setTransform(1, 0, 0, 1, 0, 0);
            };
            var _updateTiming = function(render3, time) {
              var engine2 = render3.engine, timing = render3.timing, historySize = timing.historySize, timestamp = engine2.timing.timestamp;
              timing.delta = time - timing.lastTime || Render2._goodDelta;
              timing.lastTime = time;
              timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;
              timing.lastTimestamp = timestamp;
              timing.deltaHistory.unshift(timing.delta);
              timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);
              timing.engineDeltaHistory.unshift(engine2.timing.lastDelta);
              timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);
              timing.timestampElapsedHistory.unshift(timing.timestampElapsed);
              timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);
              timing.engineUpdatesHistory.unshift(engine2.timing.lastUpdatesPerFrame);
              timing.engineUpdatesHistory.length = Math.min(timing.engineUpdatesHistory.length, historySize);
              timing.engineElapsedHistory.unshift(engine2.timing.lastElapsed);
              timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);
              timing.elapsedHistory.unshift(timing.lastElapsed);
              timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);
            };
            var _mean = function(values) {
              var result = 0;
              for (var i2 = 0; i2 < values.length; i2 += 1) {
                result += values[i2];
              }
              return result / values.length || 0;
            };
            var _createCanvas = function(width, height) {
              var canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              canvas.oncontextmenu = function() {
                return false;
              };
              canvas.onselectstart = function() {
                return false;
              };
              return canvas;
            };
            var _getPixelRatio = function(canvas) {
              var context4 = canvas.getContext("2d"), devicePixelRatio = window.devicePixelRatio || 1, backingStorePixelRatio = context4.webkitBackingStorePixelRatio || context4.mozBackingStorePixelRatio || context4.msBackingStorePixelRatio || context4.oBackingStorePixelRatio || context4.backingStorePixelRatio || 1;
              return devicePixelRatio / backingStorePixelRatio;
            };
            var _getTexture = function(render3, imagePath) {
              var image = render3.textures[imagePath];
              if (image)
                return image;
              image = render3.textures[imagePath] = new Image();
              image.src = imagePath;
              return image;
            };
            var _applyBackground = function(render3, background) {
              var cssBackground = background;
              if (/(jpg|gif|png)$/.test(background))
                cssBackground = "url(" + background + ")";
              render3.canvas.style.background = cssBackground;
              render3.canvas.style.backgroundSize = "contain";
              render3.currentBackground = background;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Runner2 = {};
          module2.exports = Runner2;
          var Events2 = __webpack_require__(5);
          var Engine2 = __webpack_require__(17);
          var Common = __webpack_require__(0);
          (function() {
            Runner2._maxFrameDelta = 1e3 / 15;
            Runner2._frameDeltaFallback = 1e3 / 60;
            Runner2._timeBufferMargin = 1.5;
            Runner2._elapsedNextEstimate = 1;
            Runner2._smoothingLowerBound = 0.1;
            Runner2._smoothingUpperBound = 0.9;
            Runner2.create = function(options) {
              var defaults2 = {
                delta: 1e3 / 60,
                frameDelta: null,
                frameDeltaSmoothing: true,
                frameDeltaSnapping: true,
                frameDeltaHistory: [],
                frameDeltaHistorySize: 100,
                frameRequestId: null,
                timeBuffer: 0,
                timeLastTick: null,
                maxUpdates: null,
                maxFrameTime: 1e3 / 30,
                lastUpdatesDeferred: 0,
                enabled: true
              };
              var runner = Common.extend(defaults2, options);
              runner.fps = 0;
              return runner;
            };
            Runner2.run = function(runner, engine2) {
              runner.timeBuffer = Runner2._frameDeltaFallback;
              (function onFrame(time) {
                runner.frameRequestId = Runner2._onNextFrame(runner, onFrame);
                if (time && runner.enabled) {
                  Runner2.tick(runner, engine2, time);
                }
              })();
              return runner;
            };
            Runner2.tick = function(runner, engine2, time) {
              var tickStartTime = Common.now(), engineDelta = runner.delta, updateCount = 0;
              var frameDelta = time - runner.timeLastTick;
              if (!frameDelta || !runner.timeLastTick || frameDelta > Math.max(Runner2._maxFrameDelta, runner.maxFrameTime)) {
                frameDelta = runner.frameDelta || Runner2._frameDeltaFallback;
              }
              if (runner.frameDeltaSmoothing) {
                runner.frameDeltaHistory.push(frameDelta);
                runner.frameDeltaHistory = runner.frameDeltaHistory.slice(-runner.frameDeltaHistorySize);
                var deltaHistorySorted = runner.frameDeltaHistory.slice(0).sort();
                var deltaHistoryWindow = runner.frameDeltaHistory.slice(deltaHistorySorted.length * Runner2._smoothingLowerBound, deltaHistorySorted.length * Runner2._smoothingUpperBound);
                var frameDeltaSmoothed = _mean(deltaHistoryWindow);
                frameDelta = frameDeltaSmoothed || frameDelta;
              }
              if (runner.frameDeltaSnapping) {
                frameDelta = 1e3 / Math.round(1e3 / frameDelta);
              }
              runner.frameDelta = frameDelta;
              runner.timeLastTick = time;
              runner.timeBuffer += runner.frameDelta;
              runner.timeBuffer = Common.clamp(runner.timeBuffer, 0, runner.frameDelta + engineDelta * Runner2._timeBufferMargin);
              runner.lastUpdatesDeferred = 0;
              var maxUpdates = runner.maxUpdates || Math.ceil(runner.maxFrameTime / engineDelta);
              var event = {
                timestamp: engine2.timing.timestamp
              };
              Events2.trigger(runner, "beforeTick", event);
              Events2.trigger(runner, "tick", event);
              var updateStartTime = Common.now();
              while (engineDelta > 0 && runner.timeBuffer >= engineDelta * Runner2._timeBufferMargin) {
                Events2.trigger(runner, "beforeUpdate", event);
                Engine2.update(engine2, engineDelta);
                Events2.trigger(runner, "afterUpdate", event);
                runner.timeBuffer -= engineDelta;
                updateCount += 1;
                var elapsedTimeTotal = Common.now() - tickStartTime, elapsedTimeUpdates = Common.now() - updateStartTime, elapsedNextEstimate = elapsedTimeTotal + Runner2._elapsedNextEstimate * elapsedTimeUpdates / updateCount;
                if (updateCount >= maxUpdates || elapsedNextEstimate > runner.maxFrameTime) {
                  runner.lastUpdatesDeferred = Math.round(Math.max(0, runner.timeBuffer / engineDelta - Runner2._timeBufferMargin));
                  break;
                }
              }
              engine2.timing.lastUpdatesPerFrame = updateCount;
              Events2.trigger(runner, "afterTick", event);
              if (runner.frameDeltaHistory.length >= 100) {
                if (runner.lastUpdatesDeferred && Math.round(runner.frameDelta / engineDelta) > maxUpdates) {
                  Common.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.");
                } else if (runner.lastUpdatesDeferred) {
                  Common.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs.");
                }
                if (typeof runner.isFixed !== "undefined") {
                  Common.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs.");
                }
                if (runner.deltaMin || runner.deltaMax) {
                  Common.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs.");
                }
                if (runner.fps !== 0) {
                  Common.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs.");
                }
              }
            };
            Runner2.stop = function(runner) {
              Runner2._cancelNextFrame(runner);
            };
            Runner2._onNextFrame = function(runner, callback) {
              if (typeof window !== "undefined" && window.requestAnimationFrame) {
                runner.frameRequestId = window.requestAnimationFrame(callback);
              } else {
                throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");
              }
              return runner.frameRequestId;
            };
            Runner2._cancelNextFrame = function(runner) {
              if (typeof window !== "undefined" && window.cancelAnimationFrame) {
                window.cancelAnimationFrame(runner.frameRequestId);
              } else {
                throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.");
              }
            };
            var _mean = function(values) {
              var result = 0, valuesLength = values.length;
              for (var i2 = 0; i2 < valuesLength; i2 += 1) {
                result += values[i2];
              }
              return result / valuesLength || 0;
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var SAT = {};
          module2.exports = SAT;
          var Collision = __webpack_require__(8);
          var Common = __webpack_require__(0);
          var deprecated = Common.deprecated;
          (function() {
            SAT.collides = function(bodyA, bodyB) {
              return Collision.collides(bodyA, bodyB);
            };
            deprecated(SAT, "collides", "SAT.collides \u27A4 replaced by Collision.collides");
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var Svg = {};
          module2.exports = Svg;
          var Bounds2 = __webpack_require__(1);
          var Common = __webpack_require__(0);
          (function() {
            Svg.pathToVertices = function(path2, sampleLength) {
              if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
                Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
              }
              var i2, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x2 = 0, y2 = 0;
              sampleLength = sampleLength || 15;
              var addPoint = function(px, py, pathSegType) {
                var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                  if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                  } else {
                    lx = 0;
                    ly = 0;
                  }
                  var point2 = {
                    x: lx + px,
                    y: ly + py
                  };
                  if (isRelative || !lastPoint) {
                    lastPoint = point2;
                  }
                  points.push(point2);
                  x2 = lx + px;
                  y2 = ly + py;
                }
              };
              var addSegmentPoint = function(segment2) {
                var segType = segment2.pathSegTypeAsLetter.toUpperCase();
                if (segType === "Z")
                  return;
                switch (segType) {
                  case "M":
                  case "L":
                  case "T":
                  case "C":
                  case "S":
                  case "Q":
                    x2 = segment2.x;
                    y2 = segment2.y;
                    break;
                  case "H":
                    x2 = segment2.x;
                    break;
                  case "V":
                    y2 = segment2.y;
                    break;
                }
                addPoint(x2, y2, segment2.pathSegType);
              };
              Svg._svgPathToAbsolute(path2);
              total = path2.getTotalLength();
              segments = [];
              for (i2 = 0; i2 < path2.pathSegList.numberOfItems; i2 += 1)
                segments.push(path2.pathSegList.getItem(i2));
              segmentsQueue = segments.concat();
              while (length < total) {
                segmentIndex = path2.getPathSegAtLength(length);
                segment = segments[segmentIndex];
                if (segment != lastSegment) {
                  while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());
                  lastSegment = segment;
                }
                switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                  case "C":
                  case "T":
                  case "S":
                  case "Q":
                  case "A":
                    point = path2.getPointAtLength(length);
                    addPoint(point.x, point.y, 0);
                    break;
                }
                length += sampleLength;
              }
              for (i2 = 0, il = segmentsQueue.length; i2 < il; ++i2)
                addSegmentPoint(segmentsQueue[i2]);
              return points;
            };
            Svg._svgPathToAbsolute = function(path2) {
              var x0, y0, x1, y1, x2, y2, segs = path2.pathSegList, x3 = 0, y3 = 0, len = segs.numberOfItems;
              for (var i2 = 0; i2 < len; ++i2) {
                var seg = segs.getItem(i2), segType = seg.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(segType)) {
                  if ("x" in seg)
                    x3 = seg.x;
                  if ("y" in seg)
                    y3 = seg.y;
                } else {
                  if ("x1" in seg)
                    x1 = x3 + seg.x1;
                  if ("x2" in seg)
                    x2 = x3 + seg.x2;
                  if ("y1" in seg)
                    y1 = y3 + seg.y1;
                  if ("y2" in seg)
                    y2 = y3 + seg.y2;
                  if ("x" in seg)
                    x3 += seg.x;
                  if ("y" in seg)
                    y3 += seg.y;
                  switch (segType) {
                    case "m":
                      segs.replaceItem(path2.createSVGPathSegMovetoAbs(x3, y3), i2);
                      break;
                    case "l":
                      segs.replaceItem(path2.createSVGPathSegLinetoAbs(x3, y3), i2);
                      break;
                    case "h":
                      segs.replaceItem(path2.createSVGPathSegLinetoHorizontalAbs(x3), i2);
                      break;
                    case "v":
                      segs.replaceItem(path2.createSVGPathSegLinetoVerticalAbs(y3), i2);
                      break;
                    case "c":
                      segs.replaceItem(path2.createSVGPathSegCurvetoCubicAbs(x3, y3, x1, y1, x2, y2), i2);
                      break;
                    case "s":
                      segs.replaceItem(path2.createSVGPathSegCurvetoCubicSmoothAbs(x3, y3, x2, y2), i2);
                      break;
                    case "q":
                      segs.replaceItem(path2.createSVGPathSegCurvetoQuadraticAbs(x3, y3, x1, y1), i2);
                      break;
                    case "t":
                      segs.replaceItem(path2.createSVGPathSegCurvetoQuadraticSmoothAbs(x3, y3), i2);
                      break;
                    case "a":
                      segs.replaceItem(path2.createSVGPathSegArcAbs(x3, y3, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i2);
                      break;
                    case "z":
                    case "Z":
                      x3 = x0;
                      y3 = y0;
                      break;
                  }
                }
                if (segType == "M" || segType == "m") {
                  x0 = x3;
                  y0 = y3;
                }
              }
            };
          })();
        },
        function(module2, exports2, __webpack_require__) {
          var World2 = {};
          module2.exports = World2;
          var Composite = __webpack_require__(6);
          var Common = __webpack_require__(0);
          (function() {
            World2.create = Composite.create;
            World2.add = Composite.add;
            World2.remove = Composite.remove;
            World2.clear = Composite.clear;
            World2.addComposite = Composite.addComposite;
            World2.addBody = Composite.addBody;
            World2.addConstraint = Composite.addConstraint;
          })();
        }
      ]);
    });
  });

  // node_modules/pixi.js/lib/extensions/Extensions.mjs
  "use strict";
  var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
    ExtensionType2["Application"] = "application";
    ExtensionType2["WebGLPipes"] = "webgl-pipes";
    ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
    ExtensionType2["WebGLSystem"] = "webgl-system";
    ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
    ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
    ExtensionType2["WebGPUSystem"] = "webgpu-system";
    ExtensionType2["CanvasSystem"] = "canvas-system";
    ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
    ExtensionType2["CanvasPipes"] = "canvas-pipes";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    ExtensionType2["MaskEffect"] = "mask-effect";
    ExtensionType2["BlendMode"] = "blend-mode";
    ExtensionType2["TextureSource"] = "texture-source";
    ExtensionType2["Environment"] = "environment";
    ExtensionType2["ShapeBuilder"] = "shape-builder";
    ExtensionType2["Batcher"] = "batcher";
    return ExtensionType2;
  })(ExtensionType || {});
  var normalizeExtension = (ext) => {
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
      if (!ext.extension) {
        throw new Error("Extension class must have an extension object");
      }
      const metadata = typeof ext.extension !== "object" ? {type: ext.extension} : ext.extension;
      ext = {...metadata, ref: ext};
    }
    if (typeof ext === "object") {
      ext = {...ext};
    } else {
      throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
      ext.type = [ext.type];
    }
    return ext;
  };
  var normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
  var extensions = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
      });
      return this;
    },
    add(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => {
          const handlers = this._addHandlers;
          const queue = this._queue;
          if (!handlers[type]) {
            queue[type] = queue[type] || [];
            queue[type]?.push(ext);
          } else {
            handlers[type]?.(ext);
          }
        });
      });
      return this;
    },
    handle(type, onAdd, onRemove) {
      const addHandlers = this._addHandlers;
      const removeHandlers = this._removeHandlers;
      if (addHandlers[type] || removeHandlers[type]) {
        throw new Error(`Extension type ${type} already has a handler`);
      }
      addHandlers[type] = onAdd;
      removeHandlers[type] = onRemove;
      const queue = this._queue;
      if (queue[type]) {
        queue[type]?.forEach((ext) => onAdd(ext));
        delete queue[type];
      }
      return this;
    },
    handleByMap(type, map) {
      return this.handle(type, (extension) => {
        if (extension.name) {
          map[extension.name] = extension.ref;
        }
      }, (extension) => {
        if (extension.name) {
          delete map[extension.name];
        }
      });
    },
    handleByNamedList(type, map, defaultPriority = -1) {
      return this.handle(type, (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index >= 0)
          return;
        map.push({name: extension.name, value: extension.ref});
        map.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
      }, (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index !== -1) {
          map.splice(index, 1);
        }
      });
    },
    handleByList(type, list, defaultPriority = -1) {
      return this.handle(type, (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
      }, (extension) => {
        const index = list.indexOf(extension.ref);
        if (index !== -1) {
          list.splice(index, 1);
        }
      });
    },
    mixin(Target, ...sources2) {
      for (const source3 of sources2) {
        Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source3));
      }
    }
  };

  // node_modules/eventemitter3/index.mjs
  var import_index = __toModule(require_eventemitter3());
  var eventemitter3_default = import_index.default;

  // node_modules/@pixi/colord/index.mjs
  var r = {grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI)};
  var t = function(r2) {
    return typeof r2 == "string" ? r2.length > 0 : typeof r2 == "number";
  };
  var n = function(r2, t2, n2) {
    return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
  };
  var e = function(r2, t2, n2) {
    return t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
  };
  var u = function(r2) {
    return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
  };
  var a = function(r2) {
    return {r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a)};
  };
  var o = function(r2) {
    return {r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3)};
  };
  var i = /^#([0-9a-f]{3,8})$/i;
  var s = function(r2) {
    var t2 = r2.toString(16);
    return t2.length < 2 ? "0" + t2 : t2;
  };
  var h = function(r2) {
    var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
    return {h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2};
  };
  var b = function(r2) {
    var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
    t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
    var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
    return {r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2};
  };
  var g = function(r2) {
    return {h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a)};
  };
  var d = function(r2) {
    return {h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3)};
  };
  var f = function(r2) {
    return b((n2 = (t2 = r2).s, {h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a}));
    var t2, n2, e2;
  };
  var c = function(r2) {
    return {h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a};
    var t2, n2, e2, u2;
  };
  var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var y = {string: [[function(r2) {
    var t2 = i.exec(r2);
    return t2 ? (r2 = t2[1]).length <= 4 ? {r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: r2.length === 4 ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1} : r2.length === 6 || r2.length === 8 ? {r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: r2.length === 8 ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1} : null : null;
  }, "hex"], [function(r2) {
    var t2 = v.exec(r2) || m.exec(r2);
    return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: t2[7] === void 0 ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1)}) : null;
  }, "rgb"], [function(t2) {
    var n2 = l.exec(t2) || p.exec(t2);
    if (!n2)
      return null;
    var e2, u2, a2 = g({h: (e2 = n2[1], u2 = n2[2], u2 === void 0 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: n2[5] === void 0 ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1)});
    return f(a2);
  }, "hsl"]], object: [[function(r2) {
    var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = o2 === void 0 ? 1 : o2;
    return t(n2) && t(e2) && t(u2) ? a({r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2)}) : null;
  }, "rgb"], [function(r2) {
    var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = a2 === void 0 ? 1 : a2;
    if (!t(n2) || !t(e2) || !t(u2))
      return null;
    var i2 = g({h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2)});
    return f(i2);
  }, "hsl"], [function(r2) {
    var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = i2 === void 0 ? 1 : i2;
    if (!t(n2) || !t(a2) || !t(o2))
      return null;
    var h2 = function(r3) {
      return {h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a)};
    }({h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2)});
    return b(h2);
  }, "hsv"]]};
  var N = function(r2, t2) {
    for (var n2 = 0; n2 < t2.length; n2++) {
      var e2 = t2[n2][0](r2);
      if (e2)
        return [e2, t2[n2][1]];
    }
    return [null, void 0];
  };
  var x = function(r2) {
    return typeof r2 == "string" ? N(r2.trim(), y.string) : typeof r2 == "object" && r2 !== null ? N(r2, y.object) : [null, void 0];
  };
  var M = function(r2, t2) {
    var n2 = c(r2);
    return {h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a};
  };
  var H = function(r2) {
    return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
  };
  var $ = function(r2, t2) {
    var n2 = c(r2);
    return {h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a};
  };
  var j = function() {
    function r2(r3) {
      this.parsed = x(r3)[0], this.rgba = this.parsed || {r: 0, g: 0, b: 0, a: 1};
    }
    return r2.prototype.isValid = function() {
      return this.parsed !== null;
    }, r2.prototype.brightness = function() {
      return n(H(this.rgba), 2);
    }, r2.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r2.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r2.prototype.toHex = function() {
      return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
      var r3, t2, e2, u2, a2, i2;
    }, r2.prototype.toRgb = function() {
      return o(this.rgba);
    }, r2.prototype.toRgbString = function() {
      return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
      var r3, t2, n2, e2, u2;
    }, r2.prototype.toHsl = function() {
      return d(c(this.rgba));
    }, r2.prototype.toHslString = function() {
      return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
      var r3, t2, n2, e2, u2;
    }, r2.prototype.toHsv = function() {
      return r3 = h(this.rgba), {h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3)};
      var r3;
    }, r2.prototype.invert = function() {
      return w({r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a});
      var r3;
    }, r2.prototype.saturate = function(r3) {
      return r3 === void 0 && (r3 = 0.1), w(M(this.rgba, r3));
    }, r2.prototype.desaturate = function(r3) {
      return r3 === void 0 && (r3 = 0.1), w(M(this.rgba, -r3));
    }, r2.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r2.prototype.lighten = function(r3) {
      return r3 === void 0 && (r3 = 0.1), w($(this.rgba, r3));
    }, r2.prototype.darken = function(r3) {
      return r3 === void 0 && (r3 = 0.1), w($(this.rgba, -r3));
    }, r2.prototype.rotate = function(r3) {
      return r3 === void 0 && (r3 = 15), this.hue(this.hue() + r3);
    }, r2.prototype.alpha = function(r3) {
      return typeof r3 == "number" ? w({r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3}) : n(this.rgba.a, 3);
      var t2;
    }, r2.prototype.hue = function(r3) {
      var t2 = c(this.rgba);
      return typeof r3 == "number" ? w({h: r3, s: t2.s, l: t2.l, a: t2.a}) : n(t2.h);
    }, r2.prototype.isEqual = function(r3) {
      return this.toHex() === w(r3).toHex();
    }, r2;
  }();
  var w = function(r2) {
    return r2 instanceof j ? r2 : new j(r2);
  };
  var S = [];
  var k = function(r2) {
    r2.forEach(function(r3) {
      S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
    });
  };

  // node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = {white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000"}, r2 = {};
    for (var d2 in a2)
      r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d3, i2, n2 = r2[this.toHex()];
      if (n2)
        return n2;
      if (f3 == null ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length)
          for (var c2 in a2)
            l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = r3 === "transparent" ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }

  // node_modules/pixi.js/lib/color/Color.mjs
  k([names_default]);
  var _Color = class _Color2 {
    constructor(value = 16777215) {
      this._value = null;
      this._components = new Float32Array(4);
      this._components.fill(1);
      this._int = 16777215;
      this.value = value;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(value) {
      this.value = value;
      return this;
    }
    set value(value) {
      if (value instanceof _Color2) {
        this._value = this._cloneSource(value._value);
        this._int = value._int;
        this._components.set(value._components);
      } else if (value === null) {
        throw new Error("Cannot set Color#value to null");
      } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
        this._value = this._cloneSource(value);
        this._normalize(this._value);
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(value) {
      if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
        return value;
      } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
        return value.slice(0);
      } else if (typeof value === "object" && value !== null) {
        return {...value};
      }
      return value;
    }
    _isSourceEqual(value1, value2) {
      const type1 = typeof value1;
      const type2 = typeof value2;
      if (type1 !== type2) {
        return false;
      } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
        return value1 === value2;
      } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
        if (value1.length !== value2.length) {
          return false;
        }
        return value1.every((v2, i2) => v2 === value2[i2]);
      } else if (value1 !== null && value2 !== null) {
        const keys1 = Object.keys(value1);
        const keys2 = Object.keys(value2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keys1.every((key) => value1[key] === value2[key]);
      }
      return value1 === value2;
    }
    toRgba() {
      const [r2, g2, b2, a2] = this._components;
      return {r: r2, g: g2, b: b2, a: a2};
    }
    toRgb() {
      const [r2, g2, b2] = this._components;
      return {r: r2, g: g2, b: b2};
    }
    toRgbaString() {
      const [r2, g2, b2] = this.toUint8RgbArray();
      return `rgba(${r2},${g2},${b2},${this.alpha})`;
    }
    toUint8RgbArray(out2) {
      const [r2, g2, b2] = this._components;
      if (!this._arrayRgb) {
        this._arrayRgb = [];
      }
      out2 || (out2 = this._arrayRgb);
      out2[0] = Math.round(r2 * 255);
      out2[1] = Math.round(g2 * 255);
      out2[2] = Math.round(b2 * 255);
      return out2;
    }
    toArray(out2) {
      if (!this._arrayRgba) {
        this._arrayRgba = [];
      }
      out2 || (out2 = this._arrayRgba);
      const [r2, g2, b2, a2] = this._components;
      out2[0] = r2;
      out2[1] = g2;
      out2[2] = b2;
      out2[3] = a2;
      return out2;
    }
    toRgbArray(out2) {
      if (!this._arrayRgb) {
        this._arrayRgb = [];
      }
      out2 || (out2 = this._arrayRgb);
      const [r2, g2, b2] = this._components;
      out2[0] = r2;
      out2[1] = g2;
      out2[2] = b2;
      return out2;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [r2, g2, b2] = this.toUint8RgbArray();
      return (b2 << 16) + (g2 << 8) + r2;
    }
    toLittleEndianNumber() {
      const value = this._int;
      return (value >> 16) + (value & 65280) + ((value & 255) << 16);
    }
    multiply(value) {
      const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
      this._components[0] *= r2;
      this._components[1] *= g2;
      this._components[2] *= b2;
      this._components[3] *= a2;
      this._refreshInt();
      this._value = null;
      return this;
    }
    premultiply(alpha, applyToRGB = true) {
      if (applyToRGB) {
        this._components[0] *= alpha;
        this._components[1] *= alpha;
        this._components[2] *= alpha;
      }
      this._components[3] = alpha;
      this._refreshInt();
      this._value = null;
      return this;
    }
    toPremultiplied(alpha, applyToRGB = true) {
      if (alpha === 1) {
        return (255 << 24) + this._int;
      }
      if (alpha === 0) {
        return applyToRGB ? 0 : this._int;
      }
      let r2 = this._int >> 16 & 255;
      let g2 = this._int >> 8 & 255;
      let b2 = this._int & 255;
      if (applyToRGB) {
        r2 = r2 * alpha + 0.5 | 0;
        g2 = g2 * alpha + 0.5 | 0;
        b2 = b2 * alpha + 0.5 | 0;
      }
      return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
    }
    toHex() {
      const hexString = this._int.toString(16);
      return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
    }
    toHexa() {
      const alphaValue = Math.round(this._components[3] * 255);
      const alphaString = alphaValue.toString(16);
      return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
    }
    setAlpha(alpha) {
      this._components[3] = this._clamp(alpha);
      return this;
    }
    _normalize(value) {
      let r2;
      let g2;
      let b2;
      let a2;
      if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
        const int = value;
        r2 = (int >> 16 & 255) / 255;
        g2 = (int >> 8 & 255) / 255;
        b2 = (int & 255) / 255;
        a2 = 1;
      } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
        value = this._clamp(value);
        [r2, g2, b2, a2 = 1] = value;
      } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
        value = this._clamp(value, 0, 255);
        [r2, g2, b2, a2 = 255] = value;
        r2 /= 255;
        g2 /= 255;
        b2 /= 255;
        a2 /= 255;
      } else if (typeof value === "string" || typeof value === "object") {
        if (typeof value === "string") {
          const match = _Color2.HEX_PATTERN.exec(value);
          if (match) {
            value = `#${match[2]}`;
          }
        }
        const color = w(value);
        if (color.isValid()) {
          ({r: r2, g: g2, b: b2, a: a2} = color.rgba);
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
        }
      }
      if (r2 !== void 0) {
        this._components[0] = r2;
        this._components[1] = g2;
        this._components[2] = b2;
        this._components[3] = a2;
        this._refreshInt();
      } else {
        throw new Error(`Unable to convert color ${value}`);
      }
    }
    _refreshInt() {
      this._clamp(this._components);
      const [r2, g2, b2] = this._components;
      this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
    }
    _clamp(value, min = 0, max = 1) {
      if (typeof value === "number") {
        return Math.min(Math.max(value, min), max);
      }
      value.forEach((v2, i2) => {
        value[i2] = Math.min(Math.max(v2, min), max);
      });
      return value;
    }
    static isColorLike(value) {
      return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
    }
  };
  _Color.shared = new _Color();
  _Color._temp = new _Color();
  _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  var Color = _Color;

  // node_modules/pixi.js/lib/culling/cullingMixin.mjs
  "use strict";
  var cullingMixin = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };

  // node_modules/pixi.js/lib/maths/misc/const.mjs
  "use strict";
  var PI_2 = Math.PI * 2;
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;

  // node_modules/pixi.js/lib/maths/point/Point.mjs
  "use strict";
  var Point = class {
    constructor(x2 = 0, y2 = 0) {
      this.x = 0;
      this.y = 0;
      this.x = x2;
      this.y = y2;
    }
    clone() {
      return new Point(this.x, this.y);
    }
    copyFrom(p2) {
      this.set(p2.x, p2.y);
      return this;
    }
    copyTo(p2) {
      p2.set(this.x, this.y);
      return p2;
    }
    equals(p2) {
      return p2.x === this.x && p2.y === this.y;
    }
    set(x2 = 0, y2 = x2) {
      this.x = x2;
      this.y = y2;
      return this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      tempPoint.x = 0;
      tempPoint.y = 0;
      return tempPoint;
    }
  };
  var tempPoint = new Point();

  // node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
  var Matrix = class {
    constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
      this.array = null;
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
    }
    fromArray(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    }
    set(a2, b2, c2, d2, tx, ty) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
      this.d = d2;
      this.tx = tx;
      this.ty = ty;
      return this;
    }
    toArray(transpose, out2) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      const array = out2 || this.array;
      if (transpose) {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
      } else {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
      }
      return array;
    }
    apply(pos, newPos) {
      newPos = newPos || new Point();
      const x2 = pos.x;
      const y2 = pos.y;
      newPos.x = this.a * x2 + this.c * y2 + this.tx;
      newPos.y = this.b * x2 + this.d * y2 + this.ty;
      return newPos;
    }
    applyInverse(pos, newPos) {
      newPos = newPos || new Point();
      const a2 = this.a;
      const b2 = this.b;
      const c2 = this.c;
      const d2 = this.d;
      const tx = this.tx;
      const ty = this.ty;
      const id = 1 / (a2 * d2 + c2 * -b2);
      const x2 = pos.x;
      const y2 = pos.y;
      newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
      newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
      return newPos;
    }
    translate(x2, y2) {
      this.tx += x2;
      this.ty += y2;
      return this;
    }
    scale(x2, y2) {
      this.a *= x2;
      this.d *= y2;
      this.c *= x2;
      this.b *= y2;
      this.tx *= x2;
      this.ty *= y2;
      return this;
    }
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const a1 = this.a;
      const c1 = this.c;
      const tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    }
    append(matrix) {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    }
    appendFrom(a2, b2) {
      const a1 = a2.a;
      const b1 = a2.b;
      const c1 = a2.c;
      const d1 = a2.d;
      const tx = a2.tx;
      const ty = a2.ty;
      const a22 = b2.a;
      const b22 = b2.b;
      const c2 = b2.c;
      const d2 = b2.d;
      this.a = a1 * a22 + b1 * c2;
      this.b = a1 * b22 + b1 * d2;
      this.c = c1 * a22 + d1 * c2;
      this.d = c1 * b22 + d1 * d2;
      this.tx = tx * a22 + ty * c2 + b2.tx;
      this.ty = tx * b22 + ty * d2 + b2.ty;
      return this;
    }
    setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x2 - (pivotX * this.a + pivotY * this.c);
      this.ty = y2 - (pivotX * this.b + pivotY * this.d);
      return this;
    }
    prepend(matrix) {
      const tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        const a1 = this.a;
        const c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    }
    decompose(transform) {
      const a2 = this.a;
      const b2 = this.b;
      const c2 = this.c;
      const d2 = this.d;
      const pivot = transform.pivot;
      const skewX = -Math.atan2(-c2, d2);
      const skewY = Math.atan2(b2, a2);
      const delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
      transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
      transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
      transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
      return transform;
    }
    invert() {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      const tx1 = this.tx;
      const n2 = a1 * d1 - b1 * c1;
      this.a = d1 / n2;
      this.b = -b1 / n2;
      this.c = -c1 / n2;
      this.d = a1 / n2;
      this.tx = (c1 * this.ty - d1 * tx1) / n2;
      this.ty = -(a1 * this.ty - b1 * tx1) / n2;
      return this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    }
    clone() {
      const matrix = new Matrix();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyTo(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyFrom(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    }
    equals(matrix) {
      return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return identityMatrix.identity();
    }
    static get shared() {
      return tempMatrix.identity();
    }
  };
  var tempMatrix = new Matrix();
  var identityMatrix = new Matrix();

  // node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
  "use strict";
  var ObservablePoint = class {
    constructor(observer, x2, y2) {
      this._x = x2 || 0;
      this._y = y2 || 0;
      this._observer = observer;
    }
    clone(observer) {
      return new ObservablePoint(observer ?? this._observer, this._x, this._y);
    }
    set(x2 = 0, y2 = x2) {
      if (this._x !== x2 || this._y !== y2) {
        this._x = x2;
        this._y = y2;
        this._observer._onUpdate(this);
      }
      return this;
    }
    copyFrom(p2) {
      if (this._x !== p2.x || this._y !== p2.y) {
        this._x = p2.x;
        this._y = p2.y;
        this._observer._onUpdate(this);
      }
      return this;
    }
    copyTo(p2) {
      p2.set(this._x, this._y);
      return p2;
    }
    equals(p2) {
      return p2.x === this._x && p2.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      if (this._x !== value) {
        this._x = value;
        this._observer._onUpdate(this);
      }
    }
    get y() {
      return this._y;
    }
    set y(value) {
      if (this._y !== value) {
        this._y = value;
        this._observer._onUpdate(this);
      }
    }
  };

  // node_modules/pixi.js/lib/utils/data/uid.mjs
  "use strict";
  var uidCache = {
    default: -1
  };
  function uid(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }

  // node_modules/pixi.js/lib/utils/logging/deprecation.mjs
  "use strict";
  var warnings = /* @__PURE__ */ new Set();
  var v8_0_0 = "8.0.0";
  var v8_3_4 = "8.3.4";
  var deprecationState = {
    quiet: false,
    noColor: false
  };
  var deprecation = (version, message, ignoreDepth = 3) => {
    if (deprecationState.quiet || warnings.has(message))
      return;
    let stack = new Error().stack;
    const deprecationMessage = `${message}
Deprecated since v${version}`;
    const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (useGroup) {
        console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", deprecationMessage);
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
        console.warn(stack);
      }
    }
    warnings.add(message);
  };
  Object.defineProperties(deprecation, {
    quiet: {
      get: () => deprecationState.quiet,
      set: (value) => {
        deprecationState.quiet = value;
      },
      enumerable: true,
      configurable: false
    },
    noColor: {
      get: () => deprecationState.noColor,
      set: (value) => {
        deprecationState.noColor = value;
      },
      enumerable: true,
      configurable: false
    }
  });

  // node_modules/pixi.js/lib/utils/logging/warn.mjs
  "use strict";
  var warnCount = 0;
  var maxWarnings = 500;
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }

  // node_modules/pixi.js/lib/utils/pool/GlobalResourceRegistry.mjs
  "use strict";
  var GlobalResourceRegistry = {
    _registeredResources: /* @__PURE__ */ new Set(),
    register(pool) {
      this._registeredResources.add(pool);
    },
    unregister(pool) {
      this._registeredResources.delete(pool);
    },
    release() {
      this._registeredResources.forEach((pool) => pool.clear());
    },
    get registeredCount() {
      return this._registeredResources.size;
    },
    isRegistered(pool) {
      return this._registeredResources.has(pool);
    },
    reset() {
      this._registeredResources.clear();
    }
  };

  // node_modules/pixi.js/lib/utils/pool/Pool.mjs
  "use strict";
  var Pool = class {
    constructor(ClassType, initialSize) {
      this._pool = [];
      this._count = 0;
      this._index = 0;
      this._classType = ClassType;
      if (initialSize) {
        this.prepopulate(initialSize);
      }
    }
    prepopulate(total) {
      for (let i2 = 0; i2 < total; i2++) {
        this._pool[this._index++] = new this._classType();
      }
      this._count += total;
    }
    get(data) {
      let item;
      if (this._index > 0) {
        item = this._pool[--this._index];
      } else {
        item = new this._classType();
      }
      item.init?.(data);
      return item;
    }
    return(item) {
      item.reset?.();
      this._pool[this._index++] = item;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      if (this._pool.length > 0 && this._pool[0].destroy) {
        for (let i2 = 0; i2 < this._index; i2++) {
          this._pool[i2].destroy();
        }
      }
      this._pool.length = 0;
      this._count = 0;
      this._index = 0;
    }
  };

  // node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass = class {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(Class, total) {
      const classPool = this.getPool(Class);
      classPool.prepopulate(total);
    }
    get(Class, data) {
      const pool = this.getPool(Class);
      return pool.get(data);
    }
    return(item) {
      const pool = this.getPool(item.constructor);
      pool.return(item);
    }
    getPool(ClassType) {
      if (!this._poolsByClass.has(ClassType)) {
        this._poolsByClass.set(ClassType, new Pool(ClassType));
      }
      return this._poolsByClass.get(ClassType);
    }
    stats() {
      const stats = {};
      this._poolsByClass.forEach((pool) => {
        const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
        stats[name] = {
          free: pool.totalFree,
          used: pool.totalUsed,
          size: pool.totalSize
        };
      });
      return stats;
    }
    clear() {
      this._poolsByClass.forEach((pool) => pool.clear());
      this._poolsByClass.clear();
    }
  };
  var BigPool = new PoolGroupClass();
  GlobalResourceRegistry.register(BigPool);

  // node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs
  var cacheAsTextureMixin = {
    get isCachedAsTexture() {
      return !!this.renderGroup?.isCachedAsTexture;
    },
    cacheAsTexture(val) {
      if (typeof val === "boolean" && val === false) {
        this.disableRenderGroup();
      } else {
        this.enableRenderGroup();
        this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
      }
    },
    updateCacheTexture() {
      this.renderGroup?.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(val) {
      deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
      this.cacheAsTexture(val);
    }
  };

  // node_modules/pixi.js/lib/utils/data/removeItems.mjs
  "use strict";
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i2;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i2 = startIdx; i2 < len; ++i2) {
      arr[i2] = arr[i2 + removeCount];
    }
    arr.length = len;
  }

  // node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin = {
    allowChildren: true,
    removeChildren(beginIndex = 0, endIndex) {
      const end = endIndex ?? this.children.length;
      const range = end - beginIndex;
      const removed = [];
      if (range > 0 && range <= end) {
        for (let i2 = end - 1; i2 >= beginIndex; i2--) {
          const child = this.children[i2];
          if (!child)
            continue;
          removed.push(child);
          child.parent = null;
        }
        removeItems(this.children, beginIndex, end);
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.removeChildren(removed);
        }
        for (let i2 = 0; i2 < removed.length; ++i2) {
          const child = removed[i2];
          child.parentRenderLayer?.detach(child);
          this.emit("childRemoved", child, this, i2);
          removed[i2].emit("removed", this);
        }
        if (removed.length > 0) {
          this._didViewChangeTick++;
        }
        return removed;
      } else if (range === 0 && this.children.length === 0) {
        return removed;
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(index) {
      const child = this.getChildAt(index);
      return this.removeChild(child);
    },
    getChildAt(index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`getChildAt: Index (${index}) does not exist.`);
      }
      return this.children[index];
    },
    setChildIndex(child, index) {
      if (index < 0 || index >= this.children.length) {
        throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
      }
      this.getChildIndex(child);
      this.addChildAt(child, index);
    },
    getChildIndex(child) {
      const index = this.children.indexOf(child);
      if (index === -1) {
        throw new Error("The supplied Container must be a child of the caller");
      }
      return index;
    },
    addChildAt(child, index) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      }
      const {children} = this;
      if (index < 0 || index > children.length) {
        throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
      }
      if (child.parent) {
        const currentIndex = child.parent.children.indexOf(child);
        if (child.parent === this && currentIndex === index) {
          return child;
        }
        if (currentIndex !== -1) {
          child.parent.children.splice(currentIndex, 1);
        }
      }
      if (index === children.length) {
        children.push(child);
      } else {
        children.splice(index, 0, child);
      }
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      if (this.sortableChildren)
        this.sortDirty = true;
      this.emit("childAdded", child, this, index);
      child.emit("added", this);
      return child;
    },
    swapChildren(child, child2) {
      if (child === child2) {
        return;
      }
      const index1 = this.getChildIndex(child);
      const index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      this._didContainerChangeTick++;
    },
    removeFromParent() {
      this.parent?.removeChild(this);
    },
    reparentChild(...child) {
      if (child.length === 1) {
        return this.reparentChildAt(child[0], this.children.length);
      }
      child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
      return child[0];
    },
    reparentChildAt(child, index) {
      if (child.parent === this) {
        this.setChildIndex(child, index);
        return child;
      }
      const childMat = child.worldTransform.clone();
      child.removeFromParent();
      this.addChildAt(child, index);
      const newMatrix = this.worldTransform.clone();
      newMatrix.invert();
      childMat.prepend(newMatrix);
      child.setFromMatrix(childMat);
      return child;
    },
    replaceChild(oldChild, newChild) {
      oldChild.updateLocalTransform();
      this.addChildAt(newChild, this.getChildIndex(oldChild));
      newChild.setFromMatrix(oldChild.localTransform);
      newChild.updateLocalTransform();
      this.removeChild(oldChild);
    }
  };

  // node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs
  "use strict";
  var collectRenderablesMixin = {
    collectRenderables(instructionSet, renderer, currentLayer) {
      if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
        return;
      if (this.sortableChildren) {
        this.sortChildren();
      }
      if (this.isSimple) {
        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
      } else if (this.renderGroup) {
        renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
      } else {
        this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
      }
    },
    collectRenderablesSimple(instructionSet, renderer, currentLayer) {
      const children = this.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        children[i2].collectRenderables(instructionSet, renderer, currentLayer);
      }
    },
    collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
      const {renderPipes} = renderer;
      for (let i2 = 0; i2 < this.effects.length; i2++) {
        const effect = this.effects[i2];
        const pipe3 = renderPipes[effect.pipe];
        pipe3.push(effect, this, instructionSet);
      }
      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
      for (let i2 = this.effects.length - 1; i2 >= 0; i2--) {
        const effect = this.effects[i2];
        const pipe3 = renderPipes[effect.pipe];
        pipe3.pop(effect, this, instructionSet);
      }
    }
  };

  // node_modules/pixi.js/lib/filters/FilterEffect.mjs
  "use strict";
  var FilterEffect = class {
    constructor() {
      this.pipe = "filter";
      this.priority = 1;
    }
    destroy() {
      for (let i2 = 0; i2 < this.filters.length; i2++) {
        this.filters[i2].destroy();
      }
      this.filters = null;
      this.filterArea = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass = class {
    constructor() {
      this._effectClasses = [];
      this._tests = [];
      this._initialized = false;
    }
    init() {
      if (this._initialized)
        return;
      this._initialized = true;
      this._effectClasses.forEach((test) => {
        this.add({
          test: test.test,
          maskClass: test
        });
      });
    }
    add(test) {
      this._tests.push(test);
    }
    getMaskEffect(item) {
      if (!this._initialized)
        this.init();
      for (let i2 = 0; i2 < this._tests.length; i2++) {
        const test = this._tests[i2];
        if (test.test(item)) {
          return BigPool.get(test.maskClass, item);
        }
      }
      return item;
    }
    returnMaskEffect(effect) {
      BigPool.return(effect);
    }
  };
  var MaskEffectManager = new MaskEffectManagerClass();
  extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);

  // node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
    },
    addEffect(effect) {
      const index = this.effects.indexOf(effect);
      if (index !== -1)
        return;
      this.effects.push(effect);
      this.effects.sort((a2, b2) => a2.priority - b2.priority);
      this._markStructureAsChanged();
      this._updateIsSimple();
    },
    removeEffect(effect) {
      const index = this.effects.indexOf(effect);
      if (index === -1)
        return;
      this.effects.splice(index, 1);
      this._markStructureAsChanged();
      this._updateIsSimple();
    },
    set mask(value) {
      const effect = this._maskEffect;
      if (effect?.mask === value)
        return;
      if (effect) {
        this.removeEffect(effect);
        MaskEffectManager.returnMaskEffect(effect);
        this._maskEffect = null;
      }
      if (value === null || value === void 0)
        return;
      this._maskEffect = MaskEffectManager.getMaskEffect(value);
      this.addEffect(this._maskEffect);
    },
    get mask() {
      return this._maskEffect?.mask;
    },
    setMask(options) {
      this._maskOptions = {
        ...this._maskOptions,
        ...options
      };
      if (options.mask) {
        this.mask = options.mask;
      }
      this._markStructureAsChanged();
    },
    set filters(value) {
      if (!Array.isArray(value) && value)
        value = [value];
      const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
      value = value;
      const hasFilters = value?.length > 0;
      const hadFilters = effect.filters?.length > 0;
      const didChange = hasFilters !== hadFilters;
      value = Array.isArray(value) ? value.slice(0) : value;
      effect.filters = Object.freeze(value);
      if (didChange) {
        if (hasFilters) {
          this.addEffect(effect);
        } else {
          this.removeEffect(effect);
          effect.filters = value ?? null;
        }
      }
    },
    get filters() {
      return this._filterEffect?.filters;
    },
    set filterArea(value) {
      this._filterEffect || (this._filterEffect = new FilterEffect());
      this._filterEffect.filterArea = value;
    },
    get filterArea() {
      return this._filterEffect?.filterArea;
    }
  };

  // node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin = {
    label: null,
    get name() {
      deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
      return this.label;
    },
    set name(value) {
      deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
      this.label = value;
    },
    getChildByName(name, deep = false) {
      return this.getChildByLabel(name, deep);
    },
    getChildByLabel(label2, deep = false) {
      const children = this.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.label === label2 || label2 instanceof RegExp && label2.test(child.label))
          return child;
      }
      if (deep) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          const found = child.getChildByLabel(label2, true);
          if (found) {
            return found;
          }
        }
      }
      return null;
    },
    getChildrenByLabel(label2, deep = false, out2 = []) {
      const children = this.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.label === label2 || label2 instanceof RegExp && label2.test(child.label)) {
          out2.push(child);
        }
      }
      if (deep) {
        for (let i2 = 0; i2 < children.length; i2++) {
          children[i2].getChildrenByLabel(label2, true, out2);
        }
      }
      return out2;
    }
  };

  // node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
  var tempPoints = [new Point(), new Point(), new Point(), new Point()];
  var Rectangle = class {
    constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
      this.type = "rectangle";
      this.x = Number(x2);
      this.y = Number(y2);
      this.width = Number(width);
      this.height = Number(height);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(bounds) {
      this.x = bounds.minX;
      this.y = bounds.minY;
      this.width = bounds.maxX - bounds.minX;
      this.height = bounds.maxY - bounds.minY;
      return this;
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    contains(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 < this.x + this.width) {
        if (y2 >= this.y && y2 < this.y + this.height) {
          return true;
        }
      }
      return false;
    }
    strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
      const {width, height} = this;
      if (width <= 0 || height <= 0)
        return false;
      const _x = this.x;
      const _y = this.y;
      const strokeWidthOuter = strokeWidth * (1 - alignment);
      const strokeWidthInner = strokeWidth - strokeWidthOuter;
      const outerLeft = _x - strokeWidthOuter;
      const outerRight = _x + width + strokeWidthOuter;
      const outerTop = _y - strokeWidthOuter;
      const outerBottom = _y + height + strokeWidthOuter;
      const innerLeft = _x + strokeWidthInner;
      const innerRight = _x + width - strokeWidthInner;
      const innerTop = _y + strokeWidthInner;
      const innerBottom = _y + height - strokeWidthInner;
      return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
    }
    intersects(other, transform) {
      if (!transform) {
        const x02 = this.x < other.x ? other.x : this.x;
        const x12 = this.right > other.right ? other.right : this.right;
        if (x12 <= x02) {
          return false;
        }
        const y02 = this.y < other.y ? other.y : this.y;
        const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y12 > y02;
      }
      const x0 = this.left;
      const x1 = this.right;
      const y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      const lt = tempPoints[0].set(other.left, other.top);
      const lb = tempPoints[1].set(other.left, other.bottom);
      const rt = tempPoints[2].set(other.right, other.top);
      const rb = tempPoints[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return false;
      }
      const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (s2 === 0) {
        return false;
      }
      transform.apply(lt, lt);
      transform.apply(lb, lb);
      transform.apply(rt, rt);
      transform.apply(rb, rb);
      if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
        return false;
      }
      const nx = s2 * (lb.y - lt.y);
      const ny = s2 * (lt.x - lb.x);
      const n00 = nx * x0 + ny * y0;
      const n10 = nx * x1 + ny * y0;
      const n01 = nx * x0 + ny * y1;
      const n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
        return false;
      }
      const mx = s2 * (lt.y - rt.y);
      const my = s2 * (rt.x - lt.x);
      const m00 = mx * x0 + my * y0;
      const m10 = mx * x1 + my * y0;
      const m01 = mx * x0 + my * y1;
      const m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
        return false;
      }
      return true;
    }
    pad(paddingX = 0, paddingY = paddingX) {
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    }
    fit(rectangle) {
      const x1 = Math.max(this.x, rectangle.x);
      const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.max(this.y, rectangle.y);
      const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    }
    ceil(resolution = 1, eps = 1e-3) {
      const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    }
    scale(x2, y2 = x2) {
      this.x *= x2;
      this.y *= y2;
      this.width *= x2;
      this.height *= y2;
      return this;
    }
    enlarge(rectangle) {
      const x1 = Math.min(this.x, rectangle.x);
      const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.min(this.y, rectangle.y);
      const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    }
    getBounds(out2) {
      out2 || (out2 = new Rectangle());
      out2.copyFrom(this);
      return out2;
    }
    containsRect(other) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      const x1 = other.x;
      const y1 = other.y;
      const x2 = other.x + other.width;
      const y2 = other.y + other.height;
      return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
    }
    set(x2, y2, width, height) {
      this.x = x2;
      this.y = y2;
      this.width = width;
      this.height = height;
      return this;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };

  // node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix = new Matrix();
  var Bounds = class {
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.matrix = defaultMatrix;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      if (!this._rectangle) {
        this._rectangle = new Rectangle();
      }
      const rectangle = this._rectangle;
      if (this.minX > this.maxX || this.minY > this.maxY) {
        rectangle.x = 0;
        rectangle.y = 0;
        rectangle.width = 0;
        rectangle.height = 0;
      } else {
        rectangle.copyFromBounds(this);
      }
      return rectangle;
    }
    clear() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.matrix = defaultMatrix;
      return this;
    }
    set(x0, y0, x1, y1) {
      this.minX = x0;
      this.minY = y0;
      this.maxX = x1;
      this.maxY = y1;
    }
    addFrame(x0, y0, x1, y1, matrix) {
      matrix || (matrix = this.matrix);
      const a2 = matrix.a;
      const b2 = matrix.b;
      const c2 = matrix.c;
      const d2 = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x2 = a2 * x0 + c2 * y0 + tx;
      let y2 = b2 * x0 + d2 * y0 + ty;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      x2 = a2 * x1 + c2 * y0 + tx;
      y2 = b2 * x1 + d2 * y0 + ty;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      x2 = a2 * x0 + c2 * y1 + tx;
      y2 = b2 * x0 + d2 * y1 + ty;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      x2 = a2 * x1 + c2 * y1 + tx;
      y2 = b2 * x1 + d2 * y1 + ty;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addRect(rect, matrix) {
      this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
    }
    addBounds(bounds, matrix) {
      this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
    }
    addBoundsMask(mask) {
      this.minX = this.minX > mask.minX ? this.minX : mask.minX;
      this.minY = this.minY > mask.minY ? this.minY : mask.minY;
      this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
      this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
    }
    applyMatrix(matrix) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      const {a: a2, b: b2, c: c2, d: d2, tx, ty} = matrix;
      let x2 = a2 * minX + c2 * minY + tx;
      let y2 = b2 * minX + d2 * minY + ty;
      this.minX = x2;
      this.minY = y2;
      this.maxX = x2;
      this.maxY = y2;
      x2 = a2 * maxX + c2 * minY + tx;
      y2 = b2 * maxX + d2 * minY + ty;
      this.minX = x2 < this.minX ? x2 : this.minX;
      this.minY = y2 < this.minY ? y2 : this.minY;
      this.maxX = x2 > this.maxX ? x2 : this.maxX;
      this.maxY = y2 > this.maxY ? y2 : this.maxY;
      x2 = a2 * minX + c2 * maxY + tx;
      y2 = b2 * minX + d2 * maxY + ty;
      this.minX = x2 < this.minX ? x2 : this.minX;
      this.minY = y2 < this.minY ? y2 : this.minY;
      this.maxX = x2 > this.maxX ? x2 : this.maxX;
      this.maxY = y2 > this.maxY ? y2 : this.maxY;
      x2 = a2 * maxX + c2 * maxY + tx;
      y2 = b2 * maxX + d2 * maxY + ty;
      this.minX = x2 < this.minX ? x2 : this.minX;
      this.minY = y2 < this.minY ? y2 : this.minY;
      this.maxX = x2 > this.maxX ? x2 : this.maxX;
      this.maxY = y2 > this.maxY ? y2 : this.maxY;
    }
    fit(rect) {
      if (this.minX < rect.left)
        this.minX = rect.left;
      if (this.maxX > rect.right)
        this.maxX = rect.right;
      if (this.minY < rect.top)
        this.minY = rect.top;
      if (this.maxY > rect.bottom)
        this.maxY = rect.bottom;
      return this;
    }
    fitBounds(left, right, top, bottom) {
      if (this.minX < left)
        this.minX = left;
      if (this.maxX > right)
        this.maxX = right;
      if (this.minY < top)
        this.minY = top;
      if (this.maxY > bottom)
        this.maxY = bottom;
      return this;
    }
    pad(paddingX, paddingY = paddingX) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
      return this;
    }
    ceil() {
      this.minX = Math.floor(this.minX);
      this.minY = Math.floor(this.minY);
      this.maxX = Math.ceil(this.maxX);
      this.maxY = Math.ceil(this.maxY);
      return this;
    }
    clone() {
      return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(x2, y2 = x2) {
      this.minX *= x2;
      this.minY *= y2;
      this.maxX *= x2;
      this.maxY *= y2;
      return this;
    }
    get x() {
      return this.minX;
    }
    set x(value) {
      const width = this.maxX - this.minX;
      this.minX = value;
      this.maxX = value + width;
    }
    get y() {
      return this.minY;
    }
    set y(value) {
      const height = this.maxY - this.minY;
      this.minY = value;
      this.maxY = value + height;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(value) {
      this.maxX = this.minX + value;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(value) {
      this.maxY = this.minY + value;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== Infinity;
    }
    addVertexData(vertexData, beginOffset, endOffset, matrix) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      matrix || (matrix = this.matrix);
      const a2 = matrix.a;
      const b2 = matrix.b;
      const c2 = matrix.c;
      const d2 = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
        const localX = vertexData[i2];
        const localY = vertexData[i2 + 1];
        const x2 = a2 * localX + c2 * localY + tx;
        const y2 = b2 * localX + d2 * localY + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    containsPoint(x2, y2) {
      if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
        return true;
      }
      return false;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(bounds) {
      this.minX = bounds.minX;
      this.minY = bounds.minY;
      this.maxX = bounds.maxX;
      this.maxY = bounds.maxY;
      return this;
    }
  };

  // node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool = BigPool.getPool(Matrix);
  var boundsPool = BigPool.getPool(Bounds);

  // node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs
  var tempMatrix2 = new Matrix();
  var getFastGlobalBoundsMixin = {
    getFastGlobalBounds(factorRenderLayers, bounds) {
      bounds || (bounds = new Bounds());
      bounds.clear();
      this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
      if (!bounds.isValid) {
        bounds.set(0, 0, 0, 0);
      }
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      bounds.applyMatrix(renderGroup.worldTransform);
      return bounds;
    },
    _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
      let localBounds = bounds;
      if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
        return;
      if (this.localDisplayStatus !== 7 || !this.measurable) {
        return;
      }
      const manageEffects = !!this.effects.length;
      if (this.renderGroup || manageEffects) {
        localBounds = boundsPool.get().clear();
      }
      if (this.boundsArea) {
        bounds.addRect(this.boundsArea, this.worldTransform);
      } else {
        if (this.renderPipeId) {
          const viewBounds = this.bounds;
          localBounds.addFrame(viewBounds.minX, viewBounds.minY, viewBounds.maxX, viewBounds.maxY, this.groupTransform);
        }
        const children = this.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          children[i2]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
        }
      }
      if (manageEffects) {
        let advanced = false;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        for (let i2 = 0; i2 < this.effects.length; i2++) {
          if (this.effects[i2].addBounds) {
            if (!advanced) {
              advanced = true;
              localBounds.applyMatrix(renderGroup.worldTransform);
            }
            this.effects[i2].addBounds(localBounds, true);
          }
        }
        if (advanced) {
          localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix2).invert());
        }
        bounds.addBounds(localBounds);
        boundsPool.return(localBounds);
      } else if (this.renderGroup) {
        bounds.addBounds(localBounds, this.relativeGroupTransform);
        boundsPool.return(localBounds);
      }
    }
  };

  // node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      const renderableBounds = target.bounds;
      if (renderableBounds && !renderableBounds.isEmpty()) {
        bounds.matrix = worldTransform;
        bounds.addBounds(renderableBounds);
      }
      for (let i2 = 0; i2 < target.children.length; i2++) {
        _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addBounds?.(bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }

  // node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
  "use strict";
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 * r2 / 255 | 0;
    const g3 = g1 * g2 / 255 | 0;
    const b3 = b1 * b2 / 255 | 0;
    return (r3 << 16) + (g3 << 8) + b3;
  }

  // node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs
  var WHITE_BGR = 16777215;
  function multiplyColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR) {
      return parentBGRColor;
    }
    if (parentBGRColor === WHITE_BGR) {
      return localBGRColor;
    }
    return multiplyHexColors(localBGRColor, parentBGRColor);
  }

  // node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs
  function bgr2rgb(color) {
    return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
  }
  var getGlobalMixin = {
    getGlobalAlpha(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return this.renderGroup.worldAlpha;
        }
        if (this.parentRenderGroup) {
          return this.parentRenderGroup.worldAlpha * this.alpha;
        }
        return this.alpha;
      }
      let alpha = this.alpha;
      let current = this.parent;
      while (current) {
        alpha *= current.alpha;
        current = current.parent;
      }
      return alpha;
    },
    getGlobalTransform(matrix = new Matrix(), skipUpdate) {
      if (skipUpdate) {
        return matrix.copyFrom(this.worldTransform);
      }
      this.updateLocalTransform();
      const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
      matrix.appendFrom(this.localTransform, parentTransform);
      matrixPool.return(parentTransform);
      return matrix;
    },
    getGlobalTint(skipUpdate) {
      if (skipUpdate) {
        if (this.renderGroup) {
          return bgr2rgb(this.renderGroup.worldColor);
        }
        if (this.parentRenderGroup) {
          return bgr2rgb(multiplyColors(this.localColor, this.parentRenderGroup.worldColor));
        }
        return this.tint;
      }
      let color = this.localColor;
      let parent = this.parent;
      while (parent) {
        color = multiplyColors(color, parent.localColor);
        parent = parent.parent;
      }
      return bgr2rgb(color);
    }
  };

  // node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        bounds.addBounds(target.bounds);
      }
      const children = target.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        _getLocalBounds(children[i2], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }

  // node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
  "use strict";
  function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      const uid3 = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index = previousData.index;
      if (previousData.data[index] !== uid3 || previousData.data[index + 1] !== didChange) {
        previousData.data[previousData.index] = uid3;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }

  // node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix3 = new Matrix();
  var measureMixin = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(value, localWidth) {
      const sign2 = Math.sign(this.scale.x) || 1;
      if (localWidth !== 0) {
        this.scale.x = value / localWidth * sign2;
      } else {
        this.scale.x = sign2;
      }
    },
    _setHeight(value, localHeight) {
      const sign2 = Math.sign(this.scale.y) || 1;
      if (localHeight !== 0) {
        this.scale.y = value / localHeight * sign2;
      } else {
        this.scale.y = sign2;
      }
    },
    getLocalBounds() {
      if (!this._localBoundsCacheData) {
        this._localBoundsCacheData = {
          data: [],
          index: 1,
          didChange: false,
          localBounds: new Bounds()
        };
      }
      const localBoundsCacheData = this._localBoundsCacheData;
      localBoundsCacheData.index = 1;
      localBoundsCacheData.didChange = false;
      if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
        localBoundsCacheData.didChange = true;
        localBoundsCacheData.data[0] = this._didViewChangeTick;
      }
      checkChildrenDidChange(this, localBoundsCacheData);
      if (localBoundsCacheData.didChange) {
        getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix3);
      }
      return localBoundsCacheData.localBounds;
    },
    getBounds(skipUpdate, bounds) {
      return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
    }
  };

  // node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
  "use strict";
  var onRenderMixin = {
    _onRender: null,
    set onRender(func) {
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (!func) {
        if (this._onRender) {
          renderGroup?.removeOnRender(this);
        }
        this._onRender = null;
        return;
      }
      if (!this._onRender) {
        renderGroup?.addOnRender(this);
      }
      this._onRender = func;
    },
    get onRender() {
      return this._onRender;
    }
  };

  // node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
  "use strict";
  var sortMixin = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(value) {
      if (this._zIndex === value)
        return;
      this._zIndex = value;
      this.depthOfChildModified();
    },
    depthOfChildModified() {
      if (this.parent) {
        this.parent.sortableChildren = true;
        this.parent.sortDirty = true;
      }
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
    },
    sortChildren() {
      if (!this.sortDirty)
        return;
      this.sortDirty = false;
      this.children.sort(sortChildren);
    }
  };
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }

  // node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin = {
    getGlobalPosition(point = new Point(), skipUpdate = false) {
      if (this.parent) {
        this.parent.toGlobal(this._position, point, skipUpdate);
      } else {
        point.x = this._position.x;
        point.y = this._position.y;
      }
      return point;
    },
    toGlobal(position, point, skipUpdate = false) {
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.apply(position, point);
      matrixPool.return(globalMatrix);
      return point;
    },
    toLocal(position, from, point, skipUpdate) {
      if (from) {
        position = from.toGlobal(position, point, skipUpdate);
      }
      const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
      point = globalMatrix.applyInverse(position, point);
      matrixPool.return(globalMatrix);
      return point;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var InstructionSet = class {
    constructor() {
      this.uid = uid("instructionSet");
      this.instructions = [];
      this.instructionSize = 0;
      this.renderables = [];
      this.gcTick = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    destroy() {
      this.instructions.length = 0;
      this.renderables.length = 0;
      this.renderPipes = null;
      this.gcTick = 0;
    }
    add(instruction) {
      this.instructions[this.instructionSize++] = instruction;
    }
    log() {
      this.instructions.length = this.instructionSize;
      console.table(this.instructions, ["type", "action"]);
    }
  };

  // node_modules/pixi.js/lib/maths/misc/pow2.mjs
  "use strict";
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }

  // node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
  "use strict";
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  var idHash = /* @__PURE__ */ Object.create(null);
  function createResourceIdFromString(value) {
    const id = idHash[value];
    if (id === void 0) {
      idHash[value] = uid("resource");
    }
    return id;
  }
  var _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this._resourceType = "textureSampler";
      this._touched = 0;
      this._maxAnisotropy = 1;
      this.destroyed = false;
      options = {..._TextureStyle2.defaultOptions, ...options};
      this.addressMode = options.addressMode;
      this.addressModeU = options.addressModeU ?? this.addressModeU;
      this.addressModeV = options.addressModeV ?? this.addressModeV;
      this.addressModeW = options.addressModeW ?? this.addressModeW;
      this.scaleMode = options.scaleMode;
      this.magFilter = options.magFilter ?? this.magFilter;
      this.minFilter = options.minFilter ?? this.minFilter;
      this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
      this.lodMinClamp = options.lodMinClamp;
      this.lodMaxClamp = options.lodMaxClamp;
      this.compare = options.compare;
      this.maxAnisotropy = options.maxAnisotropy ?? 1;
    }
    set addressMode(value) {
      this.addressModeU = value;
      this.addressModeV = value;
      this.addressModeW = value;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(value) {
      deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
      this.addressMode = value;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(value) {
      this.magFilter = value;
      this.minFilter = value;
      this.mipmapFilter = value;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(value) {
      this._maxAnisotropy = Math.min(value, 16);
      if (this._maxAnisotropy > 1) {
        this.scaleMode = "linear";
      }
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this);
      this._sharedResourceId = null;
    }
    _generateResourceId() {
      const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      this._sharedResourceId = createResourceIdFromString(bigKey);
      return this._resourceId;
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this.removeAllListeners();
    }
  };
  _TextureStyle.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  var TextureStyle = _TextureStyle;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource = class _TextureSource2 extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.options = options;
      this.uid = uid("textureSource");
      this._resourceType = "textureSource";
      this._resourceId = uid("resource");
      this.uploadMethodId = "unknown";
      this._resolution = 1;
      this.pixelWidth = 1;
      this.pixelHeight = 1;
      this.width = 1;
      this.height = 1;
      this.sampleCount = 1;
      this.mipLevelCount = 1;
      this.autoGenerateMipmaps = false;
      this.format = "rgba8unorm";
      this.dimension = "2d";
      this.antialias = false;
      this._touched = 0;
      this._batchTick = -1;
      this._textureBindLocation = -1;
      options = {..._TextureSource2.defaultOptions, ...options};
      this.label = options.label ?? "";
      this.resource = options.resource;
      this.autoGarbageCollect = options.autoGarbageCollect;
      this._resolution = options.resolution;
      if (options.width) {
        this.pixelWidth = options.width * this._resolution;
      } else {
        this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
      }
      if (options.height) {
        this.pixelHeight = options.height * this._resolution;
      } else {
        this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
      }
      this.width = this.pixelWidth / this._resolution;
      this.height = this.pixelHeight / this._resolution;
      this.format = options.format;
      this.dimension = options.dimensions;
      this.mipLevelCount = options.mipLevelCount;
      this.autoGenerateMipmaps = options.autoGenerateMipmaps;
      this.sampleCount = options.sampleCount;
      this.antialias = options.antialias;
      this.alphaMode = options.alphaMode;
      this.style = new TextureStyle(definedProps(options));
      this.destroyed = false;
      this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(value) {
      if (this.style === value)
        return;
      this._style?.off("change", this._onStyleChange, this);
      this._style = value;
      this._style?.on("change", this._onStyleChange, this);
      this._onStyleChange();
    }
    set maxAnisotropy(value) {
      this._style.maxAnisotropy = value;
    }
    get maxAnisotropy() {
      return this._style.maxAnisotropy;
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(value) {
      this._style.addressMode = value;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(value) {
      this._style.addressMode = value;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(value) {
      this._style.magFilter = value;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(value) {
      this._style.minFilter = value;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(value) {
      this._style.mipmapFilter = value;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(value) {
      this._style.lodMinClamp = value;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(value) {
      this._style.lodMaxClamp = value;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const resolution = this._resolution;
        const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
        if (didResize)
          return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      if (this._style) {
        this._style.destroy();
        this._style = null;
      }
      this.uploadMethodId = null;
      this.resource = null;
      this.removeAllListeners();
    }
    unload() {
      this._resourceId = uid("resource");
      this.emit("change", this);
      this.emit("unload", this);
    }
    get resourceWidth() {
      const {resource} = this;
      return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
    }
    get resourceHeight() {
      const {resource} = this;
      return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(resolution) {
      if (this._resolution === resolution)
        return;
      this._resolution = resolution;
      this.width = this.pixelWidth / resolution;
      this.height = this.pixelHeight / resolution;
    }
    resize(width, height, resolution) {
      resolution || (resolution = this._resolution);
      width || (width = this.width);
      height || (height = this.height);
      const newPixelWidth = Math.round(width * resolution);
      const newPixelHeight = Math.round(height * resolution);
      this.width = newPixelWidth / resolution;
      this.height = newPixelHeight / resolution;
      this._resolution = resolution;
      if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
        return false;
      }
      this._refreshPOT();
      this.pixelWidth = newPixelWidth;
      this.pixelHeight = newPixelHeight;
      this.emit("resize", this);
      this._resourceId = uid("resource");
      this.emit("change", this);
      return true;
    }
    updateMipmaps() {
      if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
        this.emit("updateMipmaps", this);
      }
    }
    set wrapMode(value) {
      this._style.wrapMode = value;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(value) {
      this._style.scaleMode = value;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
    }
    static test(_resource) {
      throw new Error("Unimplemented");
    }
  };
  _TextureSource.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  var TextureSource = _TextureSource;

  // node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
  var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  var rotationCayley = [];
  var rotationMatrices = [];
  var signum = Math.sign;
  function init() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
        const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
        const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
        const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix();
      mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  init();
  var groupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (ind) => ux[ind],
    uY: (ind) => uy[ind],
    vX: (ind) => vx[ind],
    vY: (ind) => vy[ind],
    inv: (rotation) => {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
    sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    rotate180: (rotation) => rotation ^ 4,
    isVertical: (rotation) => (rotation & 3) === 2,
    byDirection: (dx2, dy2) => {
      if (Math.abs(dx2) * 2 <= Math.abs(dy2)) {
        if (dy2 >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy2) * 2 <= Math.abs(dx2)) {
        if (dx2 > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy2 > 0) {
        if (dx2 > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx2 > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
      const mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    },
    transformRectCoords: (rect, sourceFrame, rotation, out2) => {
      const {x: x2, y: y2, width, height} = rect;
      const {x: frameX, y: frameY, width: frameWidth, height: frameHeight} = sourceFrame;
      if (rotation === groupD8.E) {
        out2.set(x2 + frameX, y2 + frameY, width, height);
        return out2;
      } else if (rotation === groupD8.S) {
        return out2.set(frameWidth - y2 - height + frameX, x2 + frameY, height, width);
      } else if (rotation === groupD8.W) {
        return out2.set(frameWidth - x2 - width + frameX, frameHeight - y2 - height + frameY, width, height);
      } else if (rotation === groupD8.N) {
        return out2.set(y2 + frameX, frameHeight - x2 - width + frameY, height, width);
      }
      return out2.set(x2 + frameX, y2 + frameY, width, height);
    }
  };

  // node_modules/pixi.js/lib/utils/misc/NOOP.mjs
  "use strict";
  var NOOP = () => {
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource = class extends TextureSource {
    constructor(options) {
      const buffer = options.resource || new Float32Array(options.width * options.height * 4);
      let format = options.format;
      if (!format) {
        if (buffer instanceof Float32Array) {
          format = "rgba32float";
        } else if (buffer instanceof Int32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Uint32Array) {
          format = "rgba32uint";
        } else if (buffer instanceof Int16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Uint16Array) {
          format = "rgba16uint";
        } else if (buffer instanceof Int8Array) {
          format = "bgra8unorm";
        } else {
          format = "bgra8unorm";
        }
      }
      super({
        ...options,
        resource: buffer,
        format
      });
      this.uploadMethodId = "buffer";
    }
    static test(resource) {
      return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
    }
  };
  BufferImageSource.extension = ExtensionType.TextureSource;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat = new Matrix();
  var TextureMatrix = class {
    constructor(texture, clampMargin) {
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      if (typeof clampMargin === "undefined") {
        this.clampMargin = texture.width < 10 ? 0 : 0.5;
      } else {
        this.clampMargin = clampMargin;
      }
      this.isSimple = false;
      this.texture = texture;
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      if (this.texture === value)
        return;
      this._texture?.removeListener("update", this.update, this);
      this._texture = value;
      this._texture.addListener("update", this.update, this);
      this.update();
    }
    multiplyUvs(uvs, out2) {
      if (out2 === void 0) {
        out2 = uvs;
      }
      const mat = this.mapCoord;
      for (let i2 = 0; i2 < uvs.length; i2 += 2) {
        const x2 = uvs[i2];
        const y2 = uvs[i2 + 1];
        out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
        out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
      }
      return out2;
    }
    update() {
      const tex = this._texture;
      this._updateID++;
      const uvs = tex.uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      const orig = tex.orig;
      const trim = tex.trim;
      if (trim) {
        tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat);
      }
      const texBase = tex.source;
      const frame = this.uClampFrame;
      const margin = this.clampMargin / texBase._resolution;
      const offset = this.clampOffset / texBase._resolution;
      frame[0] = (tex.frame.x + margin + offset) / texBase.width;
      frame[1] = (tex.frame.y + margin + offset) / texBase.height;
      frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
      frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
      this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
      this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
      return true;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture = class extends eventemitter3_default {
    constructor({
      source: source3,
      label: label2,
      frame,
      orig,
      trim,
      defaultAnchor,
      defaultBorders,
      rotate,
      dynamic
    } = {}) {
      super();
      this.uid = uid("texture");
      this.uvs = {x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0};
      this.frame = new Rectangle();
      this.noFrame = false;
      this.dynamic = false;
      this.isTexture = true;
      this.label = label2;
      this.source = source3?.source ?? new TextureSource();
      this.noFrame = !frame;
      if (frame) {
        this.frame.copyFrom(frame);
      } else {
        const {width, height} = this._source;
        this.frame.width = width;
        this.frame.height = height;
      }
      this.orig = orig || this.frame;
      this.trim = trim;
      this.rotate = rotate ?? 0;
      this.defaultAnchor = defaultAnchor;
      this.defaultBorders = defaultBorders;
      this.destroyed = false;
      this.dynamic = dynamic || false;
      this.updateUvs();
    }
    set source(value) {
      if (this._source) {
        this._source.off("resize", this.update, this);
      }
      this._source = value;
      value.on("resize", this.update, this);
      this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      if (!this._textureMatrix) {
        this._textureMatrix = new TextureMatrix(this);
      }
      return this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const {uvs, frame} = this;
      const {width, height} = this._source;
      const nX = frame.x / width;
      const nY = frame.y / height;
      const nW = frame.width / width;
      const nH = frame.height / height;
      let rotate = this.rotate;
      if (rotate) {
        const w2 = nW / 2;
        const h2 = nH / 2;
        const cX = nX + w2;
        const cY = nY + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        uvs.x0 = cX + w2 * groupD8.uX(rotate);
        uvs.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x1 = cX + w2 * groupD8.uX(rotate);
        uvs.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x2 = cX + w2 * groupD8.uX(rotate);
        uvs.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        uvs.x3 = cX + w2 * groupD8.uX(rotate);
        uvs.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        uvs.x0 = nX;
        uvs.y0 = nY;
        uvs.x1 = nX + nW;
        uvs.y1 = nY;
        uvs.x2 = nX + nW;
        uvs.y2 = nY + nH;
        uvs.x3 = nX;
        uvs.y3 = nY + nH;
      }
    }
    destroy(destroySource = false) {
      if (this._source) {
        if (destroySource) {
          this._source.destroy();
          this._source = null;
        }
      }
      this._textureMatrix = null;
      this.destroyed = true;
      this.emit("destroy", this);
      this.removeAllListeners();
    }
    update() {
      if (this.noFrame) {
        this.frame.width = this._source.width;
        this.frame.height = this._source.height;
      }
      this.updateUvs();
      this.emit("update", this);
    }
    get baseTexture() {
      deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
      return this._source;
    }
  };
  Texture.EMPTY = new Texture({
    label: "EMPTY",
    source: new TextureSource({
      label: "EMPTY"
    })
  });
  Texture.EMPTY.destroy = NOOP;
  Texture.WHITE = new Texture({
    source: new BufferImageSource({
      resource: new Uint8Array([255, 255, 255, 255]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Texture.WHITE.destroy = NOOP;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count = 0;
  var TexturePoolClass = class {
    constructor(textureOptions) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null);
      this._texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this.textureStyle = new TextureStyle(this.textureOptions);
    }
    createTexture(pixelWidth, pixelHeight, antialias) {
      const textureSource = new TextureSource({
        ...this.textureOptions,
        width: pixelWidth,
        height: pixelHeight,
        resolution: 1,
        antialias,
        autoGarbageCollect: false
      });
      return new Texture({
        source: textureSource,
        label: `texturePool_${count++}`
      });
    }
    getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
      let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
      let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
      po2Width = nextPow2(po2Width);
      po2Height = nextPow2(po2Height);
      const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
      if (!this._texturePool[key]) {
        this._texturePool[key] = [];
      }
      let texture = this._texturePool[key].pop();
      if (!texture) {
        texture = this.createTexture(po2Width, po2Height, antialias);
      }
      texture.source._resolution = resolution;
      texture.source.width = po2Width / resolution;
      texture.source.height = po2Height / resolution;
      texture.source.pixelWidth = po2Width;
      texture.source.pixelHeight = po2Height;
      texture.frame.x = 0;
      texture.frame.y = 0;
      texture.frame.width = frameWidth;
      texture.frame.height = frameHeight;
      texture.updateUvs();
      this._poolKeyHash[texture.uid] = key;
      return texture;
    }
    getSameSizeTexture(texture, antialias = false) {
      const source3 = texture.source;
      return this.getOptimalTexture(texture.width, texture.height, source3._resolution, antialias);
    }
    returnTexture(renderTexture, resetStyle = false) {
      const key = this._poolKeyHash[renderTexture.uid];
      if (resetStyle) {
        renderTexture.source.style = this.textureStyle;
      }
      this._texturePool[key].push(renderTexture);
    }
    clear(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (const i2 in this._texturePool) {
          const textures = this._texturePool[i2];
          if (textures) {
            for (let j2 = 0; j2 < textures.length; j2++) {
              textures[j2].destroy(true);
            }
          }
        }
      }
      this._texturePool = {};
    }
  };
  var TexturePool = new TexturePoolClass();
  GlobalResourceRegistry.register(TexturePool);

  // node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
  var RenderGroup = class {
    constructor() {
      this.renderPipeId = "renderGroup";
      this.root = null;
      this.canBundle = false;
      this.renderGroupParent = null;
      this.renderGroupChildren = [];
      this.worldTransform = new Matrix();
      this.worldColorAlpha = 4294967295;
      this.worldColor = 16777215;
      this.worldAlpha = 1;
      this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
      this.updateTick = 0;
      this.gcTick = 0;
      this.childrenRenderablesToUpdate = {list: [], index: 0};
      this.structureDidChange = true;
      this.instructionSet = new InstructionSet();
      this._onRenderContainers = [];
      this.textureNeedsUpdate = true;
      this.isCachedAsTexture = false;
      this._matrixDirty = 7;
    }
    init(root) {
      this.root = root;
      if (root._onRender)
        this.addOnRender(root);
      root.didChange = true;
      const children = root.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        child._updateFlags = 15;
        this.addChild(child);
      }
    }
    enableCacheAsTexture(options = {}) {
      this.textureOptions = options;
      this.isCachedAsTexture = true;
      this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = false;
      if (this.texture) {
        TexturePool.returnTexture(this.texture, true);
        this.texture = null;
      }
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = true;
      const cachedParent = this._parentCacheAsTextureRenderGroup;
      if (cachedParent && !cachedParent.textureNeedsUpdate) {
        cachedParent.updateCacheTexture();
      }
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const i2 in this.childrenToUpdate) {
        const childrenAtDepth = this.childrenToUpdate[i2];
        childrenAtDepth.list.fill(null);
        childrenAtDepth.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0;
      this.childrenRenderablesToUpdate.list.fill(null);
      this.root = null;
      this.updateTick = 0;
      this.structureDidChange = true;
      this._onRenderContainers.length = 0;
      this.renderGroupParent = null;
      this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(renderGroupChild) {
      if (renderGroupChild.renderGroupParent) {
        renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
      }
      renderGroupChild.renderGroupParent = this;
      this.renderGroupChildren.push(renderGroupChild);
    }
    _removeRenderGroupChild(renderGroupChild) {
      const index = this.renderGroupChildren.indexOf(renderGroupChild);
      if (index > -1) {
        this.renderGroupChildren.splice(index, 1);
      }
      renderGroupChild.renderGroupParent = null;
    }
    addChild(child) {
      this.structureDidChange = true;
      child.parentRenderGroup = this;
      child.updateTick = -1;
      if (child.parent === this.root) {
        child.relativeRenderGroupDepth = 1;
      } else {
        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
      }
      child.didChange = true;
      this.onChildUpdate(child);
      if (child.renderGroup) {
        this.addRenderGroupChild(child.renderGroup);
        return;
      }
      if (child._onRender)
        this.addOnRender(child);
      const children = child.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        this.addChild(children[i2]);
      }
    }
    removeChild(child) {
      this.structureDidChange = true;
      if (child._onRender) {
        if (!child.renderGroup) {
          this.removeOnRender(child);
        }
      }
      child.parentRenderGroup = null;
      if (child.renderGroup) {
        this._removeRenderGroupChild(child.renderGroup);
        return;
      }
      const children = child.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
    }
    removeChildren(children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
    }
    onChildUpdate(child) {
      let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
      if (!childrenToUpdate) {
        childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
          index: 0,
          list: []
        };
      }
      childrenToUpdate.list[childrenToUpdate.index++] = child;
    }
    updateRenderable(renderable) {
      if (renderable.globalDisplayStatus < 7)
        return;
      this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
      renderable.didViewUpdate = false;
    }
    onChildViewUpdate(child) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(container) {
      this._onRenderContainers.push(container);
    }
    removeOnRender(container) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
    }
    runOnRender(renderer) {
      for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
        this._onRenderContainers[i2]._onRender(renderer);
      }
    }
    destroy() {
      this.disableCacheAsTexture();
      this.renderGroupParent = null;
      this.root = null;
      this.childrenRenderablesToUpdate = null;
      this.childrenToUpdate = null;
      this.renderGroupChildren = null;
      this._onRenderContainers = null;
      this.instructionSet = null;
    }
    getChildren(out2 = []) {
      const children = this.root.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        this._getChildren(children[i2], out2);
      }
      return out2;
    }
    _getChildren(container, out2 = []) {
      out2.push(container);
      if (container.renderGroup)
        return out2;
      const children = container.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        this._getChildren(children[i2], out2);
      }
      return out2;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      if ((this._matrixDirty & 1) === 0)
        return this._inverseWorldTransform;
      this._matrixDirty &= ~1;
      this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
      return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
    }
    get textureOffsetInverseTransform() {
      if ((this._matrixDirty & 2) === 0)
        return this._textureOffsetInverseTransform;
      this._matrixDirty &= ~2;
      this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
      return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);
    }
    get inverseParentTextureTransform() {
      if ((this._matrixDirty & 4) === 0)
        return this._inverseParentTextureTransform;
      this._matrixDirty &= ~4;
      const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
      if (parentCacheAsTexture) {
        this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
        return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y);
      }
      return this.worldTransform;
    }
    get cacheToLocalTransform() {
      if (this.isCachedAsTexture) {
        return this.textureOffsetInverseTransform;
      }
      if (!this._parentCacheAsTextureRenderGroup)
        return null;
      return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
    }
  };

  // node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
  "use strict";
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }

  // node_modules/pixi.js/lib/scene/container/Container.mjs
  var defaultSkew = new ObservablePoint(null);
  var defaultPivot = new ObservablePoint(null);
  var defaultScale = new ObservablePoint(null, 1, 1);
  var defaultOrigin = new ObservablePoint(null);
  var UPDATE_COLOR = 1;
  var UPDATE_BLEND = 2;
  var UPDATE_VISIBLE = 4;
  var Container = class extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.uid = uid("renderable");
      this._updateFlags = 15;
      this.renderGroup = null;
      this.parentRenderGroup = null;
      this.parentRenderGroupIndex = 0;
      this.didChange = false;
      this.didViewUpdate = false;
      this.relativeRenderGroupDepth = 0;
      this.children = [];
      this.parent = null;
      this.includeInBuild = true;
      this.measurable = true;
      this.isSimple = true;
      this.updateTick = -1;
      this.localTransform = new Matrix();
      this.relativeGroupTransform = new Matrix();
      this.groupTransform = this.relativeGroupTransform;
      this.destroyed = false;
      this._position = new ObservablePoint(this, 0, 0);
      this._scale = defaultScale;
      this._pivot = defaultPivot;
      this._origin = defaultOrigin;
      this._skew = defaultSkew;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._rotation = 0;
      this.localColor = 16777215;
      this.localAlpha = 1;
      this.groupAlpha = 1;
      this.groupColor = 16777215;
      this.groupColorAlpha = 4294967295;
      this.localBlendMode = "inherit";
      this.groupBlendMode = "normal";
      this.localDisplayStatus = 7;
      this.globalDisplayStatus = 7;
      this._didContainerChangeTick = 0;
      this._didViewChangeTick = 0;
      this._didLocalTransformChangeId = -1;
      this.effects = [];
      assignWithIgnore(this, options, {
        children: true,
        parent: true,
        effects: true
      });
      options.children?.forEach((child) => this.addChild(child));
      options.parent?.addChild(this);
    }
    static mixin(source3) {
      deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
      extensions.mixin(Container, source3);
    }
    set _didChangeId(value) {
      this._didViewChangeTick = value >> 12 & 4095;
      this._didContainerChangeTick = value & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...children) {
      if (!this.allowChildren) {
        deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
      }
      if (children.length > 1) {
        for (let i2 = 0; i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
        return children[0];
      }
      const child = children[0];
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (child.parent === this) {
        this.children.splice(this.children.indexOf(child), 1);
        this.children.push(child);
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        return child;
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      this.children.push(child);
      if (this.sortableChildren)
        this.sortDirty = true;
      child.parent = this;
      child.didChange = true;
      child._updateFlags = 15;
      if (renderGroup) {
        renderGroup.addChild(child);
      }
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
      this._didViewChangeTick++;
      if (child._zIndex !== 0) {
        child.depthOfChildModified();
      }
      return child;
    }
    removeChild(...children) {
      if (children.length > 1) {
        for (let i2 = 0; i2 < children.length; i2++) {
          this.removeChild(children[i2]);
        }
        return children[0];
      }
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index > -1) {
        this._didViewChangeTick++;
        this.children.splice(index, 1);
        if (this.renderGroup) {
          this.renderGroup.removeChild(child);
        } else if (this.parentRenderGroup) {
          this.parentRenderGroup.removeChild(child);
        }
        if (child.parentRenderLayer) {
          child.parentRenderLayer.detach(child);
        }
        child.parent = null;
        this.emit("childRemoved", child, this, index);
        child.emit("removed", this);
      }
      return child;
    }
    _onUpdate(point) {
      if (point) {
        if (point === this._skew) {
          this._updateSkew();
        }
      }
      this._didContainerChangeTick++;
      if (this.didChange)
        return;
      this.didChange = true;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.onChildUpdate(this);
      }
    }
    set isRenderGroup(value) {
      if (!!this.renderGroup === value)
        return;
      if (value) {
        this.enableRenderGroup();
      } else {
        this.disableRenderGroup();
      }
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup)
        return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup?.removeChild(this);
      this.renderGroup = BigPool.get(RenderGroup, this);
      this.groupTransform = Matrix.IDENTITY;
      parentRenderGroup?.addChild(this);
      this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup)
        return;
      const parentRenderGroup = this.parentRenderGroup;
      parentRenderGroup?.removeChild(this);
      BigPool.return(this.renderGroup);
      this.renderGroup = null;
      this.groupTransform = this.relativeGroupTransform;
      parentRenderGroup?.addChild(this);
      this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      this._worldTransform || (this._worldTransform = new Matrix());
      if (this.renderGroup) {
        this._worldTransform.copyFrom(this.renderGroup.worldTransform);
      } else if (this.parentRenderGroup) {
        this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
      }
      return this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(value) {
      this._position.x = value;
    }
    get y() {
      return this._position.y;
    }
    set y(value) {
      this._position.y = value;
    }
    get position() {
      return this._position;
    }
    set position(value) {
      this._position.copyFrom(value);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this._skew);
      }
    }
    get angle() {
      return this.rotation * RAD_TO_DEG;
    }
    set angle(value) {
      this.rotation = value * DEG_TO_RAD;
    }
    get pivot() {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
      }
      return this._pivot;
    }
    set pivot(value) {
      if (this._pivot === defaultPivot) {
        this._pivot = new ObservablePoint(this, 0, 0);
        if (this._origin !== defaultOrigin) {
          warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
        }
      }
      typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
    }
    get skew() {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      return this._skew;
    }
    set skew(value) {
      if (this._skew === defaultSkew) {
        this._skew = new ObservablePoint(this, 0, 0);
      }
      this._skew.copyFrom(value);
    }
    get scale() {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 1, 1);
      }
      return this._scale;
    }
    set scale(value) {
      if (this._scale === defaultScale) {
        this._scale = new ObservablePoint(this, 0, 0);
      }
      if (typeof value === "string") {
        value = parseFloat(value);
      }
      typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
    }
    get origin() {
      if (this._origin === defaultOrigin) {
        this._origin = new ObservablePoint(this, 0, 0);
      }
      return this._origin;
    }
    set origin(value) {
      if (this._origin === defaultOrigin) {
        this._origin = new ObservablePoint(this, 0, 0);
        if (this._pivot !== defaultPivot) {
          warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
        }
      }
      typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(value) {
      const localWidth = this.getLocalBounds().width;
      this._setWidth(value, localWidth);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(value) {
      const localHeight = this.getLocalBounds().height;
      this._setHeight(value, localHeight);
    }
    getSize(out2) {
      if (!out2) {
        out2 = {};
      }
      const bounds = this.getLocalBounds();
      out2.width = Math.abs(this.scale.x * bounds.width);
      out2.height = Math.abs(this.scale.y * bounds.height);
      return out2;
    }
    setSize(value, height) {
      const size = this.getLocalBounds();
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      } else {
        height ?? (height = value);
      }
      value !== void 0 && this._setWidth(value, size.width);
      height !== void 0 && this._setHeight(height, size.height);
    }
    _updateSkew() {
      const rotation = this._rotation;
      const skew = this._skew;
      this._cx = Math.cos(rotation + skew._y);
      this._sx = Math.sin(rotation + skew._y);
      this._cy = -Math.sin(rotation - skew._x);
      this._sy = Math.cos(rotation - skew._x);
    }
    updateTransform(opts) {
      this.position.set(typeof opts.x === "number" ? opts.x : this.position.x, typeof opts.y === "number" ? opts.y : this.position.y);
      this.scale.set(typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y);
      this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
      this.skew.set(typeof opts.skewX === "number" ? opts.skewX : this.skew.x, typeof opts.skewY === "number" ? opts.skewY : this.skew.y);
      this.pivot.set(typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y);
      this.origin.set(typeof opts.originX === "number" ? opts.originX : this.origin.x, typeof opts.originY === "number" ? opts.originY : this.origin.y);
      return this;
    }
    setFromMatrix(matrix) {
      matrix.decompose(this);
    }
    updateLocalTransform() {
      const localTransformChangeId = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === localTransformChangeId)
        return;
      this._didLocalTransformChangeId = localTransformChangeId;
      const lt = this.localTransform;
      const scale = this._scale;
      const pivot = this._pivot;
      const origin = this._origin;
      const position = this._position;
      const sx = scale._x;
      const sy = scale._y;
      const px = pivot._x;
      const py = pivot._y;
      const ox = -origin._x;
      const oy = -origin._y;
      lt.a = this._cx * sx;
      lt.b = this._sx * sx;
      lt.c = this._cy * sy;
      lt.d = this._sy * sy;
      lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
      lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
    }
    set alpha(value) {
      if (value === this.localAlpha)
        return;
      this.localAlpha = value;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdate();
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(value) {
      const tempColor = Color.shared.setValue(value ?? 16777215);
      const bgr = tempColor.toBgrNumber();
      if (bgr === this.localColor)
        return;
      this.localColor = bgr;
      this._updateFlags |= UPDATE_COLOR;
      this._onUpdate();
    }
    get tint() {
      return bgr2rgb(this.localColor);
    }
    set blendMode(value) {
      if (this.localBlendMode === value)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_BLEND;
      this.localBlendMode = value;
      this._onUpdate();
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(value) {
      const valueNumber = value ? 2 : 0;
      if ((this.localDisplayStatus & 2) === valueNumber)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 2;
      this._onUpdate();
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(value) {
      const valueNumber = value ? 0 : 4;
      if ((this.localDisplayStatus & 4) === valueNumber)
        return;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 4;
      this._onUpdate();
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(value) {
      const valueNumber = value ? 1 : 0;
      if ((this.localDisplayStatus & 1) === valueNumber)
        return;
      this._updateFlags |= UPDATE_VISIBLE;
      this.localDisplayStatus ^= 1;
      if (this.parentRenderGroup) {
        this.parentRenderGroup.structureDidChange = true;
      }
      this._onUpdate();
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(options = false) {
      if (this.destroyed)
        return;
      this.destroyed = true;
      let oldChildren;
      if (this.children.length) {
        oldChildren = this.removeChildren(0, this.children.length);
      }
      this.removeFromParent();
      this.parent = null;
      this._maskEffect = null;
      this._filterEffect = null;
      this.effects = null;
      this._position = null;
      this._scale = null;
      this._pivot = null;
      this._origin = null;
      this._skew = null;
      this.emit("destroyed", this);
      this.removeAllListeners();
      const destroyChildren = typeof options === "boolean" ? options : options?.children;
      if (destroyChildren && oldChildren) {
        for (let i2 = 0; i2 < oldChildren.length; ++i2) {
          oldChildren[i2].destroy(options);
        }
      }
      this.renderGroup?.destroy();
      this.renderGroup = null;
    }
  };
  extensions.mixin(Container, childrenHelperMixin, getFastGlobalBoundsMixin, toLocalGlobalMixin, onRenderMixin, measureMixin, effectsMixin, findMixin, sortMixin, cullingMixin, cacheAsTextureMixin, getGlobalMixin, collectRenderablesMixin);

  // node_modules/pixi.js/lib/ticker/const.mjs
  "use strict";
  var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
  })(UPDATE_PRIORITY || {});

  // node_modules/pixi.js/lib/ticker/TickerListener.mjs
  "use strict";
  var TickerListener = class {
    constructor(fn, context4 = null, priority = 0, once = false) {
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this._fn = fn;
      this._context = context4;
      this.priority = priority;
      this._once = once;
    }
    match(fn, context4 = null) {
      return this._fn === fn && this._context === context4;
    }
    emit(ticker) {
      if (this._fn) {
        if (this._context) {
          this._fn.call(this._context, ticker);
        } else {
          this._fn(ticker);
        }
      }
      const redirect = this.next;
      if (this._once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    }
    connect(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    }
    destroy(hard = false) {
      this._destroyed = true;
      this._fn = null;
      this._context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      const redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    }
  };

  // node_modules/pixi.js/lib/ticker/Ticker.mjs
  var _Ticker = class _Ticker2 {
    constructor() {
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / _Ticker2.targetFPMS;
      this.elapsedMS = 1 / _Ticker2.targetFPMS;
      this._tick = (time) => {
        this._requestId = null;
        if (this.started) {
          this.update(time);
          if (this.started && this._requestId === null && this._head.next) {
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
      };
    }
    _requestIfNeeded() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    }
    _cancelIfNeeded() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    }
    _startIfPossible() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    }
    add(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context4, priority));
    }
    addOnce(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context4, priority, true));
    }
    _addListener(listener) {
      let current = this._head.next;
      let previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    }
    remove(fn, context4) {
      let listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context4)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    }
    get count() {
      if (!this._head) {
        return 0;
      }
      let count2 = 0;
      let current = this._head;
      while (current = current.next) {
        count2++;
      }
      return count2;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    }
    update(currentTime = performance.now()) {
      let elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          const delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
        const head = this._head;
        let listener = head.next;
        while (listener) {
          listener = listener.emit(this);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
      const minFPS = Math.min(this.maxFPS, fps);
      const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
      this._maxElapsedMS = 1 / minFPMS;
    }
    get maxFPS() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    }
    set maxFPS(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        const maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    }
    static get shared() {
      if (!_Ticker2._shared) {
        const shared = _Ticker2._shared = new _Ticker2();
        shared.autoStart = true;
        shared._protected = true;
      }
      return _Ticker2._shared;
    }
    static get system() {
      if (!_Ticker2._system) {
        const system = _Ticker2._system = new _Ticker2();
        system.autoStart = true;
        system._protected = true;
      }
      return _Ticker2._system;
    }
  };
  _Ticker.targetFPMS = 0.06;
  var Ticker = _Ticker;

  // node_modules/pixi.js/lib/dom/CanvasObserver.mjs
  var CanvasObserver = class {
    constructor(options) {
      this._lastTransform = "";
      this._observer = null;
      this._tickerAttached = false;
      this.updateTranslation = () => {
        if (!this._canvas)
          return;
        const rect = this._canvas.getBoundingClientRect();
        const contentWidth = this._canvas.width;
        const contentHeight = this._canvas.height;
        const sx = rect.width / contentWidth * this._renderer.resolution;
        const sy = rect.height / contentHeight * this._renderer.resolution;
        const tx = rect.left;
        const ty = rect.top;
        const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
        if (newTransform !== this._lastTransform) {
          this._domElement.style.transform = newTransform;
          this._lastTransform = newTransform;
        }
      };
      this._domElement = options.domElement;
      this._renderer = options.renderer;
      if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas)
        return;
      this._canvas = this._renderer.canvas;
      this._attachObserver();
    }
    get canvas() {
      return this._canvas;
    }
    ensureAttached() {
      if (!this._domElement.parentNode && this._canvas.parentNode) {
        this._canvas.parentNode.appendChild(this._domElement);
        this.updateTranslation();
      }
    }
    _attachObserver() {
      if ("ResizeObserver" in globalThis) {
        if (this._observer) {
          this._observer.disconnect();
          this._observer = null;
        }
        this._observer = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target !== this._canvas) {
              continue;
            }
            const contentWidth = this.canvas.width;
            const contentHeight = this.canvas.height;
            const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
            const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
            const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
            if (needsUpdate) {
              this.updateTranslation();
              this._lastScaleX = sx;
              this._lastScaleY = sy;
            }
          }
        });
        this._observer.observe(this._canvas);
      } else if (!this._tickerAttached) {
        Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);
      }
    }
    destroy() {
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      } else if (this._tickerAttached) {
        Ticker.shared.remove(this.updateTranslation);
      }
      this._domElement = null;
      this._renderer = null;
      this._canvas = null;
      this._tickerAttached = false;
      this._lastTransform = "";
      this._lastScaleX = null;
      this._lastScaleY = null;
    }
  };

  // node_modules/pixi.js/lib/events/FederatedEvent.mjs
  var FederatedEvent = class {
    constructor(manager) {
      this.bubbles = true;
      this.cancelBubble = true;
      this.cancelable = false;
      this.composed = false;
      this.defaultPrevented = false;
      this.eventPhase = FederatedEvent.prototype.NONE;
      this.propagationStopped = false;
      this.propagationImmediatelyStopped = false;
      this.layer = new Point();
      this.page = new Point();
      this.NONE = 0;
      this.CAPTURING_PHASE = 1;
      this.AT_TARGET = 2;
      this.BUBBLING_PHASE = 3;
      this.manager = manager;
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
        this.path = this.target ? this.manager.propagationPath(this.target) : [];
      }
      return this.path;
    }
    initEvent(_type, _bubbles, _cancelable) {
      throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
      throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
    }
    preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    stopPropagation() {
      this.propagationStopped = true;
    }
  };

  // node_modules/ismobilejs/esm/isMobile.js
  var appleIphone = /iPhone/i;
  var appleIpod = /iPod/i;
  var appleTablet = /iPad/i;
  var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet = /Android/i;
  var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet = /Silk/i;
  var windowsPhone = /Windows Phone/i;
  var windowsTablet = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry = /BlackBerry/i;
  var otherBlackBerry10 = /BB10/i;
  var otherOpera = /Opera Mini/i;
  var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos13 = function(navigator2) {
    return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
  };
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }

  // node_modules/pixi.js/lib/utils/browser/isMobile.mjs
  var isMobileCall = isMobile.default ?? isMobile;
  var isMobile2 = isMobileCall(globalThis.navigator);

  // node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB = 9;
  var DIV_TOUCH_SIZE = 100;
  var DIV_TOUCH_POS_X = 0;
  var DIV_TOUCH_POS_Y = 0;
  var DIV_TOUCH_ZINDEX = 2;
  var DIV_HOOK_SIZE = 1;
  var DIV_HOOK_POS_X = -1e3;
  var DIV_HOOK_POS_Y = -1e3;
  var DIV_HOOK_ZINDEX = 2;
  var _AccessibilitySystem = class _AccessibilitySystem2 {
    constructor(renderer, _mobileInfo = isMobile2) {
      this._mobileInfo = _mobileInfo;
      this.debug = false;
      this._activateOnTab = true;
      this._deactivateOnMouseMove = true;
      this._isActive = false;
      this._isMobileAccessibility = false;
      this._div = null;
      this._pool = [];
      this._renderId = 0;
      this._children = [];
      this._androidUpdateCount = 0;
      this._androidUpdateFrequency = 500;
      this._hookDiv = null;
      if (_mobileInfo.tablet || _mobileInfo.phone) {
        this._createTouchHook();
      }
      this._renderer = renderer;
    }
    get isActive() {
      return this._isActive;
    }
    get isMobileAccessibility() {
      return this._isMobileAccessibility;
    }
    get hookDiv() {
      return this._hookDiv;
    }
    _createTouchHook() {
      const hookDiv = document.createElement("button");
      hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
      hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
      hookDiv.style.position = "absolute";
      hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
      hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
      hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
      hookDiv.style.backgroundColor = "#FF0000";
      hookDiv.title = "select to enable accessibility for this content";
      hookDiv.addEventListener("focus", () => {
        this._isMobileAccessibility = true;
        this._activate();
        this._destroyTouchHook();
      });
      document.body.appendChild(hookDiv);
      this._hookDiv = hookDiv;
    }
    _destroyTouchHook() {
      if (!this._hookDiv) {
        return;
      }
      document.body.removeChild(this._hookDiv);
      this._hookDiv = null;
    }
    _activate() {
      if (this._isActive) {
        return;
      }
      this._isActive = true;
      if (!this._div) {
        this._div = document.createElement("div");
        this._div.style.position = "absolute";
        this._div.style.top = `${DIV_TOUCH_POS_X}px`;
        this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
        this._div.style.pointerEvents = "none";
        this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this._canvasObserver = new CanvasObserver({
          domElement: this._div,
          renderer: this._renderer
        });
      }
      if (this._activateOnTab) {
        this._onKeyDown = this._onKeyDown.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      if (this._deactivateOnMouseMove) {
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
      }
      const canvas = this._renderer.view.canvas;
      if (!canvas.parentNode) {
        const observer = new MutationObserver(() => {
          if (canvas.parentNode) {
            observer.disconnect();
            this._canvasObserver.ensureAttached();
            this._initAccessibilitySetup();
          }
        });
        observer.observe(document.body, {childList: true, subtree: true});
      } else {
        this._canvasObserver.ensureAttached();
        this._initAccessibilitySetup();
      }
    }
    _initAccessibilitySetup() {
      this._renderer.runners.postrender.add(this);
      if (this._renderer.lastObjectRendered) {
        this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      }
    }
    _deactivate() {
      if (!this._isActive || this._isMobileAccessibility) {
        return;
      }
      this._isActive = false;
      globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
      if (this._activateOnTab) {
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      this._renderer.runners.postrender.remove(this);
      for (const child of this._children) {
        if (child._accessibleDiv && child._accessibleDiv.parentNode) {
          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
          child._accessibleDiv = null;
        }
        child._accessibleActive = false;
      }
      this._pool.forEach((div) => {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
      });
      if (this._div && this._div.parentNode) {
        this._div.parentNode.removeChild(this._div);
      }
      this._pool = [];
      this._children = [];
    }
    _updateAccessibleObjects(container) {
      if (!container.visible || !container.accessibleChildren) {
        return;
      }
      if (container.accessible) {
        if (!container._accessibleActive) {
          this._addChild(container);
        }
        container._renderId = this._renderId;
      }
      const children = container.children;
      if (children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          this._updateAccessibleObjects(children[i2]);
        }
      }
    }
    init(options) {
      const defaultOpts = _AccessibilitySystem2.defaultOptions;
      const mergedOptions = {
        accessibilityOptions: {
          ...defaultOpts,
          ...options?.accessibilityOptions || {}
        }
      };
      this.debug = mergedOptions.accessibilityOptions.debug;
      this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
      this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
      if (mergedOptions.accessibilityOptions.enabledByDefault) {
        this._activate();
      } else if (this._activateOnTab) {
        this._onKeyDown = this._onKeyDown.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      this._renderer.runners.postrender.remove(this);
    }
    postrender() {
      const now = performance.now();
      if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
        return;
      }
      this._androidUpdateCount = now + this._androidUpdateFrequency;
      if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
        return;
      }
      const activeIds = /* @__PURE__ */ new Set();
      if (this._renderer.lastObjectRendered) {
        this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        for (const child of this._children) {
          if (child._renderId === this._renderId) {
            activeIds.add(this._children.indexOf(child));
          }
        }
      }
      for (let i2 = this._children.length - 1; i2 >= 0; i2--) {
        const child = this._children[i2];
        if (!activeIds.has(i2)) {
          if (child._accessibleDiv && child._accessibleDiv.parentNode) {
            child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
            this._pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
          }
          child._accessibleActive = false;
          removeItems(this._children, i2, 1);
        }
      }
      if (this._renderer.renderingToScreen) {
        this._canvasObserver.ensureAttached();
      }
      for (let i2 = 0; i2 < this._children.length; i2++) {
        const child = this._children[i2];
        if (!child._accessibleActive || !child._accessibleDiv) {
          continue;
        }
        const div = child._accessibleDiv;
        const hitArea = child.hitArea || child.getBounds().rectangle;
        if (child.hitArea) {
          const wt = child.worldTransform;
          div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
          div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
          div.style.width = `${hitArea.width * wt.a}px`;
          div.style.height = `${hitArea.height * wt.d}px`;
        } else {
          this._capHitArea(hitArea);
          div.style.left = `${hitArea.x}px`;
          div.style.top = `${hitArea.y}px`;
          div.style.width = `${hitArea.width}px`;
          div.style.height = `${hitArea.height}px`;
        }
      }
      this._renderId++;
    }
    _updateDebugHTML(div) {
      div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
    }
    _capHitArea(hitArea) {
      if (hitArea.x < 0) {
        hitArea.width += hitArea.x;
        hitArea.x = 0;
      }
      if (hitArea.y < 0) {
        hitArea.height += hitArea.y;
        hitArea.y = 0;
      }
      const {width: viewWidth, height: viewHeight} = this._renderer;
      if (hitArea.x + hitArea.width > viewWidth) {
        hitArea.width = viewWidth - hitArea.x;
      }
      if (hitArea.y + hitArea.height > viewHeight) {
        hitArea.height = viewHeight - hitArea.y;
      }
    }
    _addChild(container) {
      let div = this._pool.pop();
      if (!div) {
        if (container.accessibleType === "button") {
          div = document.createElement("button");
        } else {
          div = document.createElement(container.accessibleType);
          div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
          if (container.accessibleText) {
            div.innerText = container.accessibleText;
          }
        }
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
        div.style.position = "absolute";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        div.style.borderStyle = "none";
        if (navigator.userAgent.toLowerCase().includes("chrome")) {
          div.setAttribute("aria-live", "off");
        } else {
          div.setAttribute("aria-live", "polite");
        }
        if (navigator.userAgent.match(/rv:.*Gecko\//)) {
          div.setAttribute("aria-relevant", "additions");
        } else {
          div.setAttribute("aria-relevant", "text");
        }
        div.addEventListener("click", this._onClick.bind(this));
        div.addEventListener("focus", this._onFocus.bind(this));
        div.addEventListener("focusout", this._onFocusOut.bind(this));
      }
      div.style.pointerEvents = container.accessiblePointerEvents;
      div.type = container.accessibleType;
      if (container.accessibleTitle && container.accessibleTitle !== null) {
        div.title = container.accessibleTitle;
      } else if (!container.accessibleHint || container.accessibleHint === null) {
        div.title = `container ${container.tabIndex}`;
      }
      if (container.accessibleHint && container.accessibleHint !== null) {
        div.setAttribute("aria-label", container.accessibleHint);
      }
      if (container.interactive) {
        div.tabIndex = container.tabIndex;
      } else {
        div.tabIndex = 0;
      }
      if (this.debug) {
        this._updateDebugHTML(div);
      }
      container._accessibleActive = true;
      container._accessibleDiv = div;
      div.container = container;
      this._children.push(container);
      this._div.appendChild(container._accessibleDiv);
    }
    _dispatchEvent(e2, type) {
      const {container: target} = e2.target;
      const boundary = this._renderer.events.rootBoundary;
      const event = Object.assign(new FederatedEvent(boundary), {target});
      boundary.rootTarget = this._renderer.lastObjectRendered;
      type.forEach((type2) => boundary.dispatchEvent(event, type2));
    }
    _onClick(e2) {
      this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
    }
    _onFocus(e2) {
      if (!e2.target.getAttribute("aria-live")) {
        e2.target.setAttribute("aria-live", "assertive");
      }
      this._dispatchEvent(e2, ["mouseover"]);
    }
    _onFocusOut(e2) {
      if (!e2.target.getAttribute("aria-live")) {
        e2.target.setAttribute("aria-live", "polite");
      }
      this._dispatchEvent(e2, ["mouseout"]);
    }
    _onKeyDown(e2) {
      if (e2.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
        return;
      }
      this._activate();
    }
    _onMouseMove(e2) {
      if (e2.movementX === 0 && e2.movementY === 0) {
        return;
      }
      this._deactivate();
    }
    destroy() {
      this._deactivate();
      this._destroyTouchHook();
      this._canvasObserver?.destroy();
      this._canvasObserver = null;
      this._div = null;
      this._pool = null;
      this._children = null;
      this._renderer = null;
      if (this._activateOnTab) {
        globalThis.removeEventListener("keydown", this._onKeyDown);
      }
    }
    setAccessibilityEnabled(enabled) {
      if (enabled) {
        this._activate();
      } else {
        this._deactivate();
      }
    }
  };
  _AccessibilitySystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "accessibility"
  };
  _AccessibilitySystem.defaultOptions = {
    enabledByDefault: false,
    debug: false,
    activateOnTab: true,
    deactivateOnMouseMove: true
  };
  var AccessibilitySystem = _AccessibilitySystem;

  // node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
  "use strict";
  var accessibilityTarget = {
    accessible: false,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    accessibleType: "button",
    accessibleText: null,
    accessiblePointerEvents: "auto",
    accessibleChildren: true,
    _accessibleActive: false,
    _accessibleDiv: null,
    _renderId: -1
  };

  // node_modules/pixi.js/lib/accessibility/init.mjs
  extensions.add(AccessibilitySystem);
  extensions.mixin(Container, accessibilityTarget);

  // node_modules/pixi.js/lib/app/ResizePlugin.mjs
  var ResizePlugin = class {
    static init(options) {
      Object.defineProperty(this, "resizeTo", {
        set(dom) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom;
          if (dom) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get() {
          return this._resizeTo;
        }
      });
      this.queueResize = () => {
        if (!this._resizeTo) {
          return;
        }
        this._cancelResize();
        this._resizeId = requestAnimationFrame(() => this.resize());
      };
      this._cancelResize = () => {
        if (this._resizeId) {
          cancelAnimationFrame(this._resizeId);
          this._resizeId = null;
        }
      };
      this.resize = () => {
        if (!this._resizeTo) {
          return;
        }
        this._cancelResize();
        let width;
        let height;
        if (this._resizeTo === globalThis.window) {
          width = globalThis.innerWidth;
          height = globalThis.innerHeight;
        } else {
          const {clientWidth, clientHeight} = this._resizeTo;
          width = clientWidth;
          height = clientHeight;
        }
        this.renderer.resize(width, height);
        this.render();
      };
      this._resizeId = null;
      this._resizeTo = null;
      this.resizeTo = options.resizeTo || null;
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize);
      this._cancelResize();
      this._cancelResize = null;
      this.queueResize = null;
      this.resizeTo = null;
      this.resize = null;
    }
  };
  ResizePlugin.extension = ExtensionType.Application;

  // node_modules/pixi.js/lib/app/TickerPlugin.mjs
  var TickerPlugin = class {
    static init(options) {
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get() {
          return this._ticker;
        }
      });
      this.stop = () => {
        this._ticker.stop();
      };
      this.start = () => {
        this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    }
    static destroy() {
      if (this._ticker) {
        const oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    }
  };
  TickerPlugin.extension = ExtensionType.Application;

  // node_modules/pixi.js/lib/app/init.mjs
  extensions.add(ResizePlugin);
  extensions.add(TickerPlugin);

  // node_modules/pixi.js/lib/events/EventTicker.mjs
  var EventsTickerClass = class {
    constructor() {
      this.interactionFrequency = 10;
      this._deltaTime = 0;
      this._didMove = false;
      this._tickerAdded = false;
      this._pauseUpdate = true;
    }
    init(events) {
      this.removeTickerListener();
      this.events = events;
      this.interactionFrequency = 10;
      this._deltaTime = 0;
      this._didMove = false;
      this._tickerAdded = false;
      this._pauseUpdate = true;
    }
    get pauseUpdate() {
      return this._pauseUpdate;
    }
    set pauseUpdate(paused) {
      this._pauseUpdate = paused;
    }
    addTickerListener() {
      if (this._tickerAdded || !this.domElement) {
        return;
      }
      Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
      this._tickerAdded = true;
    }
    removeTickerListener() {
      if (!this._tickerAdded) {
        return;
      }
      Ticker.system.remove(this._tickerUpdate, this);
      this._tickerAdded = false;
    }
    pointerMoved() {
      this._didMove = true;
    }
    _update() {
      if (!this.domElement || this._pauseUpdate) {
        return;
      }
      if (this._didMove) {
        this._didMove = false;
        return;
      }
      const rootPointerEvent = this.events["_rootPointerEvent"];
      if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
        return;
      }
      globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
        clientX: rootPointerEvent.clientX,
        clientY: rootPointerEvent.clientY,
        pointerType: rootPointerEvent.pointerType,
        pointerId: rootPointerEvent.pointerId
      }) : new MouseEvent("mousemove", {
        clientX: rootPointerEvent.clientX,
        clientY: rootPointerEvent.clientY
      }));
    }
    _tickerUpdate(ticker) {
      this._deltaTime += ticker.deltaTime;
      if (this._deltaTime < this.interactionFrequency) {
        return;
      }
      this._deltaTime = 0;
      this._update();
    }
    destroy() {
      this.removeTickerListener();
      this.events = null;
      this.domElement = null;
      this._deltaTime = 0;
      this._didMove = false;
      this._tickerAdded = false;
      this._pauseUpdate = true;
    }
  };
  var EventsTicker = new EventsTickerClass();

  // node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent = class extends FederatedEvent {
    constructor() {
      super(...arguments);
      this.client = new Point();
      this.movement = new Point();
      this.offset = new Point();
      this.global = new Point();
      this.screen = new Point();
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(container, point, globalPos) {
      return container.worldTransform.applyInverse(globalPos || this.global, point);
    }
    getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
      throw new Error("Method not implemented.");
    }
  };

  // node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent = class extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.width = 0;
      this.height = 0;
      this.isPrimary = false;
    }
    getCoalescedEvents() {
      if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
        return [this];
      }
      return [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  };

  // node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent = class extends FederatedMouseEvent {
    constructor() {
      super(...arguments);
      this.DOM_DELTA_PIXEL = 0;
      this.DOM_DELTA_LINE = 1;
      this.DOM_DELTA_PAGE = 2;
    }
  };
  FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
  FederatedWheelEvent.DOM_DELTA_LINE = 1;
  FederatedWheelEvent.DOM_DELTA_PAGE = 2;

  // node_modules/pixi.js/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT = 2048;
  var tempHitLocation = new Point();
  var tempLocalMapping = new Point();
  var EventBoundary = class {
    constructor(rootTarget) {
      this.dispatch = new eventemitter3_default();
      this.moveOnAll = false;
      this.enableGlobalMoveEvents = true;
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = /* @__PURE__ */ new Map();
      this._allInteractiveElements = [];
      this._hitElements = [];
      this._isPointerMoveEvent = false;
      this.rootTarget = rootTarget;
      this.hitPruneFn = this.hitPruneFn.bind(this);
      this.hitTestFn = this.hitTestFn.bind(this);
      this.mapPointerDown = this.mapPointerDown.bind(this);
      this.mapPointerMove = this.mapPointerMove.bind(this);
      this.mapPointerOut = this.mapPointerOut.bind(this);
      this.mapPointerOver = this.mapPointerOver.bind(this);
      this.mapPointerUp = this.mapPointerUp.bind(this);
      this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
      this.mapWheel = this.mapWheel.bind(this);
      this.mappingTable = {};
      this.addEventMapping("pointerdown", this.mapPointerDown);
      this.addEventMapping("pointermove", this.mapPointerMove);
      this.addEventMapping("pointerout", this.mapPointerOut);
      this.addEventMapping("pointerleave", this.mapPointerOut);
      this.addEventMapping("pointerover", this.mapPointerOver);
      this.addEventMapping("pointerup", this.mapPointerUp);
      this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
      this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
    }
    dispatchEvent(e2, type) {
      e2.propagationStopped = false;
      e2.propagationImmediatelyStopped = false;
      this.propagate(e2, type);
      this.dispatch.emit(type || e2.type, e2);
    }
    mapEvent(e2) {
      if (!this.rootTarget) {
        return;
      }
      const mappers = this.mappingTable[e2.type];
      if (mappers) {
        for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
          mappers[i2].fn(e2);
        }
      } else {
        warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
      }
    }
    hitTest(x2, y2) {
      EventsTicker.pauseUpdate = true;
      const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
      const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
      const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x2, y2), this.hitTestFn, this.hitPruneFn);
      return invertedPath && invertedPath[0];
    }
    propagate(e2, type) {
      if (!e2.target) {
        return;
      }
      const composedPath = e2.composedPath();
      e2.eventPhase = e2.CAPTURING_PHASE;
      for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
        e2.currentTarget = composedPath[i2];
        this.notifyTarget(e2, type);
        if (e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
      }
      e2.eventPhase = e2.AT_TARGET;
      e2.currentTarget = e2.target;
      this.notifyTarget(e2, type);
      if (e2.propagationStopped || e2.propagationImmediatelyStopped)
        return;
      e2.eventPhase = e2.BUBBLING_PHASE;
      for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
        e2.currentTarget = composedPath[i2];
        this.notifyTarget(e2, type);
        if (e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
      }
    }
    all(e2, type, targets = this._allInteractiveElements) {
      if (targets.length === 0)
        return;
      e2.eventPhase = e2.BUBBLING_PHASE;
      const events = Array.isArray(type) ? type : [type];
      for (let i2 = targets.length - 1; i2 >= 0; i2--) {
        events.forEach((event) => {
          e2.currentTarget = targets[i2];
          this.notifyTarget(e2, event);
        });
      }
    }
    propagationPath(target) {
      const propagationPath = [target];
      for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
        if (!target.parent) {
          throw new Error("Cannot find propagation path to disconnected target");
        }
        propagationPath.push(target.parent);
        target = target.parent;
      }
      propagationPath.reverse();
      return propagationPath;
    }
    hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
      let shouldReturn = false;
      if (this._interactivePrune(currentTarget))
        return null;
      if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
        EventsTicker.pauseUpdate = false;
      }
      if (currentTarget.interactiveChildren && currentTarget.children) {
        const children = currentTarget.children;
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const child = children[i2];
          const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
          if (nestedHit) {
            if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
              continue;
            }
            const isInteractive = currentTarget.isInteractive();
            if (nestedHit.length > 0 || isInteractive) {
              if (isInteractive)
                this._allInteractiveElements.push(currentTarget);
              nestedHit.push(currentTarget);
            }
            if (this._hitElements.length === 0)
              this._hitElements = nestedHit;
            shouldReturn = true;
          }
        }
      }
      const isInteractiveMode = this._isInteractive(eventMode);
      const isInteractiveTarget = currentTarget.isInteractive();
      if (isInteractiveTarget && isInteractiveTarget)
        this._allInteractiveElements.push(currentTarget);
      if (ignore || this._hitElements.length > 0)
        return null;
      if (shouldReturn)
        return this._hitElements;
      if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
        return isInteractiveTarget ? [currentTarget] : [];
      }
      return null;
    }
    hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
      if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
        return null;
      }
      if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
        EventsTicker.pauseUpdate = false;
      }
      if (currentTarget.interactiveChildren && currentTarget.children) {
        const children = currentTarget.children;
        const relativeLocation = location;
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const child = children[i2];
          const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);
          if (nestedHit) {
            if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
              continue;
            }
            const isInteractive = currentTarget.isInteractive();
            if (nestedHit.length > 0 || isInteractive)
              nestedHit.push(currentTarget);
            return nestedHit;
          }
        }
      }
      const isInteractiveMode = this._isInteractive(eventMode);
      const isInteractiveTarget = currentTarget.isInteractive();
      if (isInteractiveMode && testFn(currentTarget, location)) {
        return isInteractiveTarget ? [currentTarget] : [];
      }
      return null;
    }
    _isInteractive(int) {
      return int === "static" || int === "dynamic";
    }
    _interactivePrune(container) {
      if (!container || !container.visible || !container.renderable || !container.measurable) {
        return true;
      }
      if (container.eventMode === "none") {
        return true;
      }
      if (container.eventMode === "passive" && !container.interactiveChildren) {
        return true;
      }
      return false;
    }
    hitPruneFn(container, location) {
      if (container.hitArea) {
        container.worldTransform.applyInverse(location, tempLocalMapping);
        if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
          return true;
        }
      }
      if (container.effects && container.effects.length) {
        for (let i2 = 0; i2 < container.effects.length; i2++) {
          const effect = container.effects[i2];
          if (effect.containsPoint) {
            const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
            if (!effectContainsPoint) {
              return true;
            }
          }
        }
      }
      return false;
    }
    hitTestFn(container, location) {
      if (container.hitArea) {
        return true;
      }
      if (container?.containsPoint) {
        container.worldTransform.applyInverse(location, tempLocalMapping);
        return container.containsPoint(tempLocalMapping);
      }
      return false;
    }
    notifyTarget(e2, type) {
      if (!e2.currentTarget.isInteractive()) {
        return;
      }
      type ?? (type = e2.type);
      const handlerKey = `on${type}`;
      e2.currentTarget[handlerKey]?.(e2);
      const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
      this._notifyListeners(e2, key);
      if (e2.eventPhase === e2.AT_TARGET) {
        this._notifyListeners(e2, type);
      }
    }
    mapPointerDown(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const e2 = this.createPointerEvent(from);
      this.dispatchEvent(e2, "pointerdown");
      if (e2.pointerType === "touch") {
        this.dispatchEvent(e2, "touchstart");
      } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
        const isRightButton = e2.button === 2;
        this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
      }
      const trackingData = this.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e2.composedPath();
      this.freeEvent(e2);
    }
    mapPointerMove(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      this._allInteractiveElements.length = 0;
      this._hitElements.length = 0;
      this._isPointerMoveEvent = true;
      const e2 = this.createPointerEvent(from);
      this._isPointerMoveEvent = false;
      const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
      const trackingData = this.trackingData(from.pointerId);
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
        const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        const outEvent = this.createPointerEvent(from, outType, outTarget);
        this.dispatchEvent(outEvent, "pointerout");
        if (isMouse)
          this.dispatchEvent(outEvent, "mouseout");
        if (!e2.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e2.target) {
        const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        const overEvent = this.clonePointerEvent(e2, overType);
        this.dispatchEvent(overEvent, "pointerover");
        if (isMouse)
          this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = outTarget?.parent;
        while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
          if (overTargetAncestor === e2.target)
            break;
          overTargetAncestor = overTargetAncestor.parent;
        }
        const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
        if (didPointerEnter) {
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      const allMethods = [];
      const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
      this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
      allowGlobalPointerEvents && allMethods.push("globalpointermove");
      if (e2.pointerType === "touch") {
        this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
        allowGlobalPointerEvents && allMethods.push("globaltouchmove");
      }
      if (isMouse) {
        this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
        allowGlobalPointerEvents && allMethods.push("globalmousemove");
        this.cursor = e2.target?.cursor;
      }
      if (allMethods.length > 0) {
        this.all(e2, allMethods);
      }
      this._allInteractiveElements.length = 0;
      this._hitElements.length = 0;
      trackingData.overTargets = e2.composedPath();
      this.freeEvent(e2);
    }
    mapPointerOver(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      const e2 = this.createPointerEvent(from);
      const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
      this.dispatchEvent(e2, "pointerover");
      if (isMouse)
        this.dispatchEvent(e2, "mouseover");
      if (e2.pointerType === "mouse")
        this.cursor = e2.target?.cursor;
      const enterEvent = this.clonePointerEvent(e2, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
        enterEvent.currentTarget = enterEvent.target;
        this.notifyTarget(enterEvent);
        if (isMouse)
          this.notifyTarget(enterEvent, "mouseenter");
        enterEvent.target = enterEvent.target.parent;
      }
      trackingData.overTargets = e2.composedPath();
      this.freeEvent(e2);
      this.freeEvent(enterEvent);
    }
    mapPointerOut(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
        this.dispatchEvent(outEvent);
        if (isMouse)
          this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        trackingData.overTargets = null;
        this.freeEvent(outEvent);
        this.freeEvent(leaveEvent);
      }
      this.cursor = null;
    }
    mapPointerUp(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const now = performance.now();
      const e2 = this.createPointerEvent(from);
      this.dispatchEvent(e2, "pointerup");
      if (e2.pointerType === "touch") {
        this.dispatchEvent(e2, "touchend");
      } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
        const isRightButton = e2.button === 2;
        this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId);
      const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e2.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        while (currentTarget && !e2.composedPath().includes(currentTarget)) {
          e2.currentTarget = currentTarget;
          this.notifyTarget(e2, "pointerupoutside");
          if (e2.pointerType === "touch") {
            this.notifyTarget(e2, "touchendoutside");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e2, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = null;
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now
          };
        }
        const clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now;
        clickEvent.detail = clickHistory.clickCount;
        if (clickEvent.pointerType === "mouse") {
          const isRightButton = clickEvent.button === 2;
          this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
        } else if (clickEvent.pointerType === "touch") {
          this.dispatchEvent(clickEvent, "tap");
        }
        this.dispatchEvent(clickEvent, "pointertap");
        this.freeEvent(clickEvent);
      }
      this.freeEvent(e2);
    }
    mapPointerUpOutside(from) {
      if (!(from instanceof FederatedPointerEvent)) {
        warn("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const trackingData = this.trackingData(from.pointerId);
      const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      const e2 = this.createPointerEvent(from);
      if (pressTarget) {
        let currentTarget = pressTarget;
        while (currentTarget) {
          e2.currentTarget = currentTarget;
          this.notifyTarget(e2, "pointerupoutside");
          if (e2.pointerType === "touch") {
            this.notifyTarget(e2, "touchendoutside");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e2);
    }
    mapWheel(from) {
      if (!(from instanceof FederatedWheelEvent)) {
        warn("EventBoundary cannot map a non-wheel event as a wheel event");
        return;
      }
      const wheelEvent = this.createWheelEvent(from);
      this.dispatchEvent(wheelEvent);
      this.freeEvent(wheelEvent);
    }
    findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      let currentTarget = propagationPath[0];
      for (let i2 = 1; i2 < propagationPath.length; i2++) {
        if (propagationPath[i2].parent === currentTarget) {
          currentTarget = propagationPath[i2];
        } else {
          break;
        }
      }
      return currentTarget;
    }
    createPointerEvent(from, type, target) {
      const event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    }
    createWheelEvent(from) {
      const event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      event.target = this.hitTest(event.global.x, event.global.y);
      return event;
    }
    clonePointerEvent(from, type) {
      const event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type ?? event.type;
      return event;
    }
    copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
    copyPointerData(from, to) {
      if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
        return;
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
    copyMouseData(from, to) {
      if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
        return;
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.client.copyFrom(from.client);
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.movement.copyFrom(from.movement);
      to.screen.copyFrom(from.screen);
      to.shiftKey = from.shiftKey;
      to.global.copyFrom(from.global);
    }
    copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.srcElement = from.srcElement;
      to.timeStamp = performance.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.which = from.which;
      to.layer.copyFrom(from.layer);
      to.page.copyFrom(from.page);
    }
    trackingData(id) {
      if (!this.mappingState.trackingData[id]) {
        this.mappingState.trackingData[id] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id];
    }
    allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      const event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.defaultPrevented = false;
      event.path = null;
      event.target = null;
      return event;
    }
    freeEvent(event) {
      if (event.manager !== this)
        throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      const constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
    _notifyListeners(e2, type) {
      const listeners = e2.currentTarget._events[type];
      if (!listeners)
        return;
      if ("fn" in listeners) {
        if (listeners.once)
          e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
        listeners.fn.call(listeners.context, e2);
      } else {
        for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
          if (listeners[i2].once)
            e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
          listeners[i2].fn.call(listeners[i2].context, e2);
        }
      }
    }
  };

  // node_modules/pixi.js/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  var _EventSystem = class _EventSystem2 {
    constructor(renderer) {
      this.supportsTouchEvents = "ontouchstart" in globalThis;
      this.supportsPointerEvents = !!globalThis.PointerEvent;
      this.domElement = null;
      this.resolution = 1;
      this.renderer = renderer;
      this.rootBoundary = new EventBoundary(null);
      EventsTicker.init(this);
      this.autoPreventDefault = true;
      this._eventsAdded = false;
      this._rootPointerEvent = new FederatedPointerEvent(null);
      this._rootWheelEvent = new FederatedWheelEvent(null);
      this.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      };
      this.features = new Proxy({..._EventSystem2.defaultEventFeatures}, {
        set: (target, key, value) => {
          if (key === "globalMove") {
            this.rootBoundary.enableGlobalMoveEvents = value;
          }
          target[key] = value;
          return true;
        }
      });
      this._onPointerDown = this._onPointerDown.bind(this);
      this._onPointerMove = this._onPointerMove.bind(this);
      this._onPointerUp = this._onPointerUp.bind(this);
      this._onPointerOverOut = this._onPointerOverOut.bind(this);
      this.onWheel = this.onWheel.bind(this);
    }
    static get defaultEventMode() {
      return this._defaultEventMode;
    }
    init(options) {
      const {canvas, resolution} = this.renderer;
      this.setTargetElement(canvas);
      this.resolution = resolution;
      _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
      Object.assign(this.features, options.eventFeatures ?? {});
      this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
    }
    resolutionChange(resolution) {
      this.resolution = resolution;
    }
    destroy() {
      EventsTicker.destroy();
      this.setTargetElement(null);
      this.renderer = null;
      this._currentCursor = null;
    }
    setCursor(mode) {
      mode || (mode = "default");
      let applyStyles = true;
      if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
        applyStyles = false;
      }
      if (this._currentCursor === mode) {
        return;
      }
      this._currentCursor = mode;
      const style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style) {
          case "string":
            if (applyStyles) {
              this.domElement.style.cursor = style;
            }
            break;
          case "function":
            style(mode);
            break;
          case "object":
            if (applyStyles) {
              Object.assign(this.domElement.style, style);
            }
            break;
        }
      } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.domElement.style.cursor = mode;
      }
    }
    get pointer() {
      return this._rootPointerEvent;
    }
    _onPointerDown(nativeEvent) {
      if (!this.features.click)
        return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const events = this._normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }
      for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
        const nativeEvent2 = events[i2];
        const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
        this.rootBoundary.mapEvent(federatedEvent);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerMove(nativeEvent) {
      if (!this.features.move)
        return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      EventsTicker.pointerMoved();
      const normalizedEvents = this._normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerUp(nativeEvent) {
      if (!this.features.click)
        return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      let target = nativeEvent.target;
      if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
        target = nativeEvent.composedPath()[0];
      }
      const outside = target !== this.domElement ? "outside" : "";
      const normalizedEvents = this._normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
        event.type += outside;
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    _onPointerOverOut(nativeEvent) {
      if (!this.features.click)
        return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const normalizedEvents = this._normalizeToPointerData(nativeEvent);
      for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
        const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
        this.rootBoundary.mapEvent(event);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onWheel(nativeEvent) {
      if (!this.features.wheel)
        return;
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      this.rootBoundary.mapEvent(wheelEvent);
    }
    setTargetElement(element) {
      this._removeEvents();
      this.domElement = element;
      EventsTicker.domElement = element;
      this._addEvents();
    }
    _addEvents() {
      if (this._eventsAdded || !this.domElement) {
        return;
      }
      EventsTicker.addTickerListener();
      const style = this.domElement.style;
      if (style) {
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "none";
          style.msTouchAction = "none";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "none";
        }
      }
      if (this.supportsPointerEvents) {
        globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
        this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
        this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
        this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
        globalThis.addEventListener("pointerup", this._onPointerUp, true);
      } else {
        globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
        this.domElement.addEventListener("mousedown", this._onPointerDown, true);
        this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
        this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
        globalThis.addEventListener("mouseup", this._onPointerUp, true);
        if (this.supportsTouchEvents) {
          this.domElement.addEventListener("touchstart", this._onPointerDown, true);
          this.domElement.addEventListener("touchend", this._onPointerUp, true);
          this.domElement.addEventListener("touchmove", this._onPointerMove, true);
        }
      }
      this.domElement.addEventListener("wheel", this.onWheel, {
        passive: true,
        capture: true
      });
      this._eventsAdded = true;
    }
    _removeEvents() {
      if (!this._eventsAdded || !this.domElement) {
        return;
      }
      EventsTicker.removeTickerListener();
      const style = this.domElement.style;
      if (style) {
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
      }
      if (this.supportsPointerEvents) {
        globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
        this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
        this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
        this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
        globalThis.removeEventListener("pointerup", this._onPointerUp, true);
      } else {
        globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
        this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
        this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
        this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
        globalThis.removeEventListener("mouseup", this._onPointerUp, true);
        if (this.supportsTouchEvents) {
          this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
          this.domElement.removeEventListener("touchend", this._onPointerUp, true);
          this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
        }
      }
      this.domElement.removeEventListener("wheel", this.onWheel, true);
      this.domElement = null;
      this._eventsAdded = false;
    }
    mapPositionToPoint(point, x2, y2) {
      const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
      const resolutionMultiplier = 1 / this.resolution;
      point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
      point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
    }
    _normalizeToPointerData(event) {
      const normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
          const touch = event.changedTouches[i2];
          if (typeof touch.button === "undefined")
            touch.button = 0;
          if (typeof touch.buttons === "undefined")
            touch.buttons = 1;
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined")
            touch.width = touch.radiusX || 1;
          if (typeof touch.height === "undefined")
            touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === "undefined")
            touch.tiltX = 0;
          if (typeof touch.tiltY === "undefined")
            touch.tiltY = 0;
          if (typeof touch.pointerType === "undefined")
            touch.pointerType = "touch";
          if (typeof touch.pointerId === "undefined")
            touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === "undefined")
            touch.pressure = touch.force || 0.5;
          if (typeof touch.twist === "undefined")
            touch.twist = 0;
          if (typeof touch.tangentialPressure === "undefined")
            touch.tangentialPressure = 0;
          if (typeof touch.layerX === "undefined")
            touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === "undefined")
            touch.layerY = touch.offsetY = touch.clientY;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
        const tempEvent = event;
        if (typeof tempEvent.isPrimary === "undefined")
          tempEvent.isPrimary = true;
        if (typeof tempEvent.width === "undefined")
          tempEvent.width = 1;
        if (typeof tempEvent.height === "undefined")
          tempEvent.height = 1;
        if (typeof tempEvent.tiltX === "undefined")
          tempEvent.tiltX = 0;
        if (typeof tempEvent.tiltY === "undefined")
          tempEvent.tiltY = 0;
        if (typeof tempEvent.pointerType === "undefined")
          tempEvent.pointerType = "mouse";
        if (typeof tempEvent.pointerId === "undefined")
          tempEvent.pointerId = MOUSE_POINTER_ID;
        if (typeof tempEvent.pressure === "undefined")
          tempEvent.pressure = 0.5;
        if (typeof tempEvent.twist === "undefined")
          tempEvent.twist = 0;
        if (typeof tempEvent.tangentialPressure === "undefined")
          tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
    normalizeWheelEvent(nativeEvent) {
      const event = this._rootWheelEvent;
      this._transferMouseData(event, nativeEvent);
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      event.deltaMode = nativeEvent.deltaMode;
      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
      event.global.copyFrom(event.screen);
      event.offset.copyFrom(event.screen);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    _bootstrapEvent(event, nativeEvent) {
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = nativeEvent.pointerId;
      event.width = nativeEvent.width;
      event.height = nativeEvent.height;
      event.isPrimary = nativeEvent.isPrimary;
      event.pointerType = nativeEvent.pointerType;
      event.pressure = nativeEvent.pressure;
      event.tangentialPressure = nativeEvent.tangentialPressure;
      event.tiltX = nativeEvent.tiltX;
      event.tiltY = nativeEvent.tiltY;
      event.twist = nativeEvent.twist;
      this._transferMouseData(event, nativeEvent);
      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
      event.global.copyFrom(event.screen);
      event.offset.copyFrom(event.screen);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
    _transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = performance.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.metaKey = nativeEvent.metaKey;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.relatedTarget = null;
      event.shiftKey = nativeEvent.shiftKey;
    }
  };
  _EventSystem.extension = {
    name: "events",
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.CanvasSystem,
      ExtensionType.WebGPUSystem
    ],
    priority: -1
  };
  _EventSystem.defaultEventFeatures = {
    move: true,
    globalMove: true,
    click: true,
    wheel: true
  };
  var EventSystem = _EventSystem;

  // node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
  var FederatedContainer = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive(value) {
      this.eventMode = value ? "static" : "passive";
    },
    _internalEventMode: void 0,
    get eventMode() {
      return this._internalEventMode ?? EventSystem.defaultEventMode;
    },
    set eventMode(value) {
      this._internalEventMode = value;
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: true,
    hitArea: null,
    addEventListener(type, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const signal = typeof options === "object" ? options.signal : void 0;
      const once = typeof options === "object" ? options.once === true : false;
      const context4 = typeof listener === "function" ? void 0 : listener;
      type = capture ? `${type}capture` : type;
      const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
      const emitter = this;
      if (signal) {
        signal.addEventListener("abort", () => {
          emitter.off(type, listenerFn, context4);
        });
      }
      if (once) {
        emitter.once(type, listenerFn, context4);
      } else {
        emitter.on(type, listenerFn, context4);
      }
    },
    removeEventListener(type, listener, options) {
      const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
      const context4 = typeof listener === "function" ? void 0 : listener;
      type = capture ? `${type}capture` : type;
      listener = typeof listener === "function" ? listener : listener.handleEvent;
      this.off(type, listener, context4);
    },
    dispatchEvent(e2) {
      if (!(e2 instanceof FederatedEvent)) {
        throw new Error("Container cannot propagate events outside of the Federated Events API");
      }
      e2.defaultPrevented = false;
      e2.path = null;
      e2.target = this;
      e2.manager.dispatchEvent(e2);
      return !e2.defaultPrevented;
    }
  };

  // node_modules/pixi.js/lib/events/init.mjs
  extensions.add(EventSystem);
  extensions.mixin(Container, FederatedContainer);

  // node_modules/pixi.js/lib/dom/DOMPipe.mjs
  var DOMPipe = class {
    constructor(renderer) {
      this._attachedDomElements = [];
      this._renderer = renderer;
      this._renderer.runners.postrender.add(this);
      this._renderer.runners.init.add(this);
      this._domElement = document.createElement("div");
      this._domElement.style.position = "absolute";
      this._domElement.style.top = "0";
      this._domElement.style.left = "0";
      this._domElement.style.pointerEvents = "none";
      this._domElement.style.zIndex = "1000";
    }
    init() {
      this._canvasObserver = new CanvasObserver({
        domElement: this._domElement,
        renderer: this._renderer
      });
    }
    addRenderable(domContainer, _instructionSet) {
      if (!this._attachedDomElements.includes(domContainer)) {
        this._attachedDomElements.push(domContainer);
      }
    }
    updateRenderable(_domContainer) {
    }
    validateRenderable(_domContainer) {
      return true;
    }
    postrender() {
      const attachedDomElements = this._attachedDomElements;
      if (attachedDomElements.length === 0) {
        this._domElement.remove();
        return;
      }
      this._canvasObserver.ensureAttached();
      for (let i2 = 0; i2 < attachedDomElements.length; i2++) {
        const domContainer = attachedDomElements[i2];
        const element = domContainer.element;
        if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
          element?.remove();
          attachedDomElements.splice(i2, 1);
          i2--;
        } else {
          if (!this._domElement.contains(element)) {
            element.style.position = "absolute";
            element.style.pointerEvents = "auto";
            this._domElement.appendChild(element);
          }
          const wt = domContainer.worldTransform;
          const anchor = domContainer._anchor;
          const ax = domContainer.width * anchor.x;
          const ay = domContainer.height * anchor.y;
          element.style.transformOrigin = `${ax}px ${ay}px`;
          element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
          element.style.opacity = domContainer.groupAlpha.toString();
        }
      }
    }
    destroy() {
      this._renderer.runners.postrender.remove(this);
      for (let i2 = 0; i2 < this._attachedDomElements.length; i2++) {
        const domContainer = this._attachedDomElements[i2];
        domContainer.element?.remove();
      }
      this._attachedDomElements.length = 0;
      this._domElement.remove();
      this._canvasObserver.destroy();
      this._renderer = null;
    }
  };
  DOMPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "dom"
  };

  // node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
  var ViewContainer = class extends Container {
    constructor(options) {
      super(options);
      this.canBundle = true;
      this.allowChildren = false;
      this._roundPixels = 0;
      this._lastUsed = -1;
      this._gpuData = /* @__PURE__ */ Object.create(null);
      this._bounds = new Bounds(0, 1, 0, 0);
      this._boundsDirty = true;
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this.updateBounds();
      this._boundsDirty = false;
      return this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(value) {
      this._roundPixels = value ? 1 : 0;
    }
    containsPoint(point) {
      const bounds = this.bounds;
      const {x: x2, y: y2} = point;
      return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
    }
    onViewUpdate() {
      this._didViewChangeTick++;
      this._boundsDirty = true;
      if (this.didViewUpdate)
        return;
      this.didViewUpdate = true;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.onChildViewUpdate(this);
      }
    }
    destroy(options) {
      super.destroy(options);
      this._bounds = null;
      for (const key in this._gpuData) {
        this._gpuData[key].destroy?.();
      }
      this._gpuData = null;
    }
    collectRenderablesSimple(instructionSet, renderer, currentLayer) {
      const {renderPipes} = renderer;
      renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
      const rp = renderPipes;
      rp[this.renderPipeId].addRenderable(this, instructionSet);
      this.didViewUpdate = false;
      const children = this.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        children[i2].collectRenderables(instructionSet, renderer, currentLayer);
      }
      renderPipes.blendMode.popBlendMode(instructionSet);
    }
  };

  // node_modules/pixi.js/lib/dom/init.mjs
  extensions.add(DOMPipe);

  // node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
  "use strict";
  var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
    LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
    LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
    LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
    return LoaderParserPriority2;
  })(LoaderParserPriority || {});

  // node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
  "use strict";
  var BrowserAdapter = {
    createCanvas: (width, height) => {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    createImage: () => new Image(),
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (url, options) => fetch(url, options),
    parseXML: (xml) => {
      const parser = new DOMParser();
      return parser.parseFromString(xml, "text/xml");
    }
  };

  // node_modules/pixi.js/lib/environment/adapter.mjs
  var currentAdapter = BrowserAdapter;
  var DOMAdapter = {
    get() {
      return currentAdapter;
    },
    set(adapter) {
      currentAdapter = adapter;
    }
  };

  // node_modules/pixi.js/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i2)}`;
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path = {
    toPosix(path2) {
      return replaceAll(path2, "\\", "/");
    },
    isUrl(path2) {
      return /^https?:/.test(this.toPosix(path2));
    },
    isDataUrl(path2) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    isBlobUrl(path2) {
      return path2.startsWith("blob:");
    },
    hasProtocol(path2) {
      return /^[^/:]+:/.test(this.toPosix(path2));
    },
    getProtocol(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      const matchFile = /^file:\/\/\//.exec(path2);
      if (matchFile) {
        return matchFile[0];
      }
      const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
      if (matchProtocol) {
        return matchProtocol[0];
      }
      return "";
    },
    toAbsolute(url, customBaseUrl, customRootUrl) {
      assertPath(url);
      if (this.isDataUrl(url) || this.isBlobUrl(url))
        return url;
      const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
      const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
      url = this.toPosix(url);
      if (url.startsWith("/")) {
        return path.join(rootUrl, url.slice(1));
      }
      const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
      return absolutePath;
    },
    normalize(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      if (this.isDataUrl(path2) || this.isBlobUrl(path2))
        return path2;
      path2 = this.toPosix(path2);
      let protocol = "";
      const isAbsolute = path2.startsWith("/");
      if (this.hasProtocol(path2)) {
        protocol = this.rootname(path2);
        path2 = path2.slice(protocol.length);
      }
      const trailingSeparator = path2.endsWith("/");
      path2 = normalizeStringPosix(path2, false);
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return `/${path2}`;
      return protocol + path2;
    },
    isAbsolute(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      if (this.hasProtocol(path2))
        return true;
      return path2.startsWith("/");
    },
    join(...segments) {
      if (segments.length === 0) {
        return ".";
      }
      let joined;
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const arg = segments[i2];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else {
            const prevArg = segments[i2 - 1] ?? "";
            if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
              joined += `/../${arg}`;
            } else {
              joined += `/${arg}`;
            }
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return this.normalize(joined);
    },
    dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const hasRoot = code === 47;
      let end = -1;
      let matchedSlash = true;
      const proto = this.getProtocol(path2);
      const origpath = path2;
      path2 = path2.slice(proto.length);
      for (let i2 = path2.length - 1; i2 >= 1; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            end = i2;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
      if (hasRoot && end === 1)
        return "//";
      return proto + path2.slice(0, end);
    },
    rootname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let root = "";
      if (path2.startsWith("/"))
        root = "/";
      else {
        root = this.getProtocol(path2);
      }
      if (this.isUrl(path2)) {
        const index = path2.indexOf("/", root.length);
        if (index !== -1) {
          root = path2.slice(0, index);
        } else
          root = path2;
        if (!root.endsWith("/"))
          root += "/";
      }
      return root;
    },
    basename(path2, ext) {
      assertPath(path2);
      if (ext)
        assertPath(ext);
      path2 = removeUrlParams(this.toPosix(path2));
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i2;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          const code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i2 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i2;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      }
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        if (path2.charCodeAt(i2) === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start, end);
    },
    extname(path2) {
      assertPath(path2);
      path2 = removeUrlParams(this.toPosix(path2));
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i2 = path2.length - 1; i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    parse(path2) {
      assertPath(path2);
      const ret = {root: "", dir: "", base: "", ext: "", name: ""};
      if (path2.length === 0)
        return ret;
      path2 = removeUrlParams(this.toPosix(path2));
      let code = path2.charCodeAt(0);
      const isAbsolute = this.isAbsolute(path2);
      let start;
      const protocol = "";
      ret.root = this.rootname(path2);
      if (isAbsolute || this.hasProtocol(path2)) {
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i2 = path2.length - 1;
      let preDotState = 0;
      for (; i2 >= start; --i2) {
        code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i2 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i2;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      ret.dir = this.dirname(path2);
      if (protocol)
        ret.dir = protocol + ret.dir;
      return ret;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
  };

  // node_modules/pixi.js/lib/assets/utils/convertToList.mjs
  "use strict";
  var convertToList = (input, transform, forceTransform = false) => {
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!transform) {
      return input;
    }
    return input.map((item) => {
      if (typeof item === "string" || forceTransform) {
        return transform(item);
      }
      return item;
    });
  };

  // node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
  "use strict";
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i2 = 0; i2 < id.length; i2++) {
      const value = id[i2];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }

  // node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
  "use strict";
  var isSingleItem = (item) => !Array.isArray(item);

  // node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
  var Resolver = class {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
        extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
      };
      this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
      this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
      this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
      this._assetMap = {};
      this._preferredOrder = [];
      this._parsers = [];
      this._resolverHash = {};
      this._bundles = {};
    }
    setBundleIdentifier(bundleIdentifier) {
      this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
      this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
      this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
      if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
        throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
      }
    }
    prefer(...preferOrders) {
      preferOrders.forEach((prefer) => {
        this._preferredOrder.push(prefer);
        if (!prefer.priority) {
          prefer.priority = Object.keys(prefer.params);
        }
      });
      this._resolverHash = {};
    }
    set basePath(basePath) {
      this._basePath = basePath;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(rootPath) {
      this._rootPath = rootPath;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
      this._assetMap = {};
      this._preferredOrder = [];
      this._resolverHash = {};
      this._rootPath = null;
      this._basePath = null;
      this._manifest = null;
      this._bundles = {};
      this._defaultSearchParams = null;
    }
    setDefaultSearchParams(searchParams) {
      if (typeof searchParams === "string") {
        this._defaultSearchParams = searchParams;
      } else {
        const queryValues = searchParams;
        this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
      }
    }
    getAlias(asset) {
      const {alias, src} = asset;
      const aliasesToUse = convertToList(alias || src, (value) => {
        if (typeof value === "string")
          return value;
        if (Array.isArray(value))
          return value.map((v2) => v2?.src ?? v2);
        if (value?.src)
          return value.src;
        return value;
      }, true);
      return aliasesToUse;
    }
    addManifest(manifest) {
      if (this._manifest) {
        warn("[Resolver] Manifest already exists, this will be overwritten");
      }
      this._manifest = manifest;
      manifest.bundles.forEach((bundle) => {
        this.addBundle(bundle.name, bundle.assets);
      });
    }
    addBundle(bundleId, assets) {
      const assetNames = [];
      let convertedAssets = assets;
      if (!Array.isArray(assets)) {
        convertedAssets = Object.entries(assets).map(([alias, src]) => {
          if (typeof src === "string" || Array.isArray(src)) {
            return {alias, src};
          }
          return {alias, ...src};
        });
      }
      convertedAssets.forEach((asset) => {
        const srcs = asset.src;
        const aliases = asset.alias;
        let ids;
        if (typeof aliases === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
          assetNames.push(bundleAssetId);
          ids = [aliases, bundleAssetId];
        } else {
          const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
          assetNames.push(...bundleIds);
          ids = [...aliases, ...bundleIds];
        }
        this.add({
          ...asset,
          ...{
            alias: ids,
            src: srcs
          }
        });
      });
      this._bundles[bundleId] = assetNames;
    }
    add(aliases) {
      const assets = [];
      if (Array.isArray(aliases)) {
        assets.push(...aliases);
      } else {
        assets.push(aliases);
      }
      let keyCheck;
      keyCheck = (key) => {
        if (this.hasKey(key)) {
          warn(`[Resolver] already has key: ${key} overwriting`);
        }
      };
      const assetArray = convertToList(assets);
      assetArray.forEach((asset) => {
        const {src} = asset;
        let {data, format, loadParser: userDefinedLoadParser, parser: userDefinedParser} = asset;
        const srcsToUse = convertToList(src).map((src2) => {
          if (typeof src2 === "string") {
            return createStringVariations(src2);
          }
          return Array.isArray(src2) ? src2 : [src2];
        });
        const aliasesToUse = this.getAlias(asset);
        Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
        const resolvedAssets = [];
        srcsToUse.forEach((srcs) => {
          srcs.forEach((src2) => {
            let formattedAsset = {};
            if (typeof src2 !== "object") {
              formattedAsset.src = src2;
              for (let i2 = 0; i2 < this._parsers.length; i2++) {
                const parser = this._parsers[i2];
                if (parser.test(src2)) {
                  formattedAsset = parser.parse(src2);
                  break;
                }
              }
            } else {
              data = src2.data ?? data;
              format = src2.format ?? format;
              if (src2.loadParser || src2.parser) {
                userDefinedLoadParser = src2.loadParser ?? userDefinedLoadParser;
                userDefinedParser = src2.parser ?? userDefinedParser;
              }
              formattedAsset = {
                ...formattedAsset,
                ...src2
              };
            }
            if (!aliasesToUse) {
              throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
            }
            formattedAsset = this._buildResolvedAsset(formattedAsset, {
              aliases: aliasesToUse,
              data,
              format,
              loadParser: userDefinedLoadParser,
              parser: userDefinedParser
            });
            resolvedAssets.push(formattedAsset);
          });
        });
        aliasesToUse.forEach((alias) => {
          this._assetMap[alias] = resolvedAssets;
        });
      });
    }
    resolveBundle(bundleIds) {
      const singleAsset = isSingleItem(bundleIds);
      bundleIds = convertToList(bundleIds);
      const out2 = {};
      bundleIds.forEach((bundleId) => {
        const assetNames = this._bundles[bundleId];
        if (assetNames) {
          const results = this.resolve(assetNames);
          const assets = {};
          for (const key in results) {
            const asset = results[key];
            assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
          }
          out2[bundleId] = assets;
        }
      });
      return singleAsset ? out2[bundleIds[0]] : out2;
    }
    resolveUrl(key) {
      const result = this.resolve(key);
      if (typeof key !== "string") {
        const out2 = {};
        for (const i2 in result) {
          out2[i2] = result[i2].src;
        }
        return out2;
      }
      return result.src;
    }
    resolve(keys) {
      const singleAsset = isSingleItem(keys);
      keys = convertToList(keys);
      const result = {};
      keys.forEach((key) => {
        if (!this._resolverHash[key]) {
          if (this._assetMap[key]) {
            let assets = this._assetMap[key];
            const preferredOrder = this._getPreferredOrder(assets);
            preferredOrder?.priority.forEach((priorityKey) => {
              preferredOrder.params[priorityKey].forEach((value) => {
                const filteredAssets = assets.filter((asset) => {
                  if (asset[priorityKey]) {
                    return asset[priorityKey] === value;
                  }
                  return false;
                });
                if (filteredAssets.length) {
                  assets = filteredAssets;
                }
              });
            });
            this._resolverHash[key] = assets[0];
          } else {
            this._resolverHash[key] = this._buildResolvedAsset({
              alias: [key],
              src: key
            }, {});
          }
        }
        result[key] = this._resolverHash[key];
      });
      return singleAsset ? result[keys[0]] : result;
    }
    hasKey(key) {
      return !!this._assetMap[key];
    }
    hasBundle(key) {
      return !!this._bundles[key];
    }
    _getPreferredOrder(assets) {
      for (let i2 = 0; i2 < assets.length; i2++) {
        const asset = assets[i2];
        const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
        if (preferred) {
          return preferred;
        }
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(url) {
      if (!this._defaultSearchParams)
        return url;
      const paramConnector = /\?/.test(url) ? "&" : "?";
      return `${url}${paramConnector}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(formattedAsset, data) {
      const {aliases, data: assetData, loadParser, parser, format} = data;
      if (this._basePath || this._rootPath) {
        formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = {...assetData || {}, ...formattedAsset.data};
      formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
      formattedAsset.parser = parser ?? formattedAsset.parser;
      formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
      return formattedAsset;
    }
  };
  Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
  }

  // node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
  "use strict";
  var copySearchParams = (targetUrl, sourceUrl) => {
    const searchParams = sourceUrl.split("?")[1];
    if (searchParams) {
      targetUrl += `?${searchParams}`;
    }
    return targetUrl;
  };

  // node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet = class _Spritesheet2 {
    constructor(optionsOrTexture, arg1) {
      this.linkedSheets = [];
      let options = optionsOrTexture;
      if (optionsOrTexture?.source instanceof TextureSource) {
        options = {
          texture: optionsOrTexture,
          data: arg1
        };
      }
      const {texture, data, cachePrefix = ""} = options;
      this.cachePrefix = cachePrefix;
      this._texture = texture instanceof Texture ? texture : null;
      this.textureSource = texture.source;
      this.textures = {};
      this.animations = {};
      this.data = data;
      const metaResolution = parseFloat(data.meta.scale);
      if (metaResolution) {
        this.resolution = metaResolution;
        texture.source.resolution = this.resolution;
      } else {
        this.resolution = texture.source._resolution;
      }
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    parse() {
      return new Promise((resolve) => {
        this._callback = resolve;
        this._batchIndex = 0;
        if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      });
    }
    _processFrames(initialFrameIndex) {
      let frameIndex = initialFrameIndex;
      const maxFrames = _Spritesheet2.BATCH_SIZE;
      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
        const i2 = this._frameKeys[frameIndex];
        const data = this._frames[i2];
        const rect = data.frame;
        if (rect) {
          let frame = null;
          let trim = null;
          const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
          const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          if (data.rotated) {
            frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
          } else {
            frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          if (data.trimmed !== false && data.spriteSourceSize) {
            trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          this.textures[i2] = new Texture({
            source: this.textureSource,
            frame,
            orig,
            trim,
            rotate: data.rotated ? 2 : 0,
            defaultAnchor: data.anchor,
            defaultBorders: data.borders,
            label: i2.toString()
          });
        }
        frameIndex++;
      }
    }
    _processAnimations() {
      const animations = this.data.animations || {};
      for (const animName in animations) {
        this.animations[animName] = [];
        for (let i2 = 0; i2 < animations[animName].length; i2++) {
          const frameName = animations[animName][i2];
          this.animations[animName].push(this.textures[frameName]);
        }
      }
    }
    _parseComplete() {
      const callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(() => {
        if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
          this._nextBatch();
        } else {
          this._processAnimations();
          this._parseComplete();
        }
      }, 0);
    }
    destroy(destroyBase = false) {
      for (const i2 in this.textures) {
        this.textures[i2].destroy();
      }
      this._frames = null;
      this._frameKeys = null;
      this.data = null;
      this.textures = null;
      if (destroyBase) {
        this._texture?.destroy();
        this.textureSource.destroy();
      }
      this._texture = null;
      this.textureSource = null;
      this.linkedSheets = [];
    }
  };
  _Spritesheet.BATCH_SIZE = 1e3;
  var Spritesheet = _Spritesheet;

  // node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
  var validImages = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[`${asset.cachePrefix}${key}`] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var spritesheetAsset = {
    extension: ExtensionType.Asset,
    cache: {
      test: (asset) => asset instanceof Spritesheet,
      getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
    },
    resolver: {
      extension: {
        type: ExtensionType.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (value) => {
        const tempURL = value.split("?")[0];
        const split = tempURL.split(".");
        const extension = split.pop();
        const format = split.pop();
        return extension === "json" && validImages.includes(format);
      },
      parse: (value) => {
        const split = value.split(".");
        return {
          resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: split[split.length - 2],
          src: value
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      id: "spritesheet",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal,
        name: "spritesheetLoader"
      },
      async testParse(asset, options) {
        return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
      },
      async parse(asset, options, loader) {
        const {
          texture: imageTexture,
          imageFilename,
          textureOptions,
          cachePrefix
        } = options?.data ?? {};
        let basePath = path.dirname(options.src);
        if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
          basePath += "/";
        }
        let texture;
        if (imageTexture instanceof Texture) {
          texture = imageTexture;
        } else {
          const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
          const assets = await loader.load([{src: imagePath, data: textureOptions}]);
          texture = assets[imagePath];
        }
        const spritesheet = new Spritesheet({
          texture: texture.source,
          data: asset,
          cachePrefix
        });
        await spritesheet.parse();
        const multiPacks = asset?.meta?.related_multi_packs;
        if (Array.isArray(multiPacks)) {
          const promises = [];
          for (const item of multiPacks) {
            if (typeof item !== "string") {
              continue;
            }
            let itemUrl = basePath + item;
            if (options.data?.ignoreMultiPack) {
              continue;
            }
            itemUrl = copySearchParams(itemUrl, options.src);
            promises.push(loader.load({
              src: itemUrl,
              data: {
                textureOptions,
                ignoreMultiPack: true
              }
            }));
          }
          const res = await Promise.all(promises);
          spritesheet.linkedSheets = res;
          res.forEach((item) => {
            item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
          });
        }
        return spritesheet;
      },
      async unload(spritesheet, _resolvedAsset, loader) {
        await loader.unload(spritesheet.textureSource._sourceOrigin);
        spritesheet.destroy(false);
      }
    }
  };

  // node_modules/pixi.js/lib/spritesheet/init.mjs
  extensions.add(spritesheetAsset);

  // node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
  "use strict";
  function updateQuadBounds(bounds, anchor, texture) {
    const {width, height} = texture.orig;
    const trim = texture.trim;
    if (trim) {
      const sourceWidth = trim.width;
      const sourceHeight = trim.height;
      bounds.minX = trim.x - anchor._x * width;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim.y - anchor._y * height;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
  }

  // node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
  var Sprite = class extends ViewContainer {
    constructor(options = Texture.EMPTY) {
      if (options instanceof Texture) {
        options = {texture: options};
      }
      const {texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest} = options;
      super({
        label: "Sprite",
        ...rest
      });
      this.renderPipeId = "sprite";
      this.batched = true;
      this._visualBounds = {minX: 0, maxX: 1, minY: 0, maxY: 0};
      this._anchor = new ObservablePoint({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      });
      if (anchor) {
        this.anchor = anchor;
      } else if (texture.defaultAnchor) {
        this.anchor = texture.defaultAnchor;
      }
      this.texture = texture;
      this.allowChildren = false;
      this.roundPixels = roundPixels ?? false;
      if (width !== void 0)
        this.width = width;
      if (height !== void 0)
        this.height = height;
    }
    static from(source3, skipCache = false) {
      if (source3 instanceof Texture) {
        return new Sprite(source3);
      }
      return new Sprite(Texture.from(source3, skipCache));
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      this._texture = value;
      if (this._width) {
        this._setWidth(this._width, this._texture.orig.width);
      }
      if (this._height) {
        this._setHeight(this._height, this._texture.orig.height);
      }
      this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      updateQuadBounds(this._visualBounds, this._anchor, this._texture);
      return this._visualBounds;
    }
    get sourceBounds() {
      deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
      return this.visualBounds;
    }
    updateBounds() {
      const anchor = this._anchor;
      const texture = this._texture;
      const bounds = this._bounds;
      const {width, height} = texture.orig;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    destroy(options = false) {
      super.destroy(options);
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
      this._visualBounds = null;
      this._bounds = null;
      this._anchor = null;
      this._gpuData = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      this._setWidth(value, this._texture.orig.width);
      this._width = value;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      this._setHeight(value, this._texture.orig.height);
      this._height = value;
    }
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
      out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
      return out2;
    }
    setSize(value, height) {
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      } else {
        height ?? (height = value);
      }
      value !== void 0 && this._setWidth(value, this._texture.orig.width);
      height !== void 0 && this._setHeight(height, this._texture.orig.height);
    }
  };

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
  var tempBounds = new Bounds();
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix7 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix7);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix7);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask = class {
    constructor(options) {
      this.priority = 0;
      this.inverse = false;
      this.pipe = "alphaMask";
      if (options?.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
      this.renderMaskToTexture = !(mask instanceof Sprite);
      this.mask.renderable = this.renderMaskToTexture;
      this.mask.includeInBuild = !this.renderMaskToTexture;
      this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true;
      this.mask = null;
    }
    addBounds(bounds, skipUpdateTransform) {
      if (!this.inverse) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    destroy() {
      this.reset();
    }
    static test(mask) {
      return mask instanceof Sprite;
    }
  };
  AlphaMask.extension = ExtensionType.MaskEffect;

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask = class {
    constructor(options) {
      this.priority = 0;
      this.pipe = "colorMask";
      if (options?.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
    }
    destroy() {
    }
    static test(mask) {
      return typeof mask === "number";
    }
  };
  ColorMask.extension = ExtensionType.MaskEffect;

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask = class {
    constructor(options) {
      this.priority = 0;
      this.pipe = "stencilMask";
      if (options?.mask) {
        this.init(options.mask);
      }
    }
    init(mask) {
      this.mask = mask;
      this.mask.includeInBuild = false;
      this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true;
      this.mask.includeInBuild = true;
      this.mask = null;
    }
    addBounds(bounds, skipUpdateTransform) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      const mask = this.mask;
      return hitTestFn(mask, point);
    }
    destroy() {
      this.reset();
    }
    static test(mask) {
      return mask instanceof Container;
    }
  };
  StencilMask.extension = ExtensionType.MaskEffect;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource = class extends TextureSource {
    constructor(options) {
      if (!options.resource) {
        options.resource = DOMAdapter.get().createCanvas();
      }
      if (!options.width) {
        options.width = options.resource.width;
        if (!options.autoDensity) {
          options.width /= options.resolution;
        }
      }
      if (!options.height) {
        options.height = options.resource.height;
        if (!options.autoDensity) {
          options.height /= options.resolution;
        }
      }
      super(options);
      this.uploadMethodId = "image";
      this.autoDensity = options.autoDensity;
      this.resizeCanvas();
      this.transparent = !!options.transparent;
    }
    resizeCanvas() {
      if (this.autoDensity && "style" in this.resource) {
        this.resource.style.width = `${this.width}px`;
        this.resource.style.height = `${this.height}px`;
      }
      if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
    }
    resize(width = this.width, height = this.height, resolution = this._resolution) {
      const didResize = super.resize(width, height, resolution);
      if (didResize) {
        this.resizeCanvas();
      }
      return didResize;
    }
    static test(resource) {
      return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  CanvasSource.extension = ExtensionType.TextureSource;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource = class extends TextureSource {
    constructor(options) {
      super(options);
      this.uploadMethodId = "image";
      this.autoGarbageCollect = true;
    }
    static test(resource) {
      return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
    }
  };
  ImageSource.extension = ExtensionType.TextureSource;

  // node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
  var promise;
  async function detectVideoAlphaMode() {
    promise ?? (promise = (async () => {
      const canvas = DOMAdapter.get().createCanvas(1, 1);
      const gl = canvas.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve(video2);
        video2.onerror = () => resolve(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource = class _VideoSource2 extends TextureSource {
    constructor(options) {
      super(options);
      this.isReady = false;
      this.uploadMethodId = "video";
      options = {
        ..._VideoSource2.defaultOptions,
        ...options
      };
      this._autoUpdate = true;
      this._isConnectedToTicker = false;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = options.autoPlay !== false;
      this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
      this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
      this._videoFrameRequestCallbackHandle = null;
      this._load = null;
      this._resolve = null;
      this._reject = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
      this._onError = this._onError.bind(this);
      this._onPlayStart = this._onPlayStart.bind(this);
      this._onPlayStop = this._onPlayStop.bind(this);
      this._onSeeked = this._onSeeked.bind(this);
      if (options.autoLoad !== false) {
        void this.load();
      }
    }
    updateFrame() {
      if (this.destroyed) {
        return;
      }
      if (this._updateFPS) {
        const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      }
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
      if (this.isValid) {
        this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame();
      if (this.destroyed) {
        this._videoFrameRequestCallbackHandle = null;
      } else {
        this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
      }
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) {
        return this._load;
      }
      const source3 = this.resource;
      const options = this.options;
      if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
        source3.complete = true;
      }
      source3.addEventListener("play", this._onPlayStart);
      source3.addEventListener("pause", this._onPlayStop);
      source3.addEventListener("seeked", this._onSeeked);
      if (!this._isSourceReady()) {
        if (!options.preload) {
          source3.addEventListener("canplay", this._onCanPlay);
        }
        source3.addEventListener("canplaythrough", this._onCanPlayThrough);
        source3.addEventListener("error", this._onError, true);
      } else {
        this._mediaReady();
      }
      this.alphaMode = await detectVideoAlphaMode();
      this._load = new Promise((resolve, reject) => {
        if (this.isValid) {
          resolve(this);
        } else {
          this._resolve = resolve;
          this._reject = reject;
          if (options.preloadTimeoutMs !== void 0) {
            this._preloadTimeout = setTimeout(() => {
              this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
            });
          }
          source3.load();
        }
      });
      return this._load;
    }
    _onError(event) {
      this.resource.removeEventListener("error", this._onError, true);
      this.emit("error", event);
      if (this._reject) {
        this._reject(event);
        this._reject = null;
        this._resolve = null;
      }
    }
    _isSourcePlaying() {
      const source3 = this.resource;
      return !source3.paused && !source3.ended;
    }
    _isSourceReady() {
      const source3 = this.resource;
      return source3.readyState > 2;
    }
    _onPlayStart() {
      if (!this.isValid) {
        this._mediaReady();
      }
      this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      if (this._autoUpdate && !this._isSourcePlaying()) {
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
      }
    }
    _onCanPlay() {
      const source3 = this.resource;
      source3.removeEventListener("canplay", this._onCanPlay);
      this._mediaReady();
    }
    _onCanPlayThrough() {
      const source3 = this.resource;
      source3.removeEventListener("canplaythrough", this._onCanPlay);
      if (this._preloadTimeout) {
        clearTimeout(this._preloadTimeout);
        this._preloadTimeout = void 0;
      }
      this._mediaReady();
    }
    _mediaReady() {
      const source3 = this.resource;
      if (this.isValid) {
        this.isReady = true;
        this.resize(source3.videoWidth, source3.videoHeight);
      }
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
      if (this._resolve) {
        this._resolve(this);
        this._resolve = null;
        this._reject = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        void this.resource.play();
      }
    }
    destroy() {
      this._configureAutoUpdate();
      const source3 = this.resource;
      if (source3) {
        source3.removeEventListener("play", this._onPlayStart);
        source3.removeEventListener("pause", this._onPlayStop);
        source3.removeEventListener("seeked", this._onSeeked);
        source3.removeEventListener("canplay", this._onCanPlay);
        source3.removeEventListener("canplaythrough", this._onCanPlayThrough);
        source3.removeEventListener("error", this._onError, true);
        source3.pause();
        source3.src = "";
        source3.load();
      }
      super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        this._configureAutoUpdate();
      }
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
        this._configureAutoUpdate();
      }
    }
    _configureAutoUpdate() {
      if (this._autoUpdate && this._isSourcePlaying()) {
        if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
          if (this._videoFrameRequestCallbackHandle === null) {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (!this._isConnectedToTicker) {
            Ticker.shared.add(this.updateFrame, this);
            this._isConnectedToTicker = true;
            this._msToNextUpdate = 0;
          }
        }
      } else {
        if (this._videoFrameRequestCallbackHandle !== null) {
          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
          this._videoFrameRequestCallbackHandle = null;
        }
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.updateFrame, this);
          this._isConnectedToTicker = false;
          this._msToNextUpdate = 0;
        }
      }
    }
    static test(resource) {
      return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
    }
  };
  _VideoSource.extension = ExtensionType.TextureSource;
  _VideoSource.defaultOptions = {
    ...TextureSource.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  _VideoSource.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  var VideoSource = _VideoSource;

  // node_modules/pixi.js/lib/assets/cache/Cache.mjs
  var CacheClass = class {
    constructor() {
      this._parsers = [];
      this._cache = /* @__PURE__ */ new Map();
      this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear();
      this._cache.clear();
    }
    has(key) {
      return this._cache.has(key);
    }
    get(key) {
      const result = this._cache.get(key);
      if (!result) {
        warn(`[Assets] Asset id ${key} was not found in the Cache`);
      }
      return result;
    }
    set(key, value) {
      const keys = convertToList(key);
      let cacheableAssets;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser = this.parsers[i2];
        if (parser.test(value)) {
          cacheableAssets = parser.getCacheableAssets(keys, value);
          break;
        }
      }
      const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
      if (!cacheableAssets) {
        keys.forEach((key2) => {
          cacheableMap.set(key2, value);
        });
      }
      const cacheKeys = [...cacheableMap.keys()];
      const cachedAssets = {
        cacheKeys,
        keys
      };
      keys.forEach((key2) => {
        this._cacheMap.set(key2, cachedAssets);
      });
      cacheKeys.forEach((key2) => {
        const val = cacheableAssets ? cacheableAssets[key2] : value;
        if (this._cache.has(key2) && this._cache.get(key2) !== val) {
          warn("[Cache] already has key:", key2);
        }
        this._cache.set(key2, cacheableMap.get(key2));
      });
    }
    remove(key) {
      if (!this._cacheMap.has(key)) {
        warn(`[Assets] Asset id ${key} was not found in the Cache`);
        return;
      }
      const cacheMap2 = this._cacheMap.get(key);
      const cacheKeys = cacheMap2.cacheKeys;
      cacheKeys.forEach((key2) => {
        this._cache.delete(key2);
      });
      cacheMap2.keys.forEach((key2) => {
        this._cacheMap.delete(key2);
      });
    }
    get parsers() {
      return this._parsers;
    }
  };
  var Cache = new CacheClass();

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  var sources = [];
  extensions.handleByList(ExtensionType.TextureSource, sources);
  function textureSourceFrom(options = {}) {
    const hasResource = options && options.resource;
    const res = hasResource ? options.resource : options;
    const opts = hasResource ? options : {resource: options};
    for (let i2 = 0; i2 < sources.length; i2++) {
      const Source = sources[i2];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options = {}, skipCache = false) {
    const hasResource = options && options.resource;
    const resource = hasResource ? options.resource : options;
    const opts = hasResource ? options : {resource: options};
    if (!skipCache && Cache.has(resource)) {
      return Cache.get(resource);
    }
    const texture = new Texture({source: textureSourceFrom(opts)});
    texture.on("destroy", () => {
      if (Cache.has(resource)) {
        Cache.remove(resource);
      }
    });
    if (!skipCache) {
      Cache.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id, skipCache = false) {
    if (typeof id === "string") {
      return Cache.get(id);
    } else if (id instanceof TextureSource) {
      return new Texture({source: id});
    }
    return resourceToTexture(id, skipCache);
  }
  Texture.from = textureFrom;
  TextureSource.from = textureSourceFrom;

  // node_modules/pixi.js/lib/rendering/init.mjs
  extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  "use strict";
  var BindGroup = class {
    constructor(resources) {
      this.resources = /* @__PURE__ */ Object.create(null);
      this._dirty = true;
      let index = 0;
      for (const i2 in resources) {
        const resource = resources[i2];
        this.setResource(resource, index++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty)
        return;
      this._dirty = false;
      const keyParts = [];
      let index = 0;
      for (const i2 in this.resources) {
        keyParts[index++] = this.resources[i2]._resourceId;
      }
      this._key = keyParts.join("|");
    }
    setResource(resource, index) {
      const currentResource = this.resources[index];
      if (resource === currentResource)
        return;
      if (currentResource) {
        resource.off?.("change", this.onResourceChange, this);
      }
      resource.on?.("change", this.onResourceChange, this);
      this.resources[index] = resource;
      this._dirty = true;
    }
    getResource(index) {
      return this.resources[index];
    }
    _touch(tick) {
      const resources = this.resources;
      for (const i2 in resources) {
        resources[i2]._touched = tick;
      }
    }
    destroy() {
      const resources = this.resources;
      for (const i2 in resources) {
        const resource = resources[i2];
        resource?.off?.("change", this.onResourceChange, this);
      }
      this.resources = null;
    }
    onResourceChange(resource) {
      this._dirty = true;
      if (resource.destroyed) {
        const resources = this.resources;
        for (const i2 in resources) {
          if (resources[i2] === resource) {
            resources[i2] = null;
          }
        }
      } else {
        this._updateKey();
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  var cachedGroups = {};
  function getTextureBatchBindGroup(textures, size, maxTextures) {
    let uid3 = 2166136261;
    for (let i2 = 0; i2 < size; i2++) {
      uid3 ^= textures[i2].uid;
      uid3 = Math.imul(uid3, 16777619);
      uid3 >>>= 0;
    }
    return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size, uid3, maxTextures);
  }
  function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
    const bindGroupResources = {};
    let bindIndex = 0;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      const texture = i2 < size ? textures[i2] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }

  // node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
  "use strict";
  var ViewableBuffer = class {
    constructor(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
      this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    }
    get uint8View() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    }
    get int16View() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    }
    get int32View() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    }
    get float64View() {
      if (!this._float64Array) {
        this._float64Array = new Float64Array(this.rawBinaryData);
      }
      return this._float64Array;
    }
    get bigUint64View() {
      if (!this._bigUint64Array) {
        this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
      }
      return this._bigUint64Array;
    }
    view(type) {
      return this[`${type}View`];
    }
    destroy() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this.uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    }
    static sizeOf(type) {
      switch (type) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${type} isn't a valid view type`);
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  "use strict";
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
  "use strict";
  var BLEND_TO_NPM = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  var STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
    STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
    STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
    STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
    STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
    return STENCIL_MODES2;
  })(STENCIL_MODES || {});

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  var context;
  function getTestContext() {
    if (!context || context?.isContextLost()) {
      const canvas = DOMAdapter.get().createCanvas();
      context = canvas.getContext("webgl", {});
    }
    return context;
  }

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
  "use strict";
  var fragTemplate = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i2 = 0; i2 < maxIfs; ++i2) {
      if (i2 > 0) {
        src += "\nelse ";
      }
      if (i2 < maxIfs - 1) {
        src += `if(test == ${i2}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
  var maxTexturesPerBatchCache = null;
  function getMaxTexturesPerBatch() {
    if (maxTexturesPerBatchCache)
      return maxTexturesPerBatchCache;
    const gl = getTestContext();
    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(maxTexturesPerBatchCache, gl);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return maxTexturesPerBatchCache;
  }

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
  "use strict";
  var BatchTextureArray = class {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null);
      this.textures = [];
      this.count = 0;
    }
    clear() {
      for (let i2 = 0; i2 < this.count; i2++) {
        const t2 = this.textures[i2];
        this.textures[i2] = null;
        this.ids[t2.uid] = null;
      }
      this.count = 0;
    }
  };

  // node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
  var Batch = class {
    constructor() {
      this.renderPipeId = "batch";
      this.action = "startBatch";
      this.start = 0;
      this.size = 0;
      this.textures = new BatchTextureArray();
      this.blendMode = "normal";
      this.topology = "triangle-strip";
      this.canBundle = true;
    }
    destroy() {
      this.textures = null;
      this.gpuBindGroup = null;
      this.bindGroup = null;
      this.batcher = null;
    }
  };
  var batchPool = [];
  var batchPoolIndex = 0;
  GlobalResourceRegistry.register({
    clear: () => {
      if (batchPool.length > 0) {
        for (const item of batchPool) {
          if (item)
            item.destroy();
        }
      }
      batchPool.length = 0;
      batchPoolIndex = 0;
    }
  });
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  var BATCH_TICK = 0;
  var _Batcher = class _Batcher2 {
    constructor(options) {
      this.uid = uid("batcher");
      this.dirty = true;
      this.batchIndex = 0;
      this.batches = [];
      this._elements = [];
      options = {..._Batcher2.defaultOptions, ...options};
      if (!options.maxTextures) {
        deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
        options.maxTextures = getMaxTexturesPerBatch();
      }
      const {maxTextures, attributesInitialSize, indicesInitialSize} = options;
      this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
      this.indexBuffer = new Uint16Array(indicesInitialSize);
      this.maxTextures = maxTextures;
    }
    begin() {
      this.elementSize = 0;
      this.elementStart = 0;
      this.indexSize = 0;
      this.attributeSize = 0;
      for (let i2 = 0; i2 < this.batchIndex; i2++) {
        returnBatchToPool(this.batches[i2]);
      }
      this.batchIndex = 0;
      this._batchIndexStart = 0;
      this._batchIndexSize = 0;
      this.dirty = true;
    }
    add(batchableObject) {
      this._elements[this.elementSize++] = batchableObject;
      batchableObject._indexStart = this.indexSize;
      batchableObject._attributeStart = this.attributeSize;
      batchableObject._batcher = this;
      this.indexSize += batchableObject.indexSize;
      this.attributeSize += batchableObject.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(batchableObject, texture) {
      const textureId = batchableObject._batch.textures.ids[texture._source.uid];
      if (!textureId && textureId !== 0)
        return false;
      batchableObject._textureId = textureId;
      batchableObject.texture = texture;
      return true;
    }
    updateElement(batchableObject) {
      this.dirty = true;
      const attributeBuffer = this.attributeBuffer;
      if (batchableObject.packAsQuad) {
        this.packQuadAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);
      } else {
        this.packAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);
      }
    }
    break(instructionSet) {
      const elements = this._elements;
      if (!elements[this.elementStart])
        return;
      let batch = getBatchFromPool();
      let textureBatch = batch.textures;
      textureBatch.clear();
      const firstElement = elements[this.elementStart];
      let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
      let topology = firstElement.topology;
      if (this.attributeSize * 4 > this.attributeBuffer.size) {
        this._resizeAttributeBuffer(this.attributeSize * 4);
      }
      if (this.indexSize > this.indexBuffer.length) {
        this._resizeIndexBuffer(this.indexSize);
      }
      const f32 = this.attributeBuffer.float32View;
      const u32 = this.attributeBuffer.uint32View;
      const indexBuffer = this.indexBuffer;
      let size = this._batchIndexSize;
      let start = this._batchIndexStart;
      let action = "startBatch";
      const maxTextures = this.maxTextures;
      for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
        const element = elements[i2];
        elements[i2] = null;
        const texture = element.texture;
        const source3 = texture._source;
        const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source3);
        const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
        if (source3._batchTick === BATCH_TICK && !breakRequired) {
          element._textureId = source3._textureBindLocation;
          size += element.indexSize;
          if (element.packAsQuad) {
            this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);
            this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
          } else {
            this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);
            this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
          }
          element._batch = batch;
          continue;
        }
        source3._batchTick = BATCH_TICK;
        if (textureBatch.count >= maxTextures || breakRequired) {
          this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);
          action = "renderBatch";
          start = size;
          blendMode = adjustedBlendMode;
          topology = element.topology;
          batch = getBatchFromPool();
          textureBatch = batch.textures;
          textureBatch.clear();
          ++BATCH_TICK;
        }
        element._textureId = source3._textureBindLocation = textureBatch.count;
        textureBatch.ids[source3.uid] = textureBatch.count;
        textureBatch.textures[textureBatch.count++] = source3;
        element._batch = batch;
        size += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);
          this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
        } else {
          this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);
          this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);
        }
      }
      if (textureBatch.count > 0) {
        this._finishBatch(batch, start, size - start, textureBatch, blendMode, topology, instructionSet, action);
        start = size;
        ++BATCH_TICK;
      }
      this.elementStart = this.elementSize;
      this._batchIndexStart = start;
      this._batchIndexSize = size;
    }
    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
      batch.gpuBindGroup = null;
      batch.bindGroup = null;
      batch.action = action;
      batch.batcher = this;
      batch.textures = textureBatch;
      batch.blendMode = blendMode;
      batch.topology = topology;
      batch.start = indexStart;
      batch.size = indexSize;
      ++BATCH_TICK;
      this.batches[this.batchIndex++] = batch;
      instructionSet.add(batch);
    }
    finish(instructionSet) {
      this.break(instructionSet);
    }
    ensureAttributeBuffer(size) {
      if (size * 4 <= this.attributeBuffer.size)
        return;
      this._resizeAttributeBuffer(size * 4);
    }
    ensureIndexBuffer(size) {
      if (size <= this.indexBuffer.length)
        return;
      this._resizeIndexBuffer(size);
    }
    _resizeAttributeBuffer(size) {
      const newSize = Math.max(size, this.attributeBuffer.size * 2);
      const newArrayBuffer = new ViewableBuffer(newSize);
      fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
      this.attributeBuffer = newArrayBuffer;
    }
    _resizeIndexBuffer(size) {
      const indexBuffer = this.indexBuffer;
      let newSize = Math.max(size, indexBuffer.length * 1.5);
      newSize += newSize % 2;
      const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
      if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
        for (let i2 = 0; i2 < indexBuffer.length; i2++) {
          newIndexBuffer[i2] = indexBuffer[i2];
        }
      } else {
        fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
      }
      this.indexBuffer = newIndexBuffer;
    }
    packQuadIndex(indexBuffer, index, indicesOffset) {
      indexBuffer[index] = indicesOffset + 0;
      indexBuffer[index + 1] = indicesOffset + 1;
      indexBuffer[index + 2] = indicesOffset + 2;
      indexBuffer[index + 3] = indicesOffset + 0;
      indexBuffer[index + 4] = indicesOffset + 2;
      indexBuffer[index + 5] = indicesOffset + 3;
    }
    packIndex(element, indexBuffer, index, indicesOffset) {
      const indices = element.indices;
      const size = element.indexSize;
      const indexOffset = element.indexOffset;
      const attributeOffset = element.attributeOffset;
      for (let i2 = 0; i2 < size; i2++) {
        indexBuffer[index++] = indicesOffset + indices[i2 + indexOffset] - attributeOffset;
      }
    }
    destroy() {
      if (this.batches === null)
        return;
      for (let i2 = 0; i2 < this.batches.length; i2++) {
        returnBatchToPool(this.batches[i2]);
      }
      this.batches = null;
      for (let i2 = 0; i2 < this._elements.length; i2++) {
        if (this._elements[i2])
          this._elements[i2]._batch = null;
      }
      this._elements = null;
      this.indexBuffer = null;
      this.attributeBuffer.destroy();
      this.attributeBuffer = null;
    }
  };
  _Batcher.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  var Batcher = _Batcher;

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
  "use strict";
  var BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
    BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
    BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
    BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
    BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
    BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
    BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
    BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
    BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
    BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
    BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
    BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
    return BufferUsage2;
  })(BufferUsage || {});

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2 = class extends eventemitter3_default {
    constructor(options) {
      let {data, size} = options;
      const {usage, label: label2, shrinkToFit} = options;
      super();
      this.uid = uid("buffer");
      this._resourceType = "buffer";
      this._resourceId = uid("resource");
      this._touched = 0;
      this._updateID = 1;
      this._dataInt32 = null;
      this.shrinkToFit = true;
      this.destroyed = false;
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      this._data = data;
      size ?? (size = data?.byteLength);
      const mappedAtCreation = !!data;
      this.descriptor = {
        size,
        usage,
        mappedAtCreation,
        label: label2
      };
      this.shrinkToFit = shrinkToFit ?? true;
    }
    get data() {
      return this._data;
    }
    set data(value) {
      this.setDataWithSize(value, value.length, true);
    }
    get dataInt32() {
      if (!this._dataInt32) {
        this._dataInt32 = new Int32Array(this.data.buffer);
      }
      return this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & BufferUsage.STATIC);
    }
    set static(value) {
      if (value) {
        this.descriptor.usage |= BufferUsage.STATIC;
      } else {
        this.descriptor.usage &= ~BufferUsage.STATIC;
      }
    }
    setDataWithSize(value, size, syncGPU) {
      this._updateID++;
      this._updateSize = size * value.BYTES_PER_ELEMENT;
      if (this._data === value) {
        if (syncGPU)
          this.emit("update", this);
        return;
      }
      const oldData = this._data;
      this._data = value;
      this._dataInt32 = null;
      if (!oldData || oldData.length !== value.length) {
        if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
          if (syncGPU)
            this.emit("update", this);
        } else {
          this.descriptor.size = value.byteLength;
          this._resourceId = uid("resource");
          this.emit("change", this);
        }
        return;
      }
      if (syncGPU)
        this.emit("update", this);
    }
    update(sizeInBytes) {
      this._updateSize = sizeInBytes ?? this._updateSize;
      this._updateID++;
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true;
      this.emit("destroy", this);
      this.emit("change", this);
      this._data = null;
      this.descriptor = null;
      this.removeAllListeners();
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  "use strict";
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i2 = offset; i2 < data.length; i2 += stride) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry = class extends eventemitter3_default {
    constructor(options = {}) {
      super();
      this.uid = uid("geometry");
      this._layoutKey = 0;
      this.instanceCount = 1;
      this._bounds = new Bounds();
      this._boundsDirty = true;
      const {attributes, indexBuffer, topology} = options;
      this.buffers = [];
      this.attributes = {};
      if (attributes) {
        for (const i2 in attributes) {
          this.addAttribute(i2, attributes[i2]);
        }
      }
      this.instanceCount = options.instanceCount ?? 1;
      if (indexBuffer) {
        this.addIndex(indexBuffer);
      }
      this.topology = topology || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true;
      this.emit("update", this);
    }
    getAttribute(id) {
      return this.attributes[id];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(id) {
      return this.getAttribute(id).buffer;
    }
    getSize() {
      for (const i2 in this.attributes) {
        const attribute = this.attributes[i2];
        const buffer = attribute.buffer;
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    }
    addAttribute(name, attributeOption) {
      const attribute = ensureIsAttribute(attributeOption);
      const bufferIndex = this.buffers.indexOf(attribute.buffer);
      if (bufferIndex === -1) {
        this.buffers.push(attribute.buffer);
        attribute.buffer.on("update", this.onBufferUpdate, this);
        attribute.buffer.on("change", this.onBufferUpdate, this);
      }
      this.attributes[name] = attribute;
    }
    addIndex(indexBuffer) {
      this.indexBuffer = ensureIsBuffer(indexBuffer, true);
      this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this._boundsDirty = false;
      return getGeometryBounds(this, "aPosition", this._bounds);
    }
    destroy(destroyBuffers = false) {
      this.emit("destroy", this);
      this.removeAllListeners();
      if (destroyBuffers) {
        this.buffers.forEach((buffer) => buffer.destroy());
      }
      this.attributes = null;
      this.buffers = null;
      this.indexBuffer = null;
      this._bounds = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
  var placeHolderBufferData = new Float32Array(1);
  var placeHolderIndexData = new Uint32Array(1);
  var BatchGeometry = class extends Geometry {
    constructor() {
      const vertexSize = 6;
      const attributeBuffer = new Buffer2({
        data: placeHolderBufferData,
        label: "attribute-batch-buffer",
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const indexBuffer = new Buffer2({
        data: placeHolderIndexData,
        label: "index-batch-buffer",
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
        shrinkToFit: false
      });
      const stride = vertexSize * 4;
      super({
        attributes: {
          aPosition: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 0
          },
          aUV: {
            buffer: attributeBuffer,
            format: "float32x2",
            stride,
            offset: 2 * 4
          },
          aColor: {
            buffer: attributeBuffer,
            format: "unorm8x4",
            stride,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: attributeBuffer,
            format: "uint16x2",
            stride,
            offset: 5 * 4
          }
        },
        indexBuffer
      });
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  "use strict";
  var idCounts = /* @__PURE__ */ Object.create(null);
  var idHash2 = /* @__PURE__ */ Object.create(null);
  function createIdFromString(value, groupId) {
    let id = idHash2[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value] = id = idCounts[groupId]++;
    }
    return id;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  var maxFragmentPrecision;
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  "use strict";
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  "use strict";
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  "use strict";
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  "use strict";
  var fragmentNameCache = {};
  var VertexNameCache = {};
  function setProgramName(src, {name = `pixi-program`}, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  "use strict";
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes = {
    stripVersion,
    ensurePrecision,
    addProgramDefines,
    setProgramName,
    insertVersion
  };
  var programCache = /* @__PURE__ */ Object.create(null);
  var _GlProgram = class _GlProgram2 {
    constructor(options) {
      options = {..._GlProgram2.defaultOptions, ...options};
      const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
      const preprocessorOptions = {
        stripVersion: isES300,
        ensurePrecision: {
          requestedFragmentPrecision: options.preferredFragmentPrecision,
          requestedVertexPrecision: options.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: getMaxFragmentPrecision()
        },
        setProgramName: {
          name: options.name
        },
        addProgramDefines: isES300,
        insertVersion: isES300
      };
      let fragment4 = options.fragment;
      let vertex4 = options.vertex;
      Object.keys(processes).forEach((processKey) => {
        const processOptions = preprocessorOptions[processKey];
        fragment4 = processes[processKey](fragment4, processOptions, true);
        vertex4 = processes[processKey](vertex4, processOptions, false);
      });
      this.fragment = fragment4;
      this.vertex = vertex4;
      this.transformFeedbackVaryings = options.transformFeedbackVaryings;
      this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null;
      this.vertex = null;
      this._attributeData = null;
      this._uniformData = null;
      this._uniformBlockData = null;
      this.transformFeedbackVaryings = null;
      programCache[this._cacheKey] = null;
    }
    static from(options) {
      const key = `${options.vertex}:${options.fragment}`;
      if (!programCache[key]) {
        programCache[key] = new _GlProgram2(options);
        programCache[key]._cacheKey = key;
      }
      return programCache[key];
    }
  };
  _GlProgram.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  var GlProgram = _GlProgram;

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  "use strict";
  var attributeFormatData = {
    uint8x2: {size: 2, stride: 2, normalised: false},
    uint8x4: {size: 4, stride: 4, normalised: false},
    sint8x2: {size: 2, stride: 2, normalised: false},
    sint8x4: {size: 4, stride: 4, normalised: false},
    unorm8x2: {size: 2, stride: 2, normalised: true},
    unorm8x4: {size: 4, stride: 4, normalised: true},
    snorm8x2: {size: 2, stride: 2, normalised: true},
    snorm8x4: {size: 4, stride: 4, normalised: true},
    uint16x2: {size: 2, stride: 4, normalised: false},
    uint16x4: {size: 4, stride: 8, normalised: false},
    sint16x2: {size: 2, stride: 4, normalised: false},
    sint16x4: {size: 4, stride: 8, normalised: false},
    unorm16x2: {size: 2, stride: 4, normalised: true},
    unorm16x4: {size: 4, stride: 8, normalised: true},
    snorm16x2: {size: 2, stride: 4, normalised: true},
    snorm16x4: {size: 4, stride: 8, normalised: true},
    float16x2: {size: 2, stride: 4, normalised: false},
    float16x4: {size: 4, stride: 8, normalised: false},
    float32: {size: 1, stride: 4, normalised: false},
    float32x2: {size: 2, stride: 8, normalised: false},
    float32x3: {size: 3, stride: 12, normalised: false},
    float32x4: {size: 4, stride: 16, normalised: false},
    uint32: {size: 1, stride: 4, normalised: false},
    uint32x2: {size: 2, stride: 8, normalised: false},
    uint32x3: {size: 3, stride: 12, normalised: false},
    uint32x4: {size: 4, stride: 16, normalised: false},
    sint32: {size: 1, stride: 4, normalised: false},
    sint32x2: {size: 2, stride: 8, normalised: false},
    sint32x3: {size: 3, stride: 12, normalised: false},
    sint32x4: {size: 4, stride: 16, normalised: false}
  };
  function getAttributeInfoFromFormat(format) {
    return attributeFormatData[format] ?? attributeFormatData.float32;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  var WGSL_TO_VERTEX_TYPES = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function extractAttributesFromGpuProgram({source: source3, entryPoint}) {
    const results = {};
    const mainVertStart = source3.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source3.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source3.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  "use strict";
  function extractStructAndGroups(wgsl2) {
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl2.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl2.match(structPattern)?.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return {name, members};
    }).filter(({name}) => groups.some((group) => group.type === name)) ?? [];
    return {
      groups,
      structs
    };
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
  "use strict";
  var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
    ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
    ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
    ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
    return ShaderStage2;
  })(ShaderStage || {});

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({groups}) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  "use strict";
  function generateLayoutHash({groups}) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  "use strict";
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return {structs, groups};
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2 = /* @__PURE__ */ Object.create(null);
  var GpuProgram = class {
    constructor(options) {
      this._layoutKey = 0;
      this._attributeLocationsKey = 0;
      const {fragment: fragment4, vertex: vertex4, layout, gpuLayout, name} = options;
      this.name = name;
      this.fragment = fragment4;
      this.vertex = vertex4;
      if (fragment4.source === vertex4.source) {
        const structsAndGroups = extractStructAndGroups(fragment4.source);
        this.structsAndGroups = structsAndGroups;
      } else {
        const vertexStructsAndGroups = extractStructAndGroups(vertex4.source);
        const fragmentStructsAndGroups = extractStructAndGroups(fragment4.source);
        this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
      }
      this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
      this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
      this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
      this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
      this._generateProgramKey();
    }
    _generateProgramKey() {
      const {vertex: vertex4, fragment: fragment4} = this;
      const bigKey = vertex4.source + fragment4.source + vertex4.entryPoint + fragment4.entryPoint;
      this._layoutKey = createIdFromString(bigKey, "program");
    }
    get attributeData() {
      this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
      return this._attributeData;
    }
    destroy() {
      this.gpuLayout = null;
      this.layout = null;
      this.structsAndGroups = null;
      this.fragment = null;
      this.vertex = null;
      programCache2[this._cacheKey] = null;
    }
    static from(options) {
      const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
      if (!programCache2[key]) {
        programCache2[key] = new GpuProgram(options);
        programCache2[key]._cacheKey = key;
      }
      return programCache2[key];
    }
  };

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i2 in srcParts) {
        const id = i2.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i2];
          if (i2 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i2} placement hook does not exist in shader`);
        }
      }
    }
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  "use strict";
  var findHooksRx = /\{\{(.*?)\}\}/g;
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  "use strict";
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment4) => {
      if (fragment4.header) {
        extractInputs(fragment4.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  "use strict";
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment4) => {
      if (fragment4.header) {
        extractOutputs(fragment4.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  "use strict";
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i2 in fragmentParts) {
      const parts = fragmentParts[i2];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i2}}}`, "");
      }
    }
    return out2;
  }

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
  var cacheMap = /* @__PURE__ */ Object.create(null);
  var bitCacheMap = /* @__PURE__ */ new Map();
  var CACHE_UID = 0;
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const {vertex: vertex4, fragment: fragment4} = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex4, fragment4, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex4, fragment4, bits) {
    const vertexParts = compileHooks(vertex4);
    const fragmentParts = compileHooks(fragment4);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex4, vertexParts),
      fragment: injectBits(fragment4, fragmentParts)
    };
  }

  // node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
  "use strict";
  var vertexGPUTemplate = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
  var fragmentGPUTemplate = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
  var vertexGlTemplate = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
  var fragmentGlTemplate = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`;

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  "use strict";
  var globalUniformsBit = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  };
  var globalUniformsBitGl = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };

  // node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({bits, name}) {
    const source3 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name,
      vertex: {
        source: source3.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source3.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({bits, name}) {
    return new GlProgram({
      name,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
  "use strict";
  var colorBit = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  var colorBitGl = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  "use strict";
  var textureBatchBitGpuCache = {};
  function generateBindingSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i2 = 0; i2 < maxTextures; i2++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i2 = 0; i2 < maxTextures; i2++) {
        if (i2 === maxTextures - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i2}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures) {
    if (!textureBatchBitGpuCache[maxTextures]) {
      textureBatchBitGpuCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures];
  }
  var textureBatchBitGlCache = {};
  function generateSampleGlSrc(maxTextures) {
    const src = [];
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src.push("else");
      }
      if (i2 < maxTextures - 1) {
        src.push(`if(vTextureId < ${i2}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures) {
    if (!textureBatchBitGlCache[maxTextures]) {
      textureBatchBitGlCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures];
  }

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  "use strict";
  var roundPixelsBit = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  var roundPixelsBitGl = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
  "use strict";
  var UNIFORM_TYPES_VALUES = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ];
  var UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
    acc[type] = true;
    return acc;
  }, {});

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  "use strict";
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup = class _UniformGroup2 {
    constructor(uniformStructures, options) {
      this._touched = 0;
      this.uid = uid("uniform");
      this._resourceType = "uniformGroup";
      this._resourceId = uid("resource");
      this.isUniformGroup = true;
      this._dirtyId = 0;
      this.destroyed = false;
      options = {..._UniformGroup2.defaultOptions, ...options};
      this.uniformStructures = uniformStructures;
      const uniforms = {};
      for (const i2 in uniformStructures) {
        const uniformData = uniformStructures[i2];
        uniformData.name = i2;
        uniformData.size = uniformData.size ?? 1;
        if (!UNIFORM_TYPES_MAP[uniformData.type]) {
          const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
          if (arrayMatch) {
            const [, innerType, size] = arrayMatch;
            throw new Error(`Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`);
          }
          throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
        }
        uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
        uniforms[i2] = uniformData.value;
      }
      this.uniforms = uniforms;
      this._dirtyId = 1;
      this.ubo = options.ubo;
      this.isStatic = options.isStatic;
      this._signature = createIdFromString(Object.keys(uniforms).map((i2) => `${i2}-${uniformStructures[i2].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  _UniformGroup.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  var UniformGroup = _UniformGroup;

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
  var batchSamplersUniformGroupHash = {};
  function getBatchSamplersUniformGroup(maxTextures) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures);
    for (let i2 = 0; i2 < maxTextures; i2++) {
      sampleValues[i2] = i2;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
      uTextures: {value: sampleValues, type: `i32`, size: maxTextures}
    }, {isStatic: true});
    return batchSamplersUniformGroup;
  }

  // node_modules/pixi.js/lib/rendering/renderers/types.mjs
  "use strict";
  var RendererType = /* @__PURE__ */ ((RendererType2) => {
    RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
    RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
    RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
    return RendererType2;
  })(RendererType || {});

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader = class extends eventemitter3_default {
    constructor(options) {
      super();
      this.uid = uid("shader");
      this._uniformBindMap = /* @__PURE__ */ Object.create(null);
      this._ownedBindGroups = [];
      let {
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        groups,
        resources,
        compatibleRenderers,
        groupMap
      } = options;
      this.gpuProgram = gpuProgram3;
      this.glProgram = glProgram3;
      if (compatibleRenderers === void 0) {
        compatibleRenderers = 0;
        if (gpuProgram3)
          compatibleRenderers |= RendererType.WEBGPU;
        if (glProgram3)
          compatibleRenderers |= RendererType.WEBGL;
      }
      this.compatibleRenderers = compatibleRenderers;
      const nameHash = {};
      if (!resources && !groups) {
        resources = {};
      }
      if (resources && groups) {
        throw new Error("[Shader] Cannot have both resources and groups");
      } else if (!gpuProgram3 && groups && !groupMap) {
        throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      } else if (!gpuProgram3 && groups && groupMap) {
        for (const i2 in groupMap) {
          for (const j2 in groupMap[i2]) {
            const uniformName = groupMap[i2][j2];
            nameHash[uniformName] = {
              group: i2,
              binding: j2,
              name: uniformName
            };
          }
        }
      } else if (gpuProgram3 && groups && !groupMap) {
        const groupData = gpuProgram3.structsAndGroups.groups;
        groupMap = {};
        groupData.forEach((data) => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      } else if (resources) {
        groups = {};
        groupMap = {};
        if (gpuProgram3) {
          const groupData = gpuProgram3.structsAndGroups.groups;
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        }
        let bindTick = 0;
        for (const i2 in resources) {
          if (nameHash[i2])
            continue;
          if (!groups[99]) {
            groups[99] = new BindGroup();
            this._ownedBindGroups.push(groups[99]);
          }
          nameHash[i2] = {group: 99, binding: bindTick, name: i2};
          groupMap[99] = groupMap[99] || {};
          groupMap[99][bindTick] = i2;
          bindTick++;
        }
        for (const i2 in resources) {
          const name = i2;
          let value = resources[i2];
          if (!value.source && !value._resourceType) {
            value = new UniformGroup(value);
          }
          const data = nameHash[name];
          if (data) {
            if (!groups[data.group]) {
              groups[data.group] = new BindGroup();
              this._ownedBindGroups.push(groups[data.group]);
            }
            groups[data.group].setResource(value, data.binding);
          }
        }
      }
      this.groups = groups;
      this._uniformBindMap = groupMap;
      this.resources = this._buildResourceAccessor(groups, nameHash);
    }
    addResource(name, groupIndex, bindIndex) {
      var _a, _b;
      (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
      (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      if (!this.groups[groupIndex]) {
        this.groups[groupIndex] = new BindGroup();
        this._ownedBindGroups.push(this.groups[groupIndex]);
      }
    }
    _buildResourceAccessor(groups, nameHash) {
      const uniformsOut = {};
      for (const i2 in nameHash) {
        const data = nameHash[i2];
        Object.defineProperty(uniformsOut, data.name, {
          get() {
            return groups[data.group].getResource(data.binding);
          },
          set(value) {
            groups[data.group].setResource(value, data.binding);
          }
        });
      }
      return uniformsOut;
    }
    destroy(destroyPrograms = false) {
      this.emit("destroy", this);
      if (destroyPrograms) {
        this.gpuProgram?.destroy();
        this.glProgram?.destroy();
      }
      this.gpuProgram = null;
      this.glProgram = null;
      this.removeAllListeners();
      this._uniformBindMap = null;
      this._ownedBindGroups.forEach((bindGroup) => {
        bindGroup.destroy();
      });
      this._ownedBindGroups = null;
      this.resources = null;
      this.groups = null;
    }
    static from(options) {
      const {gpu, gl, ...rest} = options;
      let gpuProgram3;
      let glProgram3;
      if (gpu) {
        gpuProgram3 = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram3 = GlProgram.from(gl);
      }
      return new Shader({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        ...rest
      });
    }
  };

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
  var DefaultShader = class extends Shader {
    constructor(maxTextures) {
      const glProgram3 = compileHighShaderGlProgram({
        name: "batch",
        bits: [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          roundPixelsBitGl
        ]
      });
      const gpuProgram3 = compileHighShaderGpuProgram({
        name: "batch",
        bits: [
          colorBit,
          generateTextureBatchBit(maxTextures),
          roundPixelsBit
        ]
      });
      super({
        glProgram: glProgram3,
        gpuProgram: gpuProgram3,
        resources: {
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  };

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
  var defaultShader = null;
  var _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
    constructor(options) {
      super(options);
      this.geometry = new BatchGeometry();
      this.name = _DefaultBatcher2.extension.name;
      this.vertexSize = 6;
      defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));
      this.shader = defaultShader;
    }
    packAttributes(element, float32View, uint32View, index, textureId) {
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const {positions, uvs} = element;
      const argb = element.color;
      const offset = element.attributeOffset;
      const end = offset + element.attributeSize;
      for (let i2 = offset; i2 < end; i2++) {
        const i22 = i2 * 2;
        const x2 = positions[i22];
        const y2 = positions[i22 + 1];
        float32View[index++] = a2 * x2 + c2 * y2 + tx;
        float32View[index++] = d2 * y2 + b2 * x2 + ty;
        float32View[index++] = uvs[i22];
        float32View[index++] = uvs[i22 + 1];
        uint32View[index++] = argb;
        uint32View[index++] = textureIdAndRound;
      }
    }
    packQuadAttributes(element, float32View, uint32View, index, textureId) {
      const texture = element.texture;
      const wt = element.transform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c2 = wt.c;
      const d2 = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const bounds = element.bounds;
      const w0 = bounds.maxX;
      const w1 = bounds.minX;
      const h0 = bounds.maxY;
      const h1 = bounds.minY;
      const uvs = texture.uvs;
      const argb = element.color;
      const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
      float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
      float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
      float32View[index + 2] = uvs.x0;
      float32View[index + 3] = uvs.y0;
      uint32View[index + 4] = argb;
      uint32View[index + 5] = textureIdAndRound;
      float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
      float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
      float32View[index + 8] = uvs.x1;
      float32View[index + 9] = uvs.y1;
      uint32View[index + 10] = argb;
      uint32View[index + 11] = textureIdAndRound;
      float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
      float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
      float32View[index + 14] = uvs.x2;
      float32View[index + 15] = uvs.y2;
      uint32View[index + 16] = argb;
      uint32View[index + 17] = textureIdAndRound;
      float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
      float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
      float32View[index + 20] = uvs.x3;
      float32View[index + 21] = uvs.y3;
      uint32View[index + 22] = argb;
      uint32View[index + 23] = textureIdAndRound;
    }
  };
  _DefaultBatcher.extension = {
    type: [
      ExtensionType.Batcher
    ],
    name: "default"
  };
  var DefaultBatcher = _DefaultBatcher;

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  "use strict";
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  "use strict";
  function transformVertices(vertices, m2, offset, stride, size) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset || (offset = 0);
    stride || (stride = 2);
    size || (size = vertices.length / stride - offset);
    let index = offset * stride;
    for (let i2 = 0; i2 < size; i2++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
  var identityMatrix2 = new Matrix();
  var BatchableGraphics = class {
    constructor() {
      this.packAsQuad = false;
      this.batcherName = "default";
      this.topology = "triangle-list";
      this.applyTransform = true;
      this.roundPixels = 0;
      this._batcher = null;
      this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      if (this.renderable && this.applyTransform) {
        return this.renderable.groupBlendMode;
      }
      return "normal";
    }
    get color() {
      const rgb = this.baseColor;
      const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
      const renderable = this.renderable;
      if (renderable) {
        return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
      }
      return bgr + (this.alpha * 255 << 24);
    }
    get transform() {
      return this.renderable?.groupTransform || identityMatrix2;
    }
    copyTo(gpuBuffer) {
      gpuBuffer.indexOffset = this.indexOffset;
      gpuBuffer.indexSize = this.indexSize;
      gpuBuffer.attributeOffset = this.attributeOffset;
      gpuBuffer.attributeSize = this.attributeSize;
      gpuBuffer.baseColor = this.baseColor;
      gpuBuffer.alpha = this.alpha;
      gpuBuffer.texture = this.texture;
      gpuBuffer.geometryData = this.geometryData;
      gpuBuffer.topology = this.topology;
    }
    reset() {
      this.applyTransform = true;
      this.renderable = null;
      this.topology = "triangle-list";
    }
    destroy() {
      this.renderable = null;
      this.texture = null;
      this.geometryData = null;
      this._batcher = null;
      this._batch = null;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "circle"
    },
    build(shape, points) {
      let x2;
      let y2;
      let dx2;
      let dy2;
      let rx;
      let ry;
      if (shape.type === "circle") {
        const circle = shape;
        rx = ry = circle.radius;
        if (rx <= 0) {
          return false;
        }
        x2 = circle.x;
        y2 = circle.y;
        dx2 = dy2 = 0;
      } else if (shape.type === "ellipse") {
        const ellipse = shape;
        rx = ellipse.halfWidth;
        ry = ellipse.halfHeight;
        if (rx <= 0 || ry <= 0) {
          return false;
        }
        x2 = ellipse.x;
        y2 = ellipse.y;
        dx2 = dy2 = 0;
      } else {
        const roundedRect = shape;
        const halfWidth = roundedRect.width / 2;
        const halfHeight = roundedRect.height / 2;
        x2 = roundedRect.x + halfWidth;
        y2 = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx2 = halfWidth - rx;
        dy2 = halfHeight - ry;
      }
      if (dx2 < 0 || dy2 < 0) {
        return false;
      }
      const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
      const m2 = n2 * 8 + (dx2 ? 4 : 0) + (dy2 ? 4 : 0);
      if (m2 === 0) {
        return false;
      }
      if (n2 === 0) {
        points[0] = points[6] = x2 + dx2;
        points[1] = points[3] = y2 + dy2;
        points[2] = points[4] = x2 - dx2;
        points[5] = points[7] = y2 - dy2;
        return true;
      }
      let j1 = 0;
      let j2 = n2 * 4 + (dx2 ? 2 : 0) + 2;
      let j3 = j2;
      let j4 = m2;
      let x0 = dx2 + rx;
      let y0 = dy2;
      let x1 = x2 + x0;
      let x22 = x2 - x0;
      let y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy2) {
        const y222 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y222;
        points[--j4] = y222;
        points[--j4] = x1;
      }
      for (let i2 = 1; i2 < n2; i2++) {
        const a2 = Math.PI / 2 * (i2 / n2);
        const x02 = dx2 + Math.cos(a2) * rx;
        const y02 = dy2 + Math.sin(a2) * ry;
        const x12 = x2 + x02;
        const x222 = x2 - x02;
        const y12 = y2 + y02;
        const y222 = y2 - y02;
        points[j1++] = x12;
        points[j1++] = y12;
        points[--j2] = y12;
        points[--j2] = x222;
        points[j3++] = x222;
        points[j3++] = y222;
        points[--j4] = y222;
        points[--j4] = x12;
      }
      x0 = dx2;
      y0 = dy2 + ry;
      x1 = x2 + x0;
      x22 = x2 - x0;
      y1 = y2 + y0;
      const y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx2) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      if (points.length === 0) {
        return;
      }
      let centerX = 0;
      let centerY = 0;
      for (let i2 = 0; i2 < points.length; i2 += 2) {
        centerX += points[i2];
        centerY += points[i2 + 1];
      }
      centerX /= points.length / 2;
      centerY /= points.length / 2;
      let count2 = verticesOffset;
      vertices[count2 * verticesStride] = centerX;
      vertices[count2 * verticesStride + 1] = centerY;
      const centerIndex = count2++;
      for (let i2 = 0; i2 < points.length; i2 += 2) {
        vertices[count2 * verticesStride] = points[i2];
        vertices[count2 * verticesStride + 1] = points[i2 + 1];
        if (i2 > 0) {
          indices[indicesOffset++] = count2;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
        count2++;
      }
      indices[indicesOffset++] = centerIndex + 1;
      indices[indicesOffset++] = centerIndex;
      indices[indicesOffset++] = count2 - 1;
    }
  };
  var buildEllipse = {...buildCircle, extension: {...buildCircle.extension, name: "ellipse"}};
  var buildRoundedRectangle = {...buildCircle, extension: {...buildCircle.extension, name: "roundedRectangle"}};

  // node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
  "use strict";
  var closePointEps = 1e-4;
  var curveEps = 1e-4;

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  "use strict";
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area2 = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      area2 += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area2 < 0) {
      return -1;
    }
    return 1;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius2 = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius2) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(cx + Math.sin(angle) * radius2, cy + Math.cos(angle) * radius2);
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx + Math.sin(angle) * radius2, cy + Math.cos(angle) * radius2);
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);
    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);
    for (let i2 = 1; i2 < length - 1; ++i2) {
      x0 = points[(i2 - 1) * 2];
      y0 = points[(i2 - 1) * 2 + 1];
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      x2 = points[(i2 + 1) * 2];
      y2 = points[(i2 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
          verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
      x0 = verts[i2 * 2];
      y0 = verts[i2 * 2 + 1];
      x1 = verts[(i2 + 1) * 2];
      y1 = verts[(i2 + 1) * 2 + 1];
      x2 = verts[(i2 + 2) * 2];
      y2 = verts[(i2 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i2, i2 + 1, i2 + 2);
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs
  function buildPixelLine(points, closed, vertices, indices) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const fx = points[0];
    const fy = points[1];
    const lx = points[points.length - 2];
    const ly = points[points.length - 1];
    const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
    const verts = vertices;
    const length = points.length / 2;
    const indexStart = verts.length / 2;
    for (let i2 = 0; i2 < length; i2++) {
      verts.push(points[i2 * 2]);
      verts.push(points[i2 * 2 + 1]);
    }
    for (let i2 = 0; i2 < length - 1; i2++) {
      indices.push(indexStart + i2, indexStart + i2 + 1);
    }
    if (closePath) {
      indices.push(indexStart + length - 1, indexStart);
    }
  }

  // node_modules/earcut/src/earcut.js
  function earcut(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = data[0];
      minY = data[1];
      let maxX = minX;
      let maxY = minY;
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        const x2 = data[i2];
        const y2 = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    let last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (let i2 = start; i2 < end; i2 += dim)
        last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
    } else {
      for (let i2 = end - dim; i2 >= start; i2 -= dim)
        last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p2 = start, again;
    do {
      again = false;
      if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    while (ear.prev !== ear.next) {
      const prev = ear.prev;
      const next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i, ear.i, next.i);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    let p2 = c2.next;
    while (p2 !== a2) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
    const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p2 = ear.prevZ, n2 = ear.nextZ;
    while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n2 && n2.z <= maxZ) {
      if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles) {
    let p2 = start;
    do {
      const a2 = p2.prev, b2 = p2.next.next;
      if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
        triangles.push(a2.i, p2.i, b2.i);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b2;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
      let b2 = a2.next.next;
      while (b2 !== a2.prev) {
        if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
          let c2 = splitPolygon(a2, b2);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    for (let i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      const start = holeIndices[i2] * dim;
      const end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      const list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareXYSlope);
    for (let i2 = 0; i2 < queue.length; i2++) {
      outerNode = eliminateHole(queue[i2], outerNode);
    }
    return outerNode;
  }
  function compareXYSlope(a2, b2) {
    let result = a2.x - b2.x;
    if (result === 0) {
      result = a2.y - b2.y;
      if (result === 0) {
        const aSlope = (a2.next.y - a2.y) / (a2.next.x - a2.x);
        const bSlope = (b2.next.y - b2.y) / (b2.next.x - b2.x);
        result = aSlope - bSlope;
      }
    }
    return result;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m2;
    if (equals(hole, p2))
      return p2;
    do {
      if (equals(hole, p2.next))
        return p2.next;
      else if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          m2 = p2.x < p2.next.x ? p2 : p2.next;
          if (x2 === hx)
            return m2;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m2)
      return null;
    const stop = m2;
    const mx = m2.x;
    const my = m2.y;
    let tanMin = Infinity;
    p2 = m2;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        const tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
          m2 = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m2;
  }
  function sectorContainsSector(m2, p2) {
    return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
      if (p2.z === 0)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    let numMerges;
    let inSize = 1;
    do {
      let p2 = list;
      let e2;
      list = null;
      let tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        let q = p2;
        let pSize = 0;
        for (let i2 = 0; i2 < inSize; i2++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        let qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
            e2 = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e2 = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e2;
          else
            list = e2;
          e2.prevZ = tail;
          tail = e2;
        }
        p2 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = (x2 - minX) * invSize | 0;
    y2 = (y2 - minY) * invSize | 0;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start) {
    let p2 = start, leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
  }
  function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p2, q, r2) {
    return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p2, q, r2) {
    return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b2) {
    let p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
        return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  }
  function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
  }
  function middleInside(a2, b2) {
    let p2 = a2;
    let inside = false;
    const px = (a2.x + b2.x) / 2;
    const py = (a2.y + b2.y) / 2;
    do {
      if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  }
  function splitPolygon(a2, b2) {
    const a22 = createNode(a2.i, a2.x, a2.y), b22 = createNode(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i2, x2, y2, last) {
    const p2 = createNode(i2, x2, y2);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function createNode(i2, x2, y2) {
    return {
      i: i2,
      x: x2,
      y: y2,
      prev: null,
      next: null,
      z: 0,
      prevZ: null,
      nextZ: null,
      steiner: false
    };
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
      sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
      j2 = i2;
    }
    return sum;
  }

  // node_modules/pixi.js/lib/utils/utils.mjs
  var earcut2 = earcut.default || earcut;

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = earcut2(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      indices[indicesOffset++] = triangles[i2] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[index] = points[i2];
      vertices[index + 1] = points[i2 + 1];
      index += verticesStride;
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray = [];
  var buildPolygon = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "polygon"
    },
    build(shape, points) {
      for (let i2 = 0; i2 < shape.points.length; i2++) {
        points[i2] = shape.points[i2];
      }
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "rectangle"
    },
    build(shape, points) {
      const rectData = shape;
      const x2 = rectData.x;
      const y2 = rectData.y;
      const width = rectData.width;
      const height = rectData.height;
      if (!(width > 0 && height > 0)) {
        return false;
      }
      points[0] = x2;
      points[1] = y2;
      points[2] = x2 + width;
      points[3] = y2;
      points[4] = x2 + width;
      points[5] = y2 + height;
      points[6] = x2;
      points[7] = y2 + height;
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count2 = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count2] = points[0];
      vertices[verticesOffset + count2 + 1] = points[1];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[2];
      vertices[verticesOffset + count2 + 1] = points[3];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[6];
      vertices[verticesOffset + count2 + 1] = points[7];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[4];
      vertices[verticesOffset + count2 + 1] = points[5];
      count2 += verticesStride;
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 3;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle = {
    extension: {
      type: ExtensionType.ShapeBuilder,
      name: "triangle"
    },
    build(shape, points) {
      points[0] = shape.x;
      points[1] = shape.y;
      points[2] = shape.x2;
      points[3] = shape.y2;
      points[4] = shape.x3;
      points[5] = shape.y3;
      return true;
    },
    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
      let count2 = 0;
      verticesOffset *= verticesStride;
      vertices[verticesOffset + count2] = points[0];
      vertices[verticesOffset + count2 + 1] = points[1];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[2];
      vertices[verticesOffset + count2 + 1] = points[3];
      count2 += verticesStride;
      vertices[verticesOffset + count2] = points[4];
      vertices[verticesOffset + count2 + 1] = points[5];
      const verticesIndex = verticesOffset / verticesStride;
      indices[indicesOffset++] = verticesIndex;
      indices[indicesOffset++] = verticesIndex + 1;
      indices[indicesOffset++] = verticesIndex + 2;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
  var emptyColorStops = [{offset: 0, color: "white"}, {offset: 1, color: "black"}];
  var _FillGradient = class _FillGradient2 {
    constructor(...args) {
      this.uid = uid("fillGradient");
      this._tick = 0;
      this.type = "linear";
      this.colorStops = [];
      let options = ensureGradientOptions(args);
      const defaults2 = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
      options = {...defaults2, ...definedProps(options)};
      this._textureSize = options.textureSize;
      this._wrapMode = options.wrapMode;
      if (options.type === "radial") {
        this.center = options.center;
        this.outerCenter = options.outerCenter ?? this.center;
        this.innerRadius = options.innerRadius;
        this.outerRadius = options.outerRadius;
        this.scale = options.scale;
        this.rotation = options.rotation;
      } else {
        this.start = options.start;
        this.end = options.end;
      }
      this.textureSpace = options.textureSpace;
      this.type = options.type;
      options.colorStops.forEach((stop) => {
        this.addColorStop(stop.offset, stop.color);
      });
    }
    addColorStop(offset, color) {
      this.colorStops.push({offset, color: Color.shared.setValue(color).toHexa()});
      return this;
    }
    buildLinearGradient() {
      if (this.texture)
        return;
      let {x: x0, y: y0} = this.start;
      let {x: x1, y: y1} = this.end;
      let dx2 = x1 - x0;
      let dy2 = y1 - y0;
      const flip = dx2 < 0 || dy2 < 0;
      if (this._wrapMode === "clamp-to-edge") {
        if (dx2 < 0) {
          const temp = x0;
          x0 = x1;
          x1 = temp;
          dx2 *= -1;
        }
        if (dy2 < 0) {
          const temp = y0;
          y0 = y1;
          y1 = temp;
          dy2 *= -1;
        }
      }
      const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
      const defaultSize = this._textureSize;
      const {canvas, context: context4} = getCanvas(defaultSize, 1);
      const gradient = !flip ? context4.createLinearGradient(0, 0, this._textureSize, 0) : context4.createLinearGradient(this._textureSize, 0, 0, 0);
      addColorStops(gradient, colorStops);
      context4.fillStyle = gradient;
      context4.fillRect(0, 0, defaultSize, 1);
      this.texture = new Texture({
        source: new ImageSource({
          resource: canvas,
          addressMode: this._wrapMode
        })
      });
      const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      const angle = Math.atan2(dy2, dx2);
      const m2 = new Matrix();
      m2.scale(dist / defaultSize, 1);
      m2.rotate(angle);
      m2.translate(x0, y0);
      if (this.textureSpace === "local") {
        m2.scale(defaultSize, defaultSize);
      }
      this.transform = m2;
    }
    buildGradient() {
      if (!this.texture)
        this._tick++;
      if (this.type === "linear") {
        this.buildLinearGradient();
      } else {
        this.buildRadialGradient();
      }
    }
    buildRadialGradient() {
      if (this.texture)
        return;
      const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
      const defaultSize = this._textureSize;
      const {canvas, context: context4} = getCanvas(defaultSize, defaultSize);
      const {x: x0, y: y0} = this.center;
      const {x: x1, y: y1} = this.outerCenter;
      const r0 = this.innerRadius;
      const r1 = this.outerRadius;
      const ox = x1 - r1;
      const oy = y1 - r1;
      const scale = defaultSize / (r1 * 2);
      const cx = (x0 - ox) * scale;
      const cy = (y0 - oy) * scale;
      const gradient = context4.createRadialGradient(cx, cy, r0 * scale, (x1 - ox) * scale, (y1 - oy) * scale, r1 * scale);
      addColorStops(gradient, colorStops);
      context4.fillStyle = colorStops[colorStops.length - 1].color;
      context4.fillRect(0, 0, defaultSize, defaultSize);
      context4.fillStyle = gradient;
      context4.translate(cx, cy);
      context4.rotate(this.rotation);
      context4.scale(1, this.scale);
      context4.translate(-cx, -cy);
      context4.fillRect(0, 0, defaultSize, defaultSize);
      this.texture = new Texture({
        source: new ImageSource({
          resource: canvas,
          addressMode: this._wrapMode
        })
      });
      const m2 = new Matrix();
      m2.scale(1 / scale, 1 / scale);
      m2.translate(ox, oy);
      if (this.textureSpace === "local") {
        m2.scale(defaultSize, defaultSize);
      }
      this.transform = m2;
    }
    destroy() {
      this.texture?.destroy(true);
      this.texture = null;
      this.transform = null;
      this.colorStops = [];
      this.start = null;
      this.end = null;
      this.center = null;
      this.outerCenter = null;
    }
    get styleKey() {
      return `fill-gradient-${this.uid}-${this._tick}`;
    }
  };
  _FillGradient.defaultLinearOptions = {
    start: {x: 0, y: 0},
    end: {x: 0, y: 1},
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
  };
  _FillGradient.defaultRadialOptions = {
    center: {x: 0.5, y: 0.5},
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
  };
  var FillGradient = _FillGradient;
  function addColorStops(gradient, colorStops) {
    for (let i2 = 0; i2 < colorStops.length; i2++) {
      const stop = colorStops[i2];
      gradient.addColorStop(stop.offset, stop.color);
    }
  }
  function getCanvas(width, height) {
    const canvas = DOMAdapter.get().createCanvas(width, height);
    const context4 = canvas.getContext("2d");
    return {canvas, context: context4};
  }
  function ensureGradientOptions(args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || args[1]) {
      deprecation("8.5.2", `use options object instead`);
      options = {
        type: "linear",
        start: {x: args[0], y: args[1]},
        end: {x: args[2], y: args[3]},
        textureSpace: args[4],
        textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
      };
    }
    return options;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs
  var tempTextureMatrix = new Matrix();
  var tempRect = new Rectangle();
  function generateTextureMatrix(out2, style, shape, matrix) {
    const textureMatrix = style.matrix ? out2.copyFrom(style.matrix).invert() : out2.identity();
    if (style.textureSpace === "local") {
      const bounds = shape.getBounds(tempRect);
      if (style.width) {
        bounds.pad(style.width);
      }
      const {x: tx, y: ty} = bounds;
      const sx = 1 / bounds.width;
      const sy = 1 / bounds.height;
      const mTx = -tx * sx;
      const mTy = -ty * sy;
      const a1 = textureMatrix.a;
      const b1 = textureMatrix.b;
      const c1 = textureMatrix.c;
      const d1 = textureMatrix.d;
      textureMatrix.a *= sx;
      textureMatrix.b *= sx;
      textureMatrix.c *= sy;
      textureMatrix.d *= sy;
      textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
      textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
    } else {
      textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
      textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
    }
    const sourceStyle = style.texture.source.style;
    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
      sourceStyle.addressMode = "repeat";
      sourceStyle.update();
    }
    if (matrix) {
      textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
    }
    return textureMatrix;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  var shapeBuilders = {};
  extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
  extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
  var tempRect2 = new Rectangle();
  var tempTextureMatrix2 = new Matrix();
  function buildContextBatches(context4, gpuContext) {
    const {geometryData, batches} = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i2 = 0; i2 < context4.instructions.length; i2++) {
      const instruction = context4.instructions[i2];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
        }
        if (hole) {
          shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
        }
        addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect2;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    if (!build.build(rect, points)) {
      return;
    }
    const {vertices, uvs, indices} = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const texture = data.image;
    const textureUvs = texture.uvs;
    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
    const {vertices, uvs, indices} = geometryData;
    shapePath.shapePrimitives.forEach(({shape, transform: matrix, holes}) => {
      const points = [];
      const build = shapeBuilders[shape.type];
      if (!build.build(shape, points)) {
        return;
      }
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      let topology = "triangle-list";
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (holes) {
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(holes);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = shape.closePath ?? true;
        const lineStyle = style;
        if (!lineStyle.pixelLine) {
          buildLine(points, lineStyle, false, close, vertices, indices);
        } else {
          buildPixelLine(points, close, vertices, indices);
          topology = "line-list";
        }
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = generateTextureMatrix(tempTextureMatrix2, style, shape, matrix);
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      graphicsBatch.topology = topology;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(holePrimitives) {
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      if (holeBuilder.build(holePrimitive, holePoints)) {
        holeArrays.push(holePoints);
      }
    }
    return holeArrays;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext = class {
    constructor() {
      this.batches = [];
      this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  };
  var GraphicsContextRenderData = class {
    constructor() {
      this.instructions = new InstructionSet();
    }
    init(maxTextures) {
      this.batcher = new DefaultBatcher({
        maxTextures
      });
      this.instructions.reset();
    }
    get geometry() {
      deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
      return this.batcher.geometry;
    }
    destroy() {
      this.batcher.destroy();
      this.instructions.destroy();
      this.batcher = null;
      this.instructions = null;
    }
  };
  var _GraphicsContextSystem = class _GraphicsContextSystem2 {
    constructor(renderer) {
      this._gpuContextHash = {};
      this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
      renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(options) {
      _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(context4) {
      return this._graphicsDataContextHash[context4.uid] || this._initContextRenderData(context4);
    }
    updateGpuContext(context4) {
      let gpuContext = this._gpuContextHash[context4.uid] || this._initContext(context4);
      if (context4.dirty) {
        if (gpuContext) {
          this._cleanGraphicsContextData(context4);
        } else {
          gpuContext = this._initContext(context4);
        }
        buildContextBatches(context4, gpuContext);
        const batchMode = context4.batchMode;
        if (context4.customShader || batchMode === "no-batch") {
          gpuContext.isBatchable = false;
        } else if (batchMode === "auto") {
          gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
        } else {
          gpuContext.isBatchable = true;
        }
        context4.dirty = false;
      }
      return gpuContext;
    }
    getGpuContext(context4) {
      return this._gpuContextHash[context4.uid] || this._initContext(context4);
    }
    _initContextRenderData(context4) {
      const graphicsData = BigPool.get(GraphicsContextRenderData, {
        maxTextures: this._renderer.limits.maxBatchableTextures
      });
      const {batches, geometryData} = this._gpuContextHash[context4.uid];
      const vertexSize = geometryData.vertices.length;
      const indexSize = geometryData.indices.length;
      for (let i2 = 0; i2 < batches.length; i2++) {
        batches[i2].applyTransform = false;
      }
      const batcher = graphicsData.batcher;
      batcher.ensureAttributeBuffer(vertexSize);
      batcher.ensureIndexBuffer(indexSize);
      batcher.begin();
      for (let i2 = 0; i2 < batches.length; i2++) {
        const batch = batches[i2];
        batcher.add(batch);
      }
      batcher.finish(graphicsData.instructions);
      const geometry = batcher.geometry;
      geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
      geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
      const drawBatches = batcher.batches;
      for (let i2 = 0; i2 < drawBatches.length; i2++) {
        const batch = drawBatches[i2];
        batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count, this._renderer.limits.maxBatchableTextures);
      }
      this._graphicsDataContextHash[context4.uid] = graphicsData;
      return graphicsData;
    }
    _initContext(context4) {
      const gpuContext = new GpuGraphicsContext();
      gpuContext.context = context4;
      this._gpuContextHash[context4.uid] = gpuContext;
      context4.on("destroy", this.onGraphicsContextDestroy, this);
      return this._gpuContextHash[context4.uid];
    }
    onGraphicsContextDestroy(context4) {
      this._cleanGraphicsContextData(context4);
      context4.off("destroy", this.onGraphicsContextDestroy, this);
      this._gpuContextHash[context4.uid] = null;
    }
    _cleanGraphicsContextData(context4) {
      const gpuContext = this._gpuContextHash[context4.uid];
      if (!gpuContext.isBatchable) {
        if (this._graphicsDataContextHash[context4.uid]) {
          BigPool.return(this.getContextRenderData(context4));
          this._graphicsDataContextHash[context4.uid] = null;
        }
      }
      if (gpuContext.batches) {
        gpuContext.batches.forEach((batch) => {
          BigPool.return(batch);
        });
      }
    }
    destroy() {
      for (const i2 in this._gpuContextHash) {
        if (this._gpuContextHash[i2]) {
          this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
        }
      }
    }
  };
  _GraphicsContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "graphicsContext"
  };
  _GraphicsContextSystem.defaultOptions = {
    bezierSmoothness: 0.5
  };
  var GraphicsContextSystem = _GraphicsContextSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
  "use strict";
  var blendModeIds = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8,
    min: 9,
    max: 10
  };
  var BLEND = 0;
  var OFFSET = 1;
  var CULLING = 2;
  var DEPTH_TEST = 3;
  var WINDING = 4;
  var DEPTH_MASK = 5;
  var _State = class _State2 {
    constructor() {
      this.data = 0;
      this.blendMode = "normal";
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    get blend() {
      return !!(this.data & 1 << BLEND);
    }
    set blend(value) {
      if (!!(this.data & 1 << BLEND) !== value) {
        this.data ^= 1 << BLEND;
      }
    }
    get offsets() {
      return !!(this.data & 1 << OFFSET);
    }
    set offsets(value) {
      if (!!(this.data & 1 << OFFSET) !== value) {
        this.data ^= 1 << OFFSET;
      }
    }
    set cullMode(value) {
      if (value === "none") {
        this.culling = false;
        return;
      }
      this.culling = true;
      this.clockwiseFrontFace = value === "front";
    }
    get cullMode() {
      if (!this.culling) {
        return "none";
      }
      return this.clockwiseFrontFace ? "front" : "back";
    }
    get culling() {
      return !!(this.data & 1 << CULLING);
    }
    set culling(value) {
      if (!!(this.data & 1 << CULLING) !== value) {
        this.data ^= 1 << CULLING;
      }
    }
    get depthTest() {
      return !!(this.data & 1 << DEPTH_TEST);
    }
    set depthTest(value) {
      if (!!(this.data & 1 << DEPTH_TEST) !== value) {
        this.data ^= 1 << DEPTH_TEST;
      }
    }
    get depthMask() {
      return !!(this.data & 1 << DEPTH_MASK);
    }
    set depthMask(value) {
      if (!!(this.data & 1 << DEPTH_MASK) !== value) {
        this.data ^= 1 << DEPTH_MASK;
      }
    }
    get clockwiseFrontFace() {
      return !!(this.data & 1 << WINDING);
    }
    set clockwiseFrontFace(value) {
      if (!!(this.data & 1 << WINDING) !== value) {
        this.data ^= 1 << WINDING;
      }
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(value) {
      this.blend = value !== "none";
      this._blendMode = value;
      this._blendModeId = blendModeIds[value] || 0;
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    }
    toString() {
      return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    static for2d() {
      const state = new _State2();
      state.depthTest = false;
      state.blend = true;
      return state;
    }
  };
  _State.default2d = _State.for2d();
  var State = _State;

  // node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
  "use strict";
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsGpuData = class {
    constructor() {
      this.batches = [];
      this.batched = false;
    }
    destroy() {
      this.batches.forEach((batch) => {
        BigPool.return(batch);
      });
      this.batches.length = 0;
    }
  };
  var GraphicsPipe = class {
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this.renderer = renderer;
      this._adaptor = adaptor;
      this.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._adaptor.contextChange(this.renderer);
    }
    validateRenderable(graphics) {
      const context4 = graphics.context;
      const wasBatched = !!graphics._gpuData;
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(context4);
      if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
        return true;
      }
      return false;
    }
    addRenderable(graphics, instructionSet) {
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      if (graphics.didViewUpdate) {
        this._rebuild(graphics);
      }
      if (gpuContext.isBatchable) {
        this._addToBatcher(graphics, instructionSet);
      } else {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(graphics);
      }
    }
    updateRenderable(graphics) {
      const gpuData = this._getGpuDataForRenderable(graphics);
      const batches = gpuData.batches;
      for (let i2 = 0; i2 < batches.length; i2++) {
        const batch = batches[i2];
        batch._batcher.updateElement(batch);
      }
    }
    execute(graphics) {
      if (!graphics.isRenderable)
        return;
      const renderer = this.renderer;
      const context4 = graphics.context;
      const contextSystem = renderer.graphicsContext;
      if (!contextSystem.getGpuContext(context4).batches.length) {
        return;
      }
      const shader = context4.customShader || this._adaptor.shader;
      this.state.blendMode = graphics.groupBlendMode;
      const localUniforms = shader.resources.localUniforms.uniforms;
      localUniforms.uTransformMatrix = graphics.groupTransform;
      localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
      color32BitToUniform(graphics.groupColorAlpha, localUniforms.uColor, 0);
      this._adaptor.execute(this, graphics);
    }
    _rebuild(graphics) {
      const gpuData = this._getGpuDataForRenderable(graphics);
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      gpuData.destroy();
      if (gpuContext.isBatchable) {
        this._updateBatchesForRenderable(graphics, gpuData);
      }
    }
    _addToBatcher(graphics, instructionSet) {
      const batchPipe = this.renderer.renderPipes.batch;
      const batches = this._getGpuDataForRenderable(graphics).batches;
      for (let i2 = 0; i2 < batches.length; i2++) {
        const batch = batches[i2];
        batchPipe.addToBatch(batch, instructionSet);
      }
    }
    _getGpuDataForRenderable(graphics) {
      return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
    }
    _initGpuDataForRenderable(graphics) {
      const gpuData = new GraphicsGpuData();
      graphics._gpuData[this.renderer.uid] = gpuData;
      return gpuData;
    }
    _updateBatchesForRenderable(graphics, gpuData) {
      const context4 = graphics.context;
      const gpuContext = this.renderer.graphicsContext.getGpuContext(context4);
      const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
      gpuData.batches = gpuContext.batches.map((batch) => {
        const batchClone = BigPool.get(BatchableGraphics);
        batch.copyTo(batchClone);
        batchClone.renderable = graphics;
        batchClone.roundPixels = roundPixels;
        return batchClone;
      });
    }
    destroy() {
      this.renderer = null;
      this._adaptor.destroy();
      this._adaptor = null;
      this.state = null;
    }
  };
  GraphicsPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "graphics"
  };

  // node_modules/pixi.js/lib/scene/graphics/init.mjs
  extensions.add(GraphicsPipe);
  extensions.add(GraphicsContextSystem);

  // node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
  "use strict";
  var BatchableMesh = class {
    constructor() {
      this.batcherName = "default";
      this.packAsQuad = false;
      this.indexOffset = 0;
      this.attributeOffset = 0;
      this.roundPixels = 0;
      this._batcher = null;
      this._batch = null;
      this._textureMatrixUpdateId = -1;
      this._uvUpdateId = -1;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get topology() {
      return this._topology || this.geometry.topology;
    }
    set topology(value) {
      this._topology = value;
    }
    reset() {
      this.renderable = null;
      this.texture = null;
      this._batcher = null;
      this._batch = null;
      this.geometry = null;
      this._uvUpdateId = -1;
      this._textureMatrixUpdateId = -1;
    }
    setTexture(value) {
      if (this.texture === value)
        return;
      this.texture = value;
      this._textureMatrixUpdateId = -1;
    }
    get uvs() {
      const geometry = this.geometry;
      const uvBuffer = geometry.getBuffer("aUV");
      const uvs = uvBuffer.data;
      let transformedUvs = uvs;
      const textureMatrix = this.texture.textureMatrix;
      if (!textureMatrix.isSimple) {
        transformedUvs = this._transformedUvs;
        if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
          if (!transformedUvs || transformedUvs.length < uvs.length) {
            transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
          }
          this._textureMatrixUpdateId = textureMatrix._updateID;
          this._uvUpdateId = uvBuffer._updateID;
          textureMatrix.multiplyUvs(uvs, transformedUvs);
        }
      }
      return transformedUvs;
    }
    get positions() {
      return this.geometry.positions;
    }
    get indices() {
      return this.geometry.indices;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    get groupTransform() {
      return this.renderable.groupTransform;
    }
    get attributeSize() {
      return this.geometry.positions.length / 2;
    }
    get indexSize() {
      return this.geometry.indices.length;
    }
  };

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshGpuData = class {
    destroy() {
    }
  };
  var MeshPipe = class {
    constructor(renderer, adaptor) {
      this.localUniforms = new UniformGroup({
        uTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uColor: {value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>"},
        uRound: {value: 0, type: "f32"}
      });
      this.localUniformsBindGroup = new BindGroup({
        0: this.localUniforms
      });
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init();
    }
    validateRenderable(mesh) {
      const meshData = this._getMeshData(mesh);
      const wasBatched = meshData.batched;
      const isBatched = mesh.batched;
      meshData.batched = isBatched;
      if (wasBatched !== isBatched) {
        return true;
      } else if (isBatched) {
        const geometry = mesh._geometry;
        if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
          meshData.indexSize = geometry.indices.length;
          meshData.vertexSize = geometry.positions.length;
          return true;
        }
        const batchableMesh = this._getBatchableMesh(mesh);
        if (batchableMesh.texture.uid !== mesh._texture.uid) {
          batchableMesh._textureMatrixUpdateId = -1;
        }
        return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, mesh._texture);
      }
      return false;
    }
    addRenderable(mesh, instructionSet) {
      const batcher = this.renderer.renderPipes.batch;
      const meshData = this._getMeshData(mesh);
      if (mesh.didViewUpdate) {
        meshData.indexSize = mesh._geometry.indices?.length;
        meshData.vertexSize = mesh._geometry.positions?.length;
      }
      if (meshData.batched) {
        const gpuBatchableMesh = this._getBatchableMesh(mesh);
        gpuBatchableMesh.setTexture(mesh._texture);
        gpuBatchableMesh.geometry = mesh._geometry;
        batcher.addToBatch(gpuBatchableMesh, instructionSet);
      } else {
        batcher.break(instructionSet);
        instructionSet.add(mesh);
      }
    }
    updateRenderable(mesh) {
      if (mesh.batched) {
        const gpuBatchableMesh = this._getBatchableMesh(mesh);
        gpuBatchableMesh.setTexture(mesh._texture);
        gpuBatchableMesh.geometry = mesh._geometry;
        gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
      }
    }
    execute(mesh) {
      if (!mesh.isRenderable)
        return;
      mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
      const localUniforms = this.localUniforms;
      localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
      localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
      localUniforms.update();
      color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);
      this._adaptor.execute(this, mesh);
    }
    _getMeshData(mesh) {
      var _a, _b;
      (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
      return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
    }
    _initMeshData(mesh) {
      mesh._gpuData[this.renderer.uid].meshData = {
        batched: mesh.batched,
        indexSize: 0,
        vertexSize: 0
      };
      return mesh._gpuData[this.renderer.uid].meshData;
    }
    _getBatchableMesh(mesh) {
      var _a, _b;
      (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
      return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
    }
    _initBatchableMesh(mesh) {
      const gpuMesh = new BatchableMesh();
      gpuMesh.renderable = mesh;
      gpuMesh.setTexture(mesh._texture);
      gpuMesh.transform = mesh.groupTransform;
      gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
      mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
      return gpuMesh;
    }
    destroy() {
      this.localUniforms = null;
      this.localUniformsBindGroup = null;
      this._adaptor.destroy();
      this._adaptor = null;
      this.renderer = null;
    }
  };
  MeshPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "mesh"
  };

  // node_modules/pixi.js/lib/scene/mesh/init.mjs
  extensions.add(MeshPipe);

  // node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
  "use strict";
  var GlParticleContainerAdaptor = class {
    execute(particleContainerPipe, container) {
      const state = particleContainerPipe.state;
      const renderer = particleContainerPipe.renderer;
      const shader = container.shader || particleContainerPipe.defaultShader;
      shader.resources.uTexture = container.texture._source;
      shader.resources.uniforms = particleContainerPipe.localUniforms;
      const gl = renderer.gl;
      const buffer = particleContainerPipe.getBuffers(container);
      renderer.shader.bind(shader);
      renderer.state.set(state);
      renderer.geometry.bind(buffer.geometry, shader.glProgram);
      const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
    }
  };

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
  "use strict";
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (totalIndices > 65535) {
      outBuffer || (outBuffer = new Uint32Array(totalIndices));
    } else {
      outBuffer || (outBuffer = new Uint16Array(totalIndices));
    }
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
      outBuffer[i2 + 0] = j2 + 0;
      outBuffer[i2 + 1] = j2 + 1;
      outBuffer[i2 + 2] = j2 + 2;
      outBuffer[i2 + 3] = j2 + 0;
      outBuffer[i2 + 4] = j2 + 2;
      outBuffer[i2 + 5] = j2 + 3;
    }
    return outBuffer;
  }

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
  function generateParticleUpdateFunction(properties) {
    return {
      dynamicUpdate: generateUpdateFunction(properties, true),
      staticUpdate: generateUpdateFunction(properties, false)
    };
  }
  function generateUpdateFunction(properties, dynamic) {
    const funcFragments = [];
    funcFragments.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let offset = 0;
    for (const i2 in properties) {
      const property = properties[i2];
      if (dynamic !== property.dynamic)
        continue;
      funcFragments.push(`offset = index + ${offset}`);
      funcFragments.push(property.code);
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      offset += attributeInfo.stride / 4;
    }
    funcFragments.push(`
            index += stride * 4;
        }
    `);
    funcFragments.unshift(`
        var stride = ${offset};
    `);
    const functionSource = funcFragments.join("\n");
    return new Function("ps", "f32v", "u32v", functionSource);
  }

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
  var ParticleBuffer = class {
    constructor(options) {
      this._size = 0;
      this._generateParticleUpdateCache = {};
      const size = this._size = options.size ?? 1e3;
      const properties = options.properties;
      let staticVertexSize = 0;
      let dynamicVertexSize = 0;
      for (const i2 in properties) {
        const property = properties[i2];
        const attributeInfo = getAttributeInfoFromFormat(property.format);
        if (property.dynamic) {
          dynamicVertexSize += attributeInfo.stride;
        } else {
          staticVertexSize += attributeInfo.stride;
        }
      }
      this._dynamicStride = dynamicVertexSize / 4;
      this._staticStride = staticVertexSize / 4;
      this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
      this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
      this.indexBuffer = createIndicesForQuads(size);
      const geometry = new Geometry();
      let dynamicOffset = 0;
      let staticOffset = 0;
      this._staticBuffer = new Buffer2({
        data: new Float32Array(1),
        label: "static-particle-buffer",
        shrinkToFit: false,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      this._dynamicBuffer = new Buffer2({
        data: new Float32Array(1),
        label: "dynamic-particle-buffer",
        shrinkToFit: false,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      for (const i2 in properties) {
        const property = properties[i2];
        const attributeInfo = getAttributeInfoFromFormat(property.format);
        if (property.dynamic) {
          geometry.addAttribute(property.attributeName, {
            buffer: this._dynamicBuffer,
            stride: this._dynamicStride * 4,
            offset: dynamicOffset * 4,
            format: property.format
          });
          dynamicOffset += attributeInfo.size;
        } else {
          geometry.addAttribute(property.attributeName, {
            buffer: this._staticBuffer,
            stride: this._staticStride * 4,
            offset: staticOffset * 4,
            format: property.format
          });
          staticOffset += attributeInfo.size;
        }
      }
      geometry.addIndex(this.indexBuffer);
      const uploadFunction = this.getParticleUpdate(properties);
      this._dynamicUpload = uploadFunction.dynamicUpdate;
      this._staticUpload = uploadFunction.staticUpdate;
      this.geometry = geometry;
    }
    getParticleUpdate(properties) {
      const key = getParticleSyncKey(properties);
      if (this._generateParticleUpdateCache[key]) {
        return this._generateParticleUpdateCache[key];
      }
      this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
      return this._generateParticleUpdateCache[key];
    }
    generateParticleUpdate(properties) {
      return generateParticleUpdateFunction(properties);
    }
    update(particles, uploadStatic) {
      if (particles.length > this._size) {
        uploadStatic = true;
        this._size = Math.max(particles.length, this._size * 1.5 | 0);
        this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
        this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
        this.indexBuffer = createIndicesForQuads(this._size);
        this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true);
      }
      const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
      this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
      this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);
      if (uploadStatic) {
        const staticAttributeBuffer = this.staticAttributeBuffer;
        this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
        this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);
      }
    }
    destroy() {
      this._staticBuffer.destroy();
      this._dynamicBuffer.destroy();
      this.geometry.destroy();
    }
  };
  function getParticleSyncKey(properties) {
    const keyGen = [];
    for (const key in properties) {
      const property = properties[key];
      keyGen.push(key, property.code, property.dynamic ? "d" : "s");
    }
    return keyGen.join("_");
  }

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
  var fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
  var vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
  var wgsl = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
  var ParticleShader = class extends Shader {
    constructor() {
      const glProgram3 = GlProgram.from({
        vertex,
        fragment
      });
      const gpuProgram3 = GpuProgram.from({
        fragment: {
          source: wgsl,
          entryPoint: "mainFragment"
        },
        vertex: {
          source: wgsl,
          entryPoint: "mainVertex"
        }
      });
      super({
        glProgram: glProgram3,
        gpuProgram: gpuProgram3,
        resources: {
          uTexture: Texture.WHITE.source,
          uSampler: new TextureStyle({}),
          uniforms: {
            uTranslationMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
            uColor: {value: new Color(16777215), type: "vec4<f32>"},
            uRound: {value: 1, type: "f32"},
            uResolution: {value: [0, 0], type: "vec2<f32>"}
          }
        }
      });
    }
  };

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
  var ParticleContainerPipe = class {
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this.localUniforms = new UniformGroup({
        uTranslationMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uColor: {value: new Float32Array(4), type: "vec4<f32>"},
        uRound: {value: 1, type: "f32"},
        uResolution: {value: [0, 0], type: "vec2<f32>"}
      });
      this.renderer = renderer;
      this.adaptor = adaptor;
      this.defaultShader = new ParticleShader();
      this.state = State.for2d();
    }
    validateRenderable(_renderable) {
      return false;
    }
    addRenderable(renderable, instructionSet) {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(renderable);
    }
    getBuffers(renderable) {
      return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);
    }
    _initBuffer(renderable) {
      renderable._gpuData[this.renderer.uid] = new ParticleBuffer({
        size: renderable.particleChildren.length,
        properties: renderable._properties
      });
      return renderable._gpuData[this.renderer.uid];
    }
    updateRenderable(_renderable) {
    }
    execute(container) {
      const children = container.particleChildren;
      if (children.length === 0) {
        return;
      }
      const renderer = this.renderer;
      const buffer = this.getBuffers(container);
      container.texture || (container.texture = children[0].texture);
      const state = this.state;
      buffer.update(children, container._childrenDirty);
      container._childrenDirty = false;
      state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
      const uniforms = this.localUniforms.uniforms;
      const transformationMatrix = uniforms.uTranslationMatrix;
      container.worldTransform.copyTo(transformationMatrix);
      transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
      uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
      uniforms.uRound = renderer._roundPixels | container._roundPixels;
      color32BitToUniform(container.groupColorAlpha, uniforms.uColor, 0);
      this.adaptor.execute(this, container);
    }
    destroy() {
      this.renderer = null;
      if (this.defaultShader) {
        this.defaultShader.destroy();
        this.defaultShader = null;
      }
    }
  };

  // node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
  var GlParticleContainerPipe = class extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GlParticleContainerAdaptor());
    }
  };
  GlParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGLPipes
    ],
    name: "particle"
  };

  // node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
  "use strict";
  var GpuParticleContainerAdaptor = class {
    execute(particleContainerPipe, container) {
      const renderer = particleContainerPipe.renderer;
      const shader = container.shader || particleContainerPipe.defaultShader;
      shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
      shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
      const state = particleContainerPipe.state;
      const buffer = particleContainerPipe.getBuffers(container);
      renderer.encoder.draw({
        geometry: buffer.geometry,
        shader: container.shader || particleContainerPipe.defaultShader,
        state,
        size: container.particleChildren.length * 6
      });
    }
  };

  // node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
  var GpuParticleContainerPipe = class extends ParticleContainerPipe {
    constructor(renderer) {
      super(renderer, new GpuParticleContainerAdaptor());
    }
  };
  GpuParticleContainerPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "particle"
  };

  // node_modules/pixi.js/lib/scene/particle-container/init.mjs
  extensions.add(GlParticleContainerPipe);
  extensions.add(GpuParticleContainerPipe);

  // node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs
  function updateTextBounds(batchableSprite, text) {
    const {texture, bounds} = batchableSprite;
    const padding = text._style._getFinalPadding();
    updateQuadBounds(bounds, text._anchor, texture);
    const paddingOffset = text._anchor._x * padding * 2;
    const paddingOffsetY = text._anchor._y * padding * 2;
    bounds.minX -= padding - paddingOffset;
    bounds.minY -= padding - paddingOffsetY;
    bounds.maxX -= padding - paddingOffset;
    bounds.maxY -= padding - paddingOffsetY;
  }

  // node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
  "use strict";
  var BatchableSprite = class {
    constructor() {
      this.batcherName = "default";
      this.topology = "triangle-list";
      this.attributeSize = 4;
      this.indexSize = 6;
      this.packAsQuad = true;
      this.roundPixels = 0;
      this._attributeStart = 0;
      this._batcher = null;
      this._batch = null;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    reset() {
      this.renderable = null;
      this.texture = null;
      this._batcher = null;
      this._batch = null;
      this.bounds = null;
    }
    destroy() {
    }
  };

  // node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs
  var BatchableText = class extends BatchableSprite {
    constructor(renderer) {
      super();
      this._renderer = renderer;
      renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const text = this.renderable;
      if (text._autoResolution) {
        text.onViewUpdate();
      }
    }
    destroy() {
      const {canvasText} = this._renderer;
      const refCount = canvasText.getReferenceCount(this.currentKey);
      if (refCount > 0) {
        canvasText.decreaseReferenceCount(this.currentKey);
      } else if (this.texture) {
        canvasText.returnTexture(this.texture);
      }
      this._renderer.runners.resolutionChange.remove(this);
      this._renderer = null;
    }
  };

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    validateRenderable(text) {
      const gpuText = this._getGpuText(text);
      const newKey = text.styleKey;
      if (gpuText.currentKey !== newKey)
        return true;
      return text._didTextUpdate;
    }
    addRenderable(text, instructionSet) {
      const batchableText = this._getGpuText(text);
      if (text._didTextUpdate) {
        const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {
          this._updateGpuText(text);
        }
        text._didTextUpdate = false;
      }
      this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);
    }
    updateRenderable(text) {
      const batchableText = this._getGpuText(text);
      batchableText._batcher.updateElement(batchableText);
    }
    _updateGpuText(text) {
      const batchableText = this._getGpuText(text);
      if (batchableText.texture) {
        this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);
      }
      text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
      batchableText.texture = this._renderer.canvasText.getManagedTexture(text);
      batchableText.currentKey = text.styleKey;
      updateTextBounds(batchableText, text);
    }
    _getGpuText(text) {
      return text._gpuData[this._renderer.uid] || this.initGpuText(text);
    }
    initGpuText(text) {
      const batchableText = new BatchableText(this._renderer);
      batchableText.currentKey = "--";
      batchableText.renderable = text;
      batchableText.transform = text.groupTransform;
      batchableText.bounds = {minX: 0, maxX: 1, minY: 0, maxY: 0};
      batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;
      text._gpuData[this._renderer.uid] = batchableText;
      return batchableText;
    }
    destroy() {
      this._renderer = null;
    }
  };
  CanvasTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "text"
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  var FillPattern = class {
    constructor(texture, repetition) {
      this.uid = uid("fillPattern");
      this._tick = 0;
      this.transform = new Matrix();
      this.texture = texture;
      this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
      if (repetition) {
        texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
        texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
      }
    }
    setTransform(transform) {
      const texture = this.texture;
      this.transform.copyFrom(transform);
      this.transform.invert();
      this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);
      this._tick++;
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      if (this._texture === value)
        return;
      this._texture = value;
      this._tick++;
    }
    get styleKey() {
      return `fill-pattern-${this.uid}-${this._tick}`;
    }
    destroy() {
      this.texture.destroy(true);
      this.texture = null;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs
  var import_parse_svg_path = __toModule(require_parse_svg_path());
  function parseSVGPath(svgPath, path2) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i2 = 0; i2 < commands.length; i2++) {
      const command = commands[i2];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path2.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);
          break;
        case "c":
          path2.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path2.bezierCurveToShort(data[1], data[2], lastX, lastY);
          break;
        case "s":
          path2.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path2.quadraticCurveTo(data[1], data[2], lastX, lastY);
          break;
        case "q":
          path2.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path2.quadraticCurveToShort(lastX, lastY);
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path2.quadraticCurveToShort(lastX, lastY);
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path2.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path2.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);
          break;
        case "Z":
        case "z":
          path2.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = {startX: lastX, startY: lastY};
          subpaths.push(currentSubPath);
        }
      }
    }
    return path2;
  }

  // node_modules/pixi.js/lib/maths/shapes/Circle.mjs
  var Circle = class {
    constructor(x2 = 0, y2 = 0, radius2 = 0) {
      this.type = "circle";
      this.x = x2;
      this.y = y2;
      this.radius = radius2;
    }
    clone() {
      return new Circle(this.x, this.y, this.radius);
    }
    contains(x2, y2) {
      if (this.radius <= 0)
        return false;
      const r2 = this.radius * this.radius;
      let dx2 = this.x - x2;
      let dy2 = this.y - y2;
      dx2 *= dx2;
      dy2 *= dy2;
      return dx2 + dy2 <= r2;
    }
    strokeContains(x2, y2, width, alignment = 0.5) {
      if (this.radius === 0)
        return false;
      const dx2 = this.x - x2;
      const dy2 = this.y - y2;
      const radius2 = this.radius;
      const outerWidth = (1 - alignment) * width;
      const distance = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      return distance <= radius2 + outerWidth && distance > radius2 - (width - outerWidth);
    }
    getBounds(out2) {
      out2 || (out2 = new Rectangle());
      out2.x = this.x - this.radius;
      out2.y = this.y - this.radius;
      out2.width = this.radius * 2;
      out2.height = this.radius * 2;
      return out2;
    }
    copyFrom(circle) {
      this.x = circle.x;
      this.y = circle.y;
      this.radius = circle.radius;
      return this;
    }
    copyTo(circle) {
      circle.copyFrom(this);
      return circle;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  };

  // node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
  var Ellipse = class {
    constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
      this.type = "ellipse";
      this.x = x2;
      this.y = y2;
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
    }
    clone() {
      return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(x2, y2) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) {
        return false;
      }
      let normx = (x2 - this.x) / this.halfWidth;
      let normy = (y2 - this.y) / this.halfHeight;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    }
    strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
      const {halfWidth, halfHeight} = this;
      if (halfWidth <= 0 || halfHeight <= 0) {
        return false;
      }
      const strokeOuterWidth = strokeWidth * (1 - alignment);
      const strokeInnerWidth = strokeWidth - strokeOuterWidth;
      const innerHorizontal = halfWidth - strokeInnerWidth;
      const innerVertical = halfHeight - strokeInnerWidth;
      const outerHorizontal = halfWidth + strokeOuterWidth;
      const outerVertical = halfHeight + strokeOuterWidth;
      const normalizedX = x2 - this.x;
      const normalizedY = y2 - this.y;
      const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
      const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
      return innerEllipse > 1 && outerEllipse <= 1;
    }
    getBounds(out2) {
      out2 || (out2 = new Rectangle());
      out2.x = this.x - this.halfWidth;
      out2.y = this.y - this.halfHeight;
      out2.width = this.halfWidth * 2;
      out2.height = this.halfHeight * 2;
      return out2;
    }
    copyFrom(ellipse) {
      this.x = ellipse.x;
      this.y = ellipse.y;
      this.halfWidth = ellipse.halfWidth;
      this.halfHeight = ellipse.halfHeight;
      return this;
    }
    copyTo(ellipse) {
      ellipse.copyFrom(this);
      return ellipse;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  };

  // node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
  "use strict";
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx2 = x2 - xx;
    const dy2 = y2 - yy;
    return dx2 * dx2 + dy2 * dy2;
  }

  // node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
  var tempRect3;
  var tempRect22;
  var Polygon = class {
    constructor(...points) {
      this.type = "polygon";
      let flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        const p2 = [];
        for (let i2 = 0, il = flat.length; i2 < il; i2++) {
          p2.push(flat[i2].x, flat[i2].y);
        }
        flat = p2;
      }
      this.points = flat;
      this.closePath = true;
    }
    isClockwise() {
      let area2 = 0;
      const points = this.points;
      const length = points.length;
      for (let i2 = 0; i2 < length; i2 += 2) {
        const x1 = points[i2];
        const y1 = points[i2 + 1];
        const x2 = points[(i2 + 2) % length];
        const y2 = points[(i2 + 3) % length];
        area2 += (x2 - x1) * (y2 + y1);
      }
      return area2 < 0;
    }
    containsPolygon(polygon) {
      const thisBounds = this.getBounds(tempRect3);
      const otherBounds = polygon.getBounds(tempRect22);
      if (!thisBounds.containsRect(otherBounds)) {
        return false;
      }
      const points = polygon.points;
      for (let i2 = 0; i2 < points.length; i2 += 2) {
        const x2 = points[i2];
        const y2 = points[i2 + 1];
        if (!this.contains(x2, y2)) {
          return false;
        }
      }
      return true;
    }
    clone() {
      const points = this.points.slice();
      const polygon = new Polygon(points);
      polygon.closePath = this.closePath;
      return polygon;
    }
    contains(x2, y2) {
      let inside = false;
      const length = this.points.length / 2;
      for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
        const xi = this.points[i2 * 2];
        const yi = this.points[i2 * 2 + 1];
        const xj = this.points[j2 * 2];
        const yj = this.points[j2 * 2 + 1];
        const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    }
    strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
      const strokeWidthSquared = strokeWidth * strokeWidth;
      const rightWidthSquared = strokeWidthSquared * (1 - alignment);
      const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
      const {points} = this;
      const iterationLength = points.length - (this.closePath ? 0 : 2);
      for (let i2 = 0; i2 < iterationLength; i2 += 2) {
        const x1 = points[i2];
        const y1 = points[i2 + 1];
        const x22 = points[(i2 + 2) % points.length];
        const y22 = points[(i2 + 3) % points.length];
        const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
        const sign2 = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
        if (distanceSquared <= (sign2 < 0 ? leftWidthSquared : rightWidthSquared)) {
          return true;
        }
      }
      return false;
    }
    getBounds(out2) {
      out2 || (out2 = new Rectangle());
      const points = this.points;
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
        const x2 = points[i2];
        const y2 = points[i2 + 1];
        minX = x2 < minX ? x2 : minX;
        maxX = x2 > maxX ? x2 : maxX;
        minY = y2 < minY ? y2 : minY;
        maxY = y2 > maxY ? y2 : maxY;
      }
      out2.x = minX;
      out2.width = maxX - minX;
      out2.y = minY;
      out2.height = maxY - minY;
      return out2;
    }
    copyFrom(polygon) {
      this.points = polygon.points.slice();
      this.closePath = polygon.closePath;
      return this;
    }
    copyTo(polygon) {
      polygon.copyFrom(this);
      return polygon;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
      return this.points[this.points.length - 2];
    }
    get y() {
      deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
      return this.points[this.points.length - 1];
    }
    get startX() {
      return this.points[0];
    }
    get startY() {
      return this.points[1];
    }
  };

  // node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius2, strokeWidthInner, strokeWidthOuter) => {
    const dx2 = pX - cornerX;
    const dy2 = pY - cornerY;
    const distance = Math.sqrt(dx2 * dx2 + dy2 * dy2);
    return distance >= radius2 - strokeWidthInner && distance <= radius2 + strokeWidthOuter;
  };
  var RoundedRectangle = class {
    constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius2 = 20) {
      this.type = "roundedRectangle";
      this.x = x2;
      this.y = y2;
      this.width = width;
      this.height = height;
      this.radius = radius2;
    }
    getBounds(out2) {
      out2 || (out2 = new Rectangle());
      out2.x = this.x;
      out2.y = this.y;
      out2.width = this.width;
      out2.height = this.height;
      return out2;
    }
    clone() {
      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    contains(x2, y2) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x2 >= this.x && x2 <= this.x + this.width) {
        if (y2 >= this.y && y2 <= this.y + this.height) {
          const radius2 = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y2 >= this.y + radius2 && y2 <= this.y + this.height - radius2 || x2 >= this.x + radius2 && x2 <= this.x + this.width - radius2) {
            return true;
          }
          let dx2 = x2 - (this.x + radius2);
          let dy2 = y2 - (this.y + radius2);
          const radius22 = radius2 * radius2;
          if (dx2 * dx2 + dy2 * dy2 <= radius22) {
            return true;
          }
          dx2 = x2 - (this.x + this.width - radius2);
          if (dx2 * dx2 + dy2 * dy2 <= radius22) {
            return true;
          }
          dy2 = y2 - (this.y + this.height - radius2);
          if (dx2 * dx2 + dy2 * dy2 <= radius22) {
            return true;
          }
          dx2 = x2 - (this.x + radius2);
          if (dx2 * dx2 + dy2 * dy2 <= radius22) {
            return true;
          }
        }
      }
      return false;
    }
    strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
      const {x: x2, y: y2, width, height, radius: radius2} = this;
      const strokeWidthOuter = strokeWidth * (1 - alignment);
      const strokeWidthInner = strokeWidth - strokeWidthOuter;
      const innerX = x2 + radius2;
      const innerY = y2 + radius2;
      const innerWidth = width - radius2 * 2;
      const innerHeight = height - radius2 * 2;
      const rightBound = x2 + width;
      const bottomBound = y2 + height;
      if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
        return true;
      }
      if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
        return true;
      }
      return pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius2, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius2 && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius2, innerY, radius2, strokeWidthInner, strokeWidthOuter) || pX > rightBound - radius2 && pY > bottomBound - radius2 && isCornerWithinStroke(pX, pY, rightBound - radius2, bottomBound - radius2, radius2, strokeWidthInner, strokeWidthOuter) || pX < innerX && pY > bottomBound - radius2 && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius2, radius2, strokeWidthInner, strokeWidthOuter);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  var RECURSION_LIMIT = 8;
  var FLT_EPSILON = 11920929e-14;
  var PATH_DISTANCE_EPSILON = 1;
  var curveAngleToleranceEpsilon = 0.01;
  var mAngleTolerance = 0;
  var mCuspLimit = 0;
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(0.99, Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx2 = x4 - x1;
      let dy2 = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy2 - (y2 - y4) * dx2);
      const d3 = Math.abs((x3 - x4) * dy2 - (y3 - y4) * dx2);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx2 * dx2 + dy2 * dy2)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx2 * dx2 + dy2 * dy2)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx2 * dx2 + dy2 * dy2)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx2 = x1234 - (x1 + x4) / 2;
        dy2 = y1234 - (y1 + y4) / 2;
        if (dx2 * dx2 + dy2 * dy2 <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  var RECURSION_LIMIT2 = 8;
  var FLT_EPSILON2 = 11920929e-14;
  var PATH_DISTANCE_EPSILON2 = 1;
  var curveAngleToleranceEpsilon2 = 0.01;
  var mAngleTolerance2 = 0;
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(0.99, Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness));
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx2 = x3 - x1;
    let dy2 = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy2 - (y2 - y3) * dx2);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx2 * dx2 + dy2 * dy2)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx2 = x123 - (x1 + x3) / 2;
      dy2 = y123 - (y1 + y3) / 2;
      if (dx2 * dx2 + dy2 * dy2 <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  "use strict";
  function buildArc(points, x2, y2, radius2, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius2, 1 / 3) * (dist / Math.PI))));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i2 = 0; i2 < steps + 1; i2++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius2;
      const ny = y2 + sn * radius2;
      points.push(nx, ny);
      t2 += f2;
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius2) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius2 === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius2 * Math.sqrt(dd) / mm;
    const k2 = radius2 * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(points, cx + x1, cy + y1, radius2, startAngle, endAngle, b1 * a2 > b2 * a1);
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  var TAU = Math.PI * 2;
  var out = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  };
  var mapToEllipse = ({x: x2, y: y2}, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
    x2 *= rx;
    y2 *= ry;
    const xp = cosPhi * x2 - sinPhi * y2;
    const yp = sinPhi * x2 + cosPhi * y2;
    out2.x = xp + centerX;
    out2.y = yp + centerY;
    return out2;
  };
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  var vectorAngle = (ux2, uy2, vx2, vy2) => {
    const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
    let dot = ux2 * vx2 + uy2 * vy2;
    if (dot > 1) {
      dot = 1;
    }
    if (dot < -1) {
      dot = -1;
    }
    return sign2 * Math.acos(dot);
  };
  var getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
    const rxSq = Math.pow(rx, 2);
    const rySq = Math.pow(ry, 2);
    const pxpSq = Math.pow(pxp, 2);
    const pypSq = Math.pow(pyp, 2);
    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rxSq * pypSq + rySq * pxpSq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    const centerXp = radicant * rx / ry * pyp;
    const centerYp = radicant * -ry / rx * pxp;
    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
    const vx1 = (pxp - centerXp) / rx;
    const vy1 = (pyp - centerYp) / ry;
    const vx2 = (-pxp - centerXp) / rx;
    const vy2 = (-pyp - centerYp) / ry;
    const ang1 = vectorAngle(1, 0, vx1, vy1);
    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }
    out2.centerX = centerX;
    out2.centerY = centerY;
    out2.ang1 = ang1;
    out2.ang2 = ang2;
  };
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out);
    let {ang1, ang2} = out;
    const {centerX, centerY} = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = {x: 0, y: 0};
    for (let i2 = 0; i2 < segments; i2++) {
      const curve = approxUnitArc(ang1, ang2);
      const {x: x1, y: y1} = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const {x: x2, y: y2} = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const {x: x3, y: y3} = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(points, lastX, lastY, x1, y1, x2, y2, x3, y3);
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
  "use strict";
  function roundedShapeArc(g2, points, radius2) {
    const vecFrom = (p2, pp) => {
      const x2 = pp.x - p2.x;
      const y2 = pp.y - p2.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return {len, nx, ny};
    };
    const sharpCorner = (i2, p2) => {
      if (i2 === 0) {
        g2.moveTo(p2.x, p2.y);
      } else {
        g2.lineTo(p2.x, p2.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i2 = 0; i2 < points.length; i2++) {
      const p2 = points[i2 % points.length];
      const pRadius = p2.radius ?? radius2;
      if (pRadius <= 0) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      const p3 = points[(i2 + 1) % points.length];
      const v1 = vecFrom(p2, p1);
      const v2 = vecFrom(p2, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i2 === 0) {
        g2.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p2;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius2, smoothness) {
    const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    const pointLerp = (p1, p2, t2) => ({
      x: p1.x + (p2.x - p1.x) * t2,
      y: p1.y + (p2.y - p1.y) * t2
    });
    const numPoints = points.length;
    for (let i2 = 0; i2 < numPoints; i2++) {
      const thisPoint = points[(i2 + 1) % numPoints];
      const pRadius = thisPoint.radius ?? radius2;
      if (pRadius <= 0) {
        if (i2 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i2];
      const nextPoint = points[(i2 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);
      }
      if (i2 === 0) {
        g2.moveTo(start.x, start.y);
      } else {
        g2.lineTo(start.x, start.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle = new Rectangle();
  var ShapePath = class {
    constructor(graphicsPath2D) {
      this.shapePrimitives = [];
      this._currentPoly = null;
      this._bounds = new Bounds();
      this._graphicsPath2D = graphicsPath2D;
      this.signed = graphicsPath2D.checkForHoles;
    }
    moveTo(x2, y2) {
      this.startPoly(x2, y2);
      return this;
    }
    lineTo(x2, y2) {
      this._ensurePoly();
      const points = this._currentPoly.points;
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      if (fromX !== x2 || fromY !== y2) {
        points.push(x2, y2);
      }
      return this;
    }
    arc(x2, y2, radius2, startAngle, endAngle, counterclockwise) {
      this._ensurePoly(false);
      const points = this._currentPoly.points;
      buildArc(points, x2, y2, radius2, startAngle, endAngle, counterclockwise);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius2) {
      this._ensurePoly();
      const points = this._currentPoly.points;
      buildArcTo(points, x1, y1, x2, y2, radius2);
      return this;
    }
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
      const points = this._currentPoly.points;
      buildArcToSvg(points, this._currentPoly.lastX, this._currentPoly.lastY, x2, y2, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
      return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveBezier(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness);
      return this;
    }
    quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveQuadratic(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x2, y2, smoothing);
      return this;
    }
    closePath() {
      this.endPoly(true);
      return this;
    }
    addPath(path2, transform) {
      this.endPoly();
      if (transform && !transform.isIdentity()) {
        path2 = path2.clone(true);
        path2.transform(transform);
      }
      const shapePrimitives = this.shapePrimitives;
      const start = shapePrimitives.length;
      for (let i2 = 0; i2 < path2.instructions.length; i2++) {
        const instruction = path2.instructions[i2];
        this[instruction.action](...instruction.data);
      }
      if (path2.checkForHoles && shapePrimitives.length - start > 1) {
        let mainShape = null;
        for (let i2 = start; i2 < shapePrimitives.length; i2++) {
          const shapePrimitive = shapePrimitives[i2];
          if (shapePrimitive.shape.type === "polygon") {
            const polygon = shapePrimitive.shape;
            const mainPolygon = mainShape?.shape;
            if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
              mainShape.holes || (mainShape.holes = []);
              mainShape.holes.push(shapePrimitive);
              shapePrimitives.copyWithin(i2, i2 + 1);
              shapePrimitives.length--;
              i2--;
            } else {
              mainShape = shapePrimitive;
            }
          }
        }
      }
      return this;
    }
    finish(closePath = false) {
      this.endPoly(closePath);
    }
    rect(x2, y2, w2, h2, transform) {
      this.drawShape(new Rectangle(x2, y2, w2, h2), transform);
      return this;
    }
    circle(x2, y2, radius2, transform) {
      this.drawShape(new Circle(x2, y2, radius2), transform);
      return this;
    }
    poly(points, close, transform) {
      const polygon = new Polygon(points);
      polygon.closePath = close;
      this.drawShape(polygon, transform);
      return this;
    }
    regularPoly(x2, y2, radius2, sides, rotation = 0, transform) {
      sides = Math.max(sides | 0, 3);
      const startAngle = -1 * Math.PI / 2 + rotation;
      const delta = Math.PI * 2 / sides;
      const polygon = [];
      for (let i2 = 0; i2 < sides; i2++) {
        const angle = startAngle - i2 * delta;
        polygon.push(x2 + radius2 * Math.cos(angle), y2 + radius2 * Math.sin(angle));
      }
      this.poly(polygon, true, transform);
      return this;
    }
    roundPoly(x2, y2, radius2, sides, corner, rotation = 0, smoothness) {
      sides = Math.max(sides | 0, 3);
      if (corner <= 0) {
        return this.regularPoly(x2, y2, radius2, sides, rotation);
      }
      const sideLength = radius2 * Math.sin(Math.PI / sides) - 1e-3;
      corner = Math.min(corner, sideLength);
      const startAngle = -1 * Math.PI / 2 + rotation;
      const delta = Math.PI * 2 / sides;
      const internalAngle = (sides - 2) * Math.PI / sides / 2;
      for (let i2 = 0; i2 < sides; i2++) {
        const angle = i2 * delta + startAngle;
        const x0 = x2 + radius2 * Math.cos(angle);
        const y0 = y2 + radius2 * Math.sin(angle);
        const a1 = angle + Math.PI + internalAngle;
        const a2 = angle - Math.PI - internalAngle;
        const x1 = x0 + corner * Math.cos(a1);
        const y1 = y0 + corner * Math.sin(a1);
        const x3 = x0 + corner * Math.cos(a2);
        const y3 = y0 + corner * Math.sin(a2);
        if (i2 === 0) {
          this.moveTo(x1, y1);
        } else {
          this.lineTo(x1, y1);
        }
        this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
      }
      return this.closePath();
    }
    roundShape(points, radius2, useQuadratic = false, smoothness) {
      if (points.length < 3) {
        return this;
      }
      if (useQuadratic) {
        roundedShapeQuadraticCurve(this, points, radius2, smoothness);
      } else {
        roundedShapeArc(this, points, radius2);
      }
      return this.closePath();
    }
    filletRect(x2, y2, width, height, fillet) {
      if (fillet === 0) {
        return this.rect(x2, y2, width, height);
      }
      const maxFillet = Math.min(width, height) / 2;
      const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
      const right = x2 + width;
      const bottom = y2 + height;
      const dir = inset < 0 ? -inset : 0;
      const size = Math.abs(inset);
      return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
    }
    chamferRect(x2, y2, width, height, chamfer, transform) {
      if (chamfer <= 0) {
        return this.rect(x2, y2, width, height);
      }
      const inset = Math.min(chamfer, Math.min(width, height) / 2);
      const right = x2 + width;
      const bottom = y2 + height;
      const points = [
        x2 + inset,
        y2,
        right - inset,
        y2,
        right,
        y2 + inset,
        right,
        bottom - inset,
        right - inset,
        bottom,
        x2 + inset,
        bottom,
        x2,
        bottom - inset,
        x2,
        y2 + inset
      ];
      for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
        if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
          points.splice(i2 - 1, 2);
        }
      }
      return this.poly(points, true, transform);
    }
    ellipse(x2, y2, radiusX, radiusY, transform) {
      this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform);
      return this;
    }
    roundRect(x2, y2, w2, h2, radius2, transform) {
      this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius2), transform);
      return this;
    }
    drawShape(shape, matrix) {
      this.endPoly();
      this.shapePrimitives.push({shape, transform: matrix});
      return this;
    }
    startPoly(x2, y2) {
      let currentPoly = this._currentPoly;
      if (currentPoly) {
        this.endPoly();
      }
      currentPoly = new Polygon();
      currentPoly.points.push(x2, y2);
      this._currentPoly = currentPoly;
      return this;
    }
    endPoly(closePath = false) {
      const shape = this._currentPoly;
      if (shape && shape.points.length > 2) {
        shape.closePath = closePath;
        this.shapePrimitives.push({shape});
      }
      this._currentPoly = null;
      return this;
    }
    _ensurePoly(start = true) {
      if (this._currentPoly)
        return;
      this._currentPoly = new Polygon();
      if (start) {
        const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (lastShape) {
          let lx = lastShape.shape.x;
          let ly = lastShape.shape.y;
          if (lastShape.transform && !lastShape.transform.isIdentity()) {
            const t2 = lastShape.transform;
            const tempX = lx;
            lx = t2.a * lx + t2.c * ly + t2.tx;
            ly = t2.b * tempX + t2.d * ly + t2.ty;
          }
          this._currentPoly.points.push(lx, ly);
        } else {
          this._currentPoly.points.push(0, 0);
        }
      }
    }
    buildPath() {
      const path2 = this._graphicsPath2D;
      this.shapePrimitives.length = 0;
      this._currentPoly = null;
      for (let i2 = 0; i2 < path2.instructions.length; i2++) {
        const instruction = path2.instructions[i2];
        this[instruction.action](...instruction.data);
      }
      this.finish();
    }
    get bounds() {
      const bounds = this._bounds;
      bounds.clear();
      const shapePrimitives = this.shapePrimitives;
      for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
        const shapePrimitive = shapePrimitives[i2];
        const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
        if (shapePrimitive.transform) {
          bounds.addRect(boundsRect, shapePrimitive.transform);
        } else {
          bounds.addRect(boundsRect);
        }
      }
      return bounds;
    }
  };

  // node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
  var GraphicsPath = class {
    constructor(instructions, signed = false) {
      this.instructions = [];
      this.uid = uid("graphicsPath");
      this._dirty = true;
      this.checkForHoles = signed;
      if (typeof instructions === "string") {
        parseSVGPath(instructions, this);
      } else {
        this.instructions = instructions?.slice() ?? [];
      }
    }
    get shapePath() {
      if (!this._shapePath) {
        this._shapePath = new ShapePath(this);
      }
      if (this._dirty) {
        this._dirty = false;
        this._shapePath.buildPath();
      }
      return this._shapePath;
    }
    addPath(path2, transform) {
      path2 = path2.clone();
      this.instructions.push({action: "addPath", data: [path2, transform]});
      this._dirty = true;
      return this;
    }
    arc(...args) {
      this.instructions.push({action: "arc", data: args});
      this._dirty = true;
      return this;
    }
    arcTo(...args) {
      this.instructions.push({action: "arcTo", data: args});
      this._dirty = true;
      return this;
    }
    arcToSvg(...args) {
      this.instructions.push({action: "arcToSvg", data: args});
      this._dirty = true;
      return this;
    }
    bezierCurveTo(...args) {
      this.instructions.push({action: "bezierCurveTo", data: args});
      this._dirty = true;
      return this;
    }
    bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
      const last = this.instructions[this.instructions.length - 1];
      const lastPoint = this.getLastPoint(Point.shared);
      let cp1x = 0;
      let cp1y = 0;
      if (!last || last.action !== "bezierCurveTo") {
        cp1x = lastPoint.x;
        cp1y = lastPoint.y;
      } else {
        cp1x = last.data[2];
        cp1y = last.data[3];
        const currentX = lastPoint.x;
        const currentY = lastPoint.y;
        cp1x = currentX + (currentX - cp1x);
        cp1y = currentY + (currentY - cp1y);
      }
      this.instructions.push({action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness]});
      this._dirty = true;
      return this;
    }
    closePath() {
      this.instructions.push({action: "closePath", data: []});
      this._dirty = true;
      return this;
    }
    ellipse(...args) {
      this.instructions.push({action: "ellipse", data: args});
      this._dirty = true;
      return this;
    }
    lineTo(...args) {
      this.instructions.push({action: "lineTo", data: args});
      this._dirty = true;
      return this;
    }
    moveTo(...args) {
      this.instructions.push({action: "moveTo", data: args});
      return this;
    }
    quadraticCurveTo(...args) {
      this.instructions.push({action: "quadraticCurveTo", data: args});
      this._dirty = true;
      return this;
    }
    quadraticCurveToShort(x2, y2, smoothness) {
      const last = this.instructions[this.instructions.length - 1];
      const lastPoint = this.getLastPoint(Point.shared);
      let cpx1 = 0;
      let cpy1 = 0;
      if (!last || last.action !== "quadraticCurveTo") {
        cpx1 = lastPoint.x;
        cpy1 = lastPoint.y;
      } else {
        cpx1 = last.data[0];
        cpy1 = last.data[1];
        const currentX = lastPoint.x;
        const currentY = lastPoint.y;
        cpx1 = currentX + (currentX - cpx1);
        cpy1 = currentY + (currentY - cpy1);
      }
      this.instructions.push({action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness]});
      this._dirty = true;
      return this;
    }
    rect(x2, y2, w2, h2, transform) {
      this.instructions.push({action: "rect", data: [x2, y2, w2, h2, transform]});
      this._dirty = true;
      return this;
    }
    circle(x2, y2, radius2, transform) {
      this.instructions.push({action: "circle", data: [x2, y2, radius2, transform]});
      this._dirty = true;
      return this;
    }
    roundRect(...args) {
      this.instructions.push({action: "roundRect", data: args});
      this._dirty = true;
      return this;
    }
    poly(...args) {
      this.instructions.push({action: "poly", data: args});
      this._dirty = true;
      return this;
    }
    regularPoly(...args) {
      this.instructions.push({action: "regularPoly", data: args});
      this._dirty = true;
      return this;
    }
    roundPoly(...args) {
      this.instructions.push({action: "roundPoly", data: args});
      this._dirty = true;
      return this;
    }
    roundShape(...args) {
      this.instructions.push({action: "roundShape", data: args});
      this._dirty = true;
      return this;
    }
    filletRect(...args) {
      this.instructions.push({action: "filletRect", data: args});
      this._dirty = true;
      return this;
    }
    chamferRect(...args) {
      this.instructions.push({action: "chamferRect", data: args});
      this._dirty = true;
      return this;
    }
    star(x2, y2, points, radius2, innerRadius, rotation, transform) {
      innerRadius || (innerRadius = radius2 / 2);
      const startAngle = -1 * Math.PI / 2 + rotation;
      const len = points * 2;
      const delta = Math.PI * 2 / len;
      const polygon = [];
      for (let i2 = 0; i2 < len; i2++) {
        const r2 = i2 % 2 ? innerRadius : radius2;
        const angle = i2 * delta + startAngle;
        polygon.push(x2 + r2 * Math.cos(angle), y2 + r2 * Math.sin(angle));
      }
      this.poly(polygon, true, transform);
      return this;
    }
    clone(deep = false) {
      const newGraphicsPath2D = new GraphicsPath();
      newGraphicsPath2D.checkForHoles = this.checkForHoles;
      if (!deep) {
        newGraphicsPath2D.instructions = this.instructions.slice();
      } else {
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          newGraphicsPath2D.instructions.push({action: instruction.action, data: instruction.data.slice()});
        }
      }
      return newGraphicsPath2D;
    }
    clear() {
      this.instructions.length = 0;
      this._dirty = true;
      return this;
    }
    transform(matrix) {
      if (matrix.isIdentity())
        return this;
      const a2 = matrix.a;
      const b2 = matrix.b;
      const c2 = matrix.c;
      const d2 = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let x2 = 0;
      let y2 = 0;
      let cpx1 = 0;
      let cpy1 = 0;
      let cpx2 = 0;
      let cpy2 = 0;
      let rx = 0;
      let ry = 0;
      for (let i2 = 0; i2 < this.instructions.length; i2++) {
        const instruction = this.instructions[i2];
        const data = instruction.data;
        switch (instruction.action) {
          case "moveTo":
          case "lineTo":
            x2 = data[0];
            y2 = data[1];
            data[0] = a2 * x2 + c2 * y2 + tx;
            data[1] = b2 * x2 + d2 * y2 + ty;
            break;
          case "bezierCurveTo":
            cpx1 = data[0];
            cpy1 = data[1];
            cpx2 = data[2];
            cpy2 = data[3];
            x2 = data[4];
            y2 = data[5];
            data[0] = a2 * cpx1 + c2 * cpy1 + tx;
            data[1] = b2 * cpx1 + d2 * cpy1 + ty;
            data[2] = a2 * cpx2 + c2 * cpy2 + tx;
            data[3] = b2 * cpx2 + d2 * cpy2 + ty;
            data[4] = a2 * x2 + c2 * y2 + tx;
            data[5] = b2 * x2 + d2 * y2 + ty;
            break;
          case "quadraticCurveTo":
            cpx1 = data[0];
            cpy1 = data[1];
            x2 = data[2];
            y2 = data[3];
            data[0] = a2 * cpx1 + c2 * cpy1 + tx;
            data[1] = b2 * cpx1 + d2 * cpy1 + ty;
            data[2] = a2 * x2 + c2 * y2 + tx;
            data[3] = b2 * x2 + d2 * y2 + ty;
            break;
          case "arcToSvg":
            x2 = data[5];
            y2 = data[6];
            rx = data[0];
            ry = data[1];
            data[0] = a2 * rx + c2 * ry;
            data[1] = b2 * rx + d2 * ry;
            data[5] = a2 * x2 + c2 * y2 + tx;
            data[6] = b2 * x2 + d2 * y2 + ty;
            break;
          case "circle":
            data[4] = adjustTransform(data[3], matrix);
            break;
          case "rect":
            data[4] = adjustTransform(data[4], matrix);
            break;
          case "ellipse":
            data[8] = adjustTransform(data[8], matrix);
            break;
          case "roundRect":
            data[5] = adjustTransform(data[5], matrix);
            break;
          case "addPath":
            data[0].transform(matrix);
            break;
          case "poly":
            data[2] = adjustTransform(data[2], matrix);
            break;
          default:
            warn("unknown transform action", instruction.action);
            break;
        }
      }
      this._dirty = true;
      return this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(out2) {
      let index = this.instructions.length - 1;
      let lastInstruction = this.instructions[index];
      if (!lastInstruction) {
        out2.x = 0;
        out2.y = 0;
        return out2;
      }
      while (lastInstruction.action === "closePath") {
        index--;
        if (index < 0) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        lastInstruction = this.instructions[index];
      }
      switch (lastInstruction.action) {
        case "moveTo":
        case "lineTo":
          out2.x = lastInstruction.data[0];
          out2.y = lastInstruction.data[1];
          break;
        case "quadraticCurveTo":
          out2.x = lastInstruction.data[2];
          out2.y = lastInstruction.data[3];
          break;
        case "bezierCurveTo":
          out2.x = lastInstruction.data[4];
          out2.y = lastInstruction.data[5];
          break;
        case "arc":
        case "arcToSvg":
          out2.x = lastInstruction.data[5];
          out2.y = lastInstruction.data[6];
          break;
        case "addPath":
          lastInstruction.data[0].getLastPoint(out2);
          break;
      }
      return out2;
    }
  };
  function adjustTransform(currentMatrix, transform) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform);
    }
    return transform.clone();
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs
  "use strict";
  function parseSVGFloatAttribute(svg, id, defaultValue2) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue2;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs
  function parseSVGDefinitions(svg, session) {
    const definitions = svg.querySelectorAll("defs");
    for (let i2 = 0; i2 < definitions.length; i2++) {
      const definition = definitions[i2];
      for (let j2 = 0; j2 < definition.children.length; j2++) {
        const child = definition.children[j2];
        switch (child.nodeName.toLowerCase()) {
          case "lineargradient":
            session.defs[child.id] = parseLinearGradient(child);
            break;
          case "radialgradient":
            session.defs[child.id] = parseRadialGradient(child);
            break;
          default:
            break;
        }
      }
    }
  }
  function parseLinearGradient(child) {
    const x0 = parseSVGFloatAttribute(child, "x1", 0);
    const y0 = parseSVGFloatAttribute(child, "y1", 0);
    const x1 = parseSVGFloatAttribute(child, "x2", 1);
    const y1 = parseSVGFloatAttribute(child, "y2", 0);
    const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
    const gradient = new FillGradient(x0, y0, x1, y1, gradientUnit === "objectBoundingBox" ? "local" : "global");
    for (let k2 = 0; k2 < child.children.length; k2++) {
      const stop = child.children[k2];
      const offset = parseSVGFloatAttribute(stop, "offset", 0);
      const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
      gradient.addColorStop(offset, color);
    }
    return gradient;
  }
  function parseRadialGradient(_child) {
    warn("[SVG Parser] Radial gradients are not yet supported");
    return new FillGradient(0, 0, 1, 0);
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs
  "use strict";
  function extractSvgUrlId(url) {
    const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return match ? match[1] : "";
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs
  var styleAttributes = {
    fill: {type: "paint", default: 0},
    "fill-opacity": {type: "number", default: 1},
    stroke: {type: "paint", default: 0},
    "stroke-width": {type: "number", default: 1},
    "stroke-opacity": {type: "number", default: 1},
    "stroke-linecap": {type: "string", default: "butt"},
    "stroke-linejoin": {type: "string", default: "miter"},
    "stroke-miterlimit": {type: "number", default: 10},
    "stroke-dasharray": {type: "string", default: "none"},
    "stroke-dashoffset": {type: "number", default: 0},
    opacity: {type: "number", default: 1}
  };
  function parseSVGStyle(svg, session) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    const result = {
      strokeStyle,
      fillStyle,
      useFill: false,
      useStroke: false
    };
    for (const key in styleAttributes) {
      const attribute = svg.getAttribute(key);
      if (attribute) {
        parseAttribute(session, result, key, attribute.trim());
      }
    }
    if (style) {
      const styleParts = style.split(";");
      for (let i2 = 0; i2 < styleParts.length; i2++) {
        const stylePart = styleParts[i2].trim();
        const [key, value] = stylePart.split(":");
        if (styleAttributes[key]) {
          parseAttribute(session, result, key, value.trim());
        }
      }
    }
    return {
      strokeStyle: result.useStroke ? strokeStyle : null,
      fillStyle: result.useFill ? fillStyle : null,
      useFill: result.useFill,
      useStroke: result.useStroke
    };
  }
  function parseAttribute(session, result, id, value) {
    switch (id) {
      case "stroke":
        if (value !== "none") {
          if (value.startsWith("url(")) {
            const id2 = extractSvgUrlId(value);
            result.strokeStyle.fill = session.defs[id2];
          } else {
            result.strokeStyle.color = Color.shared.setValue(value).toNumber();
          }
          result.useStroke = true;
        }
        break;
      case "stroke-width":
        result.strokeStyle.width = Number(value);
        break;
      case "fill":
        if (value !== "none") {
          if (value.startsWith("url(")) {
            const id2 = extractSvgUrlId(value);
            result.fillStyle.fill = session.defs[id2];
          } else {
            result.fillStyle.color = Color.shared.setValue(value).toNumber();
          }
          result.useFill = true;
        }
        break;
      case "fill-opacity":
        result.fillStyle.alpha = Number(value);
        break;
      case "stroke-opacity":
        result.strokeStyle.alpha = Number(value);
        break;
      case "opacity":
        result.fillStyle.alpha = Number(value);
        result.strokeStyle.alpha = Number(value);
        break;
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/fillOperations.mjs
  "use strict";
  function checkForNestedPattern(subpathsWithArea) {
    if (subpathsWithArea.length <= 2) {
      return true;
    }
    const areas = subpathsWithArea.map((s2) => s2.area).sort((a2, b2) => b2 - a2);
    const [largestArea, secondArea] = areas;
    const smallestArea = areas[areas.length - 1];
    const largestToSecondRatio = largestArea / secondArea;
    const secondToSmallestRatio = secondArea / smallestArea;
    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
      return false;
    }
    return true;
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/pathOperations.mjs
  function extractSubpaths(pathData) {
    const parts = pathData.split(/(?=[Mm])/);
    const subpaths = parts.filter((part) => part.trim().length > 0);
    return subpaths;
  }
  function calculatePathArea(pathData) {
    const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
    if (!coords || coords.length < 4)
      return 0;
    const numbers = coords.map(Number);
    const xs = [];
    const ys = [];
    for (let i2 = 0; i2 < numbers.length; i2 += 2) {
      if (i2 + 1 < numbers.length) {
        xs.push(numbers[i2]);
        ys.push(numbers[i2 + 1]);
      }
    }
    if (xs.length === 0 || ys.length === 0)
      return 0;
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const area2 = (maxX - minX) * (maxY - minY);
    return area2;
  }
  function appendSVGPath(pathData, graphicsPath) {
    const tempPath = new GraphicsPath(pathData, false);
    for (const instruction of tempPath.instructions) {
      graphicsPath.instructions.push(instruction);
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      defs: {},
      path: new GraphicsPath()
    };
    parseSVGDefinitions(svg, session);
    const children = svg.children;
    const {fillStyle, strokeStyle} = parseSVGStyle(svg, session);
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (child.nodeName.toLowerCase() === "defs")
        continue;
      renderChildren(child, session, fillStyle, strokeStyle);
    }
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const {fillStyle: f1, strokeStyle: s1} = parseSVGStyle(svg, session);
    if (f1 && fillStyle) {
      fillStyle = {...fillStyle, ...f1};
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = {...strokeStyle, ...s1};
    } else if (s1) {
      strokeStyle = s1;
    }
    const noStyle = !fillStyle && !strokeStyle;
    if (noStyle) {
      fillStyle = {color: 0};
    }
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path": {
        d2 = svg.getAttribute("d");
        const fillRule = svg.getAttribute("fill-rule");
        const subpaths = extractSubpaths(d2);
        const hasExplicitEvenodd = fillRule === "evenodd";
        const hasMultipleSubpaths = subpaths.length > 1;
        const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
        if (shouldProcessHoles) {
          const subpathsWithArea = subpaths.map((subpath) => ({
            path: subpath,
            area: calculatePathArea(subpath)
          }));
          subpathsWithArea.sort((a2, b2) => b2.area - a2.area);
          const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
          if (useMultipleHolesApproach) {
            for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
              const subpath = subpathsWithArea[i2];
              const isMainShape = i2 === 0;
              session.context.beginPath();
              const newPath = new GraphicsPath(void 0, true);
              appendSVGPath(subpath.path, newPath);
              session.context.path(newPath);
              if (isMainShape) {
                if (fillStyle)
                  session.context.fill(fillStyle);
                if (strokeStyle)
                  session.context.stroke(strokeStyle);
              } else {
                session.context.cut();
              }
            }
          } else {
            for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
              const subpath = subpathsWithArea[i2];
              const isHole = i2 % 2 === 1;
              session.context.beginPath();
              const newPath = new GraphicsPath(void 0, true);
              appendSVGPath(subpath.path, newPath);
              session.context.path(newPath);
              if (isHole) {
                session.context.cut();
              } else {
                if (fillStyle)
                  session.context.fill(fillStyle);
                if (strokeStyle)
                  session.context.stroke(strokeStyle);
              }
            }
          }
        } else {
          const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
          graphicsPath = new GraphicsPath(d2, useEvenoddForGraphicsPath);
          session.context.path(graphicsPath);
          if (fillStyle)
            session.context.fill(fillStyle);
          if (strokeStyle)
            session.context.stroke(strokeStyle);
        }
        break;
      }
      case "circle":
        cx = parseSVGFloatAttribute(svg, "cx", 0);
        cy = parseSVGFloatAttribute(svg, "cy", 0);
        r2 = parseSVGFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "rect":
        x2 = parseSVGFloatAttribute(svg, "x", 0);
        y2 = parseSVGFloatAttribute(svg, "y", 0);
        width = parseSVGFloatAttribute(svg, "width", 0);
        height = parseSVGFloatAttribute(svg, "height", 0);
        rx = parseSVGFloatAttribute(svg, "rx", 0);
        ry = parseSVGFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "ellipse":
        cx = parseSVGFloatAttribute(svg, "cx", 0);
        cy = parseSVGFloatAttribute(svg, "cy", 0);
        rx = parseSVGFloatAttribute(svg, "rx", 0);
        ry = parseSVGFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "line":
        x1 = parseSVGFloatAttribute(svg, "x1", 0);
        y1 = parseSVGFloatAttribute(svg, "y1", 0);
        x22 = parseSVGFloatAttribute(svg, "x2", 0);
        y22 = parseSVGFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
        break;
      case "g":
      case "svg":
        break;
      default: {
        warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    if (noStyle) {
      fillStyle = null;
    }
    for (let i2 = 0; i2 < children.length; i2++) {
      renderChildren(children[i2], session, fillStyle, strokeStyle);
    }
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function isColorLike(value) {
    return Color.isColorLike(value);
  }
  function isFillPattern(value) {
    return value instanceof FillPattern;
  }
  function isFillGradient(value) {
    return value instanceof FillGradient;
  }
  function isTexture(value) {
    return value instanceof Texture;
  }
  function handleColorLike(fill, value, defaultStyle) {
    const temp = Color.shared.setValue(value ?? 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = Texture.WHITE;
    return {...defaultStyle, ...fill};
  }
  function handleTexture(fill, value, defaultStyle) {
    fill.texture = value;
    return {...defaultStyle, ...fill};
  }
  function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return {...defaultStyle, ...fill};
  }
  function handleFillGradient(fill, value, defaultStyle) {
    value.buildGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    fill.textureSpace = value.textureSpace;
    return {...defaultStyle, ...fill};
  }
  function handleFillObject(value, defaultStyle) {
    const style = {...defaultStyle, ...value};
    const color = Color.shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    return style;
  }
  function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
      return handleColorLike(fill, value, defaultStyle);
    } else if (isTexture(value)) {
      return handleTexture(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
      return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
      return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value, defaultStyle) {
    const {width, alignment, miterLimit, cap, join, pixelLine, ...rest} = defaultStyle;
    const fill = toFillStyle(value, rest);
    if (!fill) {
      return null;
    }
    return {
      width,
      alignment,
      miterLimit,
      cap,
      join,
      pixelLine,
      ...fill
    };
  }

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint = new Point();
  var tempMatrix4 = new Matrix();
  var _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
    constructor() {
      super(...arguments);
      this.uid = uid("graphicsContext");
      this.dirty = true;
      this.batchMode = "auto";
      this.instructions = [];
      this._activePath = new GraphicsPath();
      this._transform = new Matrix();
      this._fillStyle = {..._GraphicsContext2.defaultFillStyle};
      this._strokeStyle = {..._GraphicsContext2.defaultStrokeStyle};
      this._stateStack = [];
      this._tick = 0;
      this._bounds = new Bounds();
      this._boundsDirty = true;
    }
    clone() {
      const clone = new _GraphicsContext2();
      clone.batchMode = this.batchMode;
      clone.instructions = this.instructions.slice();
      clone._activePath = this._activePath.clone();
      clone._transform = this._transform.clone();
      clone._fillStyle = {...this._fillStyle};
      clone._strokeStyle = {...this._strokeStyle};
      clone._stateStack = this._stateStack.slice();
      clone._bounds = this._bounds.clone();
      clone._boundsDirty = true;
      return clone;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(value) {
      this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(value) {
      this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
    }
    setFillStyle(style) {
      this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
      return this;
    }
    setStrokeStyle(style) {
      this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
      return this;
    }
    texture(texture, tint, dx2, dy2, dw, dh) {
      this.instructions.push({
        action: "texture",
        data: {
          image: texture,
          dx: dx2 || 0,
          dy: dy2 || 0,
          dw: dw || texture.frame.width,
          dh: dh || texture.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
        }
      });
      this.onUpdate();
      return this;
    }
    beginPath() {
      this._activePath = new GraphicsPath();
      return this;
    }
    fill(style, alpha) {
      let path2;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
        path2 = lastInstruction.data.path;
      } else {
        path2 = this._activePath.clone();
      }
      if (!path2)
        return this;
      if (style != null) {
        if (alpha !== void 0 && typeof style === "number") {
          deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
          style = {color: style, alpha};
        }
        this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
      }
      this.instructions.push({
        action: "fill",
        data: {style: this.fillStyle, path: path2}
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    _initNextPathLocation() {
      const {x: x2, y: y2} = this._activePath.getLastPoint(Point.shared);
      this._activePath.clear();
      this._activePath.moveTo(x2, y2);
    }
    stroke(style) {
      let path2;
      const lastInstruction = this.instructions[this.instructions.length - 1];
      if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
        path2 = lastInstruction.data.path;
      } else {
        path2 = this._activePath.clone();
      }
      if (!path2)
        return this;
      if (style != null) {
        this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
      }
      this.instructions.push({
        action: "stroke",
        data: {style: this.strokeStyle, path: path2}
      });
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    cut() {
      for (let i2 = 0; i2 < 2; i2++) {
        const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
        const holePath = this._activePath.clone();
        if (lastInstruction) {
          if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
            if (lastInstruction.data.hole) {
              lastInstruction.data.hole.addPath(holePath);
            } else {
              lastInstruction.data.hole = holePath;
              break;
            }
          }
        }
      }
      this._initNextPathLocation();
      return this;
    }
    arc(x2, y2, radius2, startAngle, endAngle, counterclockwise) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arc(t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, radius2, startAngle, endAngle, counterclockwise);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius2) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arcTo(t2.a * x1 + t2.c * y1 + t2.tx, t2.b * x1 + t2.d * y1 + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, radius2);
      return this;
    }
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty);
      return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.bezierCurveTo(t2.a * cp1x + t2.c * cp1y + t2.tx, t2.b * cp1x + t2.d * cp1y + t2.ty, t2.a * cp2x + t2.c * cp2y + t2.tx, t2.b * cp2x + t2.d * cp2y + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, smoothness);
      return this;
    }
    closePath() {
      this._tick++;
      this._activePath?.closePath();
      return this;
    }
    ellipse(x2, y2, radiusX, radiusY) {
      this._tick++;
      this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
      return this;
    }
    circle(x2, y2, radius2) {
      this._tick++;
      this._activePath.circle(x2, y2, radius2, this._transform.clone());
      return this;
    }
    path(path2) {
      this._tick++;
      this._activePath.addPath(path2, this._transform.clone());
      return this;
    }
    lineTo(x2, y2) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.lineTo(t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty);
      return this;
    }
    moveTo(x2, y2) {
      this._tick++;
      const t2 = this._transform;
      const instructions = this._activePath.instructions;
      const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
      const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
      if (instructions.length === 1 && instructions[0].action === "moveTo") {
        instructions[0].data[0] = transformedX;
        instructions[0].data[1] = transformedY;
        return this;
      }
      this._activePath.moveTo(transformedX, transformedY);
      return this;
    }
    quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
      this._tick++;
      const t2 = this._transform;
      this._activePath.quadraticCurveTo(t2.a * cpx + t2.c * cpy + t2.tx, t2.b * cpx + t2.d * cpy + t2.ty, t2.a * x2 + t2.c * y2 + t2.tx, t2.b * x2 + t2.d * y2 + t2.ty, smoothness);
      return this;
    }
    rect(x2, y2, w2, h2) {
      this._tick++;
      this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
      return this;
    }
    roundRect(x2, y2, w2, h2, radius2) {
      this._tick++;
      this._activePath.roundRect(x2, y2, w2, h2, radius2, this._transform.clone());
      return this;
    }
    poly(points, close) {
      this._tick++;
      this._activePath.poly(points, close, this._transform.clone());
      return this;
    }
    regularPoly(x2, y2, radius2, sides, rotation = 0, transform) {
      this._tick++;
      this._activePath.regularPoly(x2, y2, radius2, sides, rotation, transform);
      return this;
    }
    roundPoly(x2, y2, radius2, sides, corner, rotation) {
      this._tick++;
      this._activePath.roundPoly(x2, y2, radius2, sides, corner, rotation);
      return this;
    }
    roundShape(points, radius2, useQuadratic, smoothness) {
      this._tick++;
      this._activePath.roundShape(points, radius2, useQuadratic, smoothness);
      return this;
    }
    filletRect(x2, y2, width, height, fillet) {
      this._tick++;
      this._activePath.filletRect(x2, y2, width, height, fillet);
      return this;
    }
    chamferRect(x2, y2, width, height, chamfer, transform) {
      this._tick++;
      this._activePath.chamferRect(x2, y2, width, height, chamfer, transform);
      return this;
    }
    star(x2, y2, points, radius2, innerRadius = 0, rotation = 0) {
      this._tick++;
      this._activePath.star(x2, y2, points, radius2, innerRadius, rotation, this._transform.clone());
      return this;
    }
    svg(svg) {
      this._tick++;
      SVGParser(svg, this);
      return this;
    }
    restore() {
      const state = this._stateStack.pop();
      if (state) {
        this._transform = state.transform;
        this._fillStyle = state.fillStyle;
        this._strokeStyle = state.strokeStyle;
      }
      return this;
    }
    save() {
      this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {...this._fillStyle},
        strokeStyle: {...this._strokeStyle}
      });
      return this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      this._transform.identity();
      return this;
    }
    rotate(angle) {
      this._transform.rotate(angle);
      return this;
    }
    scale(x2, y2 = x2) {
      this._transform.scale(x2, y2);
      return this;
    }
    setTransform(a2, b2, c2, d2, dx2, dy2) {
      if (a2 instanceof Matrix) {
        this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
        return this;
      }
      this._transform.set(a2, b2, c2, d2, dx2, dy2);
      return this;
    }
    transform(a2, b2, c2, d2, dx2, dy2) {
      if (a2 instanceof Matrix) {
        this._transform.append(a2);
        return this;
      }
      tempMatrix4.set(a2, b2, c2, d2, dx2, dy2);
      this._transform.append(tempMatrix4);
      return this;
    }
    translate(x2, y2 = x2) {
      this._transform.translate(x2, y2);
      return this;
    }
    clear() {
      this._activePath.clear();
      this.instructions.length = 0;
      this.resetTransform();
      this.onUpdate();
      return this;
    }
    onUpdate() {
      this._boundsDirty = true;
      if (this.dirty)
        return;
      this.emit("update", this, 16);
      this.dirty = true;
    }
    get bounds() {
      if (!this._boundsDirty)
        return this._bounds;
      this._boundsDirty = false;
      const bounds = this._bounds;
      bounds.clear();
      for (let i2 = 0; i2 < this.instructions.length; i2++) {
        const instruction = this.instructions[i2];
        const action = instruction.action;
        if (action === "fill") {
          const data = instruction.data;
          bounds.addBounds(data.path.bounds);
        } else if (action === "texture") {
          const data = instruction.data;
          bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
        }
        if (action === "stroke") {
          const data = instruction.data;
          const alignment = data.style.alignment;
          const outerPadding = data.style.width * (1 - alignment);
          const _bounds = data.path.bounds;
          bounds.addFrame(_bounds.minX - outerPadding, _bounds.minY - outerPadding, _bounds.maxX + outerPadding, _bounds.maxY + outerPadding);
        }
      }
      return bounds;
    }
    containsPoint(point) {
      if (!this.bounds.containsPoint(point.x, point.y))
        return false;
      const instructions = this.instructions;
      let hasHit = false;
      for (let k2 = 0; k2 < instructions.length; k2++) {
        const instruction = instructions[k2];
        const data = instruction.data;
        const path2 = data.path;
        if (!instruction.action || !path2)
          continue;
        const style = data.style;
        const shapes = path2.shapePath.shapePrimitives;
        for (let i2 = 0; i2 < shapes.length; i2++) {
          const shape = shapes[i2].shape;
          if (!style || !shape)
            continue;
          const transform = shapes[i2].transform;
          const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
          if (instruction.action === "fill") {
            hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
          } else {
            const strokeStyle = style;
            hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
          }
          const holes = data.hole;
          if (holes) {
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (holeShapes) {
              for (let j2 = 0; j2 < holeShapes.length; j2++) {
                if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                  hasHit = false;
                }
              }
            }
          }
          if (hasHit) {
            return true;
          }
        }
      }
      return hasHit;
    }
    destroy(options = false) {
      this._stateStack.length = 0;
      this._transform = null;
      this.emit("destroy", this);
      this.removeAllListeners();
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        if (this._fillStyle.texture) {
          this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
        }
        if (this._strokeStyle.texture) {
          this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
        }
      }
      this._fillStyle = null;
      this._strokeStyle = null;
      this.instructions = null;
      this._activePath = null;
      this._bounds = null;
      this._stateStack = null;
      this.customShader = null;
      this._transform = null;
    }
  };
  _GraphicsContext.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: Texture.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  _GraphicsContext.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: Texture.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  var GraphicsContext = _GraphicsContext;

  // node_modules/pixi.js/lib/scene/text/TextStyle.mjs
  var _TextStyle = class _TextStyle2 extends eventemitter3_default {
    constructor(style = {}) {
      super();
      this.uid = uid("textStyle");
      this._tick = 0;
      convertV7Tov8Style(style);
      const fullStyle = {..._TextStyle2.defaultTextStyle, ...style};
      for (const key in fullStyle) {
        const thisKey = key;
        this[thisKey] = fullStyle[key];
      }
      this.update();
      this._tick = 0;
    }
    get align() {
      return this._align;
    }
    set align(value) {
      this._align = value;
      this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(value) {
      this._breakWords = value;
      this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(value) {
      if (value !== null && typeof value === "object") {
        this._dropShadow = this._createProxy({..._TextStyle2.defaultDropShadow, ...value});
      } else {
        this._dropShadow = value ? this._createProxy({..._TextStyle2.defaultDropShadow}) : null;
      }
      this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(value) {
      this._fontFamily = value;
      this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(value) {
      if (typeof value === "string") {
        this._fontSize = parseInt(value, 10);
      } else {
        this._fontSize = value;
      }
      this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(value) {
      this._fontStyle = value.toLowerCase();
      this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(value) {
      this._fontVariant = value;
      this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(value) {
      this._fontWeight = value;
      this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(value) {
      this._leading = value;
      this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(value) {
      this._letterSpacing = value;
      this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(value) {
      this._lineHeight = value;
      this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(value) {
      this._padding = value;
      this.update();
    }
    get filters() {
      return this._filters;
    }
    set filters(value) {
      this._filters = Object.freeze(value);
      this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(value) {
      this._trim = value;
      this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(value) {
      this._textBaseline = value;
      this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(value) {
      this._whiteSpace = value;
      this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(value) {
      this._wordWrap = value;
      this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(value) {
      this._wordWrapWidth = value;
      this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(value) {
      if (value === this._originalFill)
        return;
      this._originalFill = value;
      if (this._isFillStyle(value)) {
        this._originalFill = this._createProxy({...GraphicsContext.defaultFillStyle, ...value}, () => {
          this._fill = toFillStyle({...this._originalFill}, GraphicsContext.defaultFillStyle);
        });
      }
      this._fill = toFillStyle(value === 0 ? "black" : value, GraphicsContext.defaultFillStyle);
      this.update();
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(value) {
      if (value === this._originalStroke)
        return;
      this._originalStroke = value;
      if (this._isFillStyle(value)) {
        this._originalStroke = this._createProxy({...GraphicsContext.defaultStrokeStyle, ...value}, () => {
          this._stroke = toStrokeStyle({...this._originalStroke}, GraphicsContext.defaultStrokeStyle);
        });
      }
      this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
      this.update();
    }
    update() {
      this._tick++;
      this.emit("update", this);
    }
    reset() {
      const defaultStyle = _TextStyle2.defaultTextStyle;
      for (const key in defaultStyle) {
        this[key] = defaultStyle[key];
      }
    }
    get styleKey() {
      return `${this.uid}-${this._tick}`;
    }
    clone() {
      return new _TextStyle2({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {...this._dropShadow} : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        filters: this._filters ? [...this._filters] : void 0
      });
    }
    _getFinalPadding() {
      let filterPadding = 0;
      if (this._filters) {
        for (let i2 = 0; i2 < this._filters.length; i2++) {
          filterPadding += this._filters[i2].padding;
        }
      }
      return Math.max(this._padding, filterPadding);
    }
    destroy(options = false) {
      this.removeAllListeners();
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        if (this._fill?.texture) {
          this._fill.texture.destroy(destroyTextureSource);
        }
        if (this._originalFill?.texture) {
          this._originalFill.texture.destroy(destroyTextureSource);
        }
        if (this._stroke?.texture) {
          this._stroke.texture.destroy(destroyTextureSource);
        }
        if (this._originalStroke?.texture) {
          this._originalStroke.texture.destroy(destroyTextureSource);
        }
      }
      this._fill = null;
      this._stroke = null;
      this.dropShadow = null;
      this._originalStroke = null;
      this._originalFill = null;
    }
    _createProxy(value, cb) {
      return new Proxy(value, {
        set: (target, property, newValue) => {
          target[property] = newValue;
          cb?.(property, newValue);
          this.update();
          return true;
        }
      });
    }
    _isFillStyle(value) {
      return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
    }
  };
  _TextStyle.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  _TextStyle.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  var TextStyle = _TextStyle;
  function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults2 = TextStyle.defaultDropShadow;
      style.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? defaults2.alpha,
        angle: oldStyle.dropShadowAngle ?? defaults2.angle,
        blur: oldStyle.dropShadowBlur ?? defaults2.blur,
        color: oldStyle.dropShadowColor ?? defaults2.color,
        distance: oldStyle.dropShadowDistance ?? defaults2.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      let obj = {};
      if (Color.isColorLike(color)) {
        obj.color = color;
      } else if (color instanceof FillGradient || color instanceof FillPattern) {
        obj.fill = color;
      } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
        obj = color;
      } else {
        throw new Error("Invalid stroke value.");
      }
      style.stroke = {
        ...obj,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
        throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
      }
      if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
        warn("The number of fill colors must match the number of fill gradient stops.");
      }
      const gradientFill = new FillGradient({
        start: {x: 0, y: 0},
        end: {x: 0, y: 1},
        textureSpace: "local"
      });
      const fillGradientStops = oldStyle.fillGradientStops.slice();
      const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
      fillGradientStops.forEach((stop, index) => {
        gradientFill.addColorStop(stop, fills[index]);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }

  // node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
  var tempBounds2 = new Bounds();
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, false);
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass = class {
    constructor(canvasOptions) {
      this._canvasPool = /* @__PURE__ */ Object.create(null);
      this.canvasOptions = canvasOptions || {};
      this.enableFullScreen = false;
    }
    _createCanvasAndContext(pixelWidth, pixelHeight) {
      const canvas = DOMAdapter.get().createCanvas();
      canvas.width = pixelWidth;
      canvas.height = pixelHeight;
      const context4 = canvas.getContext("2d");
      return {canvas, context: context4};
    }
    getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      const key = (minWidth << 17) + (minHeight << 1);
      if (!this._canvasPool[key]) {
        this._canvasPool[key] = [];
      }
      let canvasAndContext = this._canvasPool[key].pop();
      if (!canvasAndContext) {
        canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
      }
      return canvasAndContext;
    }
    returnCanvasAndContext(canvasAndContext) {
      const canvas = canvasAndContext.canvas;
      const {width, height} = canvas;
      const key = (width << 17) + (height << 1);
      canvasAndContext.context.resetTransform();
      canvasAndContext.context.clearRect(0, 0, width, height);
      this._canvasPool[key].push(canvasAndContext);
    }
    clear() {
      this._canvasPool = {};
    }
  };
  var CanvasPool = new CanvasPoolClass();
  GlobalResourceRegistry.register(CanvasPool);

  // node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
  var _internalCanvas = null;
  var _internalContext = null;
  function ensureInternalCanvas(width, height) {
    if (!_internalCanvas) {
      _internalCanvas = DOMAdapter.get().createCanvas(256, 128);
      _internalContext = _internalCanvas.getContext("2d", {willReadFrequently: true});
      _internalContext.globalCompositeOperation = "copy";
      _internalContext.globalAlpha = 1;
    }
    if (_internalCanvas.width < width || _internalCanvas.height < height) {
      _internalCanvas.width = nextPow2(width);
      _internalCanvas.height = nextPow2(height);
    }
  }
  function checkRow(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(...args) {
    let options = args[0];
    if (!options.canvas) {
      options = {canvas: args[0], resolution: args[1]};
    }
    const {canvas} = options;
    const resolution = Math.min(options.resolution ?? 1, 1);
    const width = options.width ?? canvas.width;
    const height = options.height ?? canvas.height;
    let output = options.output;
    ensureInternalCanvas(width, height);
    if (!_internalContext) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    _internalContext.drawImage(canvas, 0, 0, width, height, 0, 0, width * resolution, height * resolution);
    const imageData = _internalContext.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height)
      return Rectangle.EMPTY;
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    _internalContext.globalCompositeOperation = "source-over";
    _internalContext.strokeRect(left, top, right - left, bottom - top);
    _internalContext.globalCompositeOperation = "copy";
    output ?? (output = new Rectangle());
    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
    return output;
  }

  // node_modules/tiny-lru/dist/tiny-lru.js
  /**
   * tiny-lru
   *
   * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.4.5
   */
  var LRU = class {
    constructor(max = 0, ttl = 0, resetTtl = false) {
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.max = max;
      this.resetTtl = resetTtl;
      this.size = 0;
      this.ttl = ttl;
    }
    clear() {
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.size = 0;
      return this;
    }
    delete(key) {
      if (this.has(key)) {
        const item = this.items[key];
        delete this.items[key];
        this.size--;
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
      return this;
    }
    entries(keys = this.keys()) {
      return keys.map((key) => [key, this.get(key)]);
    }
    evict(bypass = false) {
      if (bypass || this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
      return this;
    }
    expiresAt(key) {
      let result;
      if (this.has(key)) {
        result = this.items[key].expiry;
      }
      return result;
    }
    get(key) {
      const item = this.items[key];
      if (item !== void 0) {
        if (this.ttl > 0) {
          if (item.expiry <= Date.now()) {
            this.delete(key);
            return void 0;
          }
        }
        this.moveToEnd(item);
        return item.value;
      }
      return void 0;
    }
    has(key) {
      return key in this.items;
    }
    moveToEnd(item) {
      if (this.last === item) {
        return;
      }
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      item.prev = this.last;
      item.next = null;
      if (this.last !== null) {
        this.last.next = item;
      }
      this.last = item;
      if (this.first === null) {
        this.first = item;
      }
    }
    keys() {
      const result = [];
      let x2 = this.first;
      while (x2 !== null) {
        result.push(x2.key);
        x2 = x2.next;
      }
      return result;
    }
    setWithEvicted(key, value, resetTtl = this.resetTtl) {
      let evicted = null;
      if (this.has(key)) {
        this.set(key, value, true, resetTtl);
      } else {
        if (this.max > 0 && this.size === this.max) {
          evicted = {...this.first};
          this.evict(true);
        }
        let item = this.items[key] = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
      return evicted;
    }
    set(key, value, bypass = false, resetTtl = this.resetTtl) {
      let item = this.items[key];
      if (bypass || item !== void 0) {
        item.value = value;
        if (bypass === false && resetTtl) {
          item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        }
        this.moveToEnd(item);
      } else {
        if (this.max > 0 && this.size === this.max) {
          this.evict(true);
        }
        item = this.items[key] = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
      return this;
    }
    values(keys = this.keys()) {
      return keys.map((key) => this.get(key));
    }
  };
  function lru(max = 1e3, ttl = 0, resetTtl = false) {
    if (isNaN(max) || max < 0) {
      throw new TypeError("Invalid max value");
    }
    if (isNaN(ttl) || ttl < 0) {
      throw new TypeError("Invalid ttl value");
    }
    if (typeof resetTtl !== "boolean") {
      throw new TypeError("Invalid resetTtl value");
    }
    return new LRU(max, ttl, resetTtl);
  }

  // node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  "use strict";
  var genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings = {
    willReadFrequently: true
  };
  var _CanvasTextMetrics = class _CanvasTextMetrics2 {
    static get experimentalLetterSpacingSupported() {
      let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
      if (result === void 0) {
        const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
        result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
      }
      return result;
    }
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
      const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
      if (_CanvasTextMetrics2._measurementCache.has(textKey)) {
        return _CanvasTextMetrics2._measurementCache.get(textKey);
      }
      const font = fontStringFromTextStyle(style);
      const fontProperties = _CanvasTextMetrics2.measureFont(font);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = style.fontSize;
        fontProperties.ascent = style.fontSize;
      }
      const context4 = _CanvasTextMetrics2.__context;
      context4.font = font;
      const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
      const lines = outputText.split(/(?:\r\n|\r|\n)/);
      const lineWidths = new Array(lines.length);
      let maxLineWidth = 0;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context4);
        lineWidths[i2] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      const strokeWidth = style._stroke?.width || 0;
      let width = maxLineWidth + strokeWidth;
      if (style.dropShadow) {
        width += style.dropShadow.distance;
      }
      const lineHeight = style.lineHeight || fontProperties.fontSize;
      let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
      if (style.dropShadow) {
        height += style.dropShadow.distance;
      }
      const measurements = new _CanvasTextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      _CanvasTextMetrics2._measurementCache.set(textKey, measurements);
      return measurements;
    }
    static _measureText(text, letterSpacing, context4) {
      let useExperimentalLetterSpacing = false;
      if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
        if (_CanvasTextMetrics2.experimentalLetterSpacing) {
          context4.letterSpacing = `${letterSpacing}px`;
          context4.textLetterSpacing = `${letterSpacing}px`;
          useExperimentalLetterSpacing = true;
        } else {
          context4.letterSpacing = "0px";
          context4.textLetterSpacing = "0px";
        }
      }
      const metrics = context4.measureText(text);
      let metricWidth = metrics.width;
      const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
      const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
      let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
      if (metricWidth > 0) {
        if (useExperimentalLetterSpacing) {
          metricWidth -= letterSpacing;
          boundsWidth -= letterSpacing;
        } else {
          const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
          metricWidth += val;
          boundsWidth += val;
        }
      }
      return Math.max(metricWidth, boundsWidth);
    }
    static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
      const context4 = canvas.getContext("2d", contextSettings);
      let width = 0;
      let line = "";
      let lines = "";
      const cache = /* @__PURE__ */ Object.create(null);
      const {letterSpacing, whiteSpace} = style;
      const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
      const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
      let canPrependSpaces = !collapseSpaces;
      const wordWrapWidth = style.wordWrapWidth + letterSpacing;
      const tokens = _CanvasTextMetrics2._tokenize(text);
      for (let i2 = 0; i2 < tokens.length; i2++) {
        let token = tokens[i2];
        if (_CanvasTextMetrics2._isNewline(token)) {
          if (!collapseNewlines) {
            lines += _CanvasTextMetrics2._addLine(line);
            canPrependSpaces = !collapseSpaces;
            line = "";
            width = 0;
            continue;
          }
          token = " ";
        }
        if (collapseSpaces) {
          const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
          const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context4);
        if (tokenWidth > wordWrapWidth) {
          if (line !== "") {
            lines += _CanvasTextMetrics2._addLine(line);
            line = "";
            width = 0;
          }
          if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
            const characters = _CanvasTextMetrics2.wordWrapSplit(token);
            for (let j2 = 0; j2 < characters.length; j2++) {
              let char = characters[j2];
              let lastChar = char;
              let k2 = 1;
              while (characters[j2 + k2]) {
                const nextChar = characters[j2 + k2];
                if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                  char += nextChar;
                } else {
                  break;
                }
                lastChar = nextChar;
                k2++;
              }
              j2 += k2 - 1;
              const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context4);
              if (characterWidth + width > wordWrapWidth) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
              line += char;
              width += characterWidth;
            }
          } else {
            if (line.length > 0) {
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            const isLastToken = i2 === tokens.length - 1;
            lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
            canPrependSpaces = false;
            line = "";
            width = 0;
          }
        } else {
          if (tokenWidth + width > wordWrapWidth) {
            canPrependSpaces = false;
            lines += _CanvasTextMetrics2._addLine(line);
            line = "";
            width = 0;
          }
          if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
            line += token;
            width += tokenWidth;
          }
        }
      }
      lines += _CanvasTextMetrics2._addLine(line, false);
      return lines;
    }
    static _addLine(line, newLine = true) {
      line = _CanvasTextMetrics2._trimRight(line);
      line = newLine ? `${line}
` : line;
      return line;
    }
    static _getFromCache(key, letterSpacing, cache, context4) {
      let width = cache[key];
      if (typeof width !== "number") {
        width = _CanvasTextMetrics2._measureText(key, letterSpacing, context4) + letterSpacing;
        cache[key] = width;
      }
      return width;
    }
    static _collapseSpaces(whiteSpace) {
      return whiteSpace === "normal" || whiteSpace === "pre-line";
    }
    static _collapseNewlines(whiteSpace) {
      return whiteSpace === "normal";
    }
    static _trimRight(text) {
      if (typeof text !== "string") {
        return "";
      }
      for (let i2 = text.length - 1; i2 >= 0; i2--) {
        const char = text[i2];
        if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
          break;
        }
        text = text.slice(0, -1);
      }
      return text;
    }
    static _isNewline(char) {
      if (typeof char !== "string") {
        return false;
      }
      return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
    }
    static isBreakingSpace(char, _nextChar) {
      if (typeof char !== "string") {
        return false;
      }
      return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
    }
    static _tokenize(text) {
      const tokens = [];
      let token = "";
      if (typeof text !== "string") {
        return tokens;
      }
      for (let i2 = 0; i2 < text.length; i2++) {
        const char = text[i2];
        const nextChar = text[i2 + 1];
        if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
          if (token !== "") {
            tokens.push(token);
            token = "";
          }
          if (char === "\r" && nextChar === "\n") {
            tokens.push("\r\n");
            i2++;
          } else {
            tokens.push(char);
          }
          continue;
        }
        token += char;
      }
      if (token !== "") {
        tokens.push(token);
      }
      return tokens;
    }
    static canBreakWords(_token, breakWords) {
      return breakWords;
    }
    static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
      return true;
    }
    static wordWrapSplit(token) {
      return _CanvasTextMetrics2.graphemeSegmenter(token);
    }
    static measureFont(font) {
      if (_CanvasTextMetrics2._fonts[font]) {
        return _CanvasTextMetrics2._fonts[font];
      }
      const context4 = _CanvasTextMetrics2._context;
      context4.font = font;
      const metrics = context4.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
      const properties = {
        ascent: metrics.actualBoundingBoxAscent,
        descent: metrics.actualBoundingBoxDescent,
        fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
      };
      _CanvasTextMetrics2._fonts[font] = properties;
      return properties;
    }
    static clearMetrics(font = "") {
      if (font) {
        delete _CanvasTextMetrics2._fonts[font];
      } else {
        _CanvasTextMetrics2._fonts = {};
      }
    }
    static get _canvas() {
      if (!_CanvasTextMetrics2.__canvas) {
        let canvas;
        try {
          const c2 = new OffscreenCanvas(0, 0);
          const context4 = c2.getContext("2d", contextSettings);
          if (context4?.measureText) {
            _CanvasTextMetrics2.__canvas = c2;
            return c2;
          }
          canvas = DOMAdapter.get().createCanvas();
        } catch (_cx) {
          canvas = DOMAdapter.get().createCanvas();
        }
        canvas.width = canvas.height = 10;
        _CanvasTextMetrics2.__canvas = canvas;
      }
      return _CanvasTextMetrics2.__canvas;
    }
    static get _context() {
      if (!_CanvasTextMetrics2.__context) {
        _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
      }
      return _CanvasTextMetrics2.__context;
    }
  };
  _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
  _CanvasTextMetrics.BASELINE_SYMBOL = "M";
  _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
  _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
  _CanvasTextMetrics.graphemeSegmenter = (() => {
    if (typeof Intl?.Segmenter === "function") {
      const segmenter = new Intl.Segmenter();
      return (s2) => {
        const segments = segmenter.segment(s2);
        const result = [];
        let i2 = 0;
        for (const segment of segments) {
          result[i2++] = segment.segment;
        }
        return result;
      };
    }
    return (s2) => [...s2];
  })();
  _CanvasTextMetrics.experimentalLetterSpacing = false;
  _CanvasTextMetrics._fonts = {};
  _CanvasTextMetrics._newlines = [
    10,
    13
  ];
  _CanvasTextMetrics._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  _CanvasTextMetrics._measurementCache = lru(1e3);
  var CanvasTextMetrics = _CanvasTextMetrics;

  // node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  var PRECISION = 1e5;
  function getCanvasFillStyle(fillStyle, context4, textMetrics, padding = 0) {
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    } else if (!fillStyle.fill) {
      const pattern = context4.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix7 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix7.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern.setTransform(tempMatrix7);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context4.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix7 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix7.scale(fillPattern.texture.frame.width, fillPattern.texture.frame.height);
      pattern.setTransform(tempMatrix7);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      const isLinear = fillGradient.type === "linear";
      const isLocal = fillGradient.textureSpace === "local";
      let width = 1;
      let height = 1;
      if (isLocal && textMetrics) {
        width = textMetrics.width + padding;
        height = textMetrics.height + padding;
      }
      let gradient;
      let isNearlyVertical = false;
      if (isLinear) {
        const {start, end} = fillGradient;
        gradient = context4.createLinearGradient(start.x * width, start.y * height, end.x * width, end.y * height);
        isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
      } else {
        const {center, innerRadius, outerCenter, outerRadius} = fillGradient;
        gradient = context4.createRadialGradient(center.x * width, center.y * height, innerRadius * width, outerCenter.x * width, outerCenter.y * height, outerRadius * width);
      }
      if (isNearlyVertical && isLocal && textMetrics) {
        const ratio = textMetrics.lineHeight / height;
        for (let i2 = 0; i2 < textMetrics.lines.length; i2++) {
          const start = (i2 * textMetrics.lineHeight + padding / 2) / height;
          fillGradient.colorStops.forEach((stop) => {
            const globalStop = start + stop.offset * ratio;
            gradient.addColorStop(Math.floor(globalStop * PRECISION) / PRECISION, Color.shared.setValue(stop.color).toHex());
          });
        }
      } else {
        fillGradient.colorStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
      }
      return gradient;
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs
  var tempRect4 = new Rectangle();
  var CanvasTextGeneratorClass = class {
    getCanvasAndContext(options) {
      const {text, style, resolution = 1} = options;
      const padding = style._getFinalPadding();
      const measured = CanvasTextMetrics.measureText(text || " ", style);
      const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution);
      const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution);
      const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
      this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);
      const frame = style.trim ? getCanvasBoundingBox({canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect4}) : tempRect4.set(0, 0, width, height);
      return {
        canvasAndContext,
        frame
      };
    }
    returnCanvasAndContext(canvasAndContext) {
      CanvasPool.returnCanvasAndContext(canvasAndContext);
    }
    _renderTextToCanvas(text, style, padding, resolution, canvasAndContext) {
      const {canvas, context: context4} = canvasAndContext;
      const font = fontStringFromTextStyle(style);
      const measured = CanvasTextMetrics.measureText(text || " ", style);
      const lines = measured.lines;
      const lineHeight = measured.lineHeight;
      const lineWidths = measured.lineWidths;
      const maxLineWidth = measured.maxLineWidth;
      const fontProperties = measured.fontProperties;
      const height = canvas.height;
      context4.resetTransform();
      context4.scale(resolution, resolution);
      context4.textBaseline = style.textBaseline;
      if (style._stroke?.width) {
        const strokeStyle = style._stroke;
        context4.lineWidth = strokeStyle.width;
        context4.miterLimit = strokeStyle.miterLimit;
        context4.lineJoin = strokeStyle.join;
        context4.lineCap = strokeStyle.cap;
      }
      context4.font = font;
      let linePositionX;
      let linePositionY;
      const passesCount = style.dropShadow ? 2 : 1;
      for (let i2 = 0; i2 < passesCount; ++i2) {
        const isShadowPass = style.dropShadow && i2 === 0;
        const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
        const dsOffsetShadow = dsOffsetText * resolution;
        if (isShadowPass) {
          context4.fillStyle = "black";
          context4.strokeStyle = "black";
          const shadowOptions = style.dropShadow;
          const dropShadowColor = shadowOptions.color;
          const dropShadowAlpha = shadowOptions.alpha;
          context4.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context4.shadowBlur = dropShadowBlur;
          context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
        } else {
          context4.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context4, measured, padding * 2) : null;
          if (style._stroke?.width) {
            const strokePadding = style._stroke.width * 0.5 + padding * 2;
            context4.strokeStyle = getCanvasFillStyle(style._stroke, context4, measured, strokePadding);
          }
          context4.shadowColor = "black";
        }
        let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
        if (lineHeight - fontProperties.fontSize < 0) {
          linePositionYShift = 0;
        }
        const strokeWidth = style._stroke?.width ?? 0;
        for (let i22 = 0; i22 < lines.length; i22++) {
          linePositionX = strokeWidth / 2;
          linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
          if (style.align === "right") {
            linePositionX += maxLineWidth - lineWidths[i22];
          } else if (style.align === "center") {
            linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
          }
          if (style._stroke?.width) {
            this._drawLetterSpacing(lines[i22], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText, true);
          }
          if (style._fill !== void 0) {
            this._drawLetterSpacing(lines[i22], style, canvasAndContext, linePositionX + padding, linePositionY + padding - dsOffsetText);
          }
        }
      }
    }
    _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
      const {context: context4} = canvasAndContext;
      const letterSpacing = style.letterSpacing;
      let useExperimentalLetterSpacing = false;
      if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
        if (CanvasTextMetrics.experimentalLetterSpacing) {
          context4.letterSpacing = `${letterSpacing}px`;
          context4.textLetterSpacing = `${letterSpacing}px`;
          useExperimentalLetterSpacing = true;
        } else {
          context4.letterSpacing = "0px";
          context4.textLetterSpacing = "0px";
        }
      }
      if (letterSpacing === 0 || useExperimentalLetterSpacing) {
        if (isStroke) {
          context4.strokeText(text, x2, y2);
        } else {
          context4.fillText(text, x2, y2);
        }
        return;
      }
      let currentPosition = x2;
      const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
      let previousWidth = context4.measureText(text).width;
      let currentWidth = 0;
      for (let i2 = 0; i2 < stringArray.length; ++i2) {
        const currentChar = stringArray[i2];
        if (isStroke) {
          context4.strokeText(currentChar, currentPosition, y2);
        } else {
          context4.fillText(currentChar, currentPosition, y2);
        }
        let textStr = "";
        for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
          textStr += stringArray[j2];
        }
        currentWidth = context4.measureText(textStr).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
    }
  };
  var CanvasTextGenerator = new CanvasTextGeneratorClass();

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem = class {
    constructor(_renderer) {
      this._activeTextures = {};
      this._renderer = _renderer;
    }
    getTexture(options, _resolution, _style, _textKey) {
      if (typeof options === "string") {
        deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
        options = {
          text: options,
          style: _style,
          resolution: _resolution
        };
      }
      if (!(options.style instanceof TextStyle)) {
        options.style = new TextStyle(options.style);
      }
      if (!(options.textureStyle instanceof TextureStyle)) {
        options.textureStyle = new TextureStyle(options.textureStyle);
      }
      if (typeof options.text !== "string") {
        options.text = options.text.toString();
      }
      const {text, style, textureStyle} = options;
      const resolution = options.resolution ?? this._renderer.resolution;
      const {frame, canvasAndContext} = CanvasTextGenerator.getCanvasAndContext({
        text,
        style,
        resolution
      });
      const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);
      if (textureStyle)
        texture.source.style = textureStyle;
      if (style.trim) {
        frame.pad(style.padding);
        texture.frame.copyFrom(frame);
        texture.frame.scale(1 / resolution);
        texture.updateUvs();
      }
      if (style.filters) {
        const filteredTexture = this._applyFilters(texture, style.filters);
        this.returnTexture(texture);
        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
        return filteredTexture;
      }
      this._renderer.texture.initSource(texture._source);
      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
      return texture;
    }
    returnTexture(texture) {
      const source3 = texture.source;
      source3.resource = null;
      source3.uploadMethodId = "unknown";
      source3.alphaMode = "no-premultiply-alpha";
      TexturePool.returnTexture(texture, true);
    }
    renderTextToCanvas() {
      deprecation("8.10.0", "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead");
    }
    getManagedTexture(text) {
      text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
      const textKey = text.styleKey;
      if (this._activeTextures[textKey]) {
        this._increaseReferenceCount(textKey);
        return this._activeTextures[textKey].texture;
      }
      const texture = this.getTexture({
        text: text.text,
        style: text.style,
        resolution: text._resolution,
        textureStyle: text.textureStyle
      });
      this._activeTextures[textKey] = {
        texture,
        usageCount: 1
      };
      return texture;
    }
    decreaseReferenceCount(textKey) {
      const activeTexture = this._activeTextures[textKey];
      activeTexture.usageCount--;
      if (activeTexture.usageCount === 0) {
        this.returnTexture(activeTexture.texture);
        this._activeTextures[textKey] = null;
      }
    }
    getReferenceCount(textKey) {
      return this._activeTextures[textKey]?.usageCount ?? 0;
    }
    _increaseReferenceCount(textKey) {
      this._activeTextures[textKey].usageCount++;
    }
    _applyFilters(texture, filters) {
      const currentRenderTarget = this._renderer.renderTarget.renderTarget;
      const resultTexture = this._renderer.filter.generateFilteredTexture({
        texture,
        filters
      });
      this._renderer.renderTarget.bind(currentRenderTarget, false);
      return resultTexture;
    }
    destroy() {
      this._renderer = null;
      for (const key in this._activeTextures) {
        if (this._activeTextures[key])
          this.returnTexture(this._activeTextures[key].texture);
      }
      this._activeTextures = null;
    }
  };
  CanvasTextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "canvasText"
  };

  // node_modules/pixi.js/lib/scene/text/init.mjs
  extensions.add(CanvasTextSystem);
  extensions.add(CanvasTextPipe);

  // node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
  var Graphics = class extends ViewContainer {
    constructor(options) {
      if (options instanceof GraphicsContext) {
        options = {context: options};
      }
      const {context: context4, roundPixels, ...rest} = options || {};
      super({
        label: "Graphics",
        ...rest
      });
      this.renderPipeId = "graphics";
      if (!context4) {
        this._context = this._ownedContext = new GraphicsContext();
      } else {
        this._context = context4;
      }
      this._context.on("update", this.onViewUpdate, this);
      this.didViewUpdate = true;
      this.allowChildren = false;
      this.roundPixels = roundPixels ?? false;
    }
    set context(context4) {
      if (context4 === this._context)
        return;
      this._context.off("update", this.onViewUpdate, this);
      this._context = context4;
      this._context.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {
    }
    containsPoint(point) {
      return this._context.containsPoint(point);
    }
    destroy(options) {
      if (this._ownedContext && !options) {
        this._ownedContext.destroy(options);
      } else if (options === true || options?.context === true) {
        this._context.destroy(options);
      }
      this._ownedContext = null;
      this._context = null;
      super.destroy(options);
    }
    _callContextMethod(method, args) {
      this.context[method](...args);
      return this;
    }
    setFillStyle(...args) {
      return this._callContextMethod("setFillStyle", args);
    }
    setStrokeStyle(...args) {
      return this._callContextMethod("setStrokeStyle", args);
    }
    fill(...args) {
      return this._callContextMethod("fill", args);
    }
    stroke(...args) {
      return this._callContextMethod("stroke", args);
    }
    texture(...args) {
      return this._callContextMethod("texture", args);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...args) {
      return this._callContextMethod("arc", args);
    }
    arcTo(...args) {
      return this._callContextMethod("arcTo", args);
    }
    arcToSvg(...args) {
      return this._callContextMethod("arcToSvg", args);
    }
    bezierCurveTo(...args) {
      return this._callContextMethod("bezierCurveTo", args);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...args) {
      return this._callContextMethod("ellipse", args);
    }
    circle(...args) {
      return this._callContextMethod("circle", args);
    }
    path(...args) {
      return this._callContextMethod("path", args);
    }
    lineTo(...args) {
      return this._callContextMethod("lineTo", args);
    }
    moveTo(...args) {
      return this._callContextMethod("moveTo", args);
    }
    quadraticCurveTo(...args) {
      return this._callContextMethod("quadraticCurveTo", args);
    }
    rect(...args) {
      return this._callContextMethod("rect", args);
    }
    roundRect(...args) {
      return this._callContextMethod("roundRect", args);
    }
    poly(...args) {
      return this._callContextMethod("poly", args);
    }
    regularPoly(...args) {
      return this._callContextMethod("regularPoly", args);
    }
    roundPoly(...args) {
      return this._callContextMethod("roundPoly", args);
    }
    roundShape(...args) {
      return this._callContextMethod("roundShape", args);
    }
    filletRect(...args) {
      return this._callContextMethod("filletRect", args);
    }
    chamferRect(...args) {
      return this._callContextMethod("chamferRect", args);
    }
    star(...args) {
      return this._callContextMethod("star", args);
    }
    svg(...args) {
      return this._callContextMethod("svg", args);
    }
    restore(...args) {
      return this._callContextMethod("restore", args);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...args) {
      return this._callContextMethod("rotate", args);
    }
    scaleTransform(...args) {
      return this._callContextMethod("scale", args);
    }
    setTransform(...args) {
      return this._callContextMethod("setTransform", args);
    }
    transform(...args) {
      return this._callContextMethod("transform", args);
    }
    translateTransform(...args) {
      return this._callContextMethod("translate", args);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(value) {
      this._context.fillStyle = value;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(value) {
      this._context.strokeStyle = value;
    }
    clone(deep = false) {
      if (deep) {
        return new Graphics(this._context.clone());
      }
      this._ownedContext = null;
      const clone = new Graphics(this._context);
      return clone;
    }
    lineStyle(width, color, alpha) {
      deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const strokeStyle = {};
      width && (strokeStyle.width = width);
      color && (strokeStyle.color = color);
      alpha && (strokeStyle.alpha = alpha);
      this.context.strokeStyle = strokeStyle;
      return this;
    }
    beginFill(color, alpha) {
      deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const fillStyle = {};
      if (color !== void 0)
        fillStyle.color = color;
      if (alpha !== void 0)
        fillStyle.alpha = alpha;
      this.context.fillStyle = fillStyle;
      return this;
    }
    endFill() {
      deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      this.context.fill();
      const strokeStyle = this.context.strokeStyle;
      if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
        this.context.stroke();
      }
      return this;
    }
    drawCircle(...args) {
      deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
      return this._callContextMethod("circle", args);
    }
    drawEllipse(...args) {
      deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
      return this._callContextMethod("ellipse", args);
    }
    drawPolygon(...args) {
      deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
      return this._callContextMethod("poly", args);
    }
    drawRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
      return this._callContextMethod("rect", args);
    }
    drawRoundedRect(...args) {
      deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
      return this._callContextMethod("roundRect", args);
    }
    drawStar(...args) {
      deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
      return this._callContextMethod("star", args);
    }
  };

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  "use strict";
  var localUniformMSDFBit = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    },
    fragment: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
      main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    }
  };
  var localUniformMSDFBitGl = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    },
    fragment: {
      header: `
            uniform float uDistance;
         `,
      main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    }
  };

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  "use strict";
  var mSDFBit = {
    name: "msdf-bit",
    fragment: {
      header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
    }
  };
  var mSDFBitGl = {
    name: "msdf-bit",
    fragment: {
      header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
    }
  };

  // node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
  var gpuProgram;
  var glProgram;
  var SdfShader = class extends Shader {
    constructor(maxTextures) {
      const uniforms = new UniformGroup({
        uColor: {value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>"},
        uTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uDistance: {value: 4, type: "f32"},
        uRound: {value: 0, type: "f32"}
      });
      gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
        name: "sdf-shader",
        bits: [
          colorBit,
          generateTextureBatchBit(maxTextures),
          localUniformMSDFBit,
          mSDFBit,
          roundPixelsBit
        ]
      }));
      glProgram ?? (glProgram = compileHighShaderGlProgram({
        name: "sdf-shader",
        bits: [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          localUniformMSDFBitGl,
          mSDFBitGl,
          roundPixelsBitGl
        ]
      }));
      super({
        glProgram,
        gpuProgram,
        resources: {
          localUniforms: uniforms,
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont = class extends eventemitter3_default {
    constructor() {
      super(...arguments);
      this.chars = /* @__PURE__ */ Object.create(null);
      this.lineHeight = 0;
      this.fontFamily = "";
      this.fontMetrics = {fontSize: 0, ascent: 0, descent: 0};
      this.baseLineOffset = 0;
      this.distanceField = {type: "none", range: 0};
      this.pages = [];
      this.applyFillAsTint = true;
      this.baseMeasurementFontSize = 100;
      this.baseRenderedFontSize = 100;
    }
    get font() {
      deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
      return this.fontFamily;
    }
    get pageTextures() {
      deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
      return this.pages;
    }
    get size() {
      deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
      return this.fontMetrics.fontSize;
    }
    get distanceFieldRange() {
      deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
      return this.distanceField.range;
    }
    get distanceFieldType() {
      deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
      return this.distanceField.type;
    }
    destroy(destroyTextures = false) {
      this.emit("destroy", this);
      this.removeAllListeners();
      for (const i2 in this.chars) {
        this.chars[i2].texture?.destroy();
      }
      this.chars = null;
      if (destroyTextures) {
        this.pages.forEach((page) => page.texture.destroy(true));
        this.pages = null;
      }
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
    constructor(options) {
      super();
      this.resolution = 1;
      this.pages = [];
      this._padding = 0;
      this._measureCache = /* @__PURE__ */ Object.create(null);
      this._currentChars = [];
      this._currentX = 0;
      this._currentY = 0;
      this._currentMaxCharHeight = 0;
      this._currentPageIndex = -1;
      this._skipKerning = false;
      const dynamicOptions = {..._DynamicBitmapFont2.defaultOptions, ...options};
      this._textureSize = dynamicOptions.textureSize;
      this._mipmap = dynamicOptions.mipmap;
      const style = dynamicOptions.style.clone();
      if (dynamicOptions.overrideFill) {
        style._fill.color = 16777215;
        style._fill.alpha = 1;
        style._fill.texture = Texture.WHITE;
        style._fill.fill = null;
      }
      this.applyFillAsTint = dynamicOptions.overrideFill;
      const requestedFontSize = style.fontSize;
      style.fontSize = this.baseMeasurementFontSize;
      const font = fontStringFromTextStyle(style);
      if (dynamicOptions.overrideSize) {
        if (style._stroke) {
          style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
        }
      } else {
        style.fontSize = this.baseRenderedFontSize = requestedFontSize;
      }
      this._style = style;
      this._skipKerning = dynamicOptions.skipKerning ?? false;
      this.resolution = dynamicOptions.resolution ?? 1;
      this._padding = dynamicOptions.padding ?? 4;
      if (dynamicOptions.textureStyle) {
        this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle ? dynamicOptions.textureStyle : new TextureStyle(dynamicOptions.textureStyle);
      }
      this.fontMetrics = CanvasTextMetrics.measureFont(font);
      this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
    }
    ensureCharacters(chars) {
      const charList = CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
      if (!charList.length)
        return;
      this._currentChars = [...this._currentChars, ...charList];
      let pageData;
      if (this._currentPageIndex === -1) {
        pageData = this._nextPage();
      } else {
        pageData = this.pages[this._currentPageIndex];
      }
      let {canvas, context: context4} = pageData.canvasAndContext;
      let textureSource = pageData.texture.source;
      const style = this._style;
      let currentX = this._currentX;
      let currentY = this._currentY;
      let currentMaxCharHeight = this._currentMaxCharHeight;
      const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
      const padding = this._padding * fontScale;
      let skipTexture = false;
      const maxTextureWidth = canvas.width / this.resolution;
      const maxTextureHeight = canvas.height / this.resolution;
      for (let i2 = 0; i2 < charList.length; i2++) {
        const char = charList[i2];
        const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
        metrics.lineHeight = metrics.height;
        const width = metrics.width * fontScale;
        const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        const height = metrics.height * fontScale;
        const paddedWidth = textureGlyphWidth + padding * 2;
        const paddedHeight = height + padding * 2;
        skipTexture = false;
        if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
          skipTexture = true;
          currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
        }
        if (currentX + paddedWidth > maxTextureWidth) {
          currentY += currentMaxCharHeight;
          currentMaxCharHeight = paddedHeight;
          currentX = 0;
          if (currentY + currentMaxCharHeight > maxTextureHeight) {
            textureSource.update();
            const pageData2 = this._nextPage();
            canvas = pageData2.canvasAndContext.canvas;
            context4 = pageData2.canvasAndContext.context;
            textureSource = pageData2.texture.source;
            currentX = 0;
            currentY = 0;
            currentMaxCharHeight = 0;
          }
        }
        const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
        this.chars[char] = {
          id: char.codePointAt(0),
          xOffset: -this._padding,
          yOffset: -this._padding,
          xAdvance,
          kerning: {}
        };
        if (skipTexture) {
          this._drawGlyph(context4, metrics, currentX + padding, currentY + padding, fontScale, style);
          const px = textureSource.width * fontScale;
          const py = textureSource.height * fontScale;
          const frame = new Rectangle(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);
          this.chars[char].texture = new Texture({
            source: textureSource,
            frame
          });
          currentX += Math.ceil(paddedWidth);
        }
      }
      textureSource.update();
      this._currentX = currentX;
      this._currentY = currentY;
      this._currentMaxCharHeight = currentMaxCharHeight;
      this._skipKerning && this._applyKerning(charList, context4);
    }
    get pageTextures() {
      deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
      return this.pages;
    }
    _applyKerning(newChars, context4) {
      const measureCache = this._measureCache;
      for (let i2 = 0; i2 < newChars.length; i2++) {
        const first = newChars[i2];
        for (let j2 = 0; j2 < this._currentChars.length; j2++) {
          const second = this._currentChars[j2];
          let c1 = measureCache[first];
          if (!c1)
            c1 = measureCache[first] = context4.measureText(first).width;
          let c2 = measureCache[second];
          if (!c2)
            c2 = measureCache[second] = context4.measureText(second).width;
          let total = context4.measureText(first + second).width;
          let amount = total - (c1 + c2);
          if (amount) {
            this.chars[first].kerning[second] = amount;
          }
          total = context4.measureText(first + second).width;
          amount = total - (c1 + c2);
          if (amount) {
            this.chars[second].kerning[first] = amount;
          }
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      const textureResolution = this.resolution;
      const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);
      this._setupContext(canvasAndContext.context, this._style, textureResolution);
      const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
      const texture = new Texture({
        source: new ImageSource({
          resource: canvasAndContext.canvas,
          resolution,
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: this._mipmap
        })
      });
      if (this._textureStyle) {
        texture.source.style = this._textureStyle;
      }
      const pageData = {
        canvasAndContext,
        texture
      };
      this.pages[this._currentPageIndex] = pageData;
      return pageData;
    }
    _setupContext(context4, style, resolution) {
      style.fontSize = this.baseRenderedFontSize;
      context4.scale(resolution, resolution);
      context4.font = fontStringFromTextStyle(style);
      style.fontSize = this.baseMeasurementFontSize;
      context4.textBaseline = style.textBaseline;
      const stroke = style._stroke;
      const strokeThickness = stroke?.width ?? 0;
      if (stroke) {
        context4.lineWidth = strokeThickness;
        context4.lineJoin = stroke.join;
        context4.miterLimit = stroke.miterLimit;
        context4.strokeStyle = getCanvasFillStyle(stroke, context4);
      }
      if (style._fill) {
        context4.fillStyle = getCanvasFillStyle(style._fill, context4);
      }
      if (style.dropShadow) {
        const shadowOptions = style.dropShadow;
        const rgb = Color.shared.setValue(shadowOptions.color).toArray();
        const dropShadowBlur = shadowOptions.blur * resolution;
        const dropShadowDistance = shadowOptions.distance * resolution;
        context4.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
        context4.shadowBlur = dropShadowBlur;
        context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
        context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
      } else {
        context4.shadowColor = "black";
        context4.shadowBlur = 0;
        context4.shadowOffsetX = 0;
        context4.shadowOffsetY = 0;
      }
    }
    _drawGlyph(context4, metrics, x2, y2, fontScale, style) {
      const char = metrics.text;
      const fontProperties = metrics.fontProperties;
      const stroke = style._stroke;
      const strokeThickness = (stroke?.width ?? 0) * fontScale;
      const tx = x2 + strokeThickness / 2;
      const ty = y2 - strokeThickness / 2;
      const descent = fontProperties.descent * fontScale;
      const lineHeight = metrics.lineHeight * fontScale;
      let removeShadow = false;
      if (style.stroke && strokeThickness) {
        removeShadow = true;
        context4.strokeText(char, tx, ty + lineHeight - descent);
      }
      const {shadowBlur, shadowOffsetX, shadowOffsetY} = context4;
      if (style._fill) {
        if (removeShadow) {
          context4.shadowBlur = 0;
          context4.shadowOffsetX = 0;
          context4.shadowOffsetY = 0;
        }
        context4.fillText(char, tx, ty + lineHeight - descent);
      }
      if (removeShadow) {
        context4.shadowBlur = shadowBlur;
        context4.shadowOffsetX = shadowOffsetX;
        context4.shadowOffsetY = shadowOffsetY;
      }
    }
    destroy() {
      super.destroy();
      for (let i2 = 0; i2 < this.pages.length; i2++) {
        const {canvasAndContext, texture} = this.pages[i2];
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        texture.destroy(true);
      }
      this.pages = null;
    }
  };
  _DynamicBitmapFont.defaultOptions = {
    textureSize: 512,
    style: new TextStyle(),
    mipmap: true
  };
  var DynamicBitmapFont = _DynamicBitmapFont;

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  "use strict";
  function getBitmapTextLayout(chars, style, font, trimEnd) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      positions: [],
      chars: []
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
    const breakWords = style.wordWrap && style.breakWords;
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index];
        while (lastChar === " ") {
          currentLine.width -= font.chars[lastChar].xAdvance;
          lastChar = currentLine.chars[--index];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += adjustedLineHeight;
    };
    const checkIsOverflow = (lineWidth) => lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
    for (let i2 = 0; i2 < chars.length + 1; i2++) {
      let char;
      const isEnd = i2 === chars.length;
      if (!isEnd) {
        char = chars[i2];
      }
      const charData = font.chars[char] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          nextLine();
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
        if (addWordToNextLine) {
          nextWord(currentWord);
          nextLine();
        }
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  "use strict";
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
  var fontCount = 0;
  var BitmapFontManagerClass = class {
    constructor() {
      this.ALPHA = [["a", "z"], ["A", "Z"], " "];
      this.NUMERIC = [["0", "9"]];
      this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      this.ASCII = [[" ", "~"]];
      this.defaultOptions = {
        chars: this.ALPHANUMERIC,
        resolution: 1,
        padding: 4,
        skipKerning: false,
        textureStyle: null
      };
      this.measureCache = lru(1e3);
    }
    getFont(text, style) {
      let fontFamilyKey = `${style.fontFamily}-bitmap`;
      let overrideFill = true;
      if (style._fill.fill && !style._stroke) {
        fontFamilyKey += style._fill.fill.styleKey;
        overrideFill = false;
      } else if (style._stroke || style.dropShadow) {
        fontFamilyKey = `${style.styleKey}-bitmap`;
        overrideFill = false;
      }
      if (!Cache.has(fontFamilyKey)) {
        const styleCopy = Object.create(style);
        styleCopy.lineHeight = 0;
        const fnt = new DynamicBitmapFont({
          style: styleCopy,
          overrideFill,
          overrideSize: true,
          ...this.defaultOptions
        });
        fontCount++;
        if (fontCount > 50) {
          warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
        }
        fnt.once("destroy", () => {
          fontCount--;
          Cache.remove(fontFamilyKey);
        });
        Cache.set(fontFamilyKey, fnt);
      }
      const dynamicFont = Cache.get(fontFamilyKey);
      dynamicFont.ensureCharacters?.(text);
      return dynamicFont;
    }
    getLayout(text, style, trimEnd = true) {
      const bitmapFont = this.getFont(text, style);
      const id = `${text}-${style.styleKey}-${trimEnd}`;
      if (this.measureCache.has(id)) {
        return this.measureCache.get(id);
      }
      const segments = CanvasTextMetrics.graphemeSegmenter(text);
      const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);
      this.measureCache.set(id, layoutData);
      return layoutData;
    }
    measureText(text, style, trimEnd = true) {
      return this.getLayout(text, style, trimEnd);
    }
    install(...args) {
      let options = args[0];
      if (typeof options === "string") {
        options = {
          name: options,
          style: args[1],
          chars: args[2]?.chars,
          resolution: args[2]?.resolution,
          padding: args[2]?.padding,
          skipKerning: args[2]?.skipKerning
        };
        deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
      }
      const name = options?.name;
      if (!name) {
        throw new Error("[BitmapFontManager] Property `name` is required.");
      }
      options = {...this.defaultOptions, ...options};
      const textStyle = options.style;
      const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
      const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);
      const font = new DynamicBitmapFont({
        style,
        overrideFill,
        skipKerning: options.skipKerning,
        padding: options.padding,
        resolution: options.resolution,
        overrideSize: false,
        textureStyle: options.textureStyle
      });
      const flatChars = resolveCharacters(options.chars);
      font.ensureCharacters(flatChars.join(""));
      Cache.set(`${name}-bitmap`, font);
      font.once("destroy", () => Cache.remove(`${name}-bitmap`));
      return font;
    }
    uninstall(name) {
      const cacheKey = `${name}-bitmap`;
      const font = Cache.get(cacheKey);
      if (font) {
        font.destroy();
      }
    }
    _canUseTintForStyle(style) {
      return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
    }
  };
  var BitmapFontManager = new BitmapFontManagerClass();

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
  var BitmapTextGraphics = class extends Graphics {
    destroy() {
      if (this.context.customShader) {
        this.context.customShader.destroy();
      }
      super.destroy();
    }
  };
  var BitmapTextPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    validateRenderable(bitmapText) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
    }
    addRenderable(bitmapText, instructionSet) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      syncWithProxy(bitmapText, graphicsRenderable);
      if (bitmapText._didTextUpdate) {
        bitmapText._didTextUpdate = false;
        this._updateContext(bitmapText, graphicsRenderable);
      }
      this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
      if (graphicsRenderable.context.customShader) {
        this._updateDistanceField(bitmapText);
      }
    }
    updateRenderable(bitmapText) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      syncWithProxy(bitmapText, graphicsRenderable);
      this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
      if (graphicsRenderable.context.customShader) {
        this._updateDistanceField(bitmapText);
      }
    }
    _updateContext(bitmapText, proxyGraphics) {
      const {context: context4} = proxyGraphics;
      const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
      context4.clear();
      if (bitmapFont.distanceField.type !== "none") {
        if (!context4.customShader) {
          context4.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);
        }
      }
      const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);
      const style = bitmapText._style;
      let currentY = bitmapFont.baseLineOffset;
      const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
      const padding = style.padding;
      const scale = bitmapTextLayout.scale;
      let tx = bitmapTextLayout.width;
      let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
      if (style._stroke) {
        tx += style._stroke.width / scale;
        ty += style._stroke.width / scale;
      }
      context4.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
      const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
      let fontSize = bitmapFont.fontMetrics.fontSize;
      let lineHeight = bitmapFont.lineHeight;
      if (style.lineHeight) {
        fontSize = style.fontSize / scale;
        lineHeight = style.lineHeight / scale;
      }
      let linePositionYShift = (lineHeight - fontSize) / 2;
      if (linePositionYShift - bitmapFont.baseLineOffset < 0) {
        linePositionYShift = 0;
      }
      for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
        const line = bitmapTextLayout.lines[i2];
        for (let j2 = 0; j2 < line.charPositions.length; j2++) {
          const char = line.chars[j2];
          const charData = bitmapFont.chars[char];
          if (charData?.texture) {
            const texture = charData.texture;
            context4.texture(texture, tint ? tint : "black", Math.round(line.charPositions[j2] + charData.xOffset), Math.round(currentY + charData.yOffset + linePositionYShift), texture.orig.width, texture.orig.height);
          }
        }
        currentY += lineHeight;
      }
    }
    _getGpuBitmapText(bitmapText) {
      return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);
    }
    initGpuText(bitmapText) {
      const proxyRenderable = new BitmapTextGraphics();
      bitmapText._gpuData[this._renderer.uid] = proxyRenderable;
      this._updateContext(bitmapText, proxyRenderable);
      return proxyRenderable;
    }
    _updateDistanceField(bitmapText) {
      const context4 = this._getGpuBitmapText(bitmapText).context;
      const fontFamily = bitmapText._style.fontFamily;
      const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
      const {a: a2, b: b2, c: c2, d: d2} = bitmapText.groupTransform;
      const dx2 = Math.sqrt(a2 * a2 + b2 * b2);
      const dy2 = Math.sqrt(c2 * c2 + d2 * d2);
      const worldScale = (Math.abs(dx2) + Math.abs(dy2)) / 2;
      const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
      const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
      context4.customShader.resources.localUniforms.uniforms.uDistance = distance;
    }
    destroy() {
      this._renderer = null;
    }
  };
  BitmapTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "bitmapText"
  };
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }

  // node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
  extensions.add(BitmapTextPipe);

  // node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs
  var BatchableHTMLText = class extends BatchableSprite {
    constructor(renderer) {
      super();
      this.generatingTexture = false;
      this.currentKey = "--";
      this._renderer = renderer;
      renderer.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const text = this.renderable;
      if (text._autoResolution) {
        text.onViewUpdate();
      }
    }
    destroy() {
      const {htmlText} = this._renderer;
      htmlText.getReferenceCount(this.currentKey) === null ? htmlText.returnTexturePromise(this.texturePromise) : htmlText.decreaseReferenceCount(this.currentKey);
      this._renderer.runners.resolutionChange.remove(this);
      this.texturePromise = null;
      this._renderer = null;
    }
  };

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    validateRenderable(htmlText) {
      const gpuText = this._getGpuText(htmlText);
      const newKey = htmlText.styleKey;
      if (gpuText.currentKey !== newKey) {
        return true;
      }
      return false;
    }
    addRenderable(htmlText, instructionSet) {
      const batchableHTMLText = this._getGpuText(htmlText);
      if (htmlText._didTextUpdate) {
        const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {
          this._updateGpuText(htmlText).catch((e2) => {
            console.error(e2);
          });
        }
        htmlText._didTextUpdate = false;
        updateTextBounds(batchableHTMLText, htmlText);
      }
      this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);
    }
    updateRenderable(htmlText) {
      const batchableHTMLText = this._getGpuText(htmlText);
      batchableHTMLText._batcher.updateElement(batchableHTMLText);
    }
    async _updateGpuText(htmlText) {
      htmlText._didTextUpdate = false;
      const batchableHTMLText = this._getGpuText(htmlText);
      if (batchableHTMLText.generatingTexture)
        return;
      const oldTexturePromise = batchableHTMLText.texturePromise;
      batchableHTMLText.texturePromise = null;
      batchableHTMLText.generatingTexture = true;
      htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
      let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);
      if (oldTexturePromise) {
        texturePromise = texturePromise.finally(() => {
          this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);
          this._renderer.htmlText.returnTexturePromise(oldTexturePromise);
        });
      }
      batchableHTMLText.texturePromise = texturePromise;
      batchableHTMLText.currentKey = htmlText.styleKey;
      batchableHTMLText.texture = await texturePromise;
      const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      batchableHTMLText.generatingTexture = false;
      updateTextBounds(batchableHTMLText, htmlText);
    }
    _getGpuText(htmlText) {
      return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);
    }
    initGpuText(htmlText) {
      const batchableHTMLText = new BatchableHTMLText(this._renderer);
      batchableHTMLText.renderable = htmlText;
      batchableHTMLText.transform = htmlText.groupTransform;
      batchableHTMLText.texture = Texture.EMPTY;
      batchableHTMLText.bounds = {minX: 0, maxX: 1, minY: 0, maxY: 0};
      batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
      htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
      htmlText._gpuData[this._renderer.uid] = batchableHTMLText;
      return batchableHTMLText;
    }
    destroy() {
      this._renderer = null;
    }
  };
  HTMLTextPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "htmlText"
  };

  // node_modules/pixi.js/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const {userAgent} = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg = "http://www.w3.org/2000/svg";
  var nsxhtml = "http://www.w3.org/1999/xhtml";
  var HTMLTextRenderData = class {
    constructor() {
      this.svgRoot = document.createElementNS(nssvg, "svg");
      this.foreignObject = document.createElementNS(nssvg, "foreignObject");
      this.domElement = document.createElementNS(nsxhtml, "div");
      this.styleElement = document.createElementNS(nsxhtml, "style");
      const {foreignObject, svgRoot, styleElement, domElement} = this;
      foreignObject.setAttribute("width", "10000");
      foreignObject.setAttribute("height", "10000");
      foreignObject.style.overflow = "hidden";
      svgRoot.appendChild(foreignObject);
      foreignObject.appendChild(styleElement);
      foreignObject.appendChild(domElement);
      this.image = DOMAdapter.get().createImage();
    }
    destroy() {
      this.svgRoot.remove();
      this.foreignObject.remove();
      this.styleElement.remove();
      this.domElement.remove();
      this.image.src = "";
      this.image.remove();
      this.svgRoot = null;
      this.foreignObject = null;
      this.styleElement = null;
      this.domElement = null;
      this.image = null;
      this.canvasAndContext = null;
    }
  };

  // node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
  "use strict";
  function extractFontFamilies(text, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i2 = 0; i2 < fontFamily.length; i2++) {
        addFontFamily(fontFamily[i2]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i2 in style.tagStyles) {
      const fontFamily2 = style.tagStyles[i2].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url) {
    const response = await DOMAdapter.get().fetch(url);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
  async function loadFontCSS(style, url) {
    const dataSrc = await loadFontAsBase64(url);
    return `@font-face {
        font-family: "${style.fontFamily}";
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        src: url('${dataSrc}');
    }`;
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
  var FontStylePromiseCache = /* @__PURE__ */ new Map();
  async function getFontCss(fontFamilies) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const {entries} = Cache.get(`${fontFamily}-and-url`);
        const promises = [];
        entries.forEach((entry) => {
          const url = entry.url;
          const faces = entry.faces;
          const out2 = faces.map((face) => ({weight: face.weight, style: face.style}));
          promises.push(...out2.map((style) => loadFontCSS({
            fontWeight: style.weight,
            fontStyle: style.style,
            fontFamily
          }, url)));
        });
        FontStylePromiseCache.set(fontFamily, Promise.all(promises).then((css) => css.join("\n")));
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
  "use strict";
  function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const {domElement, styleElement, svgRoot} = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const {width, height} = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(image.width, image.height, resolution);
    const {context: context4} = canvasAndContext;
    context4.clearRect(0, 0, image.width, image.height);
    context4.drawImage(image, 0, 0);
    return canvasAndContext;
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
  "use strict";
  function loadSVGImage(image, url, delay) {
    return new Promise(async (resolve) => {
      if (delay) {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
      image.crossOrigin = "anonymous";
    });
  }

  // node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
  var tempHTMLTextRenderData;
  function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));
    const {domElement, styleElement, svgRoot} = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const doublePadding = style.padding * 2;
    return {
      width: contentBounds.width - doublePadding,
      height: contentBounds.height - doublePadding
    };
  }

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem = class {
    constructor(renderer) {
      this._activeTextures = {};
      this._renderer = renderer;
      this._createCanvas = renderer.type === RendererType.WEBGPU;
    }
    getTexture(options) {
      return this.getTexturePromise(options);
    }
    getManagedTexture(text) {
      const textKey = text.styleKey;
      if (this._activeTextures[textKey]) {
        this._increaseReferenceCount(textKey);
        return this._activeTextures[textKey].promise;
      }
      const promise2 = this._buildTexturePromise(text).then((texture) => {
        this._activeTextures[textKey].texture = texture;
        return texture;
      });
      this._activeTextures[textKey] = {
        texture: null,
        promise: promise2,
        usageCount: 1
      };
      return promise2;
    }
    getReferenceCount(textKey) {
      return this._activeTextures[textKey]?.usageCount ?? null;
    }
    _increaseReferenceCount(textKey) {
      this._activeTextures[textKey].usageCount++;
    }
    decreaseReferenceCount(textKey) {
      const activeTexture = this._activeTextures[textKey];
      if (!activeTexture)
        return;
      activeTexture.usageCount--;
      if (activeTexture.usageCount === 0) {
        if (activeTexture.texture) {
          this._cleanUp(activeTexture.texture);
        } else {
          activeTexture.promise.then((texture) => {
            activeTexture.texture = texture;
            this._cleanUp(activeTexture.texture);
          }).catch(() => {
            warn("HTMLTextSystem: Failed to clean texture");
          });
        }
        this._activeTextures[textKey] = null;
      }
    }
    getTexturePromise(options) {
      return this._buildTexturePromise(options);
    }
    async _buildTexturePromise(options) {
      const {text, style, resolution, textureStyle} = options;
      const htmlTextData = BigPool.get(HTMLTextRenderData);
      const fontFamilies = extractFontFamilies(text, style);
      const fontCSS = await getFontCss(fontFamilies);
      const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
      const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
      const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
      const image = htmlTextData.image;
      const uvSafeOffset = 2;
      image.width = (width | 0) + uvSafeOffset;
      image.height = (height | 0) + uvSafeOffset;
      const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
      await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
      const resource = image;
      let canvasAndContext;
      if (this._createCanvas) {
        canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
      }
      const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource, image.width - uvSafeOffset, image.height - uvSafeOffset, resolution);
      if (textureStyle)
        texture.source.style = textureStyle;
      if (this._createCanvas) {
        this._renderer.texture.initSource(texture.source);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
      }
      BigPool.return(htmlTextData);
      return texture;
    }
    returnTexturePromise(texturePromise) {
      texturePromise.then((texture) => {
        this._cleanUp(texture);
      }).catch(() => {
        warn("HTMLTextSystem: Failed to clean texture");
      });
    }
    _cleanUp(texture) {
      TexturePool.returnTexture(texture, true);
      texture.source.resource = null;
      texture.source.uploadMethodId = "unknown";
    }
    destroy() {
      this._renderer = null;
      for (const key in this._activeTextures) {
        if (this._activeTextures[key])
          this.returnTexturePromise(this._activeTextures[key].promise);
      }
      this._activeTextures = null;
    }
  };
  HTMLTextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "htmlText"
  };

  // node_modules/pixi.js/lib/scene/text-html/init.mjs
  extensions.add(HTMLTextSystem);
  extensions.add(HTMLTextPipe);

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry = class _MeshGeometry2 extends Geometry {
    constructor(...args) {
      let options = args[0] ?? {};
      if (options instanceof Float32Array) {
        deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
        options = {
          positions: options,
          uvs: args[1],
          indices: args[2]
        };
      }
      options = {..._MeshGeometry2.defaultOptions, ...options};
      const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      let uvs = options.uvs;
      if (!uvs) {
        if (options.positions) {
          uvs = new Float32Array(positions.length);
        } else {
          uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        }
      }
      const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
      const shrinkToFit = options.shrinkBuffersToFit;
      const positionBuffer = new Buffer2({
        data: positions,
        label: "attribute-mesh-positions",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const uvBuffer = new Buffer2({
        data: uvs,
        label: "attribute-mesh-uvs",
        shrinkToFit,
        usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
      });
      const indexBuffer = new Buffer2({
        data: indices,
        label: "index-mesh-buffer",
        shrinkToFit,
        usage: BufferUsage.INDEX | BufferUsage.COPY_DST
      });
      super({
        attributes: {
          aPosition: {
            buffer: positionBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          },
          aUV: {
            buffer: uvBuffer,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer,
        topology: options.topology
      });
      this.batchMode = "auto";
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(value) {
      this.attributes.aPosition.buffer.data = value;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(value) {
      this.attributes.aUV.buffer.data = value;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(value) {
      this.indexBuffer.data = value;
    }
  };
  _MeshGeometry.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: false
  };
  var MeshGeometry = _MeshGeometry;

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  "use strict";
  var localUniformBit = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    }
  };
  var localUniformBitGroup2 = {
    ...localUniformBit,
    vertex: {
      ...localUniformBit.vertex,
      header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
    }
  };
  var localUniformBitGl = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
      main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
      end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
  "use strict";
  var tilingBit = {
    name: "tiling-bit",
    vertex: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    }
  };
  var tilingBitGl = {
    name: "tiling-bit",
    vertex: {
      header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
      main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    },
    fragment: {
      header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
      main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram2;
  var glProgram2;
  var TilingSpriteShader = class extends Shader {
    constructor() {
      gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
        name: "tiling-sprite-shader",
        bits: [
          localUniformBit,
          tilingBit,
          roundPixelsBit
        ]
      }));
      glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
        name: "tiling-sprite-shader",
        bits: [
          localUniformBitGl,
          tilingBitGl,
          roundPixelsBitGl
        ]
      }));
      const tilingUniforms = new UniformGroup({
        uMapCoord: {value: new Matrix(), type: "mat3x3<f32>"},
        uClampFrame: {value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>"},
        uClampOffset: {value: new Float32Array([0, 0]), type: "vec2<f32>"},
        uTextureTransform: {value: new Matrix(), type: "mat3x3<f32>"},
        uSizeAnchor: {value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>"}
      });
      super({
        glProgram: glProgram2,
        gpuProgram: gpuProgram2,
        resources: {
          localUniforms: new UniformGroup({
            uTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
            uColor: {value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>"},
            uRound: {value: 0, type: "f32"}
          }),
          tilingUniforms,
          uTexture: Texture.EMPTY.source,
          uSampler: Texture.EMPTY.source.style
        }
      });
    }
    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
      const tilingUniforms = this.resources.tilingUniforms;
      const textureWidth = texture.width;
      const textureHeight = texture.height;
      const textureMatrix = texture.textureMatrix;
      const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
      uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);
      uTextureTransform.invert();
      tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
      tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
      tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
      tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
      tilingUniforms.uniforms.uSizeAnchor[0] = width;
      tilingUniforms.uniforms.uSizeAnchor[1] = height;
      tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
      tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
      if (texture) {
        this.resources.uTexture = texture.source;
        this.resources.uSampler = texture.source.style;
      }
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry = class extends MeshGeometry {
    constructor() {
      super({
        positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        indices: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
  "use strict";
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  "use strict";
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite.applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad = new QuadGeometry();
  var TilingSpriteGpuData = class {
    constructor() {
      this.canBatch = true;
      this.geometry = new MeshGeometry({
        indices: sharedQuad.indices.slice(),
        positions: sharedQuad.positions.slice(),
        uvs: sharedQuad.uvs.slice()
      });
    }
    destroy() {
      this.geometry.destroy();
      this.shader?.destroy();
    }
  };
  var TilingSpritePipe = class {
    constructor(renderer) {
      this._state = State.default2d;
      this._renderer = renderer;
    }
    validateRenderable(renderable) {
      const tilingSpriteData = this._getTilingSpriteData(renderable);
      const couldBatch = tilingSpriteData.canBatch;
      this._updateCanBatch(renderable);
      const canBatch = tilingSpriteData.canBatch;
      if (canBatch && canBatch === couldBatch) {
        const {batchableMesh} = tilingSpriteData;
        return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
      }
      return couldBatch !== canBatch;
    }
    addRenderable(tilingSprite, instructionSet) {
      const batcher = this._renderer.renderPipes.batch;
      this._updateCanBatch(tilingSprite);
      const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const {geometry, canBatch} = tilingSpriteData;
      if (canBatch) {
        tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
        const batchableMesh = tilingSpriteData.batchableMesh;
        if (tilingSprite.didViewUpdate) {
          this._updateBatchableMesh(tilingSprite);
          batchableMesh.geometry = geometry;
          batchableMesh.renderable = tilingSprite;
          batchableMesh.transform = tilingSprite.groupTransform;
          batchableMesh.setTexture(tilingSprite._texture);
        }
        batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
        batcher.addToBatch(batchableMesh, instructionSet);
      } else {
        batcher.break(instructionSet);
        tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
        this.updateRenderable(tilingSprite);
        instructionSet.add(tilingSprite);
      }
    }
    execute(tilingSprite) {
      const {shader} = this._getTilingSpriteData(tilingSprite);
      shader.groups[0] = this._renderer.globalUniforms.bindGroup;
      const localUniforms = shader.resources.localUniforms.uniforms;
      localUniforms.uTransformMatrix = tilingSprite.groupTransform;
      localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
      color32BitToUniform(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);
      this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
      this._renderer.encoder.draw({
        geometry: sharedQuad,
        shader,
        state: this._state
      });
    }
    updateRenderable(tilingSprite) {
      const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const {canBatch} = tilingSpriteData;
      if (canBatch) {
        const {batchableMesh} = tilingSpriteData;
        if (tilingSprite.didViewUpdate)
          this._updateBatchableMesh(tilingSprite);
        batchableMesh._batcher.updateElement(batchableMesh);
      } else if (tilingSprite.didViewUpdate) {
        const {shader} = tilingSpriteData;
        shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);
      }
    }
    _getTilingSpriteData(renderable) {
      return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);
    }
    _initTilingSpriteData(tilingSprite) {
      const gpuData = new TilingSpriteGpuData();
      gpuData.renderable = tilingSprite;
      tilingSprite._gpuData[this._renderer.uid] = gpuData;
      return gpuData;
    }
    _updateBatchableMesh(tilingSprite) {
      const renderableData = this._getTilingSpriteData(tilingSprite);
      const {geometry} = renderableData;
      const style = tilingSprite.texture.source.style;
      if (style.addressMode !== "repeat") {
        style.addressMode = "repeat";
        style.update();
      }
      setUvs(tilingSprite, geometry.uvs);
      setPositions(tilingSprite, geometry.positions);
    }
    destroy() {
      this._renderer = null;
    }
    _updateCanBatch(tilingSprite) {
      const renderableData = this._getTilingSpriteData(tilingSprite);
      const texture = tilingSprite.texture;
      let _nonPowOf2wrapping = true;
      if (this._renderer.type === RendererType.WEBGL) {
        _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
      }
      renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
      return renderableData.canBatch;
    }
  };
  TilingSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "tilingSprite"
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
  extensions.add(TilingSpritePipe);

  // node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
    constructor(...args) {
      super({});
      let options = args[0] ?? {};
      if (typeof options === "number") {
        deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
        options = {
          width: options,
          height: args[1],
          verticesX: args[2],
          verticesY: args[3]
        };
      }
      this.build(options);
    }
    build(options) {
      options = {..._PlaneGeometry2.defaultOptions, ...options};
      this.verticesX = this.verticesX ?? options.verticesX;
      this.verticesY = this.verticesY ?? options.verticesY;
      this.width = this.width ?? options.width;
      this.height = this.height ?? options.height;
      const total = this.verticesX * this.verticesY;
      const verts = [];
      const uvs = [];
      const indices = [];
      const verticesX = this.verticesX - 1;
      const verticesY = this.verticesY - 1;
      const sizeX = this.width / verticesX;
      const sizeY = this.height / verticesY;
      for (let i2 = 0; i2 < total; i2++) {
        const x2 = i2 % this.verticesX;
        const y2 = i2 / this.verticesX | 0;
        verts.push(x2 * sizeX, y2 * sizeY);
        uvs.push(x2 / verticesX, y2 / verticesY);
      }
      const totalSub = verticesX * verticesY;
      for (let i2 = 0; i2 < totalSub; i2++) {
        const xpos = i2 % verticesX;
        const ypos = i2 / verticesX | 0;
        const value = ypos * this.verticesX + xpos;
        const value2 = ypos * this.verticesX + xpos + 1;
        const value3 = (ypos + 1) * this.verticesX + xpos;
        const value4 = (ypos + 1) * this.verticesX + xpos + 1;
        indices.push(value, value2, value3, value2, value4, value3);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint32Array(indices);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    }
  };
  _PlaneGeometry.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
  };
  var PlaneGeometry = _PlaneGeometry;

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
    constructor(options = {}) {
      options = {..._NineSliceGeometry2.defaultOptions, ...options};
      super({
        width: options.width,
        height: options.height,
        verticesX: 4,
        verticesY: 4
      });
      this.update(options);
    }
    update(options) {
      this.width = options.width ?? this.width;
      this.height = options.height ?? this.height;
      this._originalWidth = options.originalWidth ?? this._originalWidth;
      this._originalHeight = options.originalHeight ?? this._originalHeight;
      this._leftWidth = options.leftWidth ?? this._leftWidth;
      this._rightWidth = options.rightWidth ?? this._rightWidth;
      this._topHeight = options.topHeight ?? this._topHeight;
      this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
      this._anchorX = options.anchor?.x;
      this._anchorY = options.anchor?.y;
      this.updateUvs();
      this.updatePositions();
    }
    updatePositions() {
      const p2 = this.positions;
      const {
        width,
        height,
        _leftWidth,
        _rightWidth,
        _topHeight,
        _bottomHeight,
        _anchorX,
        _anchorY
      } = this;
      const w2 = _leftWidth + _rightWidth;
      const scaleW = width > w2 ? 1 : width / w2;
      const h2 = _topHeight + _bottomHeight;
      const scaleH = height > h2 ? 1 : height / h2;
      const scale = Math.min(scaleW, scaleH);
      const anchorOffsetX = _anchorX * width;
      const anchorOffsetY = _anchorY * height;
      p2[0] = p2[8] = p2[16] = p2[24] = -anchorOffsetX;
      p2[2] = p2[10] = p2[18] = p2[26] = _leftWidth * scale - anchorOffsetX;
      p2[4] = p2[12] = p2[20] = p2[28] = width - _rightWidth * scale - anchorOffsetX;
      p2[6] = p2[14] = p2[22] = p2[30] = width - anchorOffsetX;
      p2[1] = p2[3] = p2[5] = p2[7] = -anchorOffsetY;
      p2[9] = p2[11] = p2[13] = p2[15] = _topHeight * scale - anchorOffsetY;
      p2[17] = p2[19] = p2[21] = p2[23] = height - _bottomHeight * scale - anchorOffsetY;
      p2[25] = p2[27] = p2[29] = p2[31] = height - anchorOffsetY;
      this.getBuffer("aPosition").update();
    }
    updateUvs() {
      const uvs = this.uvs;
      uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
      uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
      uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
      uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
      const _uvw = 1 / this._originalWidth;
      const _uvh = 1 / this._originalHeight;
      uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
      uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
      uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
      uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
      this.getBuffer("aUV").update();
    }
  };
  _NineSliceGeometry.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
  };
  var NineSliceGeometry = _NineSliceGeometry;

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpriteGpuData = class extends BatchableMesh {
    constructor() {
      super();
      this.geometry = new NineSliceGeometry();
    }
    destroy() {
      this.geometry.destroy();
    }
  };
  var NineSliceSpritePipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderable(sprite, instructionSet) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
      batchableSprite.geometry.update(sprite);
      batchableSprite.setTexture(sprite._texture);
    }
    _getGpuSprite(sprite) {
      return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
      const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();
      const batchableMesh = gpuData;
      batchableMesh.renderable = sprite;
      batchableMesh.transform = sprite.groupTransform;
      batchableMesh.texture = sprite._texture;
      batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
      if (!sprite.didViewUpdate) {
        this._updateBatchableSprite(sprite, batchableMesh);
      }
      return gpuData;
    }
    destroy() {
      this._renderer = null;
    }
  };
  NineSliceSpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "nineSliceSprite"
  };

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
  extensions.add(NineSliceSpritePipe);

  // node_modules/pixi.js/lib/filters/FilterPipe.mjs
  var FilterPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    push(filterEffect, container, instructionSet) {
      const renderPipes = this._renderer.renderPipes;
      renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "filter",
        canBundle: false,
        action: "pushFilter",
        container,
        filterEffect
      });
    }
    pop(_filterEffect, _container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    execute(instruction) {
      if (instruction.action === "pushFilter") {
        this._renderer.filter.push(instruction);
      } else if (instruction.action === "popFilter") {
        this._renderer.filter.pop();
      }
    }
    destroy() {
      this._renderer = null;
    }
  };
  FilterPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "filter"
  };

  // node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
  var tempProjectionMatrix = new Matrix();
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const actualMatrix = bounds.matrix;
    for (let i2 = 0; i2 < renderables.length; i2++) {
      const renderable = renderables[i2];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
      if (renderGroup?.isCachedAsTexture) {
        bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
      } else if (renderGroup?._parentCacheAsTextureRenderGroup) {
        bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
      } else {
        bounds.matrix = renderable.worldTransform;
      }
      bounds.addBounds(renderable.bounds);
    }
    bounds.matrix = actualMatrix;
    return bounds;
  }

  // node_modules/pixi.js/lib/filters/FilterSystem.mjs
  var quadGeometry = new Geometry({
    attributes: {
      aPosition: {
        buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        format: "float32x2",
        stride: 2 * 4,
        offset: 0
      }
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
  });
  var FilterData = class {
    constructor() {
      this.skip = false;
      this.inputTexture = null;
      this.backTexture = null;
      this.filters = null;
      this.bounds = new Bounds();
      this.container = null;
      this.blendRequired = false;
      this.outputRenderSurface = null;
      this.globalFrame = {x: 0, y: 0, width: 0, height: 0};
    }
  };
  var FilterSystem = class {
    constructor(renderer) {
      this._filterStackIndex = 0;
      this._filterStack = [];
      this._filterGlobalUniforms = new UniformGroup({
        uInputSize: {value: new Float32Array(4), type: "vec4<f32>"},
        uInputPixel: {value: new Float32Array(4), type: "vec4<f32>"},
        uInputClamp: {value: new Float32Array(4), type: "vec4<f32>"},
        uOutputFrame: {value: new Float32Array(4), type: "vec4<f32>"},
        uGlobalFrame: {value: new Float32Array(4), type: "vec4<f32>"},
        uOutputTexture: {value: new Float32Array(4), type: "vec4<f32>"}
      });
      this._globalFilterBindGroup = new BindGroup({});
      this.renderer = renderer;
    }
    get activeBackTexture() {
      return this._activeFilterData?.backTexture;
    }
    push(instruction) {
      const renderer = this.renderer;
      const filters = instruction.filterEffect.filters;
      const filterData = this._pushFilterData();
      filterData.skip = false;
      filterData.filters = filters;
      filterData.container = instruction.container;
      filterData.outputRenderSurface = renderer.renderTarget.renderSurface;
      const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
      const rootResolution = colorTextureSource.resolution;
      const rootAntialias = colorTextureSource.antialias;
      if (filters.length === 0) {
        filterData.skip = true;
        return;
      }
      const bounds = filterData.bounds;
      this._calculateFilterArea(instruction, bounds);
      this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
      if (filterData.skip) {
        return;
      }
      const previousFilterData = this._getPreviousFilterData();
      const globalResolution = this._findFilterResolution(rootResolution);
      let offsetX = 0;
      let offsetY = 0;
      if (previousFilterData) {
        offsetX = previousFilterData.bounds.minX;
        offsetY = previousFilterData.bounds.minY;
      }
      this._calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, colorTextureSource.width, colorTextureSource.height);
      this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
    }
    generateFilteredTexture({texture, filters}) {
      const filterData = this._pushFilterData();
      this._activeFilterData = filterData;
      filterData.skip = false;
      filterData.filters = filters;
      const colorTextureSource = texture.source;
      const rootResolution = colorTextureSource.resolution;
      const rootAntialias = colorTextureSource.antialias;
      if (filters.length === 0) {
        filterData.skip = true;
        return texture;
      }
      const bounds = filterData.bounds;
      bounds.addRect(texture.frame);
      this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
      if (filterData.skip) {
        return texture;
      }
      const globalResolution = rootResolution;
      const offsetX = 0;
      const offsetY = 0;
      this._calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, colorTextureSource.width, colorTextureSource.height);
      filterData.outputRenderSurface = TexturePool.getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);
      filterData.backTexture = Texture.EMPTY;
      filterData.inputTexture = texture;
      const renderer = this.renderer;
      renderer.renderTarget.finishRenderPass();
      this._applyFiltersToTexture(filterData, true);
      const outputTexture = filterData.outputRenderSurface;
      outputTexture.source.alphaMode = "premultiplied-alpha";
      return outputTexture;
    }
    pop() {
      const renderer = this.renderer;
      const filterData = this._popFilterData();
      if (filterData.skip) {
        return;
      }
      renderer.globalUniforms.pop();
      renderer.renderTarget.finishRenderPass();
      this._activeFilterData = filterData;
      this._applyFiltersToTexture(filterData, false);
      if (filterData.blendRequired) {
        TexturePool.returnTexture(filterData.backTexture);
      }
      TexturePool.returnTexture(filterData.inputTexture);
    }
    getBackTexture(lastRenderSurface, bounds, previousBounds) {
      const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
      const backTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);
      let x2 = bounds.minX;
      let y2 = bounds.minY;
      if (previousBounds) {
        x2 -= previousBounds.minX;
        y2 -= previousBounds.minY;
      }
      x2 = Math.floor(x2 * backgroundResolution);
      y2 = Math.floor(y2 * backgroundResolution);
      const width = Math.ceil(bounds.width * backgroundResolution);
      const height = Math.ceil(bounds.height * backgroundResolution);
      this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {x: x2, y: y2}, {width, height}, {x: 0, y: 0});
      return backTexture;
    }
    applyFilter(filter, input, output, clear) {
      const renderer = this.renderer;
      const filterData = this._activeFilterData;
      const outputRenderSurface = filterData.outputRenderSurface;
      const isFinalTarget = outputRenderSurface === output;
      const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
      const resolution = this._findFilterResolution(rootResolution);
      let offsetX = 0;
      let offsetY = 0;
      if (isFinalTarget) {
        const offset = this._findPreviousFilterOffset();
        offsetX = offset.x;
        offsetY = offset.y;
      }
      this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
      this._setupBindGroupsAndRender(filter, input, renderer);
    }
    calculateSpriteMatrix(outputMatrix, sprite) {
      const data = this._activeFilterData;
      const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);
      const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
      const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
      if (renderGroup && renderGroup.cacheToLocalTransform) {
        worldTransform.prepend(renderGroup.cacheToLocalTransform);
      }
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / sprite.texture.orig.width, 1 / sprite.texture.orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    }
    destroy() {
    }
    _setupBindGroupsAndRender(filter, input, renderer) {
      if (renderer.renderPipes.uniformBatch) {
        const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
        this._globalFilterBindGroup.setResource(batchUniforms, 0);
      } else {
        this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
      }
      this._globalFilterBindGroup.setResource(input.source, 1);
      this._globalFilterBindGroup.setResource(input.source.style, 2);
      filter.groups[0] = this._globalFilterBindGroup;
      renderer.encoder.draw({
        geometry: quadGeometry,
        shader: filter,
        state: filter._state,
        topology: "triangle-list"
      });
      if (renderer.type === RendererType.WEBGL) {
        renderer.renderTarget.finishRenderPass();
      }
    }
    _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
      filterData.backTexture = Texture.EMPTY;
      filterData.inputTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);
      if (filterData.blendRequired) {
        renderer.renderTarget.finishRenderPass();
        const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);
        filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);
      }
      renderer.renderTarget.bind(filterData.inputTexture, true);
      renderer.globalUniforms.push({
        offset: bounds
      });
    }
    _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
      const globalFrame = filterData.globalFrame;
      globalFrame.x = offsetX * globalResolution;
      globalFrame.y = offsetY * globalResolution;
      globalFrame.width = sourceWidth * globalResolution;
      globalFrame.height = sourceHeight * globalResolution;
    }
    _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
      const uniforms = this._filterGlobalUniforms.uniforms;
      const outputFrame = uniforms.uOutputFrame;
      const inputSize = uniforms.uInputSize;
      const inputPixel = uniforms.uInputPixel;
      const inputClamp = uniforms.uInputClamp;
      const globalFrame = uniforms.uGlobalFrame;
      const outputTexture = uniforms.uOutputTexture;
      if (isFinalTarget) {
        outputFrame[0] = filterData.bounds.minX - offsetX;
        outputFrame[1] = filterData.bounds.minY - offsetY;
      } else {
        outputFrame[0] = 0;
        outputFrame[1] = 0;
      }
      outputFrame[2] = input.frame.width;
      outputFrame[3] = input.frame.height;
      inputSize[0] = input.source.width;
      inputSize[1] = input.source.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = input.source.pixelWidth;
      inputPixel[1] = input.source.pixelHeight;
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
      const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
      globalFrame[0] = offsetX * resolution;
      globalFrame[1] = offsetY * resolution;
      globalFrame[2] = rootTexture.source.width * resolution;
      globalFrame[3] = rootTexture.source.height * resolution;
      if (output instanceof Texture)
        output.source.resource = null;
      const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
      this.renderer.renderTarget.bind(output, !!clear);
      if (output instanceof Texture) {
        outputTexture[0] = output.frame.width;
        outputTexture[1] = output.frame.height;
      } else {
        outputTexture[0] = renderTarget.width;
        outputTexture[1] = renderTarget.height;
      }
      outputTexture[2] = renderTarget.isRoot ? -1 : 1;
      this._filterGlobalUniforms.update();
    }
    _findFilterResolution(rootResolution) {
      let currentIndex = this._filterStackIndex - 1;
      while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
        --currentIndex;
      }
      return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;
    }
    _findPreviousFilterOffset() {
      let offsetX = 0;
      let offsetY = 0;
      let lastIndex = this._filterStackIndex;
      while (lastIndex > 0) {
        lastIndex--;
        const prevFilterData = this._filterStack[lastIndex];
        if (!prevFilterData.skip) {
          offsetX = prevFilterData.bounds.minX;
          offsetY = prevFilterData.bounds.minY;
          break;
        }
      }
      return {x: offsetX, y: offsetY};
    }
    _calculateFilterArea(instruction, bounds) {
      if (instruction.renderables) {
        getGlobalRenderableBounds(instruction.renderables, bounds);
      } else if (instruction.filterEffect.filterArea) {
        bounds.clear();
        bounds.addRect(instruction.filterEffect.filterArea);
        bounds.applyMatrix(instruction.container.worldTransform);
      } else {
        instruction.container.getFastGlobalBounds(true, bounds);
      }
      if (instruction.container) {
        const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
        const filterFrameTransform = renderGroup.cacheToLocalTransform;
        if (filterFrameTransform) {
          bounds.applyMatrix(filterFrameTransform);
        }
      }
    }
    _applyFiltersToTexture(filterData, clear) {
      const inputTexture = filterData.inputTexture;
      const bounds = filterData.bounds;
      const filters = filterData.filters;
      this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
      this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);
      if (filters.length === 1) {
        filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);
      } else {
        let flip = filterData.inputTexture;
        const tempTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);
        let flop = tempTexture;
        let i2 = 0;
        for (i2 = 0; i2 < filters.length - 1; ++i2) {
          const filter = filters[i2];
          filter.apply(this, flip, flop, true);
          const t2 = flip;
          flip = flop;
          flop = t2;
        }
        filters[i2].apply(this, flip, filterData.outputRenderSurface, clear);
        TexturePool.returnTexture(tempTexture);
      }
    }
    _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
      const renderer = this.renderer;
      const bounds = filterData.bounds;
      const filters = filterData.filters;
      let resolution = Infinity;
      let padding = 0;
      let antialias = true;
      let blendRequired = false;
      let enabled = false;
      let clipToViewport = true;
      for (let i2 = 0; i2 < filters.length; i2++) {
        const filter = filters[i2];
        resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
        padding += filter.padding;
        if (filter.antialias === "off") {
          antialias = false;
        } else if (filter.antialias === "inherit") {
          antialias && (antialias = rootAntialias);
        }
        if (!filter.clipToViewport) {
          clipToViewport = false;
        }
        const isCompatible = !!(filter.compatibleRenderers & renderer.type);
        if (!isCompatible) {
          enabled = false;
          break;
        }
        if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
          warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
          enabled = false;
          break;
        }
        enabled = filter.enabled || enabled;
        blendRequired || (blendRequired = filter.blendRequired);
      }
      if (!enabled) {
        filterData.skip = true;
        return;
      }
      if (clipToViewport) {
        bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
      }
      bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
      if (!bounds.isPositive) {
        filterData.skip = true;
        return;
      }
      filterData.antialias = antialias;
      filterData.resolution = resolution;
      filterData.blendRequired = blendRequired;
    }
    _popFilterData() {
      this._filterStackIndex--;
      return this._filterStack[this._filterStackIndex];
    }
    _getPreviousFilterData() {
      let previousFilterData;
      let index = this._filterStackIndex - 1;
      while (index > 0) {
        index--;
        previousFilterData = this._filterStack[index];
        if (!previousFilterData.skip) {
          break;
        }
      }
      return previousFilterData;
    }
    _pushFilterData() {
      let filterData = this._filterStack[this._filterStackIndex];
      if (!filterData) {
        filterData = this._filterStack[this._filterStackIndex] = new FilterData();
      }
      this._filterStackIndex++;
      return filterData;
    }
  };
  FilterSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "filter"
  };

  // node_modules/pixi.js/lib/filters/init.mjs
  extensions.add(FilterSystem);
  extensions.add(FilterPipe);

  // node_modules/pixi.js/lib/environment-browser/browserExt.mjs
  var browserExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Promise.resolve().then(() => __toModule(require_browserAll()));
    }
  };

  // node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
  var webworkerExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Promise.resolve().then(() => __toModule(require_webworkerAll()));
    }
  };

  // node_modules/pixi.js/lib/filters/Filter.mjs
  var _Filter = class _Filter2 extends Shader {
    constructor(options) {
      options = {..._Filter2.defaultOptions, ...options};
      super(options);
      this.enabled = true;
      this._state = State.for2d();
      this.blendMode = options.blendMode;
      this.padding = options.padding;
      if (typeof options.antialias === "boolean") {
        this.antialias = options.antialias ? "on" : "off";
      } else {
        this.antialias = options.antialias;
      }
      this.resolution = options.resolution;
      this.blendRequired = options.blendRequired;
      this.clipToViewport = options.clipToViewport;
      this.addResource("uTexture", 0, 1);
    }
    apply(filterManager, input, output, clearMode) {
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get blendMode() {
      return this._state.blendMode;
    }
    set blendMode(value) {
      this._state.blendMode = value;
    }
    static from(options) {
      const {gpu, gl, ...rest} = options;
      let gpuProgram3;
      let glProgram3;
      if (gpu) {
        gpuProgram3 = GpuProgram.from(gpu);
      }
      if (gl) {
        glProgram3 = GlProgram.from(gl);
      }
      return new _Filter2({
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        ...rest
      });
    }
  };
  _Filter.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: false,
    clipToViewport: true
  };
  var Filter = _Filter;

  // node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
  var environments = [];
  extensions.handleByNamedList(ExtensionType.Environment, environments);
  async function loadEnvironmentExtensions(skip) {
    if (skip)
      return;
    for (let i2 = 0; i2 < environments.length; i2++) {
      const env = environments[i2];
      if (env.value.test()) {
        await env.value.load();
        return;
      }
    }
  }

  // node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
  "use strict";
  var unsafeEval;
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({a: "b"}, "a", "b") === true;
    } catch (_e) {
      unsafeEval = false;
    }
    return unsafeEval;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
  "use strict";
  var CLEAR = /* @__PURE__ */ ((CLEAR2) => {
    CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
    CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
    CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
    CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
    CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
    CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
    CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
    CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
    return CLEAR2;
  })(CLEAR || {});

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
  "use strict";
  var SystemRunner = class {
    constructor(name) {
      this.items = [];
      this._name = name;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
      const {name, items} = this;
      for (let i2 = 0, len = items.length; i2 < len; i2++) {
        items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      return this;
    }
    add(item) {
      if (item[this._name]) {
        this.remove(item);
        this.items.push(item);
      }
      return this;
    }
    remove(item) {
      const index = this.items.indexOf(item);
      if (index !== -1) {
        this.items.splice(index, 1);
      }
      return this;
    }
    contains(item) {
      return this.items.indexOf(item) !== -1;
    }
    removeAll() {
      this.items.length = 0;
      return this;
    }
    destroy() {
      this.removeAll();
      this.items = null;
      this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ];
  var _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
    constructor(config3) {
      super();
      this.uid = uid("renderer");
      this.runners = /* @__PURE__ */ Object.create(null);
      this.renderPipes = /* @__PURE__ */ Object.create(null);
      this._initOptions = {};
      this._systemsHash = /* @__PURE__ */ Object.create(null);
      this.type = config3.type;
      this.name = config3.name;
      this.config = config3;
      const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
      this._addRunners(...combinedRunners);
      this._unsafeEvalCheck();
    }
    async init(options = {}) {
      const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
      await loadEnvironmentExtensions(skip);
      this._addSystems(this.config.systems);
      this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const systemName in this._systemsHash) {
        const system = this._systemsHash[systemName];
        const defaultSystemOptions = system.constructor.defaultOptions;
        options = {...defaultSystemOptions, ...options};
      }
      options = {..._AbstractRenderer2.defaultOptions, ...options};
      this._roundPixels = options.roundPixels ? 1 : 0;
      for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
        await this.runners.init.items[i2].init(options);
      }
      this._initOptions = options;
    }
    render(args, deprecated) {
      let options = args;
      if (options instanceof Container) {
        options = {container: options};
        if (deprecated) {
          deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
          options.target = deprecated.renderTexture;
        }
      }
      options.target || (options.target = this.view.renderTarget);
      if (options.target === this.view.renderTarget) {
        this._lastObjectRendered = options.container;
        options.clearColor ?? (options.clearColor = this.background.colorRgba);
        options.clear ?? (options.clear = this.background.clearBeforeRender);
      }
      if (options.clearColor) {
        const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
        options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
      }
      if (!options.transform) {
        options.container.updateLocalTransform();
        options.transform = options.container.localTransform;
      }
      if (!options.container.visible) {
        return;
      }
      options.container.enableRenderGroup();
      this.runners.prerender.emit(options);
      this.runners.renderStart.emit(options);
      this.runners.render.emit(options);
      this.runners.renderEnd.emit(options);
      this.runners.postrender.emit(options);
    }
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      const previousResolution = this.view.resolution;
      this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
      if (resolution !== void 0 && resolution !== previousResolution) {
        this.runners.resolutionChange.emit(resolution);
      }
    }
    clear(options = {}) {
      const renderer = this;
      options.target || (options.target = renderer.renderTarget.renderTarget);
      options.clearColor || (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = CLEAR.ALL);
      const {clear, clearColor, target} = options;
      Color.shared.setValue(clearColor ?? this.background.colorRgba);
      renderer.renderTarget.clear(target, clear, Color.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(value) {
      this.view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      const renderer = this;
      return renderer.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...runnerIds) {
      runnerIds.forEach((runnerId) => {
        this.runners[runnerId] = new SystemRunner(runnerId);
      });
    }
    _addSystems(systems) {
      let i2;
      for (i2 in systems) {
        const val = systems[i2];
        this._addSystem(val.value, val.name);
      }
    }
    _addSystem(ClassRef, name) {
      const system = new ClassRef(this);
      if (this[name]) {
        throw new Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = system;
      this._systemsHash[name] = system;
      for (const i2 in this.runners) {
        this.runners[i2].add(system);
      }
      return this;
    }
    _addPipes(pipes, pipeAdaptors) {
      const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
        acc[adaptor.name] = adaptor.value;
        return acc;
      }, {});
      pipes.forEach((pipe3) => {
        const PipeClass = pipe3.value;
        const name = pipe3.name;
        const Adaptor = adaptors[name];
        this.renderPipes[name] = new PipeClass(this, Adaptor ? new Adaptor() : null);
        this.runners.destroy.add(this.renderPipes[name]);
      });
    }
    destroy(options = false) {
      this.runners.destroy.items.reverse();
      this.runners.destroy.emit(options);
      Object.values(this.runners).forEach((runner) => {
        runner.destroy();
      });
      if (options === true || typeof options === "object" && options.releaseGlobalResources) {
        GlobalResourceRegistry.release();
      }
      this._systemsHash = null;
      this.renderPipes = null;
    }
    generateTexture(options) {
      return this.textureGenerator.generateTexture(options);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  _AbstractRenderer.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  var AbstractRenderer = _AbstractRenderer;

  // node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
  var _isWebGLSupported;
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas = DOMAdapter.get().createCanvas();
        let gl = canvas.getContext("webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (_e) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }

  // node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
  var _isWebGPUSupported;
  async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = DOMAdapter.get().getNavigator().gpu;
      if (!gpu) {
        return false;
      }
      try {
        const adapter = await gpu.requestAdapter(options);
        await adapter.requestDevice();
        return true;
      } catch (_e) {
        return false;
      }
    })();
    return _isWebGPUSupported;
  }

  // node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  var renderPriority = ["webgl", "webgpu", "canvas"];

  // node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor = class {
    constructor() {
      this._maxTextures = 0;
    }
    contextChange(renderer) {
      const localUniforms = new UniformGroup({
        uTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uColor: {value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>"},
        uRound: {value: 0, type: "f32"}
      });
      this._maxTextures = renderer.limits.maxBatchableTextures;
      const gpuProgram3 = compileHighShaderGpuProgram({
        name: "graphics",
        bits: [
          colorBit,
          generateTextureBatchBit(this._maxTextures),
          localUniformBitGroup2,
          roundPixelsBit
        ]
      });
      this.shader = new Shader({
        gpuProgram: gpuProgram3,
        resources: {
          localUniforms
        }
      });
    }
    execute(graphicsPipe, renderable) {
      const context4 = renderable.context;
      const shader = context4.customShader || this.shader;
      const renderer = graphicsPipe.renderer;
      const contextSystem = renderer.graphicsContext;
      const {
        batcher,
        instructions
      } = contextSystem.getContextRenderData(context4);
      const encoder = renderer.encoder;
      encoder.setGeometry(batcher.geometry, shader.gpuProgram);
      const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
      encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
      const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
      encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
      const batches = instructions.instructions;
      let topology = null;
      for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
        const batch = batches[i2];
        if (batch.topology !== topology) {
          topology = batch.topology;
          encoder.setPipelineFromGeometryProgramAndState(batcher.geometry, shader.gpuProgram, graphicsPipe.state, batch.topology);
        }
        shader.groups[1] = batch.bindGroup;
        if (!batch.gpuBindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count, this._maxTextures);
          batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);
        }
        encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
    }
    destroy() {
      this.shader.destroy(true);
      this.shader = null;
    }
  };
  GpuGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "graphics"
  };

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
  "use strict";
  var textureBit = {
    name: "texture-bit",
    vertex: {
      header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
      main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
      main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    }
  };
  var textureBitGl = {
    name: "texture-bit",
    vertex: {
      header: `
            uniform mat3 uTextureMatrix;
        `,
      main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    },
    fragment: {
      header: `
        uniform sampler2D uTexture;


        `,
      main: `
            outColor = texture(uTexture, vUV);
        `
    }
  };

  // node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter = class {
    init() {
      const gpuProgram3 = compileHighShaderGpuProgram({
        name: "mesh",
        bits: [
          localUniformBit,
          textureBit,
          roundPixelsBit
        ]
      });
      this._shader = new Shader({
        gpuProgram: gpuProgram3,
        resources: {
          uTexture: Texture.EMPTY._source,
          uSampler: Texture.EMPTY._source.style,
          textureUniforms: {
            uTextureMatrix: {type: "mat3x3<f32>", value: new Matrix()}
          }
        }
      });
    }
    execute(meshPipe, mesh) {
      const renderer = meshPipe.renderer;
      let shader = mesh._shader;
      if (!shader) {
        shader = this._shader;
        shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
      } else if (!shader.gpuProgram) {
        warn("Mesh shader has no gpuProgram", mesh.shader);
        return;
      }
      const gpuProgram3 = shader.gpuProgram;
      if (gpuProgram3.autoAssignGlobalUniforms) {
        shader.groups[0] = renderer.globalUniforms.bindGroup;
      }
      if (gpuProgram3.autoAssignLocalUniforms) {
        const localUniforms = meshPipe.localUniforms;
        shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
      }
      renderer.encoder.draw({
        geometry: mesh._geometry,
        shader,
        state: mesh.state
      });
    }
    destroy() {
      this._shader.destroy(true);
      this._shader = null;
    }
  };
  GpuMeshAdapter.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "mesh"
  };

  // node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState = State.for2d();
  var GpuBatchAdaptor = class {
    start(batchPipe, geometry, shader) {
      const renderer = batchPipe.renderer;
      const encoder = renderer.encoder;
      const program = shader.gpuProgram;
      this._shader = shader;
      this._geometry = geometry;
      encoder.setGeometry(geometry, program);
      tempState.blendMode = "normal";
      renderer.pipeline.getPipeline(geometry, program, tempState);
      const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
      encoder.resetBindGroup(1);
      encoder.setBindGroup(0, globalUniformsBindGroup, program);
    }
    execute(batchPipe, batch) {
      const program = this._shader.gpuProgram;
      const renderer = batchPipe.renderer;
      const encoder = renderer.encoder;
      if (!batch.bindGroup) {
        const textureBatch = batch.textures;
        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count, renderer.limits.maxBatchableTextures);
      }
      tempState.blendMode = batch.blendMode;
      const gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, program, 1);
      const pipeline = renderer.pipeline.getPipeline(this._geometry, program, tempState, batch.topology);
      batch.bindGroup._touch(renderer.textureGC.count);
      encoder.setPipeline(pipeline);
      encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
    }
  };
  GpuBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGPUPipesAdaptor
    ],
    name: "batch"
  };

  // node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    updateRenderable() {
    }
    destroyRenderable() {
    }
    validateRenderable() {
      return false;
    }
    addRenderable(container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(container);
    }
    execute(container) {
      if (!container.isRenderable)
        return;
      container.render(this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  };
  CustomRenderPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "customRender"
  };

  // node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
  "use strict";
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
      const instruction = instructions[i2];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }

  // node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
  var tempMatrix5 = new Matrix();
  var RenderGroupPipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderGroup(renderGroup, instructionSet) {
      if (renderGroup.isCachedAsTexture) {
        this._addRenderableCacheAsTexture(renderGroup, instructionSet);
      } else {
        this._addRenderableDirect(renderGroup, instructionSet);
      }
    }
    execute(renderGroup) {
      if (!renderGroup.isRenderable)
        return;
      if (renderGroup.isCachedAsTexture) {
        this._executeCacheAsTexture(renderGroup);
      } else {
        this._executeDirect(renderGroup);
      }
    }
    destroy() {
      this._renderer = null;
    }
    _addRenderableDirect(renderGroup, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      if (renderGroup._batchableRenderGroup) {
        BigPool.return(renderGroup._batchableRenderGroup);
        renderGroup._batchableRenderGroup = null;
      }
      instructionSet.add(renderGroup);
    }
    _addRenderableCacheAsTexture(renderGroup, instructionSet) {
      const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));
      batchableRenderGroup.renderable = renderGroup.root;
      batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
      batchableRenderGroup.texture = renderGroup.texture;
      batchableRenderGroup.bounds = renderGroup._textureBounds;
      instructionSet.add(renderGroup);
      this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
      this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
      this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
    }
    _executeCacheAsTexture(renderGroup) {
      if (renderGroup.textureNeedsUpdate) {
        renderGroup.textureNeedsUpdate = false;
        const worldTransformMatrix = tempMatrix5.identity().translate(-renderGroup._textureBounds.x, -renderGroup._textureBounds.y);
        this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
        this._renderer.globalUniforms.push({
          worldTransformMatrix,
          worldColor: 4294967295,
          offset: {x: 0, y: 0}
        });
        executeInstructions(renderGroup, this._renderer.renderPipes);
        this._renderer.renderTarget.finishRenderPass();
        this._renderer.renderTarget.pop();
        this._renderer.globalUniforms.pop();
      }
      renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
      renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
    }
    _executeDirect(renderGroup) {
      this._renderer.globalUniforms.push({
        worldTransformMatrix: renderGroup.inverseParentTextureTransform,
        worldColor: renderGroup.worldColorAlpha
      });
      executeInstructions(renderGroup, this._renderer.renderPipes);
      this._renderer.globalUniforms.pop();
    }
  };
  RenderGroupPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "renderGroup"
  };

  // node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
  "use strict";
  function clearList(list, index) {
    index || (index = 0);
    for (let j2 = index; j2 < list.length; j2++) {
      if (list[j2]) {
        list[j2] = null;
      } else {
        break;
      }
    }
  }

  // node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  var tempContainer = new Container();
  var UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const renderGroupDepth = Number(j2);
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i2 = 0; i2 < index; i2++) {
        const child = list[i2];
        if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      clearList(list, index);
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(root.relativeGroupTransform, renderGroupParent.worldTransform);
      renderGroup.worldColor = multiplyColors(root.groupColor, renderGroupParent.worldColor);
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
      updateFlags |= container._updateFlags;
      container.relativeGroupTransform.appendFrom(localTransform, parent.relativeGroupTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        updateTransformAndChildren(children[i2], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      const renderable = container;
      if (renderable.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(renderable);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = multiplyColors(container.localColor, parent.groupColor);
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }

  // node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
  "use strict";
  function validateRenderables(renderGroup, renderPipes) {
    const {list, index} = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      const renderable = container;
      const pipe3 = renderPipes[renderable.renderPipeId];
      rebuildRequired = pipe3.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }

  // node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
  var tempMatrix6 = new Matrix();
  var RenderGroupSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    render({container, transform}) {
      const parent = container.parent;
      const renderGroupParent = container.renderGroup.renderGroupParent;
      container.parent = null;
      container.renderGroup.renderGroupParent = null;
      const renderer = this._renderer;
      const originalLocalTransform = tempMatrix6;
      if (transform) {
        originalLocalTransform.copyFrom(container.renderGroup.localTransform);
        container.renderGroup.localTransform.copyFrom(transform);
      }
      const renderPipes = renderer.renderPipes;
      this._updateCachedRenderGroups(container.renderGroup, null);
      this._updateRenderGroups(container.renderGroup);
      renderer.globalUniforms.start({
        worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
        worldColor: container.renderGroup.worldColorAlpha
      });
      executeInstructions(container.renderGroup, renderPipes);
      if (renderPipes.uniformBatch) {
        renderPipes.uniformBatch.renderEnd();
      }
      if (transform) {
        container.renderGroup.localTransform.copyFrom(originalLocalTransform);
      }
      container.parent = parent;
      container.renderGroup.renderGroupParent = renderGroupParent;
    }
    destroy() {
      this._renderer = null;
    }
    _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
      renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
      if (renderGroup.isCachedAsTexture) {
        if (!renderGroup.textureNeedsUpdate)
          return;
        closestCacheAsTexture = renderGroup;
      }
      for (let i2 = renderGroup.renderGroupChildren.length - 1; i2 >= 0; i2--) {
        this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i2], closestCacheAsTexture);
      }
      renderGroup.invalidateMatrices();
      if (renderGroup.isCachedAsTexture) {
        if (renderGroup.textureNeedsUpdate) {
          const bounds = renderGroup.root.getLocalBounds();
          bounds.ceil();
          const lastTexture = renderGroup.texture;
          if (renderGroup.texture) {
            TexturePool.returnTexture(renderGroup.texture, true);
          }
          const renderer = this._renderer;
          const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
          const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
          const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";
          const texture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);
          texture._source.style = new TextureStyle({scaleMode});
          renderGroup.texture = texture;
          renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());
          renderGroup._textureBounds.copyFrom(bounds);
          if (lastTexture !== renderGroup.texture) {
            if (renderGroup.renderGroupParent) {
              renderGroup.renderGroupParent.structureDidChange = true;
            }
          }
        }
      } else if (renderGroup.texture) {
        TexturePool.returnTexture(renderGroup.texture, true);
        renderGroup.texture = null;
      }
    }
    _updateRenderGroups(renderGroup) {
      const renderer = this._renderer;
      const renderPipes = renderer.renderPipes;
      renderGroup.runOnRender(renderer);
      renderGroup.instructionSet.renderPipes = renderPipes;
      if (!renderGroup.structureDidChange) {
        validateRenderables(renderGroup, renderPipes);
      } else {
        clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
      }
      updateRenderGroupTransforms(renderGroup);
      if (renderGroup.structureDidChange) {
        renderGroup.structureDidChange = false;
        this._buildInstructions(renderGroup, renderer);
      } else {
        this._updateRenderables(renderGroup);
      }
      renderGroup.childrenRenderablesToUpdate.index = 0;
      renderer.renderPipes.batch.upload(renderGroup.instructionSet);
      if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
        return;
      for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
        this._updateRenderGroups(renderGroup.renderGroupChildren[i2]);
      }
    }
    _updateRenderables(renderGroup) {
      const {list, index} = renderGroup.childrenRenderablesToUpdate;
      for (let i2 = 0; i2 < index; i2++) {
        const container = list[i2];
        if (container.didViewUpdate) {
          renderGroup.updateRenderable(container);
        }
      }
      clearList(list, index);
    }
    _buildInstructions(renderGroup, rendererOrPipes) {
      const root = renderGroup.root;
      const instructionSet = renderGroup.instructionSet;
      instructionSet.reset();
      const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
      const renderPipes = renderer.renderPipes;
      renderPipes.batch.buildStart(instructionSet);
      renderPipes.blendMode.buildStart();
      renderPipes.colorMask.buildStart();
      if (root.sortableChildren) {
        root.sortChildren();
      }
      root.collectRenderablesWithEffects(instructionSet, renderer, null);
      renderPipes.batch.buildEnd(instructionSet);
      renderPipes.blendMode.buildEnd(instructionSet);
    }
  };
  RenderGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "renderGroup"
  };

  // node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderable(sprite, instructionSet) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      if (sprite.didViewUpdate)
        this._updateBatchableSprite(sprite, gpuSprite);
      gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
      batchableSprite.bounds = sprite.visualBounds;
      batchableSprite.texture = sprite._texture;
    }
    _getGpuSprite(sprite) {
      return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
      const batchableSprite = new BatchableSprite();
      batchableSprite.renderable = sprite;
      batchableSprite.transform = sprite.groupTransform;
      batchableSprite.texture = sprite._texture;
      batchableSprite.bounds = sprite.visualBounds;
      batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
      sprite._gpuData[this._renderer.uid] = batchableSprite;
      return batchableSprite;
    }
    destroy() {
      this._renderer = null;
    }
  };
  SpritePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "sprite"
  };

  // node_modules/pixi.js/lib/utils/const.mjs
  var VERSION = "8.13.2";

  // node_modules/pixi.js/lib/utils/global/globalHooks.mjs
  var ApplicationInitHook = class {
    static init() {
      globalThis.__PIXI_APP_INIT__?.(this, VERSION);
    }
    static destroy() {
    }
  };
  ApplicationInitHook.extension = ExtensionType.Application;
  var RendererInitHook = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    init() {
      globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
    }
    destroy() {
      this._renderer = null;
    }
  };
  RendererInitHook.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
  var _BatcherPipe = class _BatcherPipe2 {
    constructor(renderer, adaptor) {
      this.state = State.for2d();
      this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
      this._activeBatches = /* @__PURE__ */ Object.create(null);
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init?.(this);
    }
    static getBatcher(name) {
      return new this._availableBatchers[name]();
    }
    buildStart(instructionSet) {
      let batchers = this._batchersByInstructionSet[instructionSet.uid];
      if (!batchers) {
        batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
        batchers.default || (batchers.default = new DefaultBatcher({
          maxTextures: this.renderer.limits.maxBatchableTextures
        }));
      }
      this._activeBatches = batchers;
      this._activeBatch = this._activeBatches.default;
      for (const i2 in this._activeBatches) {
        this._activeBatches[i2].begin();
      }
    }
    addToBatch(batchableObject, instructionSet) {
      if (this._activeBatch.name !== batchableObject.batcherName) {
        this._activeBatch.break(instructionSet);
        let batch = this._activeBatches[batchableObject.batcherName];
        if (!batch) {
          batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
          batch.begin();
        }
        this._activeBatch = batch;
      }
      this._activeBatch.add(batchableObject);
    }
    break(instructionSet) {
      this._activeBatch.break(instructionSet);
    }
    buildEnd(instructionSet) {
      this._activeBatch.break(instructionSet);
      const batches = this._activeBatches;
      for (const i2 in batches) {
        const batch = batches[i2];
        const geometry = batch.geometry;
        geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
        geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
      }
    }
    upload(instructionSet) {
      const batchers = this._batchersByInstructionSet[instructionSet.uid];
      for (const i2 in batchers) {
        const batcher = batchers[i2];
        const geometry = batcher.geometry;
        if (batcher.dirty) {
          batcher.dirty = false;
          geometry.buffers[0].update(batcher.attributeSize * 4);
        }
      }
    }
    execute(batch) {
      if (batch.action === "startBatch") {
        const batcher = batch.batcher;
        const geometry = batcher.geometry;
        const shader = batcher.shader;
        this._adaptor.start(this, geometry, shader);
      }
      this._adaptor.execute(this, batch);
    }
    destroy() {
      this.state = null;
      this.renderer = null;
      this._adaptor = null;
      for (const i2 in this._activeBatches) {
        this._activeBatches[i2].destroy();
      }
      this._activeBatches = null;
    }
  };
  _BatcherPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "batch"
  };
  _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
  var BatcherPipe = _BatcherPipe;
  extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
  extensions.add(DefaultBatcher);

  // node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
  var fragment2 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";

  // node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
  var vertex2 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";

  // node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
  var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";

  // node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
  var MaskFilter = class extends Filter {
    constructor(options) {
      const {sprite, ...rest} = options;
      const textureMatrix = new TextureMatrix(sprite.texture);
      const filterUniforms = new UniformGroup({
        uFilterMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uMaskClamp: {value: textureMatrix.uClampFrame, type: "vec4<f32>"},
        uAlpha: {value: 1, type: "f32"},
        uInverse: {value: options.inverse ? 1 : 0, type: "f32"}
      });
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source,
          entryPoint: "mainVertex"
        },
        fragment: {
          source,
          entryPoint: "mainFragment"
        }
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex2,
        fragment: fragment2,
        name: "mask-filter"
      });
      super({
        ...rest,
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        clipToViewport: false,
        resources: {
          filterUniforms,
          uMaskTexture: sprite.texture.source
        }
      });
      this.sprite = sprite;
      this._textureMatrix = textureMatrix;
    }
    set inverse(value) {
      this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
    }
    get inverse() {
      return this.resources.filterUniforms.uniforms.uInverse === 1;
    }
    apply(filterManager, input, output, clearMode) {
      this._textureMatrix.texture = this.sprite.texture;
      filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord);
      this.resources.uMaskTexture = this.sprite.texture.source;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  };

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3 = new Bounds();
  var AlphaMaskEffect = class extends FilterEffect {
    constructor() {
      super();
      this.filters = [new MaskFilter({
        sprite: new Sprite(Texture.EMPTY),
        inverse: false,
        resolution: "inherit",
        antialias: "inherit"
      })];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(value) {
      this.filters[0].sprite = value;
    }
    get inverse() {
      return this.filters[0].inverse;
    }
    set inverse(value) {
      this.filters[0].inverse = value;
    }
  };
  var AlphaMaskPipe = class {
    constructor(renderer) {
      this._activeMaskStage = [];
      this._renderer = renderer;
    }
    push(mask, maskedContainer, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "alphaMask",
        action: "pushMaskBegin",
        mask,
        inverse: maskedContainer._maskOptions.inverse,
        canBundle: false,
        maskedContainer
      });
      mask.inverse = maskedContainer._maskOptions.inverse;
      if (mask.renderMaskToTexture) {
        const maskContainer = mask.mask;
        maskContainer.includeInBuild = true;
        maskContainer.collectRenderables(instructionSet, renderer, null);
        maskContainer.includeInBuild = false;
      }
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "alphaMask",
        action: "pushMaskEnd",
        mask,
        maskedContainer,
        inverse: maskedContainer._maskOptions.inverse,
        canBundle: false
      });
    }
    pop(mask, _maskedContainer, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "alphaMask",
        action: "popMaskEnd",
        mask,
        inverse: _maskedContainer._maskOptions.inverse,
        canBundle: false
      });
    }
    execute(instruction) {
      const renderer = this._renderer;
      const renderMask = instruction.mask.renderMaskToTexture;
      if (instruction.action === "pushMaskBegin") {
        const filterEffect = BigPool.get(AlphaMaskEffect);
        filterEffect.inverse = instruction.inverse;
        if (renderMask) {
          instruction.mask.mask.measurable = true;
          const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
          instruction.mask.mask.measurable = false;
          bounds.ceil();
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          const filterTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, colorTextureSource._resolution, colorTextureSource.antialias);
          renderer.renderTarget.push(filterTexture, true);
          renderer.globalUniforms.push({
            offset: bounds,
            worldColor: 4294967295
          });
          const sprite = filterEffect.sprite;
          sprite.texture = filterTexture;
          sprite.worldTransform.tx = bounds.minX;
          sprite.worldTransform.ty = bounds.minY;
          this._activeMaskStage.push({
            filterEffect,
            maskedContainer: instruction.maskedContainer,
            filterTexture
          });
        } else {
          filterEffect.sprite = instruction.mask.mask;
          this._activeMaskStage.push({
            filterEffect,
            maskedContainer: instruction.maskedContainer
          });
        }
      } else if (instruction.action === "pushMaskEnd") {
        const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
        if (renderMask) {
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
          renderer.renderTarget.pop();
          renderer.globalUniforms.pop();
        }
        renderer.filter.push({
          renderPipeId: "filter",
          action: "pushFilter",
          container: maskData.maskedContainer,
          filterEffect: maskData.filterEffect,
          canBundle: false
        });
      } else if (instruction.action === "popMaskEnd") {
        renderer.filter.pop();
        const maskData = this._activeMaskStage.pop();
        if (renderMask) {
          TexturePool.returnTexture(maskData.filterTexture);
        }
        BigPool.return(maskData.filterEffect);
      }
    }
    destroy() {
      this._renderer = null;
      this._activeMaskStage = null;
    }
  };
  AlphaMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "alphaMask"
  };

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe = class {
    constructor(renderer) {
      this._colorStack = [];
      this._colorStackIndex = 0;
      this._currentColor = 0;
      this._renderer = renderer;
    }
    buildStart() {
      this._colorStack[0] = 15;
      this._colorStackIndex = 1;
      this._currentColor = 15;
    }
    push(mask, _container, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const colorStack = this._colorStack;
      colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
      const currentColor = this._colorStack[this._colorStackIndex];
      if (currentColor !== this._currentColor) {
        this._currentColor = currentColor;
        instructionSet.add({
          renderPipeId: "colorMask",
          colorMask: currentColor,
          canBundle: false
        });
      }
      this._colorStackIndex++;
    }
    pop(_mask, _container, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      const colorStack = this._colorStack;
      this._colorStackIndex--;
      const currentColor = colorStack[this._colorStackIndex - 1];
      if (currentColor !== this._currentColor) {
        this._currentColor = currentColor;
        instructionSet.add({
          renderPipeId: "colorMask",
          colorMask: currentColor,
          canBundle: false
        });
      }
    }
    execute(instruction) {
      const renderer = this._renderer;
      renderer.colorMask.setMask(instruction.colorMask);
    }
    destroy() {
      this._renderer = null;
      this._colorStack = null;
    }
  };
  ColorMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "colorMask"
  };

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe = class {
    constructor(renderer) {
      this._maskStackHash = {};
      this._maskHash = /* @__PURE__ */ new WeakMap();
      this._renderer = renderer;
    }
    push(mask, _container, instructionSet) {
      var _a;
      const effect = mask;
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "pushMaskBegin",
        mask,
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const maskContainer = effect.mask;
      maskContainer.includeInBuild = true;
      if (!this._maskHash.has(effect)) {
        this._maskHash.set(effect, {
          instructionsStart: 0,
          instructionsLength: 0
        });
      }
      const maskData = this._maskHash.get(effect);
      maskData.instructionsStart = instructionSet.instructionSize;
      maskContainer.collectRenderables(instructionSet, renderer, null);
      maskContainer.includeInBuild = false;
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "pushMaskEnd",
        mask,
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
      maskData.instructionsLength = instructionsLength;
      const renderTargetUid = renderer.renderTarget.renderTarget.uid;
      (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
    }
    pop(mask, _container, instructionSet) {
      const effect = mask;
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "popMaskBegin",
        inverse: _container._maskOptions.inverse,
        canBundle: false
      });
      const maskData = this._maskHash.get(mask);
      for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
        instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
      }
      instructionSet.add({
        renderPipeId: "stencilMask",
        action: "popMaskEnd",
        canBundle: false
      });
    }
    execute(instruction) {
      var _a;
      const renderer = this._renderer;
      const renderTargetUid = renderer.renderTarget.renderTarget.uid;
      let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
      if (instruction.action === "pushMaskBegin") {
        renderer.renderTarget.ensureDepthStencil();
        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
        maskStackIndex++;
        renderer.colorMask.setMask(0);
      } else if (instruction.action === "pushMaskEnd") {
        if (instruction.inverse) {
          renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
        } else {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
        }
        renderer.colorMask.setMask(15);
      } else if (instruction.action === "popMaskBegin") {
        renderer.colorMask.setMask(0);
        if (maskStackIndex !== 0) {
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
        } else {
          renderer.renderTarget.clear(null, CLEAR.STENCIL);
          renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
        }
        maskStackIndex--;
      } else if (instruction.action === "popMaskEnd") {
        if (instruction.inverse) {
          renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
        } else {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
        }
        renderer.colorMask.setMask(15);
      }
      this._maskStackHash[renderTargetUid] = maskStackIndex;
    }
    destroy() {
      this._renderer = null;
      this._maskStackHash = null;
      this._maskHash = null;
    }
  };
  StencilMaskPipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "stencilMask"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem = class _BackgroundSystem2 {
    constructor() {
      this.clearBeforeRender = true;
      this._backgroundColor = new Color(0);
      this.color = this._backgroundColor;
      this.alpha = 1;
    }
    init(options) {
      options = {..._BackgroundSystem2.defaultOptions, ...options};
      this.clearBeforeRender = options.clearBeforeRender;
      this.color = options.background || options.backgroundColor || this._backgroundColor;
      this.alpha = options.backgroundAlpha;
      this._backgroundColor.setAlpha(options.backgroundAlpha);
    }
    get color() {
      return this._backgroundColor;
    }
    set color(value) {
      const incoming = Color.shared.setValue(value);
      if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {
        warn("Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.");
      }
      this._backgroundColor.setValue(value);
    }
    get alpha() {
      return this._backgroundColor.alpha;
    }
    set alpha(value) {
      this._backgroundColor.setAlpha(value);
    }
    get colorRgba() {
      return this._backgroundColor.toArray();
    }
    destroy() {
    }
  };
  _BackgroundSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "background",
    priority: 0
  };
  _BackgroundSystem.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: true
  };
  var BackgroundSystem = _BackgroundSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS = {};
  extensions.handle(ExtensionType.BlendMode, (value) => {
    if (!value.name) {
      throw new Error("BlendMode extension must have a name property");
    }
    BLEND_MODE_FILTERS[value.name] = value.ref;
  }, (value) => {
    delete BLEND_MODE_FILTERS[value.name];
  });
  var BlendModePipe = class {
    constructor(renderer) {
      this._blendModeStack = [];
      this._isAdvanced = false;
      this._filterHash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._renderer.runners.prerender.add(this);
    }
    prerender() {
      this._activeBlendMode = "normal";
      this._isAdvanced = false;
    }
    pushBlendMode(renderable, blendMode, instructionSet) {
      this._blendModeStack.push(blendMode);
      this.setBlendMode(renderable, blendMode, instructionSet);
    }
    popBlendMode(instructionSet) {
      this._blendModeStack.pop();
      const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
      this.setBlendMode(null, blendMode, instructionSet);
    }
    setBlendMode(renderable, blendMode, instructionSet) {
      const isRenderGroup = renderable instanceof RenderGroup;
      if (this._activeBlendMode === blendMode) {
        if (this._isAdvanced && renderable && !isRenderGroup) {
          this._renderableList?.push(renderable);
        }
        return;
      }
      if (this._isAdvanced)
        this._endAdvancedBlendMode(instructionSet);
      this._activeBlendMode = blendMode;
      if (!renderable)
        return;
      this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
      if (this._isAdvanced)
        this._beginAdvancedBlendMode(renderable, instructionSet);
    }
    _beginAdvancedBlendMode(renderable, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      const blendMode = this._activeBlendMode;
      if (!BLEND_MODE_FILTERS[blendMode]) {
        warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
        return;
      }
      const filterEffect = this._ensureFilterEffect(blendMode);
      const isRenderGroup = renderable instanceof RenderGroup;
      const instruction = {
        renderPipeId: "filter",
        action: "pushFilter",
        filterEffect,
        renderables: isRenderGroup ? null : [renderable],
        container: isRenderGroup ? renderable.root : null,
        canBundle: false
      };
      this._renderableList = instruction.renderables;
      instructionSet.add(instruction);
    }
    _ensureFilterEffect(blendMode) {
      let filterEffect = this._filterHash[blendMode];
      if (!filterEffect) {
        filterEffect = this._filterHash[blendMode] = new FilterEffect();
        filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
      }
      return filterEffect;
    }
    _endAdvancedBlendMode(instructionSet) {
      this._isAdvanced = false;
      this._renderableList = null;
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({
        renderPipeId: "filter",
        action: "popFilter",
        canBundle: false
      });
    }
    buildStart() {
      this._isAdvanced = false;
    }
    buildEnd(instructionSet) {
      if (!this._isAdvanced)
        return;
      this._endAdvancedBlendMode(instructionSet);
    }
    destroy() {
      this._renderer = null;
      this._renderableList = null;
      for (const i2 in this._filterHash) {
        this._filterHash[i2].destroy();
      }
      this._filterHash = null;
    }
  };
  BlendModePipe.extension = {
    type: [
      ExtensionType.WebGLPipes,
      ExtensionType.WebGPUPipes,
      ExtensionType.CanvasPipes
    ],
    name: "blendMode"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes = {
    png: "image/png",
    jpg: "image/jpeg",
    webp: "image/webp"
  };
  var _ExtractSystem = class _ExtractSystem2 {
    constructor(renderer) {
      this._renderer = renderer;
    }
    _normalizeOptions(options, defaults2 = {}) {
      if (options instanceof Container || options instanceof Texture) {
        return {
          target: options,
          ...defaults2
        };
      }
      return {
        ...defaults2,
        ...options
      };
    }
    async image(options) {
      const image = DOMAdapter.get().createImage();
      image.src = await this.base64(options);
      return image;
    }
    async base64(options) {
      options = this._normalizeOptions(options, _ExtractSystem2.defaultImageOptions);
      const {format, quality} = options;
      const canvas = this.canvas(options);
      if (canvas.toBlob !== void 0) {
        return new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (!blob) {
              reject(new Error("ICanvas.toBlob failed!"));
              return;
            }
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          }, imageTypes[format], quality);
        });
      }
      if (canvas.toDataURL !== void 0) {
        return canvas.toDataURL(imageTypes[format], quality);
      }
      if (canvas.convertToBlob !== void 0) {
        const blob = await canvas.convertToBlob({type: imageTypes[format], quality});
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
      throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
    }
    canvas(options) {
      options = this._normalizeOptions(options);
      const target = options.target;
      const renderer = this._renderer;
      if (target instanceof Texture) {
        return renderer.texture.generateCanvas(target);
      }
      const texture = renderer.textureGenerator.generateTexture(options);
      const canvas = renderer.texture.generateCanvas(texture);
      texture.destroy(true);
      return canvas;
    }
    pixels(options) {
      options = this._normalizeOptions(options);
      const target = options.target;
      const renderer = this._renderer;
      const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
      const pixelInfo = renderer.texture.getPixels(texture);
      if (target instanceof Container) {
        texture.destroy(true);
      }
      return pixelInfo;
    }
    texture(options) {
      options = this._normalizeOptions(options);
      if (options.target instanceof Texture)
        return options.target;
      return this._renderer.textureGenerator.generateTexture(options);
    }
    download(options) {
      options = this._normalizeOptions(options);
      const canvas = this.canvas(options);
      const link = document.createElement("a");
      link.download = options.filename ?? "image.png";
      link.href = canvas.toDataURL("image/png");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    log(options) {
      const width = options.width ?? 200;
      options = this._normalizeOptions(options);
      const canvas = this.canvas(options);
      const base64 = canvas.toDataURL();
      console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
      const style = [
        "font-size: 1px;",
        `padding: ${width}px ${300}px;`,
        `background: url(${base64}) no-repeat;`,
        "background-size: contain;"
      ].join(" ");
      console.log("%c ", style);
    }
    destroy() {
      this._renderer = null;
    }
  };
  _ExtractSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "extract"
  };
  _ExtractSystem.defaultImageOptions = {
    format: "png",
    quality: 1
  };
  var ExtractSystem = _ExtractSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture = class extends Texture {
    static create(options) {
      return new RenderTexture({
        source: new TextureSource(options)
      });
    }
    resize(width, height, resolution) {
      this.source.resize(width, height, resolution);
      return this;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect5 = new Rectangle();
  var tempBounds4 = new Bounds();
  var noColor = [0, 0, 0, 0];
  var GenerateTextureSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    generateTexture(options) {
      if (options instanceof Container) {
        options = {
          target: options,
          frame: void 0,
          textureSourceOptions: {},
          resolution: void 0
        };
      }
      const resolution = options.resolution || this._renderer.resolution;
      const antialias = options.antialias || this._renderer.view.antialias;
      const container = options.target;
      let clearColor = options.clearColor;
      if (clearColor) {
        const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
        clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
      } else {
        clearColor = noColor;
      }
      const region = options.frame?.copyTo(tempRect5) || getLocalBounds(container, tempBounds4).rectangle;
      region.width = Math.max(region.width, 1 / resolution) | 0;
      region.height = Math.max(region.height, 1 / resolution) | 0;
      const target = RenderTexture.create({
        ...options.textureSourceOptions,
        width: region.width,
        height: region.height,
        resolution,
        antialias
      });
      const transform = Matrix.shared.translate(-region.x, -region.y);
      this._renderer.render({
        container,
        transform,
        target,
        clearColor
      });
      target.source.updateMipmaps();
      return target;
    }
    destroy() {
      this._renderer = null;
    }
  };
  GenerateTextureSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "textureGenerator"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem = class {
    constructor(renderer) {
      this._stackIndex = 0;
      this._globalUniformDataStack = [];
      this._uniformsPool = [];
      this._activeUniforms = [];
      this._bindGroupPool = [];
      this._activeBindGroups = [];
      this._renderer = renderer;
    }
    reset() {
      this._stackIndex = 0;
      for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
        this._uniformsPool.push(this._activeUniforms[i2]);
      }
      for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
        this._bindGroupPool.push(this._activeBindGroups[i2]);
      }
      this._activeUniforms.length = 0;
      this._activeBindGroups.length = 0;
    }
    start(options) {
      this.reset();
      this.push(options);
    }
    bind({
      size,
      projectionMatrix,
      worldTransformMatrix,
      worldColor,
      offset
    }) {
      const renderTarget = this._renderer.renderTarget.renderTarget;
      const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
        projectionData: renderTarget,
        worldTransformMatrix: new Matrix(),
        worldColor: 4294967295,
        offset: new Point()
      };
      const globalUniformData = {
        projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
        resolution: size || renderTarget.size,
        worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
        worldColor: worldColor || currentGlobalUniformData.worldColor,
        offset: offset || currentGlobalUniformData.offset,
        bindGroup: null
      };
      const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
      this._activeUniforms.push(uniformGroup);
      const uniforms = uniformGroup.uniforms;
      uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
      uniforms.uResolution = globalUniformData.resolution;
      uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
      uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
      uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
      color32BitToUniform(globalUniformData.worldColor, uniforms.uWorldColorAlpha, 0);
      uniformGroup.update();
      let bindGroup;
      if (this._renderer.renderPipes.uniformBatch) {
        bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
      } else {
        bindGroup = this._bindGroupPool.pop() || new BindGroup();
        this._activeBindGroups.push(bindGroup);
        bindGroup.setResource(uniformGroup, 0);
      }
      globalUniformData.bindGroup = bindGroup;
      this._currentGlobalUniformData = globalUniformData;
    }
    push(options) {
      this.bind(options);
      this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
    }
    pop() {
      this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
      if (this._renderer.type === RendererType.WEBGL) {
        this._currentGlobalUniformData.bindGroup.resources[0].update();
      }
    }
    get bindGroup() {
      return this._currentGlobalUniformData.bindGroup;
    }
    get globalUniformData() {
      return this._currentGlobalUniformData;
    }
    get uniformGroup() {
      return this._currentGlobalUniformData.bindGroup.resources[0];
    }
    _createUniforms() {
      const globalUniforms = new UniformGroup({
        uProjectionMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uWorldTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uWorldColorAlpha: {value: new Float32Array(4), type: "vec4<f32>"},
        uResolution: {value: [0, 0], type: "vec2<f32>"}
      }, {
        isStatic: true
      });
      return globalUniforms;
    }
    destroy() {
      this._renderer = null;
      this._globalUniformDataStack.length = 0;
      this._uniformsPool.length = 0;
      this._activeUniforms.length = 0;
      this._bindGroupPool.length = 0;
      this._activeBindGroups.length = 0;
      this._currentGlobalUniformData = null;
    }
  };
  GlobalUniformSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "globalUniforms"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
  var uid2 = 1;
  var SchedulerSystem = class {
    constructor() {
      this._tasks = [];
      this._offset = 0;
    }
    init() {
      Ticker.system.add(this._update, this);
    }
    repeat(func, duration, useOffset = true) {
      const id = uid2++;
      let offset = 0;
      if (useOffset) {
        this._offset += 1e3;
        offset = this._offset;
      }
      this._tasks.push({
        func,
        duration,
        start: performance.now(),
        offset,
        last: performance.now(),
        repeat: true,
        id
      });
      return id;
    }
    cancel(id) {
      for (let i2 = 0; i2 < this._tasks.length; i2++) {
        if (this._tasks[i2].id === id) {
          this._tasks.splice(i2, 1);
          return;
        }
      }
    }
    _update() {
      const now = performance.now();
      for (let i2 = 0; i2 < this._tasks.length; i2++) {
        const task = this._tasks[i2];
        if (now - task.offset - task.last >= task.duration) {
          const elapsed = now - task.start;
          task.func(elapsed);
          task.last = now;
        }
      }
    }
    destroy() {
      Ticker.system.remove(this._update, this);
      this._tasks.length = 0;
    }
  };
  SchedulerSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "scheduler",
    priority: 0
  };

  // node_modules/pixi.js/lib/utils/sayHello.mjs
  var saidHello = false;
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    init(options) {
      if (options.hello) {
        let name = this._renderer.name;
        if (this._renderer.type === RendererType.WEBGL) {
          name += ` ${this._renderer.context.webGLVersion}`;
        }
        sayHello(name);
      }
    }
  };
  HelloSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "hello",
    priority: -2
  };
  HelloSystem.defaultOptions = {
    hello: false
  };

  // node_modules/pixi.js/lib/utils/data/clean.mjs
  "use strict";
  function cleanHash(hash) {
    let clean = false;
    for (const i2 in hash) {
      if (hash[i2] == void 0) {
        clean = true;
        break;
      }
    }
    if (!clean)
      return hash;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for (const i2 in hash) {
      const value = hash[i2];
      if (value) {
        cleanHash2[i2] = value;
      }
    }
    return cleanHash2;
  }
  function cleanArray(arr) {
    let offset = 0;
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (arr[i2] == void 0) {
        offset++;
      } else {
        arr[i2 - offset] = arr[i2];
      }
    }
    arr.length -= offset;
    return arr;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
  var renderableGCTick = 0;
  var _RenderableGCSystem = class _RenderableGCSystem2 {
    constructor(renderer) {
      this._managedRenderables = [];
      this._managedHashes = [];
      this._managedArrays = [];
      this._renderer = renderer;
    }
    init(options) {
      options = {..._RenderableGCSystem2.defaultOptions, ...options};
      this.maxUnusedTime = options.renderableGCMaxUnusedTime;
      this._frequency = options.renderableGCFrequency;
      this.enabled = options.renderableGCActive;
    }
    get enabled() {
      return !!this._handler;
    }
    set enabled(value) {
      if (this.enabled === value)
        return;
      if (value) {
        this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, false);
        this._hashHandler = this._renderer.scheduler.repeat(() => {
          for (const hash of this._managedHashes) {
            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
          }
        }, this._frequency);
        this._arrayHandler = this._renderer.scheduler.repeat(() => {
          for (const array of this._managedArrays) {
            cleanArray(array.context[array.hash]);
          }
        }, this._frequency);
      } else {
        this._renderer.scheduler.cancel(this._handler);
        this._renderer.scheduler.cancel(this._hashHandler);
        this._renderer.scheduler.cancel(this._arrayHandler);
      }
    }
    addManagedHash(context4, hash) {
      this._managedHashes.push({context: context4, hash});
    }
    addManagedArray(context4, hash) {
      this._managedArrays.push({context: context4, hash});
    }
    prerender({
      container
    }) {
      this._now = performance.now();
      container.renderGroup.gcTick = renderableGCTick++;
      this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
    }
    addRenderable(renderable) {
      if (!this.enabled)
        return;
      if (renderable._lastUsed === -1) {
        this._managedRenderables.push(renderable);
        renderable.once("destroyed", this._removeRenderable, this);
      }
      renderable._lastUsed = this._now;
    }
    run() {
      const now = this._now;
      const managedRenderables = this._managedRenderables;
      const renderPipes = this._renderer.renderPipes;
      let offset = 0;
      for (let i2 = 0; i2 < managedRenderables.length; i2++) {
        const renderable = managedRenderables[i2];
        if (renderable === null) {
          offset++;
          continue;
        }
        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
        const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
        if ((renderGroup?.gcTick ?? 0) === currentTick) {
          renderable._lastUsed = now;
        }
        if (now - renderable._lastUsed > this.maxUnusedTime) {
          if (!renderable.destroyed) {
            const rp = renderPipes;
            if (renderGroup)
              renderGroup.structureDidChange = true;
            rp[renderable.renderPipeId].destroyRenderable(renderable);
          }
          renderable._lastUsed = -1;
          offset++;
          renderable.off("destroyed", this._removeRenderable, this);
        } else {
          managedRenderables[i2 - offset] = renderable;
        }
      }
      managedRenderables.length -= offset;
    }
    destroy() {
      this.enabled = false;
      this._renderer = null;
      this._managedRenderables.length = 0;
      this._managedHashes.length = 0;
      this._managedArrays.length = 0;
    }
    _removeRenderable(renderable) {
      const index = this._managedRenderables.indexOf(renderable);
      if (index >= 0) {
        renderable.off("destroyed", this._removeRenderable, this);
        this._managedRenderables[index] = null;
      }
    }
    _updateInstructionGCTick(renderGroup, gcTick) {
      renderGroup.instructionSet.gcTick = gcTick;
      for (const child of renderGroup.renderGroupChildren) {
        this._updateInstructionGCTick(child, gcTick);
      }
    }
  };
  _RenderableGCSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "renderableGC",
    priority: 0
  };
  _RenderableGCSystem.defaultOptions = {
    renderableGCActive: true,
    renderableGCMaxUnusedTime: 6e4,
    renderableGCFrequency: 3e4
  };
  var RenderableGCSystem = _RenderableGCSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem = class _TextureGCSystem2 {
    constructor(renderer) {
      this._renderer = renderer;
      this.count = 0;
      this.checkCount = 0;
    }
    init(options) {
      options = {..._TextureGCSystem2.defaultOptions, ...options};
      this.checkCountMax = options.textureGCCheckCountMax;
      this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
      this.active = options.textureGCActive;
    }
    postrender() {
      if (!this._renderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (!this.active)
        return;
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    }
    run() {
      const managedTextures = this._renderer.texture.managedTextures;
      for (let i2 = 0; i2 < managedTextures.length; i2++) {
        const texture = managedTextures[i2];
        if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
          texture._touched = -1;
          texture.unload();
        }
      }
    }
    destroy() {
      this._renderer = null;
    }
  };
  _TextureGCSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem
    ],
    name: "textureGC"
  };
  _TextureGCSystem.defaultOptions = {
    textureGCActive: true,
    textureGCAMaxIdle: null,
    textureGCMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
  };
  var TextureGCSystem = _TextureGCSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget = class _RenderTarget2 {
    constructor(descriptor = {}) {
      this.uid = uid("renderTarget");
      this.colorTextures = [];
      this.dirtyId = 0;
      this.isRoot = false;
      this._size = new Float32Array(2);
      this._managedColorTextures = false;
      descriptor = {..._RenderTarget2.defaultOptions, ...descriptor};
      this.stencil = descriptor.stencil;
      this.depth = descriptor.depth;
      this.isRoot = descriptor.isRoot;
      if (typeof descriptor.colorTextures === "number") {
        this._managedColorTextures = true;
        for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
          this.colorTextures.push(new TextureSource({
            width: descriptor.width,
            height: descriptor.height,
            resolution: descriptor.resolution,
            antialias: descriptor.antialias
          }));
        }
      } else {
        this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
        const colorSource = this.colorTexture.source;
        this.resize(colorSource.width, colorSource.height, colorSource._resolution);
      }
      this.colorTexture.source.on("resize", this.onSourceResize, this);
      if (descriptor.depthStencilTexture || this.stencil) {
        if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
          this.depthStencilTexture = descriptor.depthStencilTexture.source;
        } else {
          this.ensureDepthStencilTexture();
        }
      }
    }
    get size() {
      const _size = this._size;
      _size[0] = this.pixelWidth;
      _size[1] = this.pixelHeight;
      return _size;
    }
    get width() {
      return this.colorTexture.source.width;
    }
    get height() {
      return this.colorTexture.source.height;
    }
    get pixelWidth() {
      return this.colorTexture.source.pixelWidth;
    }
    get pixelHeight() {
      return this.colorTexture.source.pixelHeight;
    }
    get resolution() {
      return this.colorTexture.source._resolution;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    onSourceResize(source3) {
      this.resize(source3.width, source3.height, source3._resolution, true);
    }
    ensureDepthStencilTexture() {
      if (!this.depthStencilTexture) {
        this.depthStencilTexture = new TextureSource({
          width: this.width,
          height: this.height,
          resolution: this.resolution,
          format: "depth24plus-stencil8",
          autoGenerateMipmaps: false,
          antialias: false,
          mipLevelCount: 1
        });
      }
    }
    resize(width, height, resolution = this.resolution, skipColorTexture = false) {
      this.dirtyId++;
      this.colorTextures.forEach((colorTexture, i2) => {
        if (skipColorTexture && i2 === 0)
          return;
        colorTexture.source.resize(width, height, resolution);
      });
      if (this.depthStencilTexture) {
        this.depthStencilTexture.source.resize(width, height, resolution);
      }
    }
    destroy() {
      this.colorTexture.source.off("resize", this.onSourceResize, this);
      if (this._managedColorTextures) {
        this.colorTextures.forEach((texture) => {
          texture.destroy();
        });
      }
      if (this.depthStencilTexture) {
        this.depthStencilTexture.destroy();
        delete this.depthStencilTexture;
      }
    }
  };
  _RenderTarget.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: false,
    depth: false,
    antialias: false,
    isRoot: false
  };
  var RenderTarget = _RenderTarget;

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  var canvasCache = /* @__PURE__ */ new Map();
  GlobalResourceRegistry.register(canvasCache);
  function getCanvasTexture(canvas, options) {
    if (!canvasCache.has(canvas)) {
      const texture = new Texture({
        source: new CanvasSource({
          resource: canvas,
          ...options
        })
      });
      const onDestroy = () => {
        if (canvasCache.get(canvas) === texture) {
          canvasCache.delete(canvas);
        }
      };
      texture.once("destroy", onDestroy);
      texture.source.once("destroy", onDestroy);
      canvasCache.set(canvas, texture);
    }
    return canvasCache.get(canvas);
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem = class _ViewSystem2 {
    get autoDensity() {
      return this.texture.source.autoDensity;
    }
    set autoDensity(value) {
      this.texture.source.autoDensity = value;
    }
    get resolution() {
      return this.texture.source._resolution;
    }
    set resolution(value) {
      this.texture.source.resize(this.texture.source.width, this.texture.source.height, value);
    }
    init(options) {
      options = {
        ..._ViewSystem2.defaultOptions,
        ...options
      };
      if (options.view) {
        deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
        options.canvas = options.view;
      }
      this.screen = new Rectangle(0, 0, options.width, options.height);
      this.canvas = options.canvas || DOMAdapter.get().createCanvas();
      this.antialias = !!options.antialias;
      this.texture = getCanvasTexture(this.canvas, options);
      this.renderTarget = new RenderTarget({
        colorTextures: [this.texture],
        depth: !!options.depth,
        isRoot: true
      });
      this.texture.source.transparent = options.backgroundAlpha < 1;
      this.resolution = options.resolution;
    }
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      this.screen.width = this.texture.frame.width;
      this.screen.height = this.texture.frame.height;
    }
    destroy(options = false) {
      const removeView = typeof options === "boolean" ? options : !!options?.removeView;
      if (removeView && this.canvas.parentNode) {
        this.canvas.parentNode.removeChild(this.canvas);
      }
      this.texture.destroy();
    }
  };
  _ViewSystem.extension = {
    type: [
      ExtensionType.WebGLSystem,
      ExtensionType.WebGPUSystem,
      ExtensionType.CanvasSystem
    ],
    name: "view",
    priority: 0
  };
  _ViewSystem.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: false,
    antialias: false
  };
  var ViewSystem = _ViewSystem;

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems = [
    BackgroundSystem,
    GlobalUniformSystem,
    HelloSystem,
    ViewSystem,
    RenderGroupSystem,
    TextureGCSystem,
    GenerateTextureSystem,
    ExtractSystem,
    RendererInitHook,
    RenderableGCSystem,
    SchedulerSystem
  ];
  var SharedRenderPipes = [
    BlendModePipe,
    BatcherPipe,
    SpritePipe,
    RenderGroupPipe,
    AlphaMaskPipe,
    StencilMaskPipe,
    ColorMaskPipe,
    CustomRenderPipe
  ];

  // node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem = class {
    constructor(renderer) {
      this._hash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_hash");
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    getBindGroup(bindGroup, program, groupIndex) {
      bindGroup._updateKey();
      const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
      return gpuBindGroup;
    }
    _createBindGroup(group, program, groupIndex) {
      const device = this._gpu.device;
      const groupLayout = program.layout[groupIndex];
      const entries = [];
      const renderer = this._renderer;
      for (const j2 in groupLayout) {
        const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
        let gpuResource;
        if (resource._resourceType === "uniformGroup") {
          const uniformGroup = resource;
          renderer.ubo.updateUniformGroup(uniformGroup);
          const buffer = uniformGroup.buffer;
          gpuResource = {
            buffer: renderer.buffer.getGPUBuffer(buffer),
            offset: 0,
            size: buffer.descriptor.size
          };
        } else if (resource._resourceType === "buffer") {
          const buffer = resource;
          gpuResource = {
            buffer: renderer.buffer.getGPUBuffer(buffer),
            offset: 0,
            size: buffer.descriptor.size
          };
        } else if (resource._resourceType === "bufferResource") {
          const bufferResource = resource;
          gpuResource = {
            buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
            offset: bufferResource.offset,
            size: bufferResource.size
          };
        } else if (resource._resourceType === "textureSampler") {
          const sampler = resource;
          gpuResource = renderer.texture.getGpuSampler(sampler);
        } else if (resource._resourceType === "textureSource") {
          const texture = resource;
          gpuResource = renderer.texture.getGpuSource(texture).createView({});
        }
        entries.push({
          binding: groupLayout[j2],
          resource: gpuResource
        });
      }
      const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
      const gpuBindGroup = device.createBindGroup({
        layout,
        entries
      });
      this._hash[group._key] = gpuBindGroup;
      return gpuBindGroup;
    }
    destroy() {
      for (const key of Object.keys(this._hash)) {
        this._hash[key] = null;
      }
      this._hash = null;
      this._renderer = null;
    }
  };
  BindGroupSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "bindGroup"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferSystem = class {
    constructor(renderer) {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      this._managedBuffers = [];
      renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    getGPUBuffer(buffer) {
      return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
    }
    updateBuffer(buffer) {
      const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      const data = buffer.data;
      if (buffer._updateID && data) {
        buffer._updateID = 0;
        this._gpu.device.queue.writeBuffer(gpuBuffer, 0, data.buffer, 0, (buffer._updateSize || data.byteLength) + 3 & ~3);
      }
      return gpuBuffer;
    }
    destroyAll() {
      for (const id in this._gpuBuffers) {
        this._gpuBuffers[id].destroy();
      }
      this._gpuBuffers = {};
    }
    createGPUBuffer(buffer) {
      if (!this._gpuBuffers[buffer.uid]) {
        buffer.on("update", this.updateBuffer, this);
        buffer.on("change", this.onBufferChange, this);
        buffer.on("destroy", this.onBufferDestroy, this);
        this._managedBuffers.push(buffer);
      }
      const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
      buffer._updateID = 0;
      if (buffer.data) {
        fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
        gpuBuffer.unmap();
      }
      this._gpuBuffers[buffer.uid] = gpuBuffer;
      return gpuBuffer;
    }
    onBufferChange(buffer) {
      const gpuBuffer = this._gpuBuffers[buffer.uid];
      gpuBuffer.destroy();
      buffer._updateID = 0;
      this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
    }
    onBufferDestroy(buffer) {
      this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
      this._destroyBuffer(buffer);
    }
    destroy() {
      this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
      this._managedBuffers = null;
      this._gpuBuffers = null;
    }
    _destroyBuffer(buffer) {
      const gpuBuffer = this._gpuBuffers[buffer.uid];
      gpuBuffer.destroy();
      buffer.off("update", this.updateBuffer, this);
      buffer.off("change", this.onBufferChange, this);
      buffer.off("destroy", this.onBufferDestroy, this);
      this._gpuBuffers[buffer.uid] = null;
    }
  };
  GpuBufferSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "buffer"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem = class {
    constructor(renderer) {
      this._colorMaskCache = 15;
      this._renderer = renderer;
    }
    setMask(colorMask) {
      if (this._colorMaskCache === colorMask)
        return;
      this._colorMaskCache = colorMask;
      this._renderer.pipeline.setColorMask(colorMask);
    }
    destroy() {
      this._renderer = null;
      this._colorMaskCache = null;
    }
  };
  GpuColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "colorMask"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    async init(options) {
      if (this._initPromise)
        return this._initPromise;
      this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {
        this.gpu = gpu;
        this._renderer.runners.contextChange.emit(this.gpu);
      });
      return this._initPromise;
    }
    contextChange(gpu) {
      this._renderer.gpu = gpu;
    }
    async _createDeviceAndAdaptor(options) {
      const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
        powerPreference: options.powerPreference,
        forceFallbackAdapter: options.forceFallbackAdapter
      });
      const requiredFeatures = [
        "texture-compression-bc",
        "texture-compression-astc",
        "texture-compression-etc2"
      ].filter((feature) => adapter.features.has(feature));
      const device = await adapter.requestDevice({
        requiredFeatures
      });
      return {adapter, device};
    }
    destroy() {
      this.gpu = null;
      this._renderer = null;
    }
  };
  GpuDeviceSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "device"
  };
  GpuDeviceSystem.defaultOptions = {
    powerPreference: void 0,
    forceFallbackAdapter: false
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem = class {
    constructor(renderer) {
      this._boundBindGroup = /* @__PURE__ */ Object.create(null);
      this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
    }
    renderStart() {
      this.commandFinished = new Promise((resolve) => {
        this._resolveCommandFinished = resolve;
      });
      this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    }
    beginRenderPass(gpuRenderTarget) {
      this.endRenderPass();
      this._clearCache();
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
    }
    endRenderPass() {
      if (this.renderPassEncoder) {
        this.renderPassEncoder.end();
      }
      this.renderPassEncoder = null;
    }
    setViewport(viewport) {
      this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
    }
    setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
      const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
      this.setPipeline(pipeline);
    }
    setPipeline(pipeline) {
      if (this._boundPipeline === pipeline)
        return;
      this._boundPipeline = pipeline;
      this.renderPassEncoder.setPipeline(pipeline);
    }
    _setVertexBuffer(index, buffer) {
      if (this._boundVertexBuffer[index] === buffer)
        return;
      this._boundVertexBuffer[index] = buffer;
      this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
    }
    _setIndexBuffer(buffer) {
      if (this._boundIndexBuffer === buffer)
        return;
      this._boundIndexBuffer = buffer;
      const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
      this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
    }
    resetBindGroup(index) {
      this._boundBindGroup[index] = null;
    }
    setBindGroup(index, bindGroup, program) {
      if (this._boundBindGroup[index] === bindGroup)
        return;
      this._boundBindGroup[index] = bindGroup;
      bindGroup._touch(this._renderer.textureGC.count);
      const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
      this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
    }
    setGeometry(geometry, program) {
      const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
      for (const i2 in buffersToBind) {
        this._setVertexBuffer(parseInt(i2, 10), geometry.attributes[buffersToBind[i2]].buffer);
      }
      if (geometry.indexBuffer) {
        this._setIndexBuffer(geometry.indexBuffer);
      }
    }
    _setShaderBindGroups(shader, skipSync) {
      for (const i2 in shader.groups) {
        const bindGroup = shader.groups[i2];
        if (!skipSync) {
          this._syncBindGroup(bindGroup);
        }
        this.setBindGroup(i2, bindGroup, shader.gpuProgram);
      }
    }
    _syncBindGroup(bindGroup) {
      for (const j2 in bindGroup.resources) {
        const resource = bindGroup.resources[j2];
        if (resource.isUniformGroup) {
          this._renderer.ubo.updateUniformGroup(resource);
        }
      }
    }
    draw(options) {
      const {geometry, shader, state, topology, size, start, instanceCount, skipSync} = options;
      this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
      this.setGeometry(geometry, shader.gpuProgram);
      this._setShaderBindGroups(shader, skipSync);
      if (geometry.indexBuffer) {
        this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount ?? geometry.instanceCount, start || 0);
      } else {
        this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
      }
    }
    finishRenderPass() {
      if (this.renderPassEncoder) {
        this.renderPassEncoder.end();
        this.renderPassEncoder = null;
      }
    }
    postrender() {
      this.finishRenderPass();
      this._gpu.device.queue.submit([this.commandEncoder.finish()]);
      this._resolveCommandFinished();
      this.commandEncoder = null;
    }
    restoreRenderPass() {
      const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [0, 0, 0, 1]);
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
      const boundPipeline = this._boundPipeline;
      const boundVertexBuffer = {...this._boundVertexBuffer};
      const boundIndexBuffer = this._boundIndexBuffer;
      const boundBindGroup = {...this._boundBindGroup};
      this._clearCache();
      const viewport = this._renderer.renderTarget.viewport;
      this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      this.setPipeline(boundPipeline);
      for (const i2 in boundVertexBuffer) {
        this._setVertexBuffer(i2, boundVertexBuffer[i2]);
      }
      for (const i2 in boundBindGroup) {
        this.setBindGroup(i2, boundBindGroup[i2], null);
      }
      this._setIndexBuffer(boundIndexBuffer);
    }
    _clearCache() {
      for (let i2 = 0; i2 < 16; i2++) {
        this._boundBindGroup[i2] = null;
        this._boundVertexBuffer[i2] = null;
      }
      this._boundIndexBuffer = null;
      this._boundPipeline = null;
    }
    destroy() {
      this._renderer = null;
      this._gpu = null;
      this._boundBindGroup = null;
      this._boundVertexBuffer = null;
      this._boundIndexBuffer = null;
      this._boundPipeline = null;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
  };
  GpuEncoderSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "encoder",
    priority: 1
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs
  var GpuLimitsSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange() {
      this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;
      this.maxBatchableTextures = this.maxTextures;
    }
    destroy() {
    }
  };
  GpuLimitsSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "limits"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem = class {
    constructor(renderer) {
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(renderTarget) {
      let stencilState = this._renderTargetStencilState[renderTarget.uid];
      if (!stencilState) {
        stencilState = this._renderTargetStencilState[renderTarget.uid] = {
          stencilMode: STENCIL_MODES.DISABLED,
          stencilReference: 0
        };
      }
      this._activeRenderTarget = renderTarget;
      this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
    }
    setStencilMode(stencilMode, stencilReference) {
      const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
      stencilState.stencilMode = stencilMode;
      stencilState.stencilReference = stencilReference;
      const renderer = this._renderer;
      renderer.pipeline.setStencilMode(stencilMode);
      renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
    }
    destroy() {
      this._renderer.renderTarget.onRenderTargetChange.remove(this);
      this._renderer = null;
      this._activeRenderTarget = null;
      this._renderTargetStencilState = null;
    }
  };
  GpuStencilSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "stencil"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem = class {
    constructor(adaptor) {
      this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
      this._adaptor = adaptor;
      this._systemCheck();
    }
    _systemCheck() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
    }
    ensureUniformGroup(uniformGroup) {
      const uniformData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
        data: new Float32Array(uniformData.layout.size / 4),
        usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
      }));
    }
    getUniformGroupData(uniformGroup) {
      return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
    }
    _initUniformGroup(uniformGroup) {
      const uniformGroupSignature = uniformGroup._signature;
      let uniformData = this._syncFunctionHash[uniformGroupSignature];
      if (!uniformData) {
        const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
        const layout = this._adaptor.createUboElements(elements);
        const syncFunction = this._generateUboSync(layout.uboElements);
        uniformData = this._syncFunctionHash[uniformGroupSignature] = {
          layout,
          syncFunction
        };
      }
      return this._syncFunctionHash[uniformGroupSignature];
    }
    _generateUboSync(uboElements) {
      return this._adaptor.generateUboSync(uboElements);
    }
    syncUniformGroup(uniformGroup, data, offset) {
      const uniformGroupData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
        data: new Float32Array(uniformGroupData.layout.size / 4),
        usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
      }));
      let dataInt32 = null;
      if (!data) {
        data = uniformGroup.buffer.data;
        dataInt32 = uniformGroup.buffer.dataInt32;
      }
      offset || (offset = 0);
      uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
      return true;
    }
    updateUniformGroup(uniformGroup) {
      if (uniformGroup.isStatic && !uniformGroup._dirtyId)
        return false;
      uniformGroup._dirtyId = 0;
      const synced = this.syncUniformGroup(uniformGroup);
      uniformGroup.buffer.update();
      return synced;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  "use strict";
  var WGSL_ALIGN_SIZE_DATA = {
    i32: {align: 4, size: 4},
    u32: {align: 4, size: 4},
    f32: {align: 4, size: 4},
    f16: {align: 2, size: 2},
    "vec2<i32>": {align: 8, size: 8},
    "vec2<u32>": {align: 8, size: 8},
    "vec2<f32>": {align: 8, size: 8},
    "vec2<f16>": {align: 4, size: 4},
    "vec3<i32>": {align: 16, size: 12},
    "vec3<u32>": {align: 16, size: 12},
    "vec3<f32>": {align: 16, size: 12},
    "vec3<f16>": {align: 8, size: 6},
    "vec4<i32>": {align: 16, size: 16},
    "vec4<u32>": {align: 16, size: 16},
    "vec4<f32>": {align: 16, size: 16},
    "vec4<f16>": {align: 8, size: 8},
    "mat2x2<f32>": {align: 8, size: 16},
    "mat2x2<f16>": {align: 4, size: 8},
    "mat3x2<f32>": {align: 8, size: 24},
    "mat3x2<f16>": {align: 4, size: 12},
    "mat4x2<f32>": {align: 8, size: 32},
    "mat4x2<f16>": {align: 4, size: 16},
    "mat2x3<f32>": {align: 16, size: 32},
    "mat2x3<f16>": {align: 8, size: 16},
    "mat3x3<f32>": {align: 16, size: 48},
    "mat3x3<f16>": {align: 8, size: 24},
    "mat4x3<f32>": {align: 16, size: 64},
    "mat4x3<f16>": {align: 8, size: 32},
    "mat2x4<f32>": {align: 16, size: 32},
    "mat2x4<f16>": {align: 8, size: 16},
    "mat3x4<f32>": {align: 16, size: 48},
    "mat3x4<f16>": {align: 8, size: 24},
    "mat4x4<f32>": {align: 16, size: 64},
    "mat4x4<f16>": {align: 8, size: 32}
  };
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return {uboElements, size: offset};
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  "use strict";
  var uniformParsers = [
    {
      type: "mat3x3<f32>",
      test: (data) => {
        const value = data.value;
        return value.a !== void 0;
      },
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
    },
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
    },
    {
      type: "vec2<f32>",
      test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
    },
    {
      type: "vec4<f32>",
      test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
    },
    {
      type: "vec3<f32>",
      test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
    }
  ];

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(`name = "${name}";`, `offset += ${offset - prev};`, uniformParsers[j2][parserCode] || uniformParsers[j2].ubo);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(`
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `);
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function("uv", "data", "dataInt32", "offset", fragmentSrc);
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  "use strict";
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40 = {
    f32: `
        data[offset] = v;`,
    i32: `
        dataInt32[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
    "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
    "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": loopMatrix(3, 2),
    "mat4x2<f32>": loopMatrix(4, 2),
    "mat2x3<f32>": loopMatrix(2, 3),
    "mat4x3<f32>": loopMatrix(4, 3),
    "mat2x4<f32>": loopMatrix(2, 4),
    "mat3x4<f32>": loopMatrix(3, 4)
  };
  var uboSyncFunctionsWGSL = {
    ...uboSyncFunctionsSTD40,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const {size, align} = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(uboElements, "uboWgsl", generateArraySyncWGSL, uboSyncFunctionsWGSL);
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem = class extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsWGSL,
        generateUboSync: createUboSyncFunctionWGSL
      });
    }
  };
  GpuUboSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "ubo"
  };

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource = class extends eventemitter3_default {
    constructor({buffer, offset, size}) {
      super();
      this.uid = uid("buffer");
      this._resourceType = "bufferResource";
      this._touched = 0;
      this._resourceId = uid("resource");
      this._bufferResource = true;
      this.destroyed = false;
      this.buffer = buffer;
      this.offset = offset | 0;
      this.size = size;
      this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      this._resourceId = uid("resource");
      this.emit("change", this);
    }
    destroy(destroyBuffer = false) {
      this.destroyed = true;
      if (destroyBuffer) {
        this.buffer.destroy();
      }
      this.emit("change", this);
      this.buffer = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  "use strict";
  var UboBatch = class {
    constructor({minUniformOffsetAlignment: minUniformOffsetAlignment2}) {
      this._minUniformOffsetAlignment = 256;
      this.byteIndex = 0;
      this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
      this.data = new Float32Array(65535);
    }
    clear() {
      this.byteIndex = 0;
    }
    addEmptyGroup(size) {
      if (size > this._minUniformOffsetAlignment / 4) {
        throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
      }
      const start = this.byteIndex;
      let newSize = start + size * 4;
      newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
      if (newSize > this.data.length * 4) {
        throw new Error("UniformBufferBatch: ubo batch got too big");
      }
      this.byteIndex = newSize;
      return start;
    }
    addGroup(array) {
      const offset = this.addEmptyGroup(array.length);
      for (let i2 = 0; i2 < array.length; i2++) {
        this.data[offset / 4 + i2] = array[i2];
      }
      return offset;
    }
    destroy() {
      this.data = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment = 128;
  var GpuUniformBatchPipe = class {
    constructor(renderer) {
      this._bindGroupHash = /* @__PURE__ */ Object.create(null);
      this._buffers = [];
      this._bindGroups = [];
      this._bufferResources = [];
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
      this._batchBuffer = new UboBatch({minUniformOffsetAlignment});
      const totalBuffers = 256 / minUniformOffsetAlignment;
      for (let i2 = 0; i2 < totalBuffers; i2++) {
        let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
        if (i2 === 0)
          usage |= BufferUsage.COPY_SRC;
        this._buffers.push(new Buffer2({
          data: this._batchBuffer.data,
          usage
        }));
      }
    }
    renderEnd() {
      this._uploadBindGroups();
      this._resetBindGroups();
    }
    _resetBindGroups() {
      for (const i2 in this._bindGroupHash) {
        this._bindGroupHash[i2] = null;
      }
      this._batchBuffer.clear();
    }
    getUniformBindGroup(group, duplicate) {
      if (!duplicate && this._bindGroupHash[group.uid]) {
        return this._bindGroupHash[group.uid];
      }
      this._renderer.ubo.ensureUniformGroup(group);
      const data = group.buffer.data;
      const offset = this._batchBuffer.addEmptyGroup(data.length);
      this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
      this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
      return this._bindGroupHash[group.uid];
    }
    getUboResource(group) {
      this._renderer.ubo.updateUniformGroup(group);
      const data = group.buffer.data;
      const offset = this._batchBuffer.addGroup(data);
      return this._getBufferResource(offset / minUniformOffsetAlignment);
    }
    getArrayBindGroup(data) {
      const offset = this._batchBuffer.addGroup(data);
      return this._getBindGroup(offset / minUniformOffsetAlignment);
    }
    getArrayBufferResource(data) {
      const offset = this._batchBuffer.addGroup(data);
      const index = offset / minUniformOffsetAlignment;
      return this._getBufferResource(index);
    }
    _getBufferResource(index) {
      if (!this._bufferResources[index]) {
        const buffer = this._buffers[index % 2];
        this._bufferResources[index] = new BufferResource({
          buffer,
          offset: (index / 2 | 0) * 256,
          size: minUniformOffsetAlignment
        });
      }
      return this._bufferResources[index];
    }
    _getBindGroup(index) {
      if (!this._bindGroups[index]) {
        const bindGroup = new BindGroup({
          0: this._getBufferResource(index)
        });
        this._bindGroups[index] = bindGroup;
      }
      return this._bindGroups[index];
    }
    _uploadBindGroups() {
      const bufferSystem = this._renderer.buffer;
      const firstBuffer = this._buffers[0];
      firstBuffer.update(this._batchBuffer.byteIndex);
      bufferSystem.updateBuffer(firstBuffer);
      const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      for (let i2 = 1; i2 < this._buffers.length; i2++) {
        const buffer = this._buffers[i2];
        commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer), minUniformOffsetAlignment, bufferSystem.getGPUBuffer(buffer), 0, this._batchBuffer.byteIndex);
      }
      this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
    }
    destroy() {
      for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
        this._bindGroups[i2]?.destroy();
      }
      this._bindGroups = null;
      this._bindGroupHash = null;
      for (let i2 = 0; i2 < this._buffers.length; i2++) {
        this._buffers[i2].destroy();
      }
      this._buffers = null;
      for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
        this._bufferResources[i2].destroy();
      }
      this._bufferResources = null;
      this._batchBuffer.destroy();
      this._bindGroupHash = null;
      this._renderer = null;
    }
  };
  GpuUniformBatchPipe.extension = {
    type: [
      ExtensionType.WebGPUPipes
    ],
    name: "uniformBatch"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    for (const i2 in geometry.attributes) {
      const attribute = geometry.attributes[i2];
      const attributeData = extractedData[i2];
      if (attributeData) {
        attribute.format ?? (attribute.format = attributeData.format);
        attribute.offset ?? (attribute.offset = attributeData.offset);
        attribute.instance ?? (attribute.instance = attributeData.instance);
      } else {
        warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    const {buffers, attributes} = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
      attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi = [];
  GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
  GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
    stencilFront: {
      compare: "equal",
      passOp: "increment-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "increment-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
    stencilFront: {
      compare: "equal",
      passOp: "decrement-clamp"
    },
    stencilBack: {
      compare: "equal",
      passOp: "decrement-clamp"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "equal",
      passOp: "keep"
    }
  };
  GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
      compare: "not-equal",
      passOp: "keep"
    },
    stencilBack: {
      compare: "not-equal",
      passOp: "keep"
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  var topologyStringToId = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
  };
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }
  var PipelineSystem = class {
    constructor(renderer) {
      this._moduleCache = /* @__PURE__ */ Object.create(null);
      this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
      this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
      this._pipeCache = /* @__PURE__ */ Object.create(null);
      this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
      this._colorMask = 15;
      this._multisampleCount = 1;
      this._renderer = renderer;
    }
    contextChange(gpu) {
      this._gpu = gpu;
      this.setStencilMode(STENCIL_MODES.DISABLED);
      this._updatePipeHash();
    }
    setMultisampleCount(multisampleCount) {
      if (this._multisampleCount === multisampleCount)
        return;
      this._multisampleCount = multisampleCount;
      this._updatePipeHash();
    }
    setRenderTarget(renderTarget) {
      this._multisampleCount = renderTarget.msaaSamples;
      this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
      this._updatePipeHash();
    }
    setColorMask(colorMask) {
      if (this._colorMask === colorMask)
        return;
      this._colorMask = colorMask;
      this._updatePipeHash();
    }
    setStencilMode(stencilMode) {
      if (this._stencilMode === stencilMode)
        return;
      this._stencilMode = stencilMode;
      this._stencilState = GpuStencilModesToPixi[stencilMode];
      this._updatePipeHash();
    }
    setPipeline(geometry, program, state, passEncoder) {
      const pipeline = this.getPipeline(geometry, program, state);
      passEncoder.setPipeline(pipeline);
    }
    getPipeline(geometry, program, state, topology) {
      if (!geometry._layoutKey) {
        ensureAttributes(geometry, program.attributeData);
        this._generateBufferKey(geometry);
      }
      topology || (topology = geometry.topology);
      const key = getGraphicsStateKey(geometry._layoutKey, program._layoutKey, state.data, state._blendModeId, topologyStringToId[topology]);
      if (this._pipeCache[key])
        return this._pipeCache[key];
      this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
      return this._pipeCache[key];
    }
    _createPipeline(geometry, program, state, topology) {
      const device = this._gpu.device;
      const buffers = this._createVertexBufferLayouts(geometry, program);
      const blendModes = this._renderer.state.getColorTargets(state);
      blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
      const layout = this._renderer.shader.getProgramData(program).pipeline;
      const descriptor = {
        vertex: {
          module: this._getModule(program.vertex.source),
          entryPoint: program.vertex.entryPoint,
          buffers
        },
        fragment: {
          module: this._getModule(program.fragment.source),
          entryPoint: program.fragment.entryPoint,
          targets: blendModes
        },
        primitive: {
          topology,
          cullMode: state.cullMode
        },
        layout,
        multisample: {
          count: this._multisampleCount
        },
        label: `PIXI Pipeline`
      };
      if (this._depthStencilAttachment) {
        descriptor.depthStencil = {
          ...this._stencilState,
          format: "depth24plus-stencil8",
          depthWriteEnabled: state.depthTest,
          depthCompare: state.depthTest ? "less" : "always"
        };
      }
      const pipeline = device.createRenderPipeline(descriptor);
      return pipeline;
    }
    _getModule(code) {
      return this._moduleCache[code] || this._createModule(code);
    }
    _createModule(code) {
      const device = this._gpu.device;
      this._moduleCache[code] = device.createShaderModule({
        code
      });
      return this._moduleCache[code];
    }
    _generateBufferKey(geometry) {
      const keyGen = [];
      let index = 0;
      const attributeKeys = Object.keys(geometry.attributes).sort();
      for (let i2 = 0; i2 < attributeKeys.length; i2++) {
        const attribute = geometry.attributes[attributeKeys[i2]];
        keyGen[index++] = attribute.offset;
        keyGen[index++] = attribute.format;
        keyGen[index++] = attribute.stride;
        keyGen[index++] = attribute.instance;
      }
      const stringKey = keyGen.join("|");
      geometry._layoutKey = createIdFromString(stringKey, "geometry");
      return geometry._layoutKey;
    }
    _generateAttributeLocationsKey(program) {
      const keyGen = [];
      let index = 0;
      const attributeKeys = Object.keys(program.attributeData).sort();
      for (let i2 = 0; i2 < attributeKeys.length; i2++) {
        const attribute = program.attributeData[attributeKeys[i2]];
        keyGen[index++] = attribute.location;
      }
      const stringKey = keyGen.join("|");
      program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
      return program._attributeLocationsKey;
    }
    getBufferNamesToBind(geometry, program) {
      const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
      if (this._bindingNamesCache[key])
        return this._bindingNamesCache[key];
      const data = this._createVertexBufferLayouts(geometry, program);
      const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
      const attributeData = program.attributeData;
      for (let i2 = 0; i2 < data.length; i2++) {
        const attributes = Object.values(data[i2].attributes);
        const shaderLocation = attributes[0].shaderLocation;
        for (const j2 in attributeData) {
          if (attributeData[j2].location === shaderLocation) {
            bufferNamesToBind[i2] = j2;
            break;
          }
        }
      }
      this._bindingNamesCache[key] = bufferNamesToBind;
      return bufferNamesToBind;
    }
    _createVertexBufferLayouts(geometry, program) {
      if (!program._attributeLocationsKey)
        this._generateAttributeLocationsKey(program);
      const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
      if (this._bufferLayoutsCache[key]) {
        return this._bufferLayoutsCache[key];
      }
      const vertexBuffersLayout = [];
      geometry.buffers.forEach((buffer) => {
        const bufferEntry = {
          arrayStride: 0,
          stepMode: "vertex",
          attributes: []
        };
        const bufferEntryAttributes = bufferEntry.attributes;
        for (const i2 in program.attributeData) {
          const attribute = geometry.attributes[i2];
          if ((attribute.divisor ?? 1) !== 1) {
            warn(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
          }
          if (attribute.buffer === buffer) {
            bufferEntry.arrayStride = attribute.stride;
            bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
            bufferEntryAttributes.push({
              shaderLocation: program.attributeData[i2].location,
              offset: attribute.offset,
              format: attribute.format
            });
          }
        }
        if (bufferEntryAttributes.length) {
          vertexBuffersLayout.push(bufferEntry);
        }
      });
      this._bufferLayoutsCache[key] = vertexBuffersLayout;
      return vertexBuffersLayout;
    }
    _updatePipeHash() {
      const key = getGlobalStateKey(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
      if (!this._pipeStateCaches[key]) {
        this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
      }
      this._pipeCache = this._pipeStateCaches[key];
    }
    destroy() {
      this._renderer = null;
      this._bufferLayoutsCache = null;
    }
  };
  PipelineSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "pipeline"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  "use strict";
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign2 = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign2 * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign2 - y2 * pm.d;
    return pm;
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  "use strict";
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem = class {
    constructor(renderer) {
      this.rootViewPort = new Rectangle();
      this.viewport = new Rectangle();
      this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
      this.projectionMatrix = new Matrix();
      this.defaultClearColor = [0, 0, 0, 0];
      this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
      this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      this._renderTargetStack = [];
      this._renderer = renderer;
      renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
    }
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    renderStart({
      target,
      clear,
      clearColor,
      frame
    }) {
      this._renderTargetStack.length = 0;
      this.push(target, clear, clearColor, frame);
      this.rootViewPort.copyFrom(this.viewport);
      this.rootRenderTarget = this.renderTarget;
      this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
      this.adaptor.prerender?.(this.rootRenderTarget);
    }
    postrender() {
      this.adaptor.postrender?.(this.rootRenderTarget);
    }
    bind(renderSurface, clear = true, clearColor, frame) {
      const renderTarget = this.getRenderTarget(renderSurface);
      const didChange = this.renderTarget !== renderTarget;
      this.renderTarget = renderTarget;
      this.renderSurface = renderSurface;
      const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
      if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
        this.adaptor.resizeGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.pixelWidth;
        gpuRenderTarget.height = renderTarget.pixelHeight;
      }
      const source3 = renderTarget.colorTexture;
      const viewport = this.viewport;
      const pixelWidth = source3.pixelWidth;
      const pixelHeight = source3.pixelHeight;
      if (!frame && renderSurface instanceof Texture) {
        frame = renderSurface.frame;
      }
      if (frame) {
        const resolution = source3._resolution;
        viewport.x = frame.x * resolution + 0.5 | 0;
        viewport.y = frame.y * resolution + 0.5 | 0;
        viewport.width = frame.width * resolution + 0.5 | 0;
        viewport.height = frame.height * resolution + 0.5 | 0;
      } else {
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = pixelWidth;
        viewport.height = pixelHeight;
      }
      calculateProjection(this.projectionMatrix, 0, 0, viewport.width / source3.resolution, viewport.height / source3.resolution, !renderTarget.isRoot);
      this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
      if (didChange) {
        this.onRenderTargetChange.emit(renderTarget);
      }
      return renderTarget;
    }
    clear(target, clear = CLEAR.ALL, clearColor) {
      if (!clear)
        return;
      if (target) {
        target = this.getRenderTarget(target);
      }
      this.adaptor.clear(target || this.renderTarget, clear, clearColor, this.viewport);
    }
    contextChange() {
      this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
      const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
      this._renderTargetStack.push({
        renderTarget,
        frame
      });
      return renderTarget;
    }
    pop() {
      this._renderTargetStack.pop();
      const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
      this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
    }
    getRenderTarget(renderSurface) {
      if (renderSurface.isTexture) {
        renderSurface = renderSurface.source;
      }
      return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      if (originSrc.x < 0) {
        size.width += originSrc.x;
        originDest.x -= originSrc.x;
        originSrc.x = 0;
      }
      if (originSrc.y < 0) {
        size.height += originSrc.y;
        originDest.y -= originSrc.y;
        originSrc.y = 0;
      }
      const {pixelWidth, pixelHeight} = sourceRenderSurfaceTexture;
      size.width = Math.min(size.width, pixelWidth - originSrc.x);
      size.height = Math.min(size.height, pixelHeight - originSrc.y);
      return this.adaptor.copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest);
    }
    ensureDepthStencil() {
      if (!this.renderTarget.stencil) {
        this.renderTarget.stencil = true;
        this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
      }
    }
    destroy() {
      this._renderer = null;
      this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
        if (renderTarget !== key) {
          renderTarget.destroy();
        }
      });
      this._renderSurfaceToRenderTargetHash.clear();
      this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    }
    _initRenderTarget(renderSurface) {
      let renderTarget = null;
      if (CanvasSource.test(renderSurface)) {
        renderSurface = getCanvasTexture(renderSurface).source;
      }
      if (renderSurface instanceof RenderTarget) {
        renderTarget = renderSurface;
      } else if (renderSurface instanceof TextureSource) {
        renderTarget = new RenderTarget({
          colorTextures: [renderSurface]
        });
        if (renderSurface.source instanceof CanvasSource) {
          renderTarget.isRoot = true;
        }
        renderSurface.once("destroy", () => {
          renderTarget.destroy();
          this._renderSurfaceToRenderTargetHash.delete(renderSurface);
          const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
          if (gpuRenderTarget) {
            this._gpuRenderTargetHash[renderTarget.uid] = null;
            this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
          }
        });
      }
      this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
      return renderTarget;
    }
    getGpuRenderTarget(renderTarget) {
      return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
    }
    resetState() {
      this.renderTarget = null;
      this.renderSurface = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  "use strict";
  var GpuRenderTarget = class {
    constructor() {
      this.contexts = [];
      this.msaaTextures = [];
      this.msaaSamples = 1;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor = class {
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderer = this._renderer;
      const baseGpuTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);
      const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);
      renderer.encoder.commandEncoder.copyTextureToTexture({
        texture: baseGpuTexture,
        origin: originSrc
      }, {
        texture: backGpuTexture,
        origin: originDest
      }, size);
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = true, clearColor, viewport) {
      const renderTargetSystem = this._renderTargetSystem;
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
      gpuRenderTarget.descriptor = descriptor;
      this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
      this._renderer.encoder.beginRenderPass(gpuRenderTarget);
      this._renderer.encoder.setViewport(viewport);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    _getGpuColorTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (gpuRenderTarget.contexts[0]) {
        return gpuRenderTarget.contexts[0].getCurrentTexture();
      }
      return this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);
    }
    getDescriptor(renderTarget, clear, clearValue) {
      if (typeof clear === "boolean") {
        clear = clear ? CLEAR.ALL : CLEAR.NONE;
      }
      const renderTargetSystem = this._renderTargetSystem;
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      const colorAttachments = renderTarget.colorTextures.map((texture, i2) => {
        const context4 = gpuRenderTarget.contexts[i2];
        let view;
        let resolveTarget;
        if (context4) {
          const currentTexture = context4.getCurrentTexture();
          const canvasTextureView = currentTexture.createView();
          view = canvasTextureView;
        } else {
          view = this._renderer.texture.getGpuSource(texture).createView({
            mipLevelCount: 1
          });
        }
        if (gpuRenderTarget.msaaTextures[i2]) {
          resolveTarget = view;
          view = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i2]);
        }
        const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
        return {
          view,
          resolveTarget,
          clearValue,
          storeOp: "store",
          loadOp
        };
      });
      let depthStencilAttachment;
      if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
        renderTarget.ensureDepthStencilTexture();
        renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
      }
      if (renderTarget.depthStencilTexture) {
        const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
        const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
        depthStencilAttachment = {
          view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
          stencilStoreOp: "store",
          stencilLoadOp,
          depthClearValue: 1,
          depthLoadOp,
          depthStoreOp: "store"
        };
      }
      const descriptor = {
        colorAttachments,
        depthStencilAttachment
      };
      return descriptor;
    }
    clear(renderTarget, clear = true, clearColor, viewport) {
      if (!clear)
        return;
      const {gpu, encoder} = this._renderer;
      const device = gpu.device;
      const standAlone = encoder.commandEncoder === null;
      if (standAlone) {
        const commandEncoder = device.createCommandEncoder();
        const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        passEncoder.end();
        const gpuCommands = commandEncoder.finish();
        device.queue.submit([gpuCommands]);
      } else {
        this.startRenderPass(renderTarget, clear, clearColor, viewport);
      }
    }
    initGpuRenderTarget(renderTarget) {
      renderTarget.isRoot = true;
      const gpuRenderTarget = new GpuRenderTarget();
      renderTarget.colorTextures.forEach((colorTexture, i2) => {
        if (colorTexture instanceof CanvasSource) {
          const context4 = colorTexture.resource.getContext("webgpu");
          const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
          try {
            context4.configure({
              device: this._renderer.gpu.device,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
              format: "bgra8unorm",
              alphaMode
            });
          } catch (e2) {
            console.error(e2);
          }
          gpuRenderTarget.contexts[i2] = context4;
        }
        gpuRenderTarget.msaa = colorTexture.source.antialias;
        if (colorTexture.source.antialias) {
          const msaaTexture = new TextureSource({
            width: 0,
            height: 0,
            sampleCount: 4
          });
          gpuRenderTarget.msaaTextures[i2] = msaaTexture;
        }
      });
      if (gpuRenderTarget.msaa) {
        gpuRenderTarget.msaaSamples = 4;
        if (renderTarget.depthStencilTexture) {
          renderTarget.depthStencilTexture.source.sampleCount = 4;
        }
      }
      return gpuRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      gpuRenderTarget.contexts.forEach((context4) => {
        context4.unconfigure();
      });
      gpuRenderTarget.msaaTextures.forEach((texture) => {
        texture.destroy();
      });
      gpuRenderTarget.msaaTextures.length = 0;
      gpuRenderTarget.contexts.length = 0;
    }
    ensureDepthStencilTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
        renderTarget.depthStencilTexture.source.sampleCount = 4;
      }
    }
    resizeGpuRenderTarget(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.width;
      gpuRenderTarget.height = renderTarget.height;
      if (gpuRenderTarget.msaa) {
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          const msaaTexture = gpuRenderTarget.msaaTextures[i2];
          msaaTexture?.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);
        });
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem = class extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GpuRenderTargetAdaptor();
      this.adaptor.init(renderer, this);
    }
  };
  GpuRenderTargetSystem.extension = {
    type: [ExtensionType.WebGPUSystem],
    name: "renderTarget"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem = class {
    constructor() {
      this._gpuProgramData = /* @__PURE__ */ Object.create(null);
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    getProgramData(program) {
      return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
    }
    _createGPUProgramData(program) {
      const device = this._gpu.device;
      const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({entries: group}));
      const pipelineLayoutDesc = {bindGroupLayouts: bindGroups};
      this._gpuProgramData[program._layoutKey] = {
        bindGroups,
        pipeline: device.createPipelineLayout(pipelineLayoutDesc)
      };
      return this._gpuProgramData[program._layoutKey];
    }
    destroy() {
      this._gpu = null;
      this._gpuProgramData = null;
    }
  };
  GpuShaderSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "shader"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  "use strict";
  var GpuBlendModesToPixi = {};
  GpuBlendModesToPixi.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.add = {
    alpha: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.multiply = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "dst",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.screen = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.overlay = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.none = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "zero",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["normal-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["add-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one",
      operation: "add"
    }
  };
  GpuBlendModesToPixi["screen-npm"] = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "src-alpha",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.erase = {
    alpha: {
      srcFactor: "zero",
      dstFactor: "one-minus-src-alpha",
      operation: "add"
    },
    color: {
      srcFactor: "zero",
      dstFactor: "one-minus-src",
      operation: "add"
    }
  };
  GpuBlendModesToPixi.min = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "min"
    }
  };
  GpuBlendModesToPixi.max = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    },
    color: {
      srcFactor: "one",
      dstFactor: "one",
      operation: "max"
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem = class {
    constructor() {
      this.defaultState = new State();
      this.defaultState.blend = true;
    }
    contextChange(gpu) {
      this.gpu = gpu;
    }
    getColorTargets(state) {
      const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
      return [
        {
          format: "bgra8unorm",
          writeMask: 0,
          blend
        }
      ];
    }
    destroy() {
      this.gpu = null;
    }
  };
  GpuStateSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "state"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  "use strict";
  var gpuUploadBufferImageResource = {
    type: "image",
    upload(source3, gpuTexture, gpu) {
      const resource = source3.resource;
      const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
      const bytesPerPixel = resource.byteLength / total;
      gpu.device.queue.writeTexture({texture: gpuTexture}, resource, {
        offset: 0,
        rowsPerImage: source3.pixelHeight,
        bytesPerRow: source3.pixelHeight * bytesPerPixel
      }, {
        width: source3.pixelWidth,
        height: source3.pixelHeight,
        depthOrArrayLayers: 1
      });
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  "use strict";
  var blockDataMap = {
    "bc1-rgba-unorm": {blockBytes: 8, blockWidth: 4, blockHeight: 4},
    "bc2-rgba-unorm": {blockBytes: 16, blockWidth: 4, blockHeight: 4},
    "bc3-rgba-unorm": {blockBytes: 16, blockWidth: 4, blockHeight: 4},
    "bc7-rgba-unorm": {blockBytes: 16, blockWidth: 4, blockHeight: 4},
    "etc1-rgb-unorm": {blockBytes: 8, blockWidth: 4, blockHeight: 4},
    "etc2-rgba8unorm": {blockBytes: 16, blockWidth: 4, blockHeight: 4},
    "astc-4x4-unorm": {blockBytes: 16, blockWidth: 4, blockHeight: 4}
  };
  var defaultBlockData = {blockBytes: 4, blockWidth: 1, blockHeight: 1};
  var gpuUploadCompressedTextureResource = {
    type: "compressed",
    upload(source3, gpuTexture, gpu) {
      let mipWidth = source3.pixelWidth;
      let mipHeight = source3.pixelHeight;
      const blockData = blockDataMap[source3.format] || defaultBlockData;
      for (let i2 = 0; i2 < source3.resource.length; i2++) {
        const levelBuffer = source3.resource[i2];
        const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
        gpu.device.queue.writeTexture({
          texture: gpuTexture,
          mipLevel: i2
        }, levelBuffer, {
          offset: 0,
          bytesPerRow
        }, {
          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
          depthOrArrayLayers: 1
        });
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource = {
    type: "image",
    upload(source3, gpuTexture, gpu) {
      const resource = source3.resource;
      if (!resource)
        return;
      if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {
        const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);
        const context4 = canvas.getContext("2d");
        context4.drawImage(resource, 0, 0, resource.width, resource.height);
        source3.resource = canvas;
        warn("ImageSource: Image element passed, converting to canvas and replacing resource.");
      }
      const width = Math.min(gpuTexture.width, source3.resourceWidth || source3.pixelWidth);
      const height = Math.min(gpuTexture.height, source3.resourceHeight || source3.pixelHeight);
      const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
      gpu.device.queue.copyExternalImageToTexture({source: resource}, {texture: gpuTexture, premultipliedAlpha}, {
        width,
        height
      });
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource = {
    type: "video",
    upload(source3, gpuTexture, gpu) {
      gpuUploadImageResource.upload(source3, gpuTexture, gpu);
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  "use strict";
  var GpuMipmapGenerator = class {
    constructor(device) {
      this.device = device;
      this.sampler = device.createSampler({minFilter: "linear"});
      this.pipelines = {};
    }
    _getMipmapPipeline(format) {
      let pipeline = this.pipelines[format];
      if (!pipeline) {
        if (!this.mipmapShaderModule) {
          this.mipmapShaderModule = this.device.createShaderModule({
            code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
          });
        }
        pipeline = this.device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: this.mipmapShaderModule,
            entryPoint: "vertexMain"
          },
          fragment: {
            module: this.mipmapShaderModule,
            entryPoint: "fragmentMain",
            targets: [{format}]
          }
        });
        this.pipelines[format] = pipeline;
      }
      return pipeline;
    }
    generateMipmap(texture) {
      const pipeline = this._getMipmapPipeline(texture.format);
      if (texture.dimension === "3d" || texture.dimension === "1d") {
        throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
      }
      let mipTexture = texture;
      const arrayLayerCount = texture.depthOrArrayLayers || 1;
      const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      if (!renderToSource) {
        const mipTextureDescriptor = {
          size: {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          },
          format: texture.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: texture.mipLevelCount - 1
        };
        mipTexture = this.device.createTexture(mipTextureDescriptor);
      }
      const commandEncoder = this.device.createCommandEncoder({});
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
        let srcView = texture.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: arrayLayer,
          arrayLayerCount: 1
        });
        let dstMipLevel = renderToSource ? 1 : 0;
        for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
          const dstView = mipTexture.createView({
            baseMipLevel: dstMipLevel++,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          const passEncoder = commandEncoder.beginRenderPass({
            colorAttachments: [{
              view: dstView,
              storeOp: "store",
              loadOp: "clear",
              clearValue: {r: 0, g: 0, b: 0, a: 0}
            }]
          });
          const bindGroup = this.device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
              binding: 0,
              resource: this.sampler
            }, {
              binding: 1,
              resource: srcView
            }]
          });
          passEncoder.setPipeline(pipeline);
          passEncoder.setBindGroup(0, bindGroup);
          passEncoder.draw(3, 1, 0, 0);
          passEncoder.end();
          srcView = dstView;
        }
      }
      if (!renderToSource) {
        const mipLevelSize = {
          width: Math.ceil(texture.width / 2),
          height: Math.ceil(texture.height / 2),
          depthOrArrayLayers: arrayLayerCount
        };
        for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
          commandEncoder.copyTextureToTexture({
            texture: mipTexture,
            mipLevel: i2 - 1
          }, {
            texture,
            mipLevel: i2
          }, mipLevelSize);
          mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
          mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
        }
      }
      this.device.queue.submit([commandEncoder.finish()]);
      if (!renderToSource) {
        mipTexture.destroy();
      }
      return texture;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem = class {
    constructor(renderer) {
      this.managedTextures = [];
      this._gpuSources = /* @__PURE__ */ Object.create(null);
      this._gpuSamplers = /* @__PURE__ */ Object.create(null);
      this._bindGroupHash = /* @__PURE__ */ Object.create(null);
      this._textureViewHash = /* @__PURE__ */ Object.create(null);
      this._uploads = {
        image: gpuUploadImageResource,
        buffer: gpuUploadBufferImageResource,
        video: gpuUploadVideoResource,
        compressed: gpuUploadCompressedTextureResource
      };
      this._renderer = renderer;
      renderer.renderableGC.addManagedHash(this, "_gpuSources");
      renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
      renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
      renderer.renderableGC.addManagedHash(this, "_textureViewHash");
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    initSource(source3) {
      if (this._gpuSources[source3.uid]) {
        return this._gpuSources[source3.uid];
      }
      return this._initSource(source3);
    }
    _initSource(source3) {
      if (source3.autoGenerateMipmaps) {
        const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
        source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
      }
      let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      if (source3.uploadMethodId !== "compressed") {
        usage |= GPUTextureUsage.RENDER_ATTACHMENT;
        usage |= GPUTextureUsage.COPY_SRC;
      }
      const blockData = blockDataMap[source3.format] || {blockBytes: 4, blockWidth: 1, blockHeight: 1};
      const width = Math.ceil(source3.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
      const height = Math.ceil(source3.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
      const textureDescriptor = {
        label: source3.label,
        size: {width, height},
        format: source3.format,
        sampleCount: source3.sampleCount,
        mipLevelCount: source3.mipLevelCount,
        dimension: source3.dimension,
        usage
      };
      const gpuTexture = this._gpuSources[source3.uid] = this._gpu.device.createTexture(textureDescriptor);
      if (!this.managedTextures.includes(source3)) {
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceResize, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        source3.on("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.push(source3);
      }
      this.onSourceUpdate(source3);
      return gpuTexture;
    }
    onSourceUpdate(source3) {
      const gpuTexture = this.getGpuSource(source3);
      if (!gpuTexture)
        return;
      if (this._uploads[source3.uploadMethodId]) {
        this._uploads[source3.uploadMethodId].upload(source3, gpuTexture, this._gpu);
      }
      if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
        this.onUpdateMipmaps(source3);
      }
    }
    onSourceUnload(source3) {
      const gpuTexture = this._gpuSources[source3.uid];
      if (gpuTexture) {
        this._gpuSources[source3.uid] = null;
        gpuTexture.destroy();
      }
    }
    onUpdateMipmaps(source3) {
      if (!this._mipmapGenerator) {
        this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
      }
      const gpuTexture = this.getGpuSource(source3);
      this._mipmapGenerator.generateMipmap(gpuTexture);
    }
    onSourceDestroy(source3) {
      source3.off("update", this.onSourceUpdate, this);
      source3.off("unload", this.onSourceUnload, this);
      source3.off("destroy", this.onSourceDestroy, this);
      source3.off("resize", this.onSourceResize, this);
      source3.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
      this.onSourceUnload(source3);
    }
    onSourceResize(source3) {
      const gpuTexture = this._gpuSources[source3.uid];
      if (!gpuTexture) {
        this.initSource(source3);
      } else if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
        this._textureViewHash[source3.uid] = null;
        this._bindGroupHash[source3.uid] = null;
        this.onSourceUnload(source3);
        this.initSource(source3);
      }
    }
    _initSampler(sampler) {
      this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
      return this._gpuSamplers[sampler._resourceId];
    }
    getGpuSampler(sampler) {
      return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
    }
    getGpuSource(source3) {
      return this._gpuSources[source3.uid] || this.initSource(source3);
    }
    getTextureBindGroup(texture) {
      return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
    }
    _createTextureBindGroup(texture) {
      const source3 = texture.source;
      this._bindGroupHash[texture.uid] = new BindGroup({
        0: source3,
        1: source3.style,
        2: new UniformGroup({
          uTextureMatrix: {type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord}
        })
      });
      return this._bindGroupHash[texture.uid];
    }
    getTextureView(texture) {
      const source3 = texture.source;
      return this._textureViewHash[source3.uid] ?? this._createTextureView(source3);
    }
    _createTextureView(texture) {
      this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
      return this._textureViewHash[texture.uid];
    }
    generateCanvas(texture) {
      const renderer = this._renderer;
      const commandEncoder = renderer.gpu.device.createCommandEncoder();
      const canvas = DOMAdapter.get().createCanvas();
      canvas.width = texture.source.pixelWidth;
      canvas.height = texture.source.pixelHeight;
      const context4 = canvas.getContext("webgpu");
      context4.configure({
        device: renderer.gpu.device,
        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
        format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
        alphaMode: "premultiplied"
      });
      commandEncoder.copyTextureToTexture({
        texture: renderer.texture.getGpuSource(texture.source),
        origin: {
          x: 0,
          y: 0
        }
      }, {
        texture: context4.getCurrentTexture()
      }, {
        width: canvas.width,
        height: canvas.height
      });
      renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      return canvas;
    }
    getPixels(texture) {
      const webGPUCanvas = this.generateCanvas(texture);
      const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
      const context4 = canvasAndContext.context;
      context4.drawImage(webGPUCanvas, 0, 0);
      const {width, height} = webGPUCanvas;
      const imageData = context4.getImageData(0, 0, width, height);
      const pixels = new Uint8ClampedArray(imageData.data.buffer);
      CanvasPool.returnCanvasAndContext(canvasAndContext);
      return {pixels, width, height};
    }
    destroy() {
      this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
      this.managedTextures = null;
      for (const k2 of Object.keys(this._bindGroupHash)) {
        const key = Number(k2);
        const bindGroup = this._bindGroupHash[key];
        bindGroup?.destroy();
        this._bindGroupHash[key] = null;
      }
      this._gpu = null;
      this._mipmapGenerator = null;
      this._gpuSources = null;
      this._bindGroupHash = null;
      this._textureViewHash = null;
      this._gpuSamplers = null;
    }
  };
  GpuTextureSystem.extension = {
    type: [
      ExtensionType.WebGPUSystem
    ],
    name: "texture"
  };

  // node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor = class {
    contextChange(renderer) {
      const uniforms = new UniformGroup({
        uColor: {value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>"},
        uTransformMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uRound: {value: 0, type: "f32"}
      });
      const maxTextures = renderer.limits.maxBatchableTextures;
      const glProgram3 = compileHighShaderGlProgram({
        name: "graphics",
        bits: [
          colorBitGl,
          generateTextureBatchBitGl(maxTextures),
          localUniformBitGl,
          roundPixelsBitGl
        ]
      });
      this.shader = new Shader({
        glProgram: glProgram3,
        resources: {
          localUniforms: uniforms,
          batchSamplers: getBatchSamplersUniformGroup(maxTextures)
        }
      });
    }
    execute(graphicsPipe, renderable) {
      const context4 = renderable.context;
      const shader = context4.customShader || this.shader;
      const renderer = graphicsPipe.renderer;
      const contextSystem = renderer.graphicsContext;
      const {
        batcher,
        instructions
      } = contextSystem.getContextRenderData(context4);
      shader.groups[0] = renderer.globalUniforms.bindGroup;
      renderer.state.set(graphicsPipe.state);
      renderer.shader.bind(shader);
      renderer.geometry.bind(batcher.geometry, shader.glProgram);
      const batches = instructions.instructions;
      for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
        const batch = batches[i2];
        if (batch.size) {
          for (let j2 = 0; j2 < batch.textures.count; j2++) {
            renderer.texture.bind(batch.textures.textures[j2], j2);
          }
          renderer.geometry.draw(batch.topology, batch.size, batch.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(true);
      this.shader = null;
    }
  };
  GlGraphicsAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "graphics"
  };

  // node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor = class {
    init() {
      const glProgram3 = compileHighShaderGlProgram({
        name: "mesh",
        bits: [
          localUniformBitGl,
          textureBitGl,
          roundPixelsBitGl
        ]
      });
      this._shader = new Shader({
        glProgram: glProgram3,
        resources: {
          uTexture: Texture.EMPTY.source,
          textureUniforms: {
            uTextureMatrix: {type: "mat3x3<f32>", value: new Matrix()}
          }
        }
      });
    }
    execute(meshPipe, mesh) {
      const renderer = meshPipe.renderer;
      let shader = mesh._shader;
      if (!shader) {
        shader = this._shader;
        const texture = mesh.texture;
        const source3 = texture.source;
        shader.resources.uTexture = source3;
        shader.resources.uSampler = source3.style;
        shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
      } else if (!shader.glProgram) {
        warn("Mesh shader has no glProgram", mesh.shader);
        return;
      }
      shader.groups[100] = renderer.globalUniforms.bindGroup;
      shader.groups[101] = meshPipe.localUniformsBindGroup;
      renderer.encoder.draw({
        geometry: mesh._geometry,
        shader,
        state: mesh.state
      });
    }
    destroy() {
      this._shader.destroy(true);
      this._shader = null;
    }
  };
  GlMeshAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "mesh"
  };

  // node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor = class {
    constructor() {
      this._tempState = State.for2d();
      this._didUploadHash = {};
    }
    init(batcherPipe) {
      batcherPipe.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUploadHash = {};
    }
    start(batchPipe, geometry, shader) {
      const renderer = batchPipe.renderer;
      const didUpload = this._didUploadHash[shader.uid];
      renderer.shader.bind(shader, didUpload);
      if (!didUpload) {
        this._didUploadHash[shader.uid] = true;
      }
      renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
      renderer.geometry.bind(geometry, shader.glProgram);
    }
    execute(batchPipe, batch) {
      const renderer = batchPipe.renderer;
      this._tempState.blendMode = batch.blendMode;
      renderer.state.set(this._tempState);
      const textures = batch.textures.textures;
      for (let i2 = 0; i2 < batch.textures.count; i2++) {
        renderer.texture.bind(textures[i2], i2);
      }
      renderer.geometry.draw(batch.topology, batch.size, batch.start);
    }
  };
  GlBatchAdaptor.extension = {
    type: [
      ExtensionType.WebGLPipesAdaptor
    ],
    name: "batch"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
  "use strict";
  var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
    BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    return BUFFER_TYPE2;
  })(BUFFER_TYPE || {});

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  "use strict";
  var GlBuffer = class {
    constructor(buffer, type) {
      this._lastBindBaseLocation = -1;
      this._lastBindCallId = -1;
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.type = type;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem = class {
    constructor(renderer) {
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      this._boundBufferBases = /* @__PURE__ */ Object.create(null);
      this._minBaseLocation = 0;
      this._nextBindBaseIndex = this._minBaseLocation;
      this._bindCallId = 0;
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    destroy() {
      this._renderer = null;
      this._gl = null;
      this._gpuBuffers = null;
      this._boundBufferBases = null;
    }
    contextChange() {
      this._gl = this._renderer.gl;
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      this._maxBindings = this._renderer.limits.maxUniformBindings;
    }
    getGlBuffer(buffer) {
      return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
    }
    bind(buffer) {
      const {_gl: gl} = this;
      const glBuffer = this.getGlBuffer(buffer);
      gl.bindBuffer(glBuffer.type, glBuffer.buffer);
    }
    bindBufferBase(glBuffer, index) {
      const {_gl: gl} = this;
      if (this._boundBufferBases[index] !== glBuffer) {
        this._boundBufferBases[index] = glBuffer;
        glBuffer._lastBindBaseLocation = index;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
      }
    }
    nextBindBase(hasTransformFeedback) {
      this._bindCallId++;
      this._minBaseLocation = 0;
      if (hasTransformFeedback) {
        this._boundBufferBases[0] = null;
        this._minBaseLocation = 1;
        if (this._nextBindBaseIndex < 1) {
          this._nextBindBaseIndex = 1;
        }
      }
    }
    freeLocationForBufferBase(glBuffer) {
      let freeIndex = this.getLastBindBaseLocation(glBuffer);
      if (freeIndex >= this._minBaseLocation) {
        glBuffer._lastBindCallId = this._bindCallId;
        return freeIndex;
      }
      let loop = 0;
      let nextIndex = this._nextBindBaseIndex;
      while (loop < 2) {
        if (nextIndex >= this._maxBindings) {
          nextIndex = this._minBaseLocation;
          loop++;
        }
        const curBuf = this._boundBufferBases[nextIndex];
        if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
          nextIndex++;
          continue;
        }
        break;
      }
      freeIndex = nextIndex;
      this._nextBindBaseIndex = nextIndex + 1;
      if (loop >= 2) {
        return -1;
      }
      glBuffer._lastBindCallId = this._bindCallId;
      this._boundBufferBases[freeIndex] = null;
      return freeIndex;
    }
    getLastBindBaseLocation(glBuffer) {
      const index = glBuffer._lastBindBaseLocation;
      if (this._boundBufferBases[index] === glBuffer) {
        return index;
      }
      return -1;
    }
    bindBufferRange(glBuffer, index, offset, size) {
      const {_gl: gl} = this;
      offset || (offset = 0);
      index || (index = 0);
      this._boundBufferBases[index] = null;
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
    }
    updateBuffer(buffer) {
      const {_gl: gl} = this;
      const glBuffer = this.getGlBuffer(buffer);
      if (buffer._updateID === glBuffer.updateID) {
        return glBuffer;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      const data = buffer.data;
      const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      if (data) {
        if (glBuffer.byteLength >= data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
        } else {
          glBuffer.byteLength = data.byteLength;
          gl.bufferData(glBuffer.type, data, drawType);
        }
      } else {
        glBuffer.byteLength = buffer.descriptor.size;
        gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
      }
      return glBuffer;
    }
    destroyAll() {
      const gl = this._gl;
      for (const id in this._gpuBuffers) {
        gl.deleteBuffer(this._gpuBuffers[id].buffer);
      }
      this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    }
    onBufferDestroy(buffer, contextLost) {
      const glBuffer = this._gpuBuffers[buffer.uid];
      const gl = this._gl;
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      this._gpuBuffers[buffer.uid] = null;
    }
    createGLBuffer(buffer) {
      const {_gl: gl} = this;
      let type = BUFFER_TYPE.ARRAY_BUFFER;
      if (buffer.descriptor.usage & BufferUsage.INDEX) {
        type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
        type = BUFFER_TYPE.UNIFORM_BUFFER;
      }
      const glBuffer = new GlBuffer(gl.createBuffer(), type);
      this._gpuBuffers[buffer.uid] = glBuffer;
      buffer.on("destroy", this.onBufferDestroy, this);
      return glBuffer;
    }
    resetState() {
      this._boundBufferBases = /* @__PURE__ */ Object.create(null);
    }
  };
  GlBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "buffer"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem = class _GlContextSystem2 {
    constructor(renderer) {
      this.supports = {
        uint32Indices: true,
        uniformBufferObject: true,
        vertexArrayObject: true,
        srgbTextures: true,
        nonPowOf2wrapping: true,
        msaa: true,
        nonPowOf2mipmaps: true
      };
      this._renderer = renderer;
      this.extensions = /* @__PURE__ */ Object.create(null);
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(gl) {
      this.gl = gl;
      this._renderer.gl = gl;
    }
    init(options) {
      options = {..._GlContextSystem2.defaultOptions, ...options};
      let multiView = this.multiView = options.multiView;
      if (options.context && multiView) {
        warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
        multiView = false;
      }
      if (multiView) {
        this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
      } else {
        this.canvas = this._renderer.view.canvas;
      }
      if (options.context) {
        this.initFromContext(options.context);
      } else {
        const alpha = this._renderer.background.alpha < 1;
        const premultipliedAlpha = options.premultipliedAlpha ?? true;
        const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
        this.createContext(options.preferWebGLVersion, {
          alpha,
          premultipliedAlpha,
          antialias,
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: options.powerPreference ?? "default"
        });
      }
    }
    ensureCanvasSize(targetCanvas) {
      if (!this.multiView) {
        if (targetCanvas !== this.canvas) {
          warn("multiView is disabled, but targetCanvas is not the main canvas");
        }
        return;
      }
      const {canvas} = this;
      if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
        canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
        canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
      }
    }
    initFromContext(gl) {
      this.gl = gl;
      this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
      this.getExtensions();
      this.validateContext(gl);
      this._renderer.runners.contextChange.emit(gl);
      const element = this._renderer.view.canvas;
      element.addEventListener("webglcontextlost", this.handleContextLost, false);
      element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    createContext(preferWebGLVersion, options) {
      let gl;
      const canvas = this.canvas;
      if (preferWebGLVersion === 2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (!gl) {
        gl = canvas.getContext("webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.initFromContext(this.gl);
    }
    getExtensions() {
      const {gl} = this;
      const common = {
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc"),
        bptc: gl.getExtension("EXT_texture_compression_bptc"),
        rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
        loseContext: gl.getExtension("WEBGL_lose_context")
      };
      if (this.webGLVersion === 1) {
        this.extensions = {
          ...common,
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
          vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
          srgb: gl.getExtension("EXT_sRGB")
        };
      } else {
        this.extensions = {
          ...common,
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        };
        const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
        if (provokeExt) {
          provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
        }
      }
    }
    handleContextLost(event) {
      event.preventDefault();
      if (this._contextLossForced) {
        this._contextLossForced = false;
        setTimeout(() => {
          if (this.gl.isContextLost()) {
            this.extensions.loseContext?.restoreContext();
          }
        }, 0);
      }
    }
    handleContextRestored() {
      this.getExtensions();
      this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const element = this._renderer.view.canvas;
      this._renderer = null;
      element.removeEventListener("webglcontextlost", this.handleContextLost);
      element.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      this.extensions.loseContext?.loseContext();
    }
    forceContextLoss() {
      this.extensions.loseContext?.loseContext();
      this._contextLossForced = true;
    }
    validateContext(gl) {
      const attributes = gl.getContextAttributes();
      if (attributes && !attributes.stencil) {
        warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      const supports = this.supports;
      const isWebGl2 = this.webGLVersion === 2;
      const extensions2 = this.extensions;
      supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
      supports.uniformBufferObject = isWebGl2;
      supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
      supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
      supports.nonPowOf2wrapping = isWebGl2;
      supports.nonPowOf2mipmaps = isWebGl2;
      supports.msaa = isWebGl2;
      if (!supports.uint32Indices) {
        warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
      }
    }
  };
  _GlContextSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "context"
  };
  _GlContextSystem.defaultOptions = {
    context: null,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    powerPreference: void 0,
    preferWebGLVersion: 2,
    multiView: false
  };
  var GlContextSystem = _GlContextSystem;

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
  "use strict";
  var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
    GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
    GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
    GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
    GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
    GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return GL_FORMATS2;
  })(GL_FORMATS || {});
  var GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    return GL_TARGETS2;
  })(GL_TARGETS || {});
  var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
    GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
    GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
    GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
    GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
    GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return GL_TYPES2;
  })(GL_TYPES || {});

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  var infoMap = {
    uint8x2: GL_TYPES.UNSIGNED_BYTE,
    uint8x4: GL_TYPES.UNSIGNED_BYTE,
    sint8x2: GL_TYPES.BYTE,
    sint8x4: GL_TYPES.BYTE,
    unorm8x2: GL_TYPES.UNSIGNED_BYTE,
    unorm8x4: GL_TYPES.UNSIGNED_BYTE,
    snorm8x2: GL_TYPES.BYTE,
    snorm8x4: GL_TYPES.BYTE,
    uint16x2: GL_TYPES.UNSIGNED_SHORT,
    uint16x4: GL_TYPES.UNSIGNED_SHORT,
    sint16x2: GL_TYPES.SHORT,
    sint16x4: GL_TYPES.SHORT,
    unorm16x2: GL_TYPES.UNSIGNED_SHORT,
    unorm16x4: GL_TYPES.UNSIGNED_SHORT,
    snorm16x2: GL_TYPES.SHORT,
    snorm16x4: GL_TYPES.SHORT,
    float16x2: GL_TYPES.HALF_FLOAT,
    float16x4: GL_TYPES.HALF_FLOAT,
    float32: GL_TYPES.FLOAT,
    float32x2: GL_TYPES.FLOAT,
    float32x3: GL_TYPES.FLOAT,
    float32x4: GL_TYPES.FLOAT,
    uint32: GL_TYPES.UNSIGNED_INT,
    uint32x2: GL_TYPES.UNSIGNED_INT,
    uint32x3: GL_TYPES.UNSIGNED_INT,
    uint32x4: GL_TYPES.UNSIGNED_INT,
    sint32: GL_TYPES.INT,
    sint32x2: GL_TYPES.INT,
    sint32x3: GL_TYPES.INT,
    sint32x4: GL_TYPES.INT
  };
  function getGlTypeFromFormat(format) {
    return infoMap[format] ?? infoMap.float32;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
  };
  var GlGeometrySystem = class {
    constructor(renderer) {
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
    }
    contextChange() {
      const gl = this.gl = this._renderer.gl;
      if (!this._renderer.context.supports.vertexArrayObject) {
        throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
      }
      const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      }
      const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
      if (nativeInstancedExtension) {
        gl.drawArraysInstanced = (a2, b2, c2, d2) => {
          nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
        };
        gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
          nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
        };
        gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
      }
      this._activeGeometry = null;
      this._activeVao = null;
      this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    }
    bind(geometry, program) {
      const gl = this.gl;
      this._activeGeometry = geometry;
      const vao = this.getVao(geometry, program);
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        gl.bindVertexArray(vao);
      }
      this.updateBuffers();
    }
    resetState() {
      this.unbind();
    }
    updateBuffers() {
      const geometry = this._activeGeometry;
      const bufferSystem = this._renderer.buffer;
      for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
        const buffer = geometry.buffers[i2];
        bufferSystem.updateBuffer(buffer);
      }
    }
    checkCompatibility(geometry, program) {
      const geometryAttributes = geometry.attributes;
      const shaderAttributes = program._attributeData;
      for (const j2 in shaderAttributes) {
        if (!geometryAttributes[j2]) {
          throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
        }
      }
    }
    getSignature(geometry, program) {
      const attribs = geometry.attributes;
      const shaderAttributes = program._attributeData;
      const strings = ["g", geometry.uid];
      for (const i2 in attribs) {
        if (shaderAttributes[i2]) {
          strings.push(i2, shaderAttributes[i2].location);
        }
      }
      return strings.join("-");
    }
    getVao(geometry, program) {
      return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
    }
    initGeometryVao(geometry, program, _incRefCount = true) {
      const gl = this._renderer.gl;
      const bufferSystem = this._renderer.buffer;
      this._renderer.shader._getProgramData(program);
      this.checkCompatibility(geometry, program);
      const signature = this.getSignature(geometry, program);
      if (!this._geometryVaoHash[geometry.uid]) {
        this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
        geometry.on("destroy", this.onGeometryDestroy, this);
      }
      const vaoObjectHash = this._geometryVaoHash[geometry.uid];
      let vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program._key] = vao;
        return vao;
      }
      ensureAttributes(geometry, program._attributeData);
      const buffers = geometry.buffers;
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (let i2 = 0; i2 < buffers.length; i2++) {
        const buffer = buffers[i2];
        bufferSystem.bind(buffer);
      }
      this.activateVao(geometry, program);
      vaoObjectHash[program._key] = vao;
      vaoObjectHash[signature] = vao;
      gl.bindVertexArray(null);
      return vao;
    }
    onGeometryDestroy(geometry, contextLost) {
      const vaoObjectHash = this._geometryVaoHash[geometry.uid];
      const gl = this.gl;
      if (vaoObjectHash) {
        if (contextLost) {
          for (const i2 in vaoObjectHash) {
            if (this._activeVao !== vaoObjectHash[i2]) {
              this.unbind();
            }
            gl.deleteVertexArray(vaoObjectHash[i2]);
          }
        }
        this._geometryVaoHash[geometry.uid] = null;
      }
    }
    destroyAll(contextLost = false) {
      const gl = this.gl;
      for (const i2 in this._geometryVaoHash) {
        if (contextLost) {
          for (const j2 in this._geometryVaoHash[i2]) {
            const vaoObjectHash = this._geometryVaoHash[i2];
            if (this._activeVao !== vaoObjectHash) {
              this.unbind();
            }
            gl.deleteVertexArray(vaoObjectHash[j2]);
          }
        }
        this._geometryVaoHash[i2] = null;
      }
    }
    activateVao(geometry, program) {
      const gl = this._renderer.gl;
      const bufferSystem = this._renderer.buffer;
      const attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      let lastBuffer = null;
      for (const j2 in attributes) {
        const attribute = attributes[j2];
        const buffer = attribute.buffer;
        const glBuffer = bufferSystem.getGlBuffer(buffer);
        const programAttrib = program._attributeData[j2];
        if (programAttrib) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          const location = programAttrib.location;
          gl.enableVertexAttribArray(location);
          const attributeInfo = getAttributeInfoFromFormat(attribute.format);
          const type = getGlTypeFromFormat(attribute.format);
          if (programAttrib.format?.substring(1, 4) === "int") {
            gl.vertexAttribIPointer(location, attributeInfo.size, type, attribute.stride, attribute.offset);
          } else {
            gl.vertexAttribPointer(location, attributeInfo.size, type, attributeInfo.normalised, attribute.stride, attribute.offset);
          }
          if (attribute.instance) {
            if (this.hasInstance) {
              const divisor = attribute.divisor ?? 1;
              gl.vertexAttribDivisor(location, divisor);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    }
    draw(topology, size, start, instanceCount) {
      const {gl} = this._renderer;
      const geometry = this._activeGeometry;
      const glTopology = topologyToGlMap[topology || geometry.topology];
      instanceCount ?? (instanceCount = geometry.instanceCount);
      if (geometry.indexBuffer) {
        const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (instanceCount > 1) {
          gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
        } else {
          gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else if (instanceCount > 1) {
        gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
      } else {
        gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
      }
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    }
    destroy() {
      this._renderer = null;
      this.gl = null;
      this._activeVao = null;
      this._activeGeometry = null;
      this._geometryVaoHash = null;
    }
  };
  GlGeometrySystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "geometry"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry = new Geometry({
    attributes: {
      aPosition: [
        -1,
        -1,
        3,
        -1,
        -1,
        3
      ]
    }
  });
  var _GlBackBufferSystem = class _GlBackBufferSystem2 {
    constructor(renderer) {
      this.useBackBuffer = false;
      this._useBackBufferThisRender = false;
      this._renderer = renderer;
    }
    init(options = {}) {
      const {useBackBuffer, antialias} = {..._GlBackBufferSystem2.defaultOptions, ...options};
      this.useBackBuffer = useBackBuffer;
      this._antialias = antialias;
      if (!this._renderer.context.supports.msaa) {
        warn("antialiasing, is not supported on when using the back buffer");
        this._antialias = false;
      }
      this._state = State.for2d();
      const bigTriangleProgram = new GlProgram({
        vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
        fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
        name: "big-triangle"
      });
      this._bigTriangleShader = new Shader({
        glProgram: bigTriangleProgram,
        resources: {
          uTexture: Texture.WHITE.source
        }
      });
    }
    renderStart(options) {
      const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
      this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
      if (this._useBackBufferThisRender) {
        const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
        this._targetTexture = renderTarget2.colorTexture;
        options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
      }
    }
    renderEnd() {
      this._presentBackBuffer();
    }
    _presentBackBuffer() {
      const renderer = this._renderer;
      renderer.renderTarget.finishRenderPass();
      if (!this._useBackBufferThisRender)
        return;
      renderer.renderTarget.bind(this._targetTexture, false);
      this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
      renderer.encoder.draw({
        geometry: bigTriangleGeometry,
        shader: this._bigTriangleShader,
        state: this._state
      });
    }
    _getBackBufferTexture(targetSourceTexture) {
      this._backBufferTexture = this._backBufferTexture || new Texture({
        source: new TextureSource({
          width: targetSourceTexture.width,
          height: targetSourceTexture.height,
          resolution: targetSourceTexture._resolution,
          antialias: this._antialias
        })
      });
      this._backBufferTexture.source.resize(targetSourceTexture.width, targetSourceTexture.height, targetSourceTexture._resolution);
      return this._backBufferTexture;
    }
    destroy() {
      if (this._backBufferTexture) {
        this._backBufferTexture.destroy();
        this._backBufferTexture = null;
      }
    }
  };
  _GlBackBufferSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "backBuffer",
    priority: 1
  };
  _GlBackBufferSystem.defaultOptions = {
    useBackBuffer: false
  };
  var GlBackBufferSystem = _GlBackBufferSystem;

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem = class {
    constructor(renderer) {
      this._colorMaskCache = 15;
      this._renderer = renderer;
    }
    setMask(colorMask) {
      if (this._colorMaskCache === colorMask)
        return;
      this._colorMaskCache = colorMask;
      this._renderer.gl.colorMask(!!(colorMask & 8), !!(colorMask & 4), !!(colorMask & 2), !!(colorMask & 1));
    }
  };
  GlColorMaskSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "colorMask"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem = class {
    constructor(renderer) {
      this.commandFinished = Promise.resolve();
      this._renderer = renderer;
    }
    setGeometry(geometry, shader) {
      this._renderer.geometry.bind(geometry, shader.glProgram);
    }
    finishRenderPass() {
    }
    draw(options) {
      const renderer = this._renderer;
      const {geometry, shader, state, skipSync, topology: type, size, start, instanceCount} = options;
      renderer.shader.bind(shader, skipSync);
      renderer.geometry.bind(geometry, renderer.shader._activeProgram);
      if (state) {
        renderer.state.set(state);
      }
      renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
    }
    destroy() {
      this._renderer = null;
    }
  };
  GlEncoderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "encoder"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlLimitsSystem.mjs
  var GlLimitsSystem = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    contextChange() {
      const gl = this._renderer.gl;
      this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
      const isWebGl2 = this._renderer.context.webGLVersion === 2;
      this.maxUniformBindings = isWebGl2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    }
    destroy() {
    }
  };
  GlLimitsSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "limits"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem = class {
    constructor(renderer) {
      this._stencilCache = {
        enabled: false,
        stencilReference: 0,
        stencilMode: STENCIL_MODES.NONE
      };
      this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(gl) {
      this._gl = gl;
      this._comparisonFuncMapping = {
        always: gl.ALWAYS,
        never: gl.NEVER,
        equal: gl.EQUAL,
        "not-equal": gl.NOTEQUAL,
        less: gl.LESS,
        "less-equal": gl.LEQUAL,
        greater: gl.GREATER,
        "greater-equal": gl.GEQUAL
      };
      this._stencilOpsMapping = {
        keep: gl.KEEP,
        zero: gl.ZERO,
        replace: gl.REPLACE,
        invert: gl.INVERT,
        "increment-clamp": gl.INCR,
        "decrement-clamp": gl.DECR,
        "increment-wrap": gl.INCR_WRAP,
        "decrement-wrap": gl.DECR_WRAP
      };
      this.resetState();
    }
    onRenderTargetChange(renderTarget) {
      if (this._activeRenderTarget === renderTarget)
        return;
      this._activeRenderTarget = renderTarget;
      let stencilState = this._renderTargetStencilState[renderTarget.uid];
      if (!stencilState) {
        stencilState = this._renderTargetStencilState[renderTarget.uid] = {
          stencilMode: STENCIL_MODES.DISABLED,
          stencilReference: 0
        };
      }
      this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
    }
    resetState() {
      this._stencilCache.enabled = false;
      this._stencilCache.stencilMode = STENCIL_MODES.NONE;
      this._stencilCache.stencilReference = 0;
    }
    setStencilMode(stencilMode, stencilReference) {
      const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
      const gl = this._gl;
      const mode = GpuStencilModesToPixi[stencilMode];
      const _stencilCache = this._stencilCache;
      stencilState.stencilMode = stencilMode;
      stencilState.stencilReference = stencilReference;
      if (stencilMode === STENCIL_MODES.DISABLED) {
        if (this._stencilCache.enabled) {
          this._stencilCache.enabled = false;
          gl.disable(gl.STENCIL_TEST);
        }
        return;
      }
      if (!this._stencilCache.enabled) {
        this._stencilCache.enabled = true;
        gl.enable(gl.STENCIL_TEST);
      }
      if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
        _stencilCache.stencilMode = stencilMode;
        _stencilCache.stencilReference = stencilReference;
        gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
      }
    }
  };
  GlStencilSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "stencil"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  "use strict";
  var WGSL_TO_STD40_SIZE = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "vec2<i32>": 8,
    "vec3<i32>": 12,
    "vec4<i32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
  };
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    const chunkSize = 16;
    let size = 0;
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, chunkSize) * uboElement.data.size;
      }
      const boundary = size === 12 ? 16 : size;
      uboElement.size = size;
      const curOffset = offset % chunkSize;
      if (curOffset > 0 && chunkSize - curOffset < boundary) {
        offset += (chunkSize - curOffset) % 16;
      } else {
        offset += (size - curOffset % size) % size;
      }
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return {uboElements, size: offset};
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder = (4 - elementSize % 4) % 4;
    const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(uboElements, "uboStd40", generateArraySyncSTD40, uboSyncFunctionsSTD40);
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem = class extends UboSystem {
    constructor() {
      super({
        createUboElements: createUboElementsSTD40,
        generateUboSync: createUboSyncFunctionSTD40
      });
    }
  };
  GlUboSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "ubo"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
  "use strict";
  var GlRenderTarget = class {
    constructor() {
      this.width = -1;
      this.height = -1;
      this.msaa = false;
      this.msaaRenderBuffer = [];
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor = class {
    constructor() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle();
    }
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
      renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle();
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderTargetSystem = this._renderTargetSystem;
      const renderer = this._renderer;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
      const gl = renderer.gl;
      this.finishRenderPass(sourceRenderSurfaceTexture);
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
      renderer.texture.bind(destinationTexture, 0);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = true, clearColor, viewport) {
      const renderTargetSystem = this._renderTargetSystem;
      const source3 = renderTarget.colorTexture;
      const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      let viewPortY = viewport.y;
      if (renderTarget.isRoot) {
        viewPortY = source3.pixelHeight - viewport.height;
      }
      renderTarget.colorTextures.forEach((texture) => {
        this._renderer.texture.unbind(texture);
      });
      const gl = this._renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
      const viewPortCache = this._viewPortCache;
      if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
        viewPortCache.x = viewport.x;
        viewPortCache.y = viewPortY;
        viewPortCache.width = viewport.width;
        viewPortCache.height = viewport.height;
        gl.viewport(viewport.x, viewPortY, viewport.width, viewport.height);
      }
      if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
        this._initStencil(gpuRenderTarget);
      }
      this.clear(renderTarget, clear, clearColor);
    }
    finishRenderPass(renderTarget) {
      const renderTargetSystem = this._renderTargetSystem;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (!glRenderTarget.msaa)
        return;
      const gl = this._renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
      gl.blitFramebuffer(0, 0, glRenderTarget.width, glRenderTarget.height, 0, 0, glRenderTarget.width, glRenderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
    }
    initGpuRenderTarget(renderTarget) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const glRenderTarget = new GlRenderTarget();
      const colorTexture = renderTarget.colorTexture;
      if (colorTexture instanceof CanvasSource) {
        this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
        glRenderTarget.framebuffer = null;
        return glRenderTarget;
      }
      this._initColor(renderTarget, glRenderTarget);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return glRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      const gl = this._renderer.gl;
      if (gpuRenderTarget.framebuffer) {
        gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
        gpuRenderTarget.framebuffer = null;
      }
      if (gpuRenderTarget.resolveTargetFramebuffer) {
        gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
        gpuRenderTarget.resolveTargetFramebuffer = null;
      }
      if (gpuRenderTarget.depthStencilRenderBuffer) {
        gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
        gpuRenderTarget.depthStencilRenderBuffer = null;
      }
      gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
        gl.deleteRenderbuffer(renderBuffer);
      });
      gpuRenderTarget.msaaRenderBuffer = null;
    }
    clear(_renderTarget, clear, clearColor) {
      if (!clear)
        return;
      const renderTargetSystem = this._renderTargetSystem;
      if (typeof clear === "boolean") {
        clear = clear ? CLEAR.ALL : CLEAR.NONE;
      }
      const gl = this._renderer.gl;
      if (clear & CLEAR.COLOR) {
        clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
        const clearColorCache = this._clearColorCache;
        const clearColorArray = clearColor;
        if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
          clearColorCache[0] = clearColorArray[0];
          clearColorCache[1] = clearColorArray[1];
          clearColorCache[2] = clearColorArray[2];
          clearColorCache[3] = clearColorArray[3];
          gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
        }
      }
      gl.clear(clear);
    }
    resizeGpuRenderTarget(renderTarget) {
      if (renderTarget.isRoot)
        return;
      const renderTargetSystem = this._renderTargetSystem;
      const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
      this._resizeColor(renderTarget, glRenderTarget);
      if (renderTarget.stencil || renderTarget.depth) {
        this._resizeStencil(glRenderTarget);
      }
    }
    _initColor(renderTarget, glRenderTarget) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const resolveTargetFramebuffer = gl.createFramebuffer();
      glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
      glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
      glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
      renderTarget.colorTextures.forEach((colorTexture, i2) => {
        const source3 = colorTexture.source;
        if (source3.antialias) {
          if (renderer.context.supports.msaa) {
            glRenderTarget.msaa = true;
          } else {
            warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
          }
        }
        renderer.texture.bindSource(source3, 0);
        const glSource = renderer.texture.getGlSource(source3);
        const glTexture = glSource.texture;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, 3553, glTexture, 0);
      });
      if (glRenderTarget.msaa) {
        const viewFramebuffer = gl.createFramebuffer();
        glRenderTarget.framebuffer = viewFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
        renderTarget.colorTextures.forEach((_, i2) => {
          const msaaRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
        });
      } else {
        glRenderTarget.framebuffer = resolveTargetFramebuffer;
      }
      this._resizeColor(renderTarget, glRenderTarget);
    }
    _resizeColor(renderTarget, glRenderTarget) {
      const source3 = renderTarget.colorTexture.source;
      glRenderTarget.width = source3.pixelWidth;
      glRenderTarget.height = source3.pixelHeight;
      renderTarget.colorTextures.forEach((colorTexture, i2) => {
        if (i2 === 0)
          return;
        colorTexture.source.resize(source3.width, source3.height, source3._resolution);
      });
      if (glRenderTarget.msaa) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const viewFramebuffer = glRenderTarget.framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          const source22 = colorTexture.source;
          renderer.texture.bindSource(source22, 0);
          const glSource = renderer.texture.getGlSource(source22);
          const glInternalFormat = glSource.internalFormat;
          const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
          gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, source22.pixelWidth, source22.pixelHeight);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, gl.RENDERBUFFER, msaaRenderBuffer);
        });
      }
    }
    _initStencil(glRenderTarget) {
      if (glRenderTarget.framebuffer === null)
        return;
      const gl = this._renderer.gl;
      const depthStencilRenderBuffer = gl.createRenderbuffer();
      glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
      gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);
      this._resizeStencil(glRenderTarget);
    }
    _resizeStencil(glRenderTarget) {
      const gl = this._renderer.gl;
      gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);
      if (glRenderTarget.msaa) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);
      }
    }
    prerender(renderTarget) {
      const resource = renderTarget.colorTexture.resource;
      if (this._renderer.context.multiView && CanvasSource.test(resource)) {
        this._renderer.context.ensureCanvasSize(resource);
      }
    }
    postrender(renderTarget) {
      if (!this._renderer.context.multiView)
        return;
      if (CanvasSource.test(renderTarget.colorTexture.resource)) {
        const contextCanvas = this._renderer.context.canvas;
        const canvasSource = renderTarget.colorTexture;
        canvasSource.context2D.drawImage(contextCanvas, 0, canvasSource.pixelHeight - contextCanvas.height);
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem = class extends RenderTargetSystem {
    constructor(renderer) {
      super(renderer);
      this.adaptor = new GlRenderTargetAdaptor();
      this.adaptor.init(renderer, this);
    }
  };
  GlRenderTargetSystem.extension = {
    type: [ExtensionType.WebGLSystem],
    name: "renderTarget"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i2 in shader.groups) {
      const group = shader.groups[i2];
      funcFragments.push(`
            resources = g[${i2}].resources;
        `);
      for (const j2 in group.resources) {
        const resource = group.resources[j2];
        if (resource instanceof UniformGroup) {
          if (resource.ubo) {
            const resName = shader._uniformBindMap[i2][Number(j2)];
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource) {
          const resName = shader._uniformBindMap[i2][Number(j2)];
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i2][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  "use strict";
  var GlProgramData = class {
    constructor(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBlockBindings = {};
    }
    destroy() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBlockBindings = null;
      this.program = null;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  "use strict";
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  "use strict";
  function booleanArray(size) {
    const array = new Array(size);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
  "use strict";
  var GL_TABLE = null;
  var GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  var GLSL_TO_VERTEX_TYPES = {
    float: "float32",
    vec2: "float32x2",
    vec3: "float32x3",
    vec4: "float32x4",
    int: "sint32",
    ivec2: "sint32x2",
    ivec3: "sint32x3",
    ivec4: "sint32x4",
    uint: "uint32",
    uvec2: "uint32x2",
    uvec3: "uint32x3",
    uvec4: "uint32x4",
    bool: "uint32",
    bvec2: "uint32x2",
    bvec3: "uint32x3",
    bvec4: "uint32x4"
  };
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = i2;
        gl.bindAttribLocation(program, i2, keys[i2]);
      }
      gl.linkProgram(program);
    } else {
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = gl.getAttribLocation(program, keys[i2]);
      }
    }
    return attributes;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  "use strict";
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
      const name = gl.getActiveUniformBlockName(program, i2);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i2,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  "use strict";
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(webGLProgram, gl, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex));
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program._uniformData) {
      const data = program._uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram3 = new GlProgramData(webGLProgram, uniformData);
    return glProgram3;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData = {
    textureCount: 0,
    blockIndex: 0
  };
  var GlShaderSystem = class {
    constructor(renderer) {
      this._activeProgram = null;
      this._programDataHash = /* @__PURE__ */ Object.create(null);
      this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
    }
    contextChange(gl) {
      this._gl = gl;
      this._programDataHash = /* @__PURE__ */ Object.create(null);
      this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
      this._activeProgram = null;
    }
    bind(shader, skipSync) {
      this._setProgram(shader.glProgram);
      if (skipSync)
        return;
      defaultSyncData.textureCount = 0;
      defaultSyncData.blockIndex = 0;
      let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
      if (!syncFunction) {
        syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
      }
      this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
      syncFunction(this._renderer, shader, defaultSyncData);
    }
    updateUniformGroup(uniformGroup) {
      this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
    }
    bindUniformBlock(uniformGroup, name, index = 0) {
      const bufferSystem = this._renderer.buffer;
      const programData = this._getProgramData(this._activeProgram);
      const isBufferResource = uniformGroup._bufferResource;
      if (!isBufferResource) {
        this._renderer.ubo.updateUniformGroup(uniformGroup);
      }
      const buffer = uniformGroup.buffer;
      const glBuffer = bufferSystem.updateBuffer(buffer);
      const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
      if (isBufferResource) {
        const {offset, size} = uniformGroup;
        if (offset === 0 && size === buffer.data.byteLength) {
          bufferSystem.bindBufferBase(glBuffer, boundLocation);
        } else {
          bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
        }
      } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
        bufferSystem.bindBufferBase(glBuffer, boundLocation);
      }
      const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
      if (programData.uniformBlockBindings[index] === boundLocation)
        return;
      programData.uniformBlockBindings[index] = boundLocation;
      this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
    }
    _setProgram(program) {
      if (this._activeProgram === program)
        return;
      this._activeProgram = program;
      const programData = this._getProgramData(program);
      this._gl.useProgram(programData.program);
    }
    _getProgramData(program) {
      return this._programDataHash[program._key] || this._createProgramData(program);
    }
    _createProgramData(program) {
      const key = program._key;
      this._programDataHash[key] = generateProgram(this._gl, program);
      return this._programDataHash[key];
    }
    destroy() {
      for (const key of Object.keys(this._programDataHash)) {
        const programData = this._programDataHash[key];
        programData.destroy();
        this._programDataHash[key] = null;
      }
      this._programDataHash = null;
      this._shaderSyncFunctions = null;
      this._activeProgram = null;
      this._renderer = null;
      this._gl = null;
    }
    _generateShaderSync(shader, shaderSystem) {
      return generateShaderSyncCode(shader, shaderSystem);
    }
    resetState() {
      this._activeProgram = null;
    }
  };
  GlShaderSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "shader"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  "use strict";
  var UNIFORM_TO_SINGLE_SETTERS = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
  };
  var UNIFORM_TO_ARRAY_SETTERS = {
    f32: `gl.uniform1fv(location, v);`,
    "vec2<f32>": `gl.uniform2fv(location, v);`,
    "vec3<f32>": `gl.uniform3fv(location, v);`,
    "vec4<f32>": `gl.uniform4fv(location, v);`,
    "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
    "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
    "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
    i32: `gl.uniform1iv(location, v);`,
    "vec2<i32>": `gl.uniform2iv(location, v);`,
    "vec3<i32>": `gl.uniform3iv(location, v);`,
    "vec4<i32>": `gl.uniform4iv(location, v);`,
    u32: `gl.uniform1iv(location, v);`,
    "vec2<u32>": `gl.uniform2iv(location, v);`,
    "vec3<u32>": `gl.uniform3iv(location, v);`,
    "vec4<u32>": `gl.uniform4iv(location, v);`,
    bool: `gl.uniform1iv(location, v);`,
    "vec2<bool>": `gl.uniform2iv(location, v);`,
    "vec3<bool>": `gl.uniform3iv(location, v);`,
    "vec4<bool>": `gl.uniform4iv(location, v);`
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i2 in group.uniforms) {
      if (!uniformData[i2]) {
        if (group.uniforms[i2] instanceof UniformGroup) {
          if (group.uniforms[i2].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
          }
        } else if (group.uniforms[i2] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
        }
        continue;
      }
      const uniform = group.uniformStructures[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const parser = uniformParsers[j2];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i2}";`, uniformParsers[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem = class {
    constructor(renderer) {
      this._cache = {};
      this._uniformGroupSyncHash = {};
      this._renderer = renderer;
      this.gl = null;
      this._cache = {};
    }
    contextChange(gl) {
      this.gl = gl;
    }
    updateUniformGroup(group, program, syncData) {
      const programData = this._renderer.shader._getProgramData(program);
      if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
        programData.uniformDirtyGroups[group.uid] = group._dirtyId;
        const syncFunc = this._getUniformSyncFunction(group, program);
        syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
      }
    }
    _getUniformSyncFunction(group, program) {
      return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
    }
    _createUniformSyncFunction(group, program) {
      const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
      const id = this._getSignature(group, program._uniformData, "u");
      if (!this._cache[id]) {
        this._cache[id] = this._generateUniformsSync(group, program._uniformData);
      }
      uniformGroupSyncHash[program._key] = this._cache[id];
      return uniformGroupSyncHash[program._key];
    }
    _generateUniformsSync(group, uniformData) {
      return generateUniformsSync(group, uniformData);
    }
    _getSignature(group, uniformData, preFix) {
      const uniforms = group.uniforms;
      const strings = [`${preFix}-`];
      for (const i2 in uniforms) {
        strings.push(i2);
        if (uniformData[i2]) {
          strings.push(uniformData[i2].type);
        }
      }
      return strings.join("-");
    }
    destroy() {
      this._renderer = null;
      this._cache = null;
    }
  };
  GlUniformGroupSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "uniformGroup"
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2 = 0;
  var OFFSET2 = 1;
  var CULLING2 = 2;
  var DEPTH_TEST2 = 3;
  var WINDING2 = 4;
  var DEPTH_MASK2 = 5;
  var _GlStateSystem = class _GlStateSystem2 {
    constructor(renderer) {
      this._invertFrontFace = false;
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = "none";
      this._blendEq = false;
      this.map = [];
      this.map[BLEND2] = this.setBlend;
      this.map[OFFSET2] = this.setOffset;
      this.map[CULLING2] = this.setCullFace;
      this.map[DEPTH_TEST2] = this.setDepthTest;
      this.map[WINDING2] = this.setFrontFace;
      this.map[DEPTH_MASK2] = this.setDepthMask;
      this.checks = [];
      this.defaultState = State.for2d();
      renderer.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(renderTarget) {
      this._invertFrontFace = !renderTarget.isRoot;
      if (this._cullFace) {
        this.setFrontFace(this._frontFace);
      } else {
        this._frontFaceDirty = true;
      }
    }
    contextChange(gl) {
      this.gl = gl;
      this.blendModesMap = mapWebGLBlendModesToPixi(gl);
      this.resetState();
    }
    set(state) {
      state || (state = this.defaultState);
      if (this.stateId !== state.data) {
        let diff = this.stateId ^ state.data;
        let i2 = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i2].call(this, !!(state.data & 1 << i2));
          }
          diff >>= 1;
          i2++;
        }
        this.stateId = state.data;
      }
      for (let i2 = 0; i2 < this.checks.length; i2++) {
        this.checks[i2](this, state);
      }
    }
    forceState(state) {
      state || (state = this.defaultState);
      for (let i2 = 0; i2 < this.map.length; i2++) {
        this.map[i2].call(this, !!(state.data & 1 << i2));
      }
      for (let i2 = 0; i2 < this.checks.length; i2++) {
        this.checks[i2](this, state);
      }
      this.stateId = state.data;
    }
    setBlend(value) {
      this._updateCheck(_GlStateSystem2._checkBlendMode, value);
      this.gl[value ? "enable" : "disable"](this.gl.BLEND);
    }
    setOffset(value) {
      this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
      this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    setDepthTest(value) {
      this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(value) {
      this.gl.depthMask(value);
    }
    setCullFace(value) {
      this._cullFace = value;
      this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      if (this._cullFace && this._frontFaceDirty) {
        this.setFrontFace(this._frontFace);
      }
    }
    setFrontFace(value) {
      this._frontFace = value;
      this._frontFaceDirty = false;
      const faceMode = this._invertFrontFace ? !value : value;
      if (this._glFrontFace !== faceMode) {
        this._glFrontFace = faceMode;
        this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
      }
    }
    setBlendMode(value) {
      if (!this.blendModesMap[value]) {
        value = "normal";
      }
      if (value === this.blendMode) {
        return;
      }
      this.blendMode = value;
      const mode = this.blendModesMap[value];
      const gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    }
    setPolygonOffset(value, scale) {
      this.gl.polygonOffset(value, scale);
    }
    resetState() {
      this._glFrontFace = false;
      this._frontFace = false;
      this._cullFace = false;
      this._frontFaceDirty = false;
      this._invertFrontFace = false;
      this.gl.frontFace(this.gl.CCW);
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = "";
      this.setBlendMode("normal");
    }
    _updateCheck(func, value) {
      const index = this.checks.indexOf(func);
      if (value && index === -1) {
        this.checks.push(func);
      } else if (!value && index !== -1) {
        this.checks.splice(index, 1);
      }
    }
    static _checkBlendMode(system, state) {
      system.setBlendMode(state.blendMode);
    }
    static _checkPolygonOffset(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    }
    destroy() {
      this.gl = null;
      this.checks.length = 0;
    }
  };
  _GlStateSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "state"
  };
  var GlStateSystem = _GlStateSystem;

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture = class {
    constructor(texture) {
      this.target = GL_TARGETS.TEXTURE_2D;
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.type = GL_TYPES.UNSIGNED_BYTE;
      this.internalFormat = GL_FORMATS.RGBA;
      this.format = GL_FORMATS.RGBA;
      this.samplerType = 0;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  "use strict";
  var glUploadBufferImageResource = {
    id: "buffer",
    upload(source3, glTexture, gl) {
      if (glTexture.width === source3.width || glTexture.height === source3.height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, source3.width, source3.height, glTexture.format, glTexture.type, source3.resource);
      } else {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, source3.width, source3.height, 0, glTexture.format, glTexture.type, source3.resource);
      }
      glTexture.width = source3.width;
      glTexture.height = source3.height;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  "use strict";
  var compressedFormatMap = {
    "bc1-rgba-unorm": true,
    "bc1-rgba-unorm-srgb": true,
    "bc2-rgba-unorm": true,
    "bc2-rgba-unorm-srgb": true,
    "bc3-rgba-unorm": true,
    "bc3-rgba-unorm-srgb": true,
    "bc4-r-unorm": true,
    "bc4-r-snorm": true,
    "bc5-rg-unorm": true,
    "bc5-rg-snorm": true,
    "bc6h-rgb-ufloat": true,
    "bc6h-rgb-float": true,
    "bc7-rgba-unorm": true,
    "bc7-rgba-unorm-srgb": true,
    "etc2-rgb8unorm": true,
    "etc2-rgb8unorm-srgb": true,
    "etc2-rgb8a1unorm": true,
    "etc2-rgb8a1unorm-srgb": true,
    "etc2-rgba8unorm": true,
    "etc2-rgba8unorm-srgb": true,
    "eac-r11unorm": true,
    "eac-r11snorm": true,
    "eac-rg11unorm": true,
    "eac-rg11snorm": true,
    "astc-4x4-unorm": true,
    "astc-4x4-unorm-srgb": true,
    "astc-5x4-unorm": true,
    "astc-5x4-unorm-srgb": true,
    "astc-5x5-unorm": true,
    "astc-5x5-unorm-srgb": true,
    "astc-6x5-unorm": true,
    "astc-6x5-unorm-srgb": true,
    "astc-6x6-unorm": true,
    "astc-6x6-unorm-srgb": true,
    "astc-8x5-unorm": true,
    "astc-8x5-unorm-srgb": true,
    "astc-8x6-unorm": true,
    "astc-8x6-unorm-srgb": true,
    "astc-8x8-unorm": true,
    "astc-8x8-unorm-srgb": true,
    "astc-10x5-unorm": true,
    "astc-10x5-unorm-srgb": true,
    "astc-10x6-unorm": true,
    "astc-10x6-unorm-srgb": true,
    "astc-10x8-unorm": true,
    "astc-10x8-unorm-srgb": true,
    "astc-10x10-unorm": true,
    "astc-10x10-unorm-srgb": true,
    "astc-12x10-unorm": true,
    "astc-12x10-unorm-srgb": true,
    "astc-12x12-unorm": true,
    "astc-12x12-unorm-srgb": true
  };
  var glUploadCompressedTextureResource = {
    id: "compressed",
    upload(source3, glTexture, gl) {
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
      let mipWidth = source3.pixelWidth;
      let mipHeight = source3.pixelHeight;
      const compressed = !!compressedFormatMap[source3.format];
      for (let i2 = 0; i2 < source3.resource.length; i2++) {
        const levelBuffer = source3.resource[i2];
        if (compressed) {
          gl.compressedTexImage2D(gl.TEXTURE_2D, i2, glTexture.internalFormat, mipWidth, mipHeight, 0, levelBuffer);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, i2, glTexture.internalFormat, mipWidth, mipHeight, 0, glTexture.format, glTexture.type, levelBuffer);
        }
        mipWidth = Math.max(mipWidth >> 1, 1);
        mipHeight = Math.max(mipHeight >> 1, 1);
      }
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  "use strict";
  var glUploadImageResource = {
    id: "image",
    upload(source3, glTexture, gl, webGLVersion) {
      const glWidth = glTexture.width;
      const glHeight = glTexture.height;
      const textureWidth = source3.pixelWidth;
      const textureHeight = source3.pixelHeight;
      const resourceWidth = source3.resourceWidth;
      const resourceHeight = source3.resourceHeight;
      if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
        if (glWidth !== textureWidth || glHeight !== textureHeight) {
          gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, null);
        }
        if (webGLVersion === 2) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, resourceWidth, resourceHeight, glTexture.format, glTexture.type, source3.resource);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source3.resource);
        }
      } else if (glWidth === textureWidth && glHeight === textureHeight) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source3.resource);
      } else if (webGLVersion === 2) {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, source3.resource);
      } else {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, glTexture.format, glTexture.type, source3.resource);
      }
      glTexture.width = textureWidth;
      glTexture.height = textureHeight;
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource = {
    id: "video",
    upload(source3, glTexture, gl, webGLVersion) {
      if (!source3.isValid) {
        gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, 1, 1, 0, glTexture.format, glTexture.type, null);
        return;
      }
      glUploadImageResource.upload(source3, glTexture, gl, webGLVersion);
    }
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  "use strict";
  var scaleModeToGlFilter = {
    linear: 9729,
    nearest: 9728
  };
  var mipmapScaleModeToGlFilter = {
    linear: {
      linear: 9987,
      nearest: 9985
    },
    nearest: {
      linear: 9986,
      nearest: 9984
    }
  };
  var wrapModeToGlAddress = {
    "clamp-to-edge": 33071,
    repeat: 10497,
    "mirror-repeat": 33648
  };
  var compareModeToGlCompare = {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  };

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  "use strict";
  function mapFormatToGlFormat(gl) {
    return {
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions2) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions2.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return {
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      ...srgb,
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
      ...extensions2.s3tc ? {
        "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.rgtc ? {
        "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...extensions2.bptc ? {
        "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...extensions2.etc ? {
        "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
        "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
      } : {},
      ...extensions2.astc ? {
        "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  "use strict";
  function mapFormatToGlType(gl) {
    return {
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL = 4;
  var GlTextureSystem = class {
    constructor(renderer) {
      this.managedTextures = [];
      this._glTextures = /* @__PURE__ */ Object.create(null);
      this._glSamplers = /* @__PURE__ */ Object.create(null);
      this._boundTextures = [];
      this._activeTextureLocation = -1;
      this._boundSamplers = /* @__PURE__ */ Object.create(null);
      this._uploads = {
        image: glUploadImageResource,
        buffer: glUploadBufferImageResource,
        video: glUploadVideoResource,
        compressed: glUploadCompressedTextureResource
      };
      this._premultiplyAlpha = false;
      this._useSeparateSamplers = false;
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_glTextures");
      this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
    }
    contextChange(gl) {
      this._gl = gl;
      if (!this._mapFormatToInternalFormat) {
        this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
        this._mapFormatToType = mapFormatToGlType(gl);
        this._mapFormatToFormat = mapFormatToGlFormat(gl);
      }
      this._glTextures = /* @__PURE__ */ Object.create(null);
      this._glSamplers = /* @__PURE__ */ Object.create(null);
      this._boundSamplers = /* @__PURE__ */ Object.create(null);
      this._premultiplyAlpha = false;
      for (let i2 = 0; i2 < 16; i2++) {
        this.bind(Texture.EMPTY, i2);
      }
    }
    initSource(source3) {
      this.bind(source3);
    }
    bind(texture, location = 0) {
      const source3 = texture.source;
      if (texture) {
        this.bindSource(source3, location);
        if (this._useSeparateSamplers) {
          this._bindSampler(source3.style, location);
        }
      } else {
        this.bindSource(null, location);
        if (this._useSeparateSamplers) {
          this._bindSampler(null, location);
        }
      }
    }
    bindSource(source3, location = 0) {
      const gl = this._gl;
      source3._touched = this._renderer.textureGC.count;
      if (this._boundTextures[location] !== source3) {
        this._boundTextures[location] = source3;
        this._activateLocation(location);
        source3 || (source3 = Texture.EMPTY.source);
        const glTexture = this.getGlSource(source3);
        gl.bindTexture(glTexture.target, glTexture.texture);
      }
    }
    _bindSampler(style, location = 0) {
      const gl = this._gl;
      if (!style) {
        this._boundSamplers[location] = null;
        gl.bindSampler(location, null);
        return;
      }
      const sampler = this._getGlSampler(style);
      if (this._boundSamplers[location] !== sampler) {
        this._boundSamplers[location] = sampler;
        gl.bindSampler(location, sampler);
      }
    }
    unbind(texture) {
      const source3 = texture.source;
      const boundTextures = this._boundTextures;
      const gl = this._gl;
      for (let i2 = 0; i2 < boundTextures.length; i2++) {
        if (boundTextures[i2] === source3) {
          this._activateLocation(i2);
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(glTexture.target, null);
          boundTextures[i2] = null;
        }
      }
    }
    _activateLocation(location) {
      if (this._activeTextureLocation !== location) {
        this._activeTextureLocation = location;
        this._gl.activeTexture(this._gl.TEXTURE0 + location);
      }
    }
    _initSource(source3) {
      const gl = this._gl;
      const glTexture = new GlTexture(gl.createTexture());
      glTexture.type = this._mapFormatToType[source3.format];
      glTexture.internalFormat = this._mapFormatToInternalFormat[source3.format];
      glTexture.format = this._mapFormatToFormat[source3.format];
      if (source3.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source3.isPowerOfTwo)) {
        const biggestDimension = Math.max(source3.width, source3.height);
        source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
      }
      this._glTextures[source3.uid] = glTexture;
      if (!this.managedTextures.includes(source3)) {
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceUpdate, this);
        source3.on("styleChange", this.onStyleChange, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        source3.on("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.push(source3);
      }
      this.onSourceUpdate(source3);
      this.updateStyle(source3, false);
      return glTexture;
    }
    onStyleChange(source3) {
      this.updateStyle(source3, false);
    }
    updateStyle(source3, firstCreation) {
      const gl = this._gl;
      const glTexture = this.getGlSource(source3);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source3;
      applyStyleParams(source3.style, gl, source3.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", gl.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !source3.isPowerOfTwo, firstCreation);
    }
    onSourceUnload(source3) {
      const glTexture = this._glTextures[source3.uid];
      if (!glTexture)
        return;
      this.unbind(source3);
      this._glTextures[source3.uid] = null;
      this._gl.deleteTexture(glTexture.texture);
    }
    onSourceUpdate(source3) {
      const gl = this._gl;
      const glTexture = this.getGlSource(source3);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source3;
      const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
      if (this._premultiplyAlpha !== premultipliedAlpha) {
        this._premultiplyAlpha = premultipliedAlpha;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
      }
      if (this._uploads[source3.uploadMethodId]) {
        this._uploads[source3.uploadMethodId].upload(source3, glTexture, gl, this._renderer.context.webGLVersion);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
        this.onUpdateMipmaps(source3, false);
      }
    }
    onUpdateMipmaps(source3, bind = true) {
      if (bind)
        this.bindSource(source3, 0);
      const glTexture = this.getGlSource(source3);
      this._gl.generateMipmap(glTexture.target);
    }
    onSourceDestroy(source3) {
      source3.off("destroy", this.onSourceDestroy, this);
      source3.off("update", this.onSourceUpdate, this);
      source3.off("resize", this.onSourceUpdate, this);
      source3.off("unload", this.onSourceUnload, this);
      source3.off("styleChange", this.onStyleChange, this);
      source3.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
      this.onSourceUnload(source3);
    }
    _initSampler(style) {
      const gl = this._gl;
      const glSampler = this._gl.createSampler();
      this._glSamplers[style._resourceId] = glSampler;
      applyStyleParams(style, gl, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", glSampler, false, true);
      return this._glSamplers[style._resourceId];
    }
    _getGlSampler(sampler) {
      return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
    }
    getGlSource(source3) {
      return this._glTextures[source3.uid] || this._initSource(source3);
    }
    generateCanvas(texture) {
      const {pixels, width, height} = this.getPixels(texture);
      const canvas = DOMAdapter.get().createCanvas();
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        const imageData = ctx.createImageData(width, height);
        imageData.data.set(pixels);
        ctx.putImageData(imageData, 0, 0);
      }
      return canvas;
    }
    getPixels(texture) {
      const resolution = texture.source.resolution;
      const frame = texture.frame;
      const width = Math.max(Math.round(frame.width * resolution), 1);
      const height = Math.max(Math.round(frame.height * resolution), 1);
      const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const renderer = this._renderer;
      const renderTarget = renderer.renderTarget.getRenderTarget(texture);
      const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
      const gl = renderer.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      if (false) {
        unpremultiplyAlpha(pixels);
      }
      return {pixels: new Uint8ClampedArray(pixels.buffer), width, height};
    }
    destroy() {
      this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
      this.managedTextures = null;
      this._glTextures = null;
      this._glSamplers = null;
      this._boundTextures = null;
      this._boundSamplers = null;
      this._mapFormatToInternalFormat = null;
      this._mapFormatToType = null;
      this._mapFormatToFormat = null;
      this._uploads = null;
      this._renderer = null;
    }
    resetState() {
      this._activeTextureLocation = -1;
      this._boundTextures.fill(Texture.EMPTY.source);
      this._boundSamplers = /* @__PURE__ */ Object.create(null);
      const gl = this._gl;
      this._premultiplyAlpha = false;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
    }
  };
  GlTextureSystem.extension = {
    type: [
      ExtensionType.WebGLSystem
    ],
    name: "texture"
  };

  // node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  async function autoDetectRenderer(options) {
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      renderPriority.forEach((item) => {
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    let finalOptions = {};
    for (let i2 = 0; i2 < preferredOrder.length; i2++) {
      const rendererType = preferredOrder[i2];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const {WebGPURenderer} = await Promise.resolve().then(() => require_WebGPURenderer());
        RendererClass = WebGPURenderer;
        finalOptions = {...options, ...options.webgpu};
        break;
      } else if (rendererType === "webgl" && isWebGLSupported(options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)) {
        const {WebGLRenderer} = await Promise.resolve().then(() => require_WebGLRenderer());
        RendererClass = WebGLRenderer;
        finalOptions = {...options, ...options.webgl};
        break;
      } else if (rendererType === "canvas") {
        finalOptions = {...options};
        throw new Error("CanvasRenderer is not yet implemented");
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }

  // node_modules/pixi.js/lib/app/Application.mjs
  var _Application = class _Application2 {
    constructor(...args) {
      this.stage = new Container();
      if (args[0] !== void 0) {
        deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
      }
    }
    async init(options) {
      options = {...options};
      this.renderer = await autoDetectRenderer(options);
      _Application2._plugins.forEach((plugin) => {
        plugin.init.call(this, options);
      });
    }
    render() {
      this.renderer.render({container: this.stage});
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
      return this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(rendererDestroyOptions = false, options = false) {
      const plugins = _Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(options);
      this.stage = null;
      this.renderer.destroy(rendererDestroyOptions);
      this.renderer = null;
    }
  };
  _Application._plugins = [];
  var Application = _Application;
  extensions.handleByList(ExtensionType.Application, Application._plugins);
  extensions.add(ApplicationInitHook);

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
  var BitmapFont = class extends AbstractBitmapFont {
    constructor(options, url) {
      super();
      const {textures, data} = options;
      Object.keys(data.pages).forEach((key) => {
        const pageData = data.pages[parseInt(key, 10)];
        const texture = textures[pageData.id];
        this.pages.push({texture});
      });
      Object.keys(data.chars).forEach((key) => {
        const charData = data.chars[key];
        const {
          frame: textureFrame,
          source: textureSource,
          rotate: textureRotate
        } = textures[charData.page];
        const frame = groupD8.transformRectCoords(charData, textureFrame, textureRotate, new Rectangle());
        const texture = new Texture({
          frame,
          orig: new Rectangle(0, 0, charData.width, charData.height),
          source: textureSource,
          rotate: textureRotate
        });
        this.chars[key] = {
          id: key.codePointAt(0),
          xOffset: charData.xOffset,
          yOffset: charData.yOffset,
          xAdvance: charData.xAdvance,
          kerning: charData.kerning ?? {},
          texture
        };
      });
      this.baseRenderedFontSize = data.fontSize;
      this.baseMeasurementFontSize = data.fontSize;
      this.fontMetrics = {
        ascent: 0,
        descent: 0,
        fontSize: data.fontSize
      };
      this.baseLineOffset = data.baseLineOffset;
      this.lineHeight = data.lineHeight;
      this.fontFamily = data.fontFamily;
      this.distanceField = data.distanceField ?? {
        type: "none",
        range: 0
      };
      this.url = url;
    }
    destroy() {
      super.destroy();
      for (let i2 = 0; i2 < this.pages.length; i2++) {
        const {texture} = this.pages[i2];
        texture.destroy(true);
      }
      this.pages = null;
    }
    static install(options) {
      BitmapFontManager.install(options);
    }
    static uninstall(name) {
      BitmapFontManager.uninstall(name);
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  "use strict";
  var bitmapFontTextParser = {
    test(data) {
      return typeof data === "string" && data.startsWith("info face=");
    },
    parse(txt) {
      const items = txt.match(/^[a-z]+\s+.+$/gm);
      const rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const i2 in items) {
        const name = items[i2].match(/^[a-z]+/gm)[0];
        const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        const itemData = {};
        for (const i22 in attributeList) {
          const split = attributeList[i22].split("=");
          const key = split[0];
          const strValue = split[1].replace(/"/gm, "");
          const floatValue = parseFloat(strValue);
          const value = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value;
        }
        rawData[name].push(itemData);
      }
      const font = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const [info] = rawData.info;
      const [common] = rawData.common;
      const [distanceField] = rawData.distanceField ?? [];
      if (distanceField) {
        font.distanceField = {
          range: parseInt(distanceField.distanceRange, 10),
          type: distanceField.fieldType
        };
      }
      font.fontSize = parseInt(info.size, 10);
      font.fontFamily = info.face;
      font.lineHeight = parseInt(common.lineHeight, 10);
      const page = rawData.page;
      for (let i2 = 0; i2 < page.length; i2++) {
        font.pages.push({
          id: parseInt(page[i2].id, 10) || 0,
          file: page[i2].file
        });
      }
      const map = {};
      font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
      const char = rawData.char;
      for (let i2 = 0; i2 < char.length; i2++) {
        const charNode = char[i2];
        const id = parseInt(charNode.id, 10);
        let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
        if (letter === "space")
          letter = " ";
        map[id] = letter;
        font.chars[letter] = {
          id,
          page: parseInt(charNode.page, 10) || 0,
          x: parseInt(charNode.x, 10),
          y: parseInt(charNode.y, 10),
          width: parseInt(charNode.width, 10),
          height: parseInt(charNode.height, 10),
          xOffset: parseInt(charNode.xoffset, 10),
          yOffset: parseInt(charNode.yoffset, 10),
          xAdvance: parseInt(charNode.xadvance, 10),
          kerning: {}
        };
      }
      const kerning = rawData.kerning || [];
      for (let i2 = 0; i2 < kerning.length; i2++) {
        const first = parseInt(kerning[i2].first, 10);
        const second = parseInt(kerning[i2].second, 10);
        const amount = parseInt(kerning[i2].amount, 10);
        font.chars[map[second]].kerning[map[first]] = amount;
      }
      return font;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  "use strict";
  var bitmapFontXMLParser = {
    test(data) {
      const xml = data;
      return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse(xml) {
      const data = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const info = xml.getElementsByTagName("info")[0];
      const common = xml.getElementsByTagName("common")[0];
      const distanceField = xml.getElementsByTagName("distanceField")[0];
      if (distanceField) {
        data.distanceField = {
          type: distanceField.getAttribute("fieldType"),
          range: parseInt(distanceField.getAttribute("distanceRange"), 10)
        };
      }
      const page = xml.getElementsByTagName("page");
      const char = xml.getElementsByTagName("char");
      const kerning = xml.getElementsByTagName("kerning");
      data.fontSize = parseInt(info.getAttribute("size"), 10);
      data.fontFamily = info.getAttribute("face");
      data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
      for (let i2 = 0; i2 < page.length; i2++) {
        data.pages.push({
          id: parseInt(page[i2].getAttribute("id"), 10) || 0,
          file: page[i2].getAttribute("file")
        });
      }
      const map = {};
      data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
      for (let i2 = 0; i2 < char.length; i2++) {
        const charNode = char[i2];
        const id = parseInt(charNode.getAttribute("id"), 10);
        let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
        if (letter === "space")
          letter = " ";
        map[id] = letter;
        data.chars[letter] = {
          id,
          page: parseInt(charNode.getAttribute("page"), 10) || 0,
          x: parseInt(charNode.getAttribute("x"), 10),
          y: parseInt(charNode.getAttribute("y"), 10),
          width: parseInt(charNode.getAttribute("width"), 10),
          height: parseInt(charNode.getAttribute("height"), 10),
          xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
          yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
          xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
          kerning: {}
        };
      }
      for (let i2 = 0; i2 < kerning.length; i2++) {
        const first = parseInt(kerning[i2].getAttribute("first"), 10);
        const second = parseInt(kerning[i2].getAttribute("second"), 10);
        const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
        data.chars[map[second]].kerning[map[first]] = amount;
      }
      return data;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser = {
    test(data) {
      if (typeof data === "string" && data.includes("<font>")) {
        return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
      }
      return false;
    },
    parse(data) {
      return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions = [".xml", ".fnt"];
  var bitmapFontCachePlugin = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheBitmapFont"
    },
    test: (asset) => asset instanceof BitmapFont,
    getCacheableAssets(keys, asset) {
      const out2 = {};
      keys.forEach((key) => {
        out2[key] = asset;
        out2[`${key}-bitmap`] = asset;
      });
      out2[`${asset.fontFamily}-bitmap`] = asset;
      return out2;
    }
  };
  var loadBitmapFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    name: "loadBitmapFont",
    id: "bitmap-font",
    test(url) {
      return validExtensions.includes(path.extname(url).toLowerCase());
    },
    async testParse(data) {
      return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
    },
    async parse(asset, data, loader) {
      const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
      const {src} = data;
      const {pages} = bitmapFontData;
      const textureUrls = [];
      const textureOptions = bitmapFontData.distanceField ? {
        scaleMode: "linear",
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: false,
        resolution: 1
      } : {};
      for (let i2 = 0; i2 < pages.length; ++i2) {
        const pageFile = pages[i2].file;
        let imagePath = path.join(path.dirname(src), pageFile);
        imagePath = copySearchParams(imagePath, src);
        textureUrls.push({
          src: imagePath,
          data: textureOptions
        });
      }
      const loadedTextures = await loader.load(textureUrls);
      const textures = textureUrls.map((url) => loadedTextures[url.src]);
      const bitmapFont = new BitmapFont({
        data: bitmapFontData,
        textures
      }, src);
      return bitmapFont;
    },
    async load(url, _options) {
      const response = await DOMAdapter.get().fetch(url);
      return await response.text();
    },
    async unload(bitmapFont, _resolvedAsset, loader) {
      await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
      bitmapFont.destroy();
    }
  };

  // node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
  "use strict";
  var BackgroundLoader = class {
    constructor(loader, verbose = false) {
      this._loader = loader;
      this._assetList = [];
      this._isLoading = false;
      this._maxConcurrent = 1;
      this.verbose = verbose;
    }
    add(assetUrls) {
      assetUrls.forEach((a2) => {
        this._assetList.push(a2);
      });
      if (this.verbose) {
        console.log("[BackgroundLoader] assets: ", this._assetList);
      }
      if (this._isActive && !this._isLoading) {
        void this._next();
      }
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const toLoad = [];
        const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
        for (let i2 = 0; i2 < toLoadAmount; i2++) {
          toLoad.push(this._assetList.pop());
        }
        await this._loader.load(toLoad);
        this._isLoading = false;
        void this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(value) {
      if (this._isActive === value)
        return;
      this._isActive = value;
      if (value && !this._isLoading) {
        void this._next();
      }
    }
  };

  // node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheTextureArray"
    },
    test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
    getCacheableAssets: (keys, asset) => {
      const out2 = {};
      keys.forEach((key) => {
        asset.forEach((item, i2) => {
          out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
        });
      });
      return out2;
    }
  };

  // node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
  "use strict";
  async function testImageFormat(imageData) {
    if ("Image" in globalThis) {
      return new Promise((resolve) => {
        const image = new Image();
        image.onload = () => {
          resolve(true);
        };
        image.onerror = () => {
          resolve(false);
        };
        image.src = imageData;
      });
    }
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const blob = await (await fetch(imageData)).blob();
        await createImageBitmap(blob);
      } catch (_e) {
        return false;
      }
      return true;
    }
    return false;
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 1
    },
    test: async () => testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
    add: async (formats) => [...formats, "avif"],
    remove: async (formats) => formats.filter((f2) => f2 !== "avif")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
  var imageFormats = ["png", "jpg", "jpeg"];
  var detectDefaults = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (formats) => [...formats, ...imageFormats],
    remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
  };

  // node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
  "use strict";
  var inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function testVideoFormat(mimeType) {
    if (inWorker) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp4 = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/mp4"),
    add: async (formats) => [...formats, "mp4", "m4v"],
    remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
  var detectOgv = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/ogg"),
    add: async (formats) => [...formats, "ogv"],
    remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
  var detectWebm = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/webm"),
    add: async (formats) => [...formats, "webm"],
    remove: async (formats) => formats.filter((f2) => f2 !== "webm")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
  var detectWebp = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
    add: async (formats) => [...formats, "webp"],
    remove: async (formats) => formats.filter((f2) => f2 !== "webp")
  };

  // node_modules/pixi.js/lib/assets/loader/Loader.mjs
  var Loader = class {
    constructor() {
      this._parsers = [];
      this._parsersValidated = false;
      this.parsers = new Proxy(this._parsers, {
        set: (target, key, value) => {
          this._parsersValidated = false;
          target[key] = value;
          return true;
        }
      });
      this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = false;
      this.promiseCache = {};
    }
    _getLoadPromiseAndParser(url, data) {
      const result = {
        promise: null,
        parser: null
      };
      result.promise = (async () => {
        let asset = null;
        let parser = null;
        if (data.parser || data.loadParser) {
          parser = this._parserHash[data.parser || data.loadParser];
          if (data.loadParser) {
            warn(`[Assets] "loadParser" is deprecated, use "parser" instead for ${url}`);
          }
          if (!parser) {
            warn(`[Assets] specified load parser "${data.parser || data.loadParser}" not found while loading ${url}`);
          }
        }
        if (!parser) {
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parserX = this.parsers[i2];
            if (parserX.load && parserX.test?.(url, data, this)) {
              parser = parserX;
              break;
            }
          }
          if (!parser) {
            warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
            return null;
          }
        }
        asset = await parser.load(url, data, this);
        result.parser = parser;
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parser2 = this.parsers[i2];
          if (parser2.parse) {
            if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
              asset = await parser2.parse(asset, data, this) || asset;
              result.parser = parser2;
            }
          }
        }
        return asset;
      })();
      return result;
    }
    async load(assetsToLoadIn, onProgress) {
      if (!this._parsersValidated) {
        this._validateParsers();
      }
      let count2 = 0;
      const assets = {};
      const singleAsset = isSingleItem(assetsToLoadIn);
      const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
        alias: [item],
        src: item,
        data: {}
      }));
      const total = assetsToLoad.length;
      const promises = assetsToLoad.map(async (asset) => {
        const url = path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            if (!this.promiseCache[url]) {
              this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
            }
            assets[asset.src] = await this.promiseCache[url].promise;
            if (onProgress)
              onProgress(++count2 / total);
          } catch (e2) {
            delete this.promiseCache[url];
            delete assets[asset.src];
            throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
          }
        }
      });
      await Promise.all(promises);
      return singleAsset ? assets[assetsToLoad[0].src] : assets;
    }
    async unload(assetsToUnloadIn) {
      const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
        alias: [item],
        src: item
      }));
      const promises = assetsToUnload.map(async (asset) => {
        const url = path.toAbsolute(asset.src);
        const loadPromise = this.promiseCache[url];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          delete this.promiseCache[url];
          await loadPromise.parser?.unload?.(loadedAsset, asset, this);
        }
      });
      await Promise.all(promises);
    }
    _validateParsers() {
      this._parsersValidated = true;
      this._parserHash = this._parsers.filter((parser) => parser.name || parser.id).reduce((hash, parser) => {
        if (!parser.name && !parser.id) {
          warn(`[Assets] parser should have an id`);
        } else if (hash[parser.name] || hash[parser.id]) {
          warn(`[Assets] parser id conflict "${parser.id}"`);
        }
        hash[parser.name] = parser;
        if (parser.id)
          hash[parser.id] = parser;
        return hash;
      }, {});
    }
  };

  // node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
  "use strict";
  function checkDataUrl(url, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url.startsWith(`data:${mimes}`);
  }

  // node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
  function checkExtension(url, extension) {
    const tempURL = url.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  var validJSONExtension = ".json";
  var validJSONMIME = "application/json";
  var loadJson = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    name: "loadJson",
    id: "json",
    test(url) {
      return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
    },
    async load(url) {
      const response = await DOMAdapter.get().fetch(url);
      const json = await response.json();
      return json;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
  var validTXTExtension = ".txt";
  var validTXTMIME = "text/plain";
  var loadTxt = {
    name: "loadTxt",
    id: "text",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadTxt"
    },
    test(url) {
      return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
    },
    async load(url) {
      const response = await DOMAdapter.get().fetch(url);
      const txt = await response.text();
      return txt;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
  var validWeights = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ];
  var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
  var validFontMIMEs = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ];
  var CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function getFontFamilyName(url) {
    const ext = path.extname(url);
    const name = path.basename(url, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
    }
    return fontFamilyName;
  }
  var validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var loadWebFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    name: "loadWebFont",
    id: "web-font",
    test(url) {
      return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
    },
    async load(url, options) {
      const fonts = DOMAdapter.get().getFontFaceSet();
      if (fonts) {
        const fontFaces = [];
        const name = options.data?.family ?? getFontFamilyName(url);
        const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
        const data = options.data ?? {};
        for (let i2 = 0; i2 < weights.length; i2++) {
          const weight = weights[i2];
          const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
            ...data,
            weight
          });
          await font.load();
          fonts.add(font);
          fontFaces.push(font);
        }
        if (Cache.has(`${name}-and-url`)) {
          const cached = Cache.get(`${name}-and-url`);
          cached.entries.push({url, faces: fontFaces});
        } else {
          Cache.set(`${name}-and-url`, {
            entries: [{url, faces: fontFaces}]
          });
        }
        return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
      }
      warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
      return null;
    },
    unload(font) {
      const fonts = Array.isArray(font) ? font : [font];
      const fontFamily = fonts[0].family;
      const cached = Cache.get(`${fontFamily}-and-url`);
      const entry = cached.entries.find((f2) => f2.faces.some((t2) => fonts.indexOf(t2) !== -1));
      entry.faces = entry.faces.filter((f2) => fonts.indexOf(f2) === -1);
      if (entry.faces.length === 0) {
        cached.entries = cached.entries.filter((f2) => f2 !== entry);
      }
      fonts.forEach((t2) => {
        DOMAdapter.get().getFontFaceSet().delete(t2);
      });
      if (cached.entries.length === 0) {
        Cache.remove(`${fontFamily}-and-url`);
      }
    }
  };

  // node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl(url, defaultValue2 = 1) {
    const resolution = Resolver.RETINA_PREFIX?.exec(url);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  function createTexture(source3, loader, url) {
    source3.label = url;
    source3._sourceOrigin = url;
    const texture = new Texture({
      source: source3,
      label: url
    });
    const unload = () => {
      delete loader.promiseCache[url];
      if (Cache.has(url)) {
        Cache.remove(url);
      }
    };
    texture.source.once("destroy", () => {
      if (loader.promiseCache[url]) {
        warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
        unload();
      }
    });
    texture.once("destroy", () => {
      if (!source3.destroyed) {
        warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  var validSVGExtension = ".svg";
  var validSVGMIME = "image/svg+xml";
  var loadSvg = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadSVG"
    },
    name: "loadSVG",
    id: "svg",
    config: {
      crossOrigin: "anonymous",
      parseAsGraphicsContext: false
    },
    test(url) {
      return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
    },
    async load(url, asset, loader) {
      if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
        return loadAsGraphics(url);
      }
      return loadAsTexture(url, asset, loader, this.config.crossOrigin);
    },
    unload(asset) {
      asset.destroy(true);
    }
  };
  async function loadAsTexture(url, asset, loader, crossOrigin2) {
    const response = await DOMAdapter.get().fetch(url);
    const image = DOMAdapter.get().createImage();
    image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;
    image.crossOrigin = crossOrigin2;
    await image.decode();
    const width = asset.data?.width ?? image.width;
    const height = asset.data?.height ?? image.height;
    const resolution = asset.data?.resolution || getResolutionOfUrl(url);
    const canvasWidth = Math.ceil(width * resolution);
    const canvasHeight = Math.ceil(height * resolution);
    const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);
    const context4 = canvas.getContext("2d");
    context4.imageSmoothingEnabled = true;
    context4.imageSmoothingQuality = "high";
    context4.drawImage(image, 0, 0, width * resolution, height * resolution);
    const {parseAsGraphicsContext: _p, ...rest} = asset.data ?? {};
    const base = new ImageSource({
      resource: canvas,
      alphaMode: "premultiply-alpha-on-upload",
      resolution,
      ...rest
    });
    return createTexture(base, loader, url);
  }
  async function loadAsGraphics(url) {
    const response = await DOMAdapter.get().fetch(url);
    const svgSource = await response.text();
    const context4 = new GraphicsContext();
    context4.svg(svgSource);
    return context4;
  }

  // node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs
  var WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  var WORKER_URL = null;
  var WorkerInstance = class {
    constructor() {
      if (!WORKER_URL) {
        WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], {type: "application/javascript"}));
      }
      this.worker = new Worker(WORKER_URL);
    }
  };
  WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
      URL.revokeObjectURL(WORKER_URL);
      WORKER_URL = null;
    }
  };

  // node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs
  var WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
  var WORKER_URL2 = null;
  var WorkerInstance2 = class {
    constructor() {
      if (!WORKER_URL2) {
        WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], {type: "application/javascript"}));
      }
      this.worker = new Worker(WORKER_URL2);
    }
  };
  WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
    if (WORKER_URL2) {
      URL.revokeObjectURL(WORKER_URL2);
      WORKER_URL2 = null;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs
  var UUID = 0;
  var MAX_WORKERS;
  var WorkerManagerClass = class {
    constructor() {
      this._initialized = false;
      this._createdWorkers = 0;
      this._workerPool = [];
      this._queue = [];
      this._resolveHash = {};
    }
    isImageBitmapSupported() {
      if (this._isImageBitmapSupported !== void 0)
        return this._isImageBitmapSupported;
      this._isImageBitmapSupported = new Promise((resolve) => {
        const {worker} = new WorkerInstance();
        worker.addEventListener("message", (event) => {
          worker.terminate();
          WorkerInstance.revokeObjectURL();
          resolve(event.data);
        });
      });
      return this._isImageBitmapSupported;
    }
    loadImageBitmap(src, asset) {
      return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
    }
    async _initWorkers() {
      if (this._initialized)
        return;
      this._initialized = true;
    }
    _getWorker() {
      if (MAX_WORKERS === void 0) {
        MAX_WORKERS = navigator.hardwareConcurrency || 4;
      }
      let worker = this._workerPool.pop();
      if (!worker && this._createdWorkers < MAX_WORKERS) {
        this._createdWorkers++;
        worker = new WorkerInstance2().worker;
        worker.addEventListener("message", (event) => {
          this._complete(event.data);
          this._returnWorker(event.target);
          this._next();
        });
      }
      return worker;
    }
    _returnWorker(worker) {
      this._workerPool.push(worker);
    }
    _complete(data) {
      if (data.error !== void 0) {
        this._resolveHash[data.uuid].reject(data.error);
      } else {
        this._resolveHash[data.uuid].resolve(data.data);
      }
      this._resolveHash[data.uuid] = null;
    }
    async _run(id, args) {
      await this._initWorkers();
      const promise2 = new Promise((resolve, reject) => {
        this._queue.push({id, arguments: args, resolve, reject});
      });
      this._next();
      return promise2;
    }
    _next() {
      if (!this._queue.length)
        return;
      const worker = this._getWorker();
      if (!worker) {
        return;
      }
      const toDo = this._queue.pop();
      const id = toDo.id;
      this._resolveHash[UUID] = {resolve: toDo.resolve, reject: toDo.reject};
      worker.postMessage({
        data: toDo.arguments,
        uuid: UUID++,
        id
      });
    }
    reset() {
      this._workerPool.forEach((worker) => worker.terminate());
      this._workerPool.length = 0;
      Object.values(this._resolveHash).forEach(({reject}) => {
        reject?.(new Error("WorkerManager destroyed"));
      });
      this._resolveHash = {};
      this._queue.length = 0;
      this._initialized = false;
      this._createdWorkers = 0;
    }
  };
  var WorkerManager = new WorkerManagerClass();

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var validImageMIMEs = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function loadImageBitmap(url, asset) {
    const response = await DOMAdapter.get().fetch(url);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, {premultiplyAlpha: "none"}) : createImageBitmap(imageBlob);
  }
  var loadTextures = {
    name: "loadTextures",
    id: "texture",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadTextures"
    },
    config: {
      preferWorkers: true,
      preferCreateImageBitmap: true,
      crossOrigin: "anonymous"
    },
    test(url) {
      return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
    },
    async load(url, asset, loader) {
      let src = null;
      if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
        if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
          src = await WorkerManager.loadImageBitmap(url, asset);
        } else {
          src = await loadImageBitmap(url, asset);
        }
      } else {
        src = await new Promise((resolve, reject) => {
          src = DOMAdapter.get().createImage();
          src.crossOrigin = this.config.crossOrigin;
          src.src = url;
          if (src.complete) {
            resolve(src);
          } else {
            src.onload = () => {
              resolve(src);
            };
            src.onerror = reject;
          }
        });
      }
      const base = new ImageSource({
        resource: src,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: asset.data?.resolution || getResolutionOfUrl(url),
        ...asset.data
      });
      return createTexture(base, loader, url);
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  var potentialVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
  var validVideoExtensions;
  var validVideoMIMEs;
  function crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function preloadVideo(element) {
    return new Promise((resolve, reject) => {
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error);
      element.load();
      function loaded() {
        cleanup();
        resolve();
      }
      function error(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error);
      }
    });
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc || (loc = globalThis.location);
    const parsedUrl = new URL(url, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  function getBrowserSupportedVideoExtensions() {
    const supportedExtensions = [];
    const supportedMimes = [];
    for (const ext of potentialVideoExtensions) {
      const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;
      if (testVideoFormat(mimeType)) {
        supportedExtensions.push(ext);
        if (!supportedMimes.includes(mimeType)) {
          supportedMimes.push(mimeType);
        }
      }
    }
    return {
      validVideoExtensions: supportedExtensions,
      validVideoMime: supportedMimes
    };
  }
  var loadVideoTextures = {
    name: "loadVideo",
    id: "video",
    extension: {
      type: ExtensionType.LoadParser,
      name: "loadVideo"
    },
    test(url) {
      if (!validVideoExtensions || !validVideoMIMEs) {
        const {validVideoExtensions: ve, validVideoMime: vm} = getBrowserSupportedVideoExtensions();
        validVideoExtensions = ve;
        validVideoMIMEs = vm;
      }
      const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
      const isValidExtension = checkExtension(url, validVideoExtensions);
      return isValidDataUrl || isValidExtension;
    },
    async load(url, asset, loader) {
      const options = {
        ...VideoSource.defaultOptions,
        resolution: asset.data?.resolution || getResolutionOfUrl(url),
        alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
        ...asset.data
      };
      const videoElement = document.createElement("video");
      const attributeMap = {
        preload: options.autoLoad !== false ? "auto" : void 0,
        "webkit-playsinline": options.playsinline !== false ? "" : void 0,
        playsinline: options.playsinline !== false ? "" : void 0,
        muted: options.muted === true ? "" : void 0,
        loop: options.loop === true ? "" : void 0,
        autoplay: options.autoPlay !== false ? "" : void 0
      };
      Object.keys(attributeMap).forEach((key) => {
        const value = attributeMap[key];
        if (value !== void 0)
          videoElement.setAttribute(key, value);
      });
      if (options.muted === true) {
        videoElement.muted = true;
      }
      crossOrigin(videoElement, url, options.crossorigin);
      const sourceElement = document.createElement("source");
      let mime;
      if (options.mime) {
        mime = options.mime;
      } else if (url.startsWith("data:")) {
        mime = url.slice(5, url.indexOf(";"));
      } else if (!url.startsWith("blob:")) {
        const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
        mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
      }
      sourceElement.src = url;
      if (mime) {
        sourceElement.type = mime;
      }
      return new Promise((resolve) => {
        const onCanPlay = async () => {
          const base = new VideoSource({...options, resource: videoElement});
          videoElement.removeEventListener("canplay", onCanPlay);
          if (asset.data.preload) {
            await preloadVideo(videoElement);
          }
          resolve(createTexture(base, loader, url));
        };
        if (options.preload && !options.autoPlay) {
          videoElement.load();
        }
        videoElement.addEventListener("canplay", onCanPlay);
        videoElement.appendChild(sourceElement);
      });
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      name: "resolveTexture"
    },
    test: loadTextures.test,
    parse: (value) => ({
      resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    })
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  var resolveJsonUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      priority: -2,
      name: "resolveJson"
    },
    test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(".json"),
    parse: resolveTextureUrl.parse
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  var AssetsClass = class {
    constructor() {
      this._detections = [];
      this._initialized = false;
      this.resolver = new Resolver();
      this.loader = new Loader();
      this.cache = Cache;
      this._backgroundLoader = new BackgroundLoader(this.loader);
      this._backgroundLoader.active = true;
      this.reset();
    }
    async init(options = {}) {
      if (this._initialized) {
        warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
        return;
      }
      this._initialized = true;
      if (options.defaultSearchParams) {
        this.resolver.setDefaultSearchParams(options.defaultSearchParams);
      }
      if (options.basePath) {
        this.resolver.basePath = options.basePath;
      }
      if (options.bundleIdentifier) {
        this.resolver.setBundleIdentifier(options.bundleIdentifier);
      }
      if (options.manifest) {
        let manifest = options.manifest;
        if (typeof manifest === "string") {
          manifest = await this.load(manifest);
        }
        this.resolver.addManifest(manifest);
      }
      const resolutionPref = options.texturePreference?.resolution ?? 1;
      const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
      const formats = await this._detectFormats({
        preferredFormats: options.texturePreference?.format,
        skipDetections: options.skipDetections,
        detections: this._detections
      });
      this.resolver.prefer({
        params: {
          format: formats,
          resolution
        }
      });
      if (options.preferences) {
        this.setPreferences(options.preferences);
      }
    }
    add(assets) {
      this.resolver.add(assets);
    }
    async load(urls, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      const singleAsset = isSingleItem(urls);
      const urlArray = convertToList(urls).map((url) => {
        if (typeof url !== "string") {
          const aliases = this.resolver.getAlias(url);
          if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
            this.add(url);
          }
          return Array.isArray(aliases) ? aliases[0] : aliases;
        }
        if (!this.resolver.hasKey(url))
          this.add({alias: url, src: url});
        return url;
      });
      const resolveResults = this.resolver.resolve(urlArray);
      const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? out2[urlArray[0]] : out2;
    }
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    async loadBundle(bundleIds, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      let singleAsset = false;
      if (typeof bundleIds === "string") {
        singleAsset = true;
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const out2 = {};
      const keys = Object.keys(resolveResults);
      let count2 = 0;
      let total = 0;
      const _onProgress = () => {
        onProgress?.(++count2 / total);
      };
      const promises = keys.map((bundleId) => {
        const resolveResult = resolveResults[bundleId];
        const values = Object.values(resolveResult);
        const totalAssetsToLoad = [...new Set(values.flat())];
        total += totalAssetsToLoad.length;
        return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
          out2[bundleId] = resolveResult2;
        });
      });
      await Promise.all(promises);
      return singleAsset ? out2[bundleIds[0]] : out2;
    }
    async backgroundLoad(urls) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof urls === "string") {
        urls = [urls];
      }
      const resolveResults = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(resolveResults));
    }
    async backgroundLoadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof bundleIds === "string") {
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      Object.values(resolveResults).forEach((resolveResult) => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = false;
    }
    get(keys) {
      if (typeof keys === "string") {
        return Cache.get(keys);
      }
      const assets = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        assets[i2] = Cache.get(keys[i2]);
      }
      return assets;
    }
    async _mapLoadToResolve(resolveResults, onProgress) {
      const resolveArray = [...new Set(Object.values(resolveResults))];
      this._backgroundLoader.active = false;
      const loadedAssets = await this.loader.load(resolveArray, onProgress);
      this._backgroundLoader.active = true;
      const out2 = {};
      resolveArray.forEach((resolveResult) => {
        const asset = loadedAssets[resolveResult.src];
        const keys = [resolveResult.src];
        if (resolveResult.alias) {
          keys.push(...resolveResult.alias);
        }
        keys.forEach((key) => {
          out2[key] = asset;
        });
        Cache.set(keys, asset);
      });
      return out2;
    }
    async unload(urls) {
      if (!this._initialized) {
        await this.init();
      }
      const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
      const resolveResults = this.resolver.resolve(urlArray);
      await this._unloadFromResolved(resolveResults);
    }
    async unloadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      bundleIds = convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(promises);
    }
    async _unloadFromResolved(resolveResult) {
      const resolveArray = Object.values(resolveResult);
      resolveArray.forEach((resolveResult2) => {
        Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveArray);
    }
    async _detectFormats(options) {
      let formats = [];
      if (options.preferredFormats) {
        formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
      }
      for (const detection of options.detections) {
        if (options.skipDetections || await detection.test()) {
          formats = await detection.add(formats);
        } else if (!options.skipDetections) {
          formats = await detection.remove(formats);
        }
      }
      formats = formats.filter((format, index) => formats.indexOf(format) === index);
      return formats;
    }
    get detections() {
      return this._detections;
    }
    setPreferences(preferences) {
      this.loader.parsers.forEach((parser) => {
        if (!parser.config)
          return;
        Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
          parser.config[key] = preferences[key];
        });
      });
    }
  };
  var Assets = new AssetsClass();
  extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
  extensions.add(cacheTextureArray, detectDefaults, detectAvif, detectWebp, detectMp4, detectOgv, detectWebm, loadJson, loadTxt, loadWebFont, loadSvg, loadTextures, loadVideoTextures, loadBitmapFont, bitmapFontCachePlugin, resolveTextureUrl, resolveJsonUrl);
  var assetKeyMap = {
    loader: ExtensionType.LoadParser,
    resolver: ExtensionType.ResolveParser,
    cache: ExtensionType.CacheParser,
    detection: ExtensionType.DetectionParser
  };
  extensions.handle(ExtensionType.Asset, (extension) => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key], {extension: ref[key].extension ?? type})));
  }, (extension) => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
  });

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs
  var fragment3 = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs
  var vertex3 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";

  // node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs
  var source2 = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";

  // node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs
  var DisplacementFilter = class extends Filter {
    constructor(...args) {
      let options = args[0];
      if (options instanceof Sprite) {
        if (args[1]) {
          deprecation(v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
        }
        options = {sprite: options, scale: args[1]};
      }
      const {sprite, scale: scaleOption, ...rest} = options;
      let scale = scaleOption ?? 20;
      if (typeof scale === "number") {
        scale = new Point(scale, scale);
      }
      const filterUniforms = new UniformGroup({
        uFilterMatrix: {value: new Matrix(), type: "mat3x3<f32>"},
        uScale: {value: scale, type: "vec2<f32>"},
        uRotation: {value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>"}
      });
      const glProgram3 = GlProgram.from({
        vertex: vertex3,
        fragment: fragment3,
        name: "displacement-filter"
      });
      const gpuProgram3 = GpuProgram.from({
        vertex: {
          source: source2,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: source2,
          entryPoint: "mainFragment"
        }
      });
      const textureSource = sprite.texture.source;
      super({
        ...rest,
        gpuProgram: gpuProgram3,
        glProgram: glProgram3,
        resources: {
          filterUniforms,
          uMapTexture: textureSource,
          uMapSampler: textureSource.style
        }
      });
      this._sprite = options.sprite;
      this._sprite.renderable = false;
    }
    apply(filterManager, input, output, clearMode) {
      const uniforms = this.resources.filterUniforms.uniforms;
      filterManager.calculateSpriteMatrix(uniforms.uFilterMatrix, this._sprite);
      const wt = this._sprite.worldTransform;
      const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      if (lenX !== 0 && lenY !== 0) {
        uniforms.uRotation[0] = wt.a / lenX;
        uniforms.uRotation[1] = wt.b / lenX;
        uniforms.uRotation[2] = wt.c / lenY;
        uniforms.uRotation[3] = wt.d / lenY;
      }
      this.resources.uMapTexture = this._sprite.texture.source;
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get scale() {
      return this.resources.filterUniforms.uniforms.uScale;
    }
  };

  // node_modules/pixi.js/lib/utils/misc/Transform.mjs
  var Transform = class {
    constructor({matrix, observer} = {}) {
      this.dirty = true;
      this._matrix = matrix ?? new Matrix();
      this.observer = observer;
      this.position = new ObservablePoint(this, 0, 0);
      this.scale = new ObservablePoint(this, 1, 1);
      this.pivot = new ObservablePoint(this, 0, 0);
      this.skew = new ObservablePoint(this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
    }
    get matrix() {
      const lt = this._matrix;
      if (!this.dirty)
        return lt;
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this.dirty = false;
      return lt;
    }
    _onUpdate(point) {
      this.dirty = true;
      if (point === this.skew) {
        this.updateSkew();
      }
      this.observer?._onUpdate(this);
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this.dirty = true;
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    setFromMatrix(matrix) {
      matrix.decompose(this);
      this.dirty = true;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this._onUpdate(this.skew);
      }
    }
  };

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
  var _TilingSprite = class _TilingSprite2 extends ViewContainer {
    constructor(...args) {
      let options = args[0] || {};
      if (options instanceof Texture) {
        options = {texture: options};
      }
      if (args.length > 1) {
        deprecation(v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
        options.width = args[1];
        options.height = args[2];
      }
      options = {..._TilingSprite2.defaultOptions, ...options};
      const {
        texture,
        anchor,
        tilePosition,
        tileScale,
        tileRotation,
        width,
        height,
        applyAnchorToTexture,
        roundPixels,
        ...rest
      } = options ?? {};
      super({
        label: "TilingSprite",
        ...rest
      });
      this.renderPipeId = "tilingSprite";
      this.batched = true;
      this.allowChildren = false;
      this._anchor = new ObservablePoint({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      });
      this.applyAnchorToTexture = applyAnchorToTexture;
      this.texture = texture;
      this._width = width ?? texture.width;
      this._height = height ?? texture.height;
      this._tileTransform = new Transform({
        observer: {
          _onUpdate: () => this.onViewUpdate()
        }
      });
      if (anchor)
        this.anchor = anchor;
      this.tilePosition = tilePosition;
      this.tileScale = tileScale;
      this.tileRotation = tileRotation;
      this.roundPixels = roundPixels ?? false;
    }
    static from(source3, options = {}) {
      if (typeof source3 === "string") {
        return new _TilingSprite2({
          texture: Cache.get(source3),
          ...options
        });
      }
      return new _TilingSprite2({
        texture: source3,
        ...options
      });
    }
    get uvRespectAnchor() {
      deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      return this.applyAnchorToTexture;
    }
    set uvRespectAnchor(value) {
      deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      this.applyAnchorToTexture = value;
    }
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    set clampMargin(value) {
      this._texture.textureMatrix.clampMargin = value;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(value) {
      this._tileTransform.position.copyFrom(value);
    }
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(value) {
      typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
    }
    set tileRotation(value) {
      this._tileTransform.rotation = value;
    }
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    get tileTransform() {
      return this._tileTransform;
    }
    set texture(value) {
      value || (value = Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture === value)
        return;
      if (currentTexture && currentTexture.dynamic)
        currentTexture.off("update", this.onViewUpdate, this);
      if (value.dynamic)
        value.on("update", this.onViewUpdate, this);
      this._texture = value;
      this.onViewUpdate();
    }
    get texture() {
      return this._texture;
    }
    set width(value) {
      this._width = value;
      this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(value) {
      this._height = value;
      this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    setSize(value, height) {
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      }
      this._width = value;
      this._height = height ?? value;
      this.onViewUpdate();
    }
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = this._width;
      out2.height = this._height;
      return out2;
    }
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const width = this._width;
      const height = this._height;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    containsPoint(point) {
      const width = this._width;
      const height = this._height;
      const x1 = -width * this._anchor._x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width) {
        y1 = -height * this._anchor._y;
        if (point.y >= y1 && point.y <= y1 + height)
          return true;
      }
      return false;
    }
    destroy(options = false) {
      super.destroy(options);
      this._anchor = null;
      this._tileTransform = null;
      this._bounds = null;
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
        this._texture.destroy(destroyTextureSource);
      }
      this._texture = null;
    }
  };
  _TilingSprite.defaultOptions = {
    texture: Texture.EMPTY,
    anchor: {x: 0, y: 0},
    tilePosition: {x: 0, y: 0},
    tileScale: {x: 1, y: 1},
    tileRotation: 0,
    applyAnchorToTexture: false
  };
  var TilingSprite = _TilingSprite;

  // node_modules/pixi.js/lib/scene/text/AbstractText.mjs
  var AbstractText = class extends ViewContainer {
    constructor(options, styleClass) {
      const {text, resolution, style, anchor, width, height, roundPixels, ...rest} = options;
      super({
        ...rest
      });
      this.batched = true;
      this._resolution = null;
      this._autoResolution = true;
      this._didTextUpdate = true;
      this._styleClass = styleClass;
      this.text = text ?? "";
      this.style = style;
      this.resolution = resolution ?? null;
      this.allowChildren = false;
      this._anchor = new ObservablePoint({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      });
      if (anchor)
        this.anchor = anchor;
      this.roundPixels = roundPixels ?? false;
      if (width !== void 0)
        this.width = width;
      if (height !== void 0)
        this.height = height;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    set text(value) {
      value = value.toString();
      if (this._text === value)
        return;
      this._text = value;
      this.onViewUpdate();
    }
    get text() {
      return this._text;
    }
    set resolution(value) {
      this._autoResolution = value === null;
      this._resolution = value;
      this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(style) {
      style || (style = {});
      this._style?.off("update", this.onViewUpdate, this);
      if (style instanceof this._styleClass) {
        this._style = style;
      } else {
        this._style = new this._styleClass(style);
      }
      this._style.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(value) {
      this._setWidth(value, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(value) {
      this._setHeight(value, this.bounds.height);
    }
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = Math.abs(this.scale.x) * this.bounds.width;
      out2.height = Math.abs(this.scale.y) * this.bounds.height;
      return out2;
    }
    setSize(value, height) {
      if (typeof value === "object") {
        height = value.height ?? value.width;
        value = value.width;
      } else {
        height ?? (height = value);
      }
      value !== void 0 && this._setWidth(value, this.bounds.width);
      height !== void 0 && this._setHeight(height, this.bounds.height);
    }
    containsPoint(point) {
      const width = this.bounds.width;
      const height = this.bounds.height;
      const x1 = -width * this.anchor.x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width) {
        y1 = -height * this.anchor.y;
        if (point.y >= y1 && point.y <= y1 + height)
          return true;
      }
      return false;
    }
    onViewUpdate() {
      if (!this.didViewUpdate)
        this._didTextUpdate = true;
      super.onViewUpdate();
    }
    destroy(options = false) {
      super.destroy(options);
      this.owner = null;
      this._bounds = null;
      this._anchor = null;
      if (typeof options === "boolean" ? options : options?.style) {
        this._style.destroy(options);
      }
      this._style = null;
      this._text = null;
    }
    get styleKey() {
      return `${this._text}:${this._style.styleKey}:${this._resolution}`;
    }
  };
  function ensureTextOptions(args, name) {
    let options = args[0] ?? {};
    if (typeof options === "string" || args[1]) {
      deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
      options = {
        text: options,
        style: args[1]
      };
    }
    return options;
  }

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs
  var BitmapText = class extends AbstractText {
    constructor(...args) {
      var _a;
      const options = ensureTextOptions(args, "BitmapText");
      options.style ?? (options.style = options.style || {});
      (_a = options.style).fill ?? (_a.fill = 16777215);
      super(options, TextStyle);
      this.renderPipeId = "bitmapText";
    }
    updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
      const scale = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale;
      let width = bitmapMeasurement.width * scale;
      let height = bitmapMeasurement.height * scale;
      const stroke = this._style._stroke;
      if (stroke) {
        width += stroke.width;
        height += stroke.width;
      }
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * (height + offset);
      bounds.maxY = bounds.minY + height;
    }
    set resolution(value) {
      if (value !== null) {
        warn("[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.");
      }
    }
    get resolution() {
      return this._resolution;
    }
  };

  // node_modules/pixi.js/lib/index.mjs
  extensions.add(browserExt, webworkerExt);

  // src/g_variable.js
  var constant = {
    device: {width: 720, height: 1280},
    fishCount: 20,
    score: 100
  };

  // src/addBackground.js
  function addBackground(app2) {
    const background = Sprite.from("background");
    background.anchor.set(0, 0);
    background.position.set(0, 0);
    background.width = constant.device.width;
    background.height = constant.device.height;
    app2.addChild(background);
  }

  // src/addWaterOverlay.js
  var overlay;
  function addWaterOverlay(app2) {
    const texture = Texture.from("overlay");
    overlay = new TilingSprite({
      texture,
      width: constant.device.width,
      height: constant.device.height
    });
    app2.addChild(overlay);
  }
  function animateWaterOverlay(app2, time) {
    const delta = time.deltaTime;
    overlay.tilePosition.x += delta;
    overlay.tilePosition.y -= delta;
  }

  // src/bullet.js
  var bullets = [];
  function createBullet(app2, startX, startY, targetX, targetY) {
    const dx2 = targetX - startX;
    const dy2 = targetY - startY;
    const length = Math.sqrt(dx2 * dx2 + dy2 * dy2);
    const bullet = Sprite.from("bullet");
    bullet.anchor.set(0.5);
    bullet.position.set(startX, startY);
    bullet.vx = dx2 / length * 15;
    bullet.vy = dy2 / length * 15;
    bullet.hit = new Set();
    bullets.push(bullet);
    app2.addChild(bullet);
    constant.score -= 1;
  }
  function moveBullet(app2) {
    bullets.forEach(function(item, index) {
      item.x += item.vx;
      item.y += item.vy;
      if (item.x > constant.device.width || item.x < 0 || item.y > constant.device.height || item.y < 0) {
        item.destroy();
        app2.removeChild(item);
        bullets.splice(index, 1);
      }
    });
  }

  // src/addFish.js
  var import_matter_js = __toModule(require_matter());

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  /*!
   * GSAP 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i2;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i2 = _harnessPlugins.length;
      while (i2-- && !_harnessPlugins[i2].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i2];
    }
    i2 = targets.length;
    while (i2--) {
      targets[i2] && (targets[i2]._gsap || (targets[i2]._gsap = new GSCache(targets[i2], harnessPlugin))) || targets.splice(i2, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v2) {
    return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l2 = toFind.length, i2 = 0;
    for (; toSearch.indexOf(toFind[i2]) < 0 && ++i2 < l2; ) {
    }
    return i2 < l2;
  };
  var _lazyRender = function _lazyRender2() {
    var l2 = _lazyTweens.length, a2 = _lazyTweens.slice(0), i2, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i2 = 0; i2 < l2; i2++) {
      tween = a2[i2];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _isRevertWorthy = function _isRevertWorthy2(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n2 = parseFloat(value);
    return (n2 || n2 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n2 : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p2) {
    return p2;
  };
  var _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p2 in defaults2) {
      p2 in obj || (obj[p2] = defaults2[p2]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p2 in defaults2) {
        p2 in obj || p2 === "duration" && excludeDuration || p2 === "ease" || (obj[p2] = defaults2[p2]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p2 in toMerge) {
      base[p2] = toMerge[p2];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p2 in toMerge) {
      p2 !== "__proto__" && p2 !== "constructor" && p2 !== "prototype" && (base[p2] = _isObject(toMerge[p2]) ? _mergeDeep2(base[p2] || (base[p2] = {}), toMerge[p2]) : toMerge[p2]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p2;
    for (p2 in obj) {
      p2 in excluding || (copy[p2] = obj[p2]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i2 = a1.length, match = i2 === a2.length;
    while (match && i2-- && a1[i2] === a2[i2]) {
    }
    return i2 < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp], t2;
    if (sortBy) {
      t2 = child[sortBy];
      while (prev && prev[sortBy] > t2) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a2 = animation;
      while (a2) {
        a2._dirty = 1;
        a2 = a2.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t2;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t2 = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t2) - child._tTime > _tinyNum) {
        child.render(t2, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t2 = timeline2;
        while (t2._dp) {
          t2.rawTime() >= 0 && t2.totalTime(t2._tTime);
          t2 = t2._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i2, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i2 = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i2 >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i2 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i2 < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i2 - 1) + position.substr(i2 + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i2 > 1 ? _parsePosition2(animation, position.substr(0, i2 - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent = timeline2;
      while (parent && !("immediateRender" in irVars)) {
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min, max, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a2) {
    return a2.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i2, target, a2) {
      var l2 = (a2 || vars).length, distances = cache[l2], originX, originY, x2, y2, d2, j2, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a2[wrapAt++].getBoundingClientRect().left) && wrapAt < l2) {
          }
          wrapAt < l2 && wrapAt--;
        }
        distances = cache[l2] = [];
        originX = ratios ? Math.min(wrapAt, l2) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l2 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j2 = 0; j2 < l2; j2++) {
          x2 = j2 % wrapAt - originX;
          y2 = originY - (j2 / wrapAt | 0);
          distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
          d2 > max && (max = d2);
          d2 < min && (min = d2);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l2 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l2 ? l2 - 1 : !axis ? Math.max(wrapAt, l2 / wrapAt) : axis === "y" ? l2 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l2 < 0 ? base - l2 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l2 < 0 ? _invertEase(ease) : ease;
      }
      l2 = (distances[i2] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l2) : l2) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p2 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n2 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p2);
      return (n2 - n2 % 1) / p2 + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray = _isArray(snapTo), radius2, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius2 = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius2 *= radius2;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius2 ? is2D : raw;
    } : function(raw) {
      var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i2 = snapTo.length, dx2, dy2;
      while (i2--) {
        if (is2D) {
          dx2 = snapTo[i2].x - x2;
          dy2 = snapTo[i2].y - y2;
          dx2 = dx2 * dx2 + dy2 * dy2;
        } else {
          dx2 = Math.abs(snapTo[i2] - x2);
        }
        if (dx2 < min) {
          min = dx2;
          closest = i2;
        }
      }
      closest = !radius2 || min <= radius2 ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f2) {
        return f2(v2);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a2, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a2[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s2 = "", i2, nums, end, isArray;
    while (~(i2 = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i2);
      isArray = value.charAt(i2 + 7) === "[";
      nums = value.substr(i2 + 7, end - i2 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s2 += value.substr(prev, i2 - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s2 + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p3) {
      return (1 - p3) * start + p3 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p2, i2, interpolators, l2, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l2 = start.length;
        il = l2 - 2;
        for (i2 = 1; i2 < l2; i2++) {
          interpolators.push(interpolate2(start[i2 - 1], start[i2]));
        }
        l2--;
        func = function func2(p3) {
          p3 *= l2;
          var i3 = Math.min(il, ~~p3);
          return interpolators[i3](p3 - i3);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p2 in end) {
          _addPropTween.call(master, start, p2, "get", end[p2]);
        }
        func = function func2(p3) {
          return _renderPropTweens(p3, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p2, distance, label2;
    for (p2 in labels) {
      distance = labels[p2] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label2 = p2;
        min = distance;
      }
    }
    return label2;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context4 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context4 && (_context = context4);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3)
      return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h2, m1, m2) {
    h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
    return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a2 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r2, g2, b2, h2, s2, l2, max, min, d2, wasHSL;
    if (!a2) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a2 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r2 = v2.charAt(1);
          g2 = v2.charAt(2);
          b2 = v2.charAt(3);
          v2 = "#" + r2 + r2 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a2 = parseInt(v2.substr(1, 6), 16);
          return [a2 >> 16, a2 >> 8 & _255, a2 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a2 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a2 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h2 = +a2[0] % 360 / 360;
          s2 = +a2[1] / 100;
          l2 = +a2[2] / 100;
          g2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
          r2 = l2 * 2 - g2;
          a2.length > 3 && (a2[3] *= 1);
          a2[0] = _hue(h2 + 1 / 3, r2, g2);
          a2[1] = _hue(h2, r2, g2);
          a2[2] = _hue(h2 - 1 / 3, r2, g2);
        } else if (~v2.indexOf("=")) {
          a2 = v2.match(_numExp);
          forceAlpha && a2.length < 4 && (a2[3] = 1);
          return a2;
        }
      } else {
        a2 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a2 = a2.map(Number);
    }
    if (toHSL && !wasHSL) {
      r2 = a2[0] / _255;
      g2 = a2[1] / _255;
      b2 = a2[2] / _255;
      max = Math.max(r2, g2, b2);
      min = Math.min(r2, g2, b2);
      l2 = (max + min) / 2;
      if (max === min) {
        h2 = s2 = 0;
      } else {
        d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        h2 = max === r2 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max === g2 ? (b2 - r2) / d2 + 2 : (r2 - g2) / d2 + 4;
        h2 *= 60;
      }
      a2[0] = ~~(h2 + 0.5);
      a2[1] = ~~(s2 * 100 + 0.5);
      a2[2] = ~~(l2 * 100 + 0.5);
    }
    forceAlpha && a2.length < 4 && (a2[3] = 1);
    return a2;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c2 = [], i2 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a2 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a2);
      c2.push(i2 += a2.length + 1);
    });
    values.c = c2;
    return values;
  };
  var _formatColors = function _formatColors2(s2, toHSL, orderMatchData) {
    var result = "", colors = (s2 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i2 = 0, c2, shell, d2, l2;
    if (!colors) {
      return s2;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d2 = _colorOrderData(s2);
      c2 = orderMatchData.c;
      if (c2.join(result) !== d2.c.join(result)) {
        shell = s2.replace(_colorExp, "1").split(_numWithUnitExp);
        l2 = shell.length - 1;
        for (; i2 < l2; i2++) {
          result += shell[i2] + (~c2.indexOf(i2) ? colors.shift() || type + "0,0,0,0)" : (d2.length ? d2 : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s2.split(_colorExp);
      l2 = shell.length - 1;
      for (; i2 < l2; i2++) {
        result += shell[i2] + colors[i2];
      }
    }
    return result + shell[l2];
  };
  var _colorExp = function() {
    var s2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p2;
    for (p2 in _colorLookup) {
      s2 += "|" + p2 + "\\b";
    }
    return new RegExp(s2 + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a2) {
    var combined = a2.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a2[1] = _formatColors(a2[1], toHSL);
      a2[0] = _formatColors(a2[0], toHSL, _colorOrderData(a2[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f2) {
            return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t2, d2, f2, v2) {
          callback(t2, d2, f2, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i2) {
        ~(i2 = _listeners2.indexOf(callback)) && _listeners2.splice(i2, 1) && _i >= i2 && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i2 = 1, l2 = split.length, index, val, parsedVal;
    for (; i2 < l2; i2++) {
      val = split[i2];
      index = i2 !== l2 - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p2) {
      return 1 - ease(1 - p2);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p2) {
        return 1 - easeIn(1 - p2);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p2) {
        return p2 < 0.5 ? easeIn(p2 * 2) / 2 : 1 - easeIn((1 - p2) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p2 in ease) {
        _easeMap[lowercaseName + (p2 === "easeIn" ? ".in" : p2 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p2] = ease[p2];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p2) {
      return p2 < 0.5 ? (1 - easeOut(1 - p2 * 2)) / 2 : 0.5 + easeOut((p2 - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
      return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
      return 1 - easeOut(1 - p4);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p2) {
      return p2 ? --p2 * p2 * ((overshoot + 1) * p2 + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p2) {
      return 1 - easeOut(1 - p2);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i2) {
    var power = i2 < 5 ? i2 + 1 : i2;
    _insertEase(name + ",Power" + (power - 1), i2 ? function(p2) {
      return Math.pow(p2, power);
    } : function(p2) {
      return p2;
    }, function(p2) {
      return 1 - Math.pow(1 - p2, power);
    }, function(p2) {
      return p2 < 0.5 ? Math.pow(p2 * 2, power) / 2 : 1 - Math.pow((1 - p2) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n2, c2) {
    var n1 = 1 / c2, n22 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p2) {
      return p2 < n1 ? n2 * p2 * p2 : p2 < n22 ? n2 * Math.pow(p2 - 1.5 / c2, 2) + 0.75 : p2 < n3 ? n2 * (p2 -= 2.25 / c2) * p2 + 0.9375 : n2 * Math.pow(p2 - 2.625 / c2, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p2) {
      return 1 - easeOut(1 - p2);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p2) {
    return Math.pow(2, 10 * (p2 - 1)) * p2 + p2 * p2 * p2 * p2 * p2 * p2 * (1 - p2);
  });
  _insertEase("Circ", function(p2) {
    return -(_sqrt(1 - p2 * p2) - 1);
  });
  _insertEase("Sine", function(p2) {
    return p2 === 1 ? 1 : -_cos(p2 * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p4) {
        return ((p2 * _clamp(0, max, p4) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this);
        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp;
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum);
      return this;
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f2) && (f2 = f2(self2)) && (f2.then || f2 === self2) && (self2.then = _then);
          resolve(f2);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a2 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a2.push(child);
          } else {
            timelines && a2.push(child);
            nested && a2.push.apply(a2, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i2 = animations.length;
      while (i2--) {
        if (animations[i2].vars.id === id) {
          return animations[i2];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      child.parent === this && _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label2, position) {
      this.labels[label2] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label2) {
      delete this.labels[label2];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t2 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t2.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t2, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i2 = tweens.length;
      while (i2--) {
        _overwritingTween !== tweens[i2] && tweens[i2].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a2 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a2.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a2.push.apply(a2, children);
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p2;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p2 in labels) {
          if (labels[p2] >= ignoreBeforeTime) {
            labels[p2] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a2;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a2 = [start, end];
      stringFilter(a2, target, prop);
      start = a2[0];
      end = a2[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p2;
    for (p2 in vars) {
      copy[p2] = _parseFuncOrString(vars[p2], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i2;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i2 = plugin._props.length;
        while (i2--) {
          ptLookup[plugin._props[i2]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i2, p2, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p2 = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            stagger: 0,
            parent
          }, cleanVars);
          harnessVars && (p2[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p2));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i2 = 0; i2 < targets.length; i2++) {
        target = targets[i2];
        gsData = target._gsap || _harness(targets)[i2]._gsap;
        tween._ptLookup[i2] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i2 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p2 in cleanVars) {
            if (_plugins[p2] && (plugin = _checkPlugin(p2, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p2] = pt = _addPropTween.call(tween, target, p2, "get", cleanVars[p2], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i2] && tween.kill(target, tween._op[i2]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i2;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i2 = tween._targets.length;
      while (i2--) {
        pt = lookup[i2][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i2 = ptCache.length;
    while (i2--) {
      rootPT = ptCache[i2];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p2, i2, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p2 in propertyAliases) {
      if (p2 in copy) {
        aliases = propertyAliases[p2].split(",");
        i2 = aliases.length;
        while (i2--) {
          copy[aliases[i2]] = copy[p2];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p2, a2;
    if (_isArray(obj)) {
      a2 = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i2) {
        return a2.push({
          t: i2 / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p2 in obj) {
        a2 = allProps[p2] || (allProps[p2] = []);
        p2 === "ease" || a2.push({
          t: parseFloat(prop),
          v: obj[p2],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i2, target, targets) {
    return _isFunction(value) ? value.call(tween, i2, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i2, copy, l2, p2, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l2 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p2 in stagger) {
              if (~_staggerTweenProps.indexOf(p2)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p2] = stagger[p2];
              }
            }
          }
          for (i2 = 0; i2 < l2; i2++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i2];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i2, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i2, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l2 === 1 && copy.delay) {
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i2, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a2, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p2 in keyframes) {
              p2 === "ease" || p2 === "easeEach" || _parseKeyframe(p2, keyframes[p2], copy, keyframes.easeEach);
            }
            for (p2 in copy) {
              a2 = copy[p2].sort(function(a3, b2) {
                return a3.t - b2.t;
              });
              time = 0;
              for (i2 = 0; i2 < a2.length; i2++) {
                kf = a2[i2];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i2 ? a2[i2 - 1].t : 0)) / 100 * duration
                };
                v2[p2] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
        return this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p2, pt, i2;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p2 = {};
          _forEachName(vars, function(name) {
            return p2[name] = 1;
          });
          vars = p2;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i2 = parsedTargets.length;
      while (i2--) {
        if (~killingTargets.indexOf(parsedTargets[i2])) {
          curLookup = propTweenLookup[i2];
          if (vars === "all") {
            overwrittenProps[i2] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i2] = overwrittenProps[i2] || {};
            props = vars;
          }
          for (p2 in props) {
            pt = curLookup && curLookup[p2];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p2) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p2];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p2] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s2 = "";
    if (!ratio && data.b) {
      s2 = data.b;
    } else if (ratio === 1 && data.e) {
      s2 = data.e;
    } else {
      while (pt) {
        s2 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s2;
        pt = pt._next;
      }
      s2 += data.c;
    }
    data.set(data.t, data.p, s2, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
    var pt = parent._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f2) {
      return f2();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c2) {
        var queries = c2.queries, conditions = c2.conditions, match, p2, anyMatch, toggled;
        for (p2 in queries) {
          match = _win.matchMedia(queries[p2]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p2]) {
            conditions[p2] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c2.revert();
          anyMatch && matches.push(c2);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c2) {
        return c2.onMatch(c2, function(func) {
          return c2.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f2 = function f3() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f2;
      return name === _isFunction ? f2(self2, function(func2) {
        return self2.add(null, func2);
      }) : name ? self2[name] = f2 : f2;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a2 = [];
      this.data.forEach(function(e2) {
        return e2 instanceof Context2 ? a2.push.apply(a2, e2.getTweens()) : e2 instanceof Tween && !(e2.parent && e2.parent.data === "nested") && a2.push(e2);
      });
      return a2;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i3 = _this4.data.length, t2;
          while (i3--) {
            t2 = _this4.data[i3];
            if (t2.data === "isFlip") {
              t2.revert();
              t2.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t3) {
            return {
              g: t3._dur || t3._delay || t3._sat && !t3._sat.vars.immediateRender ? t3.globalTime(0) : -Infinity,
              t: t3
            };
          }).sort(function(a2, b2) {
            return b2.g - a2.g || -Infinity;
          }).forEach(function(o2) {
            return o2.t.revert(revert);
          });
          i3 = _this4.data.length;
          while (i3--) {
            t2 = _this4.data[i3];
            if (t2 instanceof Timeline) {
              if (t2.data !== "nested") {
                t2.scrollTrigger && t2.scrollTrigger.revert();
                t2.kill();
              }
            } else {
              !(t2 instanceof Tween) && t2.revert && t2.revert(revert);
            }
          }
          _this4._r.forEach(function(f2) {
            return f2(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e2) {
          return e2.kill && e2.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i2 = _media.length;
        while (i2--) {
          _media[i2].id === this.id && _media.splice(i2, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context4 = new Context(0, scope || this.scope), cond = context4.conditions = {}, mq, p2, active;
      _context && !context4.selector && (context4.selector = _context.selector);
      this.contexts.push(context4);
      func = context4.add("onMatch", func);
      context4.queries = conditions;
      for (p2 in conditions) {
        if (p2 === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p2]);
          if (mq) {
            _media.indexOf(context4) < 0 && _media.push(context4);
            (cond[p2] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context4, function(f2) {
        return context4.add(null, f2);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c2) {
        return c2.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t2) {
          return gsap.quickSetter(t2, property, unit);
        }), l2 = setters.length;
        return function(value) {
          var i2 = l2;
          while (i2--) {
            setters[i2](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p2 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p3 = new Plugin();
        _quickTween._pt = 0;
        p3.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p3.render(1, p3);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p2);
      return Plugin ? setter : function(value) {
        return setter(target, p2, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults22;
      var tween = gsap.to(target, _setDefaults((_setDefaults22 = {}, _setDefaults22[property] = "+=0.1", _setDefaults22.paused = true, _setDefaults22.stagger = 0, _setDefaults22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context2(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c2) {
        var cond = c2.conditions, found, p2;
        for (p2 in cond) {
          if (cond[p2]) {
            cond[p2] = false;
            found = 1;
          }
        }
        found && c2.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a2 = _listeners[type] || (_listeners[type] = []);
      ~a2.indexOf(callback) || a2.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a2 = _listeners[type], i2 = a2 && a2.indexOf(callback);
      i2 >= 0 && a2.splice(i2, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context3(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p2, i2, pt;
    for (p2 in modifiers) {
      i2 = targets.length;
      while (i2--) {
        pt = tween._ptLookup[i2][p2];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p2);
          }
          pt && pt.modifier && pt.modifier(modifiers[p2], tween, targets[i2], p2);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      headless: 1,
      rawVars: 1,
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p2;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p2 in vars) {
              temp[p2] = modifier(vars[p2]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init2(target, vars, tween, index, targets) {
      var p2, pt, v2;
      this.tween = tween;
      for (p2 in vars) {
        v2 = target.getAttribute(p2) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p2], index, targets, 0, 0, p2);
        pt.op = p2;
        pt.b = v2;
        this._props.push(p2);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init3(target, value) {
      var i2 = value.length;
      while (i2--) {
        this.add(target, i2, target[i2] || 0, value[i2], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.13.0";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  /*!
   * CSSPlugin 3.13.0
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a2) {
          return _this.tfm[a2] = _get(target, a2);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p2) {
          return _saveStyle2.call(_this, p2, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i2, p2;
    for (i2 = 0; i2 < props.length; i2 += 3) {
      if (!props[i2 + 1]) {
        props[i2 + 2] ? style[props[i2]] = props[i2 + 2] : style.removeProperty(props[i2].substr(0, 2) === "--" ? props[i2] : props[i2].replace(_capsExp, "-$1").toLowerCase());
      } else if (props[i2 + 1] === 2) {
        target[props[i2]](props[i2 + 2]);
      } else {
        target[props[i2]] = props[i2 + 2];
      }
    }
    if (this.tfm) {
      for (p2 in this.tfm) {
        cache[p2] = this.tfm[p2];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i2 = _reverting2();
      if ((!i2 || !i2.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && target.style && target.nodeType && properties.split(",").forEach(function(p2) {
      return saver.save(p2);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e2 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e2 && e2.style ? e2 : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e2 = element || _tempDiv, s2 = e2.style, i2 = 5;
    if (property in s2 && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i2-- && !(_prefixes[i2] + property in s2)) {
    }
    return i2 < 0 ? null : (i2 === 3 ? "ms" : i2 >= 0 ? _prefixes[i2] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getReparentedCloneBBox = function _getReparentedCloneBBox2(target) {
    var owner = target.ownerSVGElement, svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), clone = target.cloneNode(true), bbox;
    clone.style.display = "block";
    svg.appendChild(clone);
    _docElement.appendChild(svg);
    try {
      bbox = clone.getBBox();
    } catch (e2) {
    }
    svg.removeChild(clone);
    _docElement.removeChild(svg);
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i2 = attributesArray.length;
    while (i2--) {
      if (target.hasAttribute(attributesArray[i2])) {
        return target.getAttribute(attributesArray[i2]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds, cloned;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }
    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e2) {
    return !!(e2.getCTM && (!e2.parentNode || e2.ownerSVGElement) && _getBBox(e2));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc2 || !parent.appendChild) {
      parent = _doc2.body;
    }
    cache = parent._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v2 = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property] = v2 : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p2 = _checkPropPrefix(prop, target, 1), s2 = p2 && _getComputedProperty(target, p2, 1);
      if (s2 && s2 !== start) {
        prop = p2;
        start = s2;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a2, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a2 = [start, end];
    _colorStringFilter(a2);
    start = a2[0];
    end = a2[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
    if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
      value = x2;
      x2 = y2;
      y2 = value;
    }
    split[0] = _keywordToPercent[x2] || x2;
    split[1] = _keywordToPercent[y2] || y2;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i2;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i2 = props.length;
        while (--i2 > -1) {
          prop = props[i2];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a2 = matrix[0], b2 = matrix[1], c2 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a2 * d2 - b2 * c2)) {
      x2 = xOrigin * (d2 / determinant) + yOrigin * (-c2 / determinant) + (c2 * ty - d2 * tx) / determinant;
      y2 = xOrigin * (-b2 / determinant) + yOrigin * (a2 / determinant) - (a2 * ty - b2 * tx) / determinant;
      xOrigin = x2;
      yOrigin = y2;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a2 + ty * c2) - tx;
      cache.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a2, b2, c2, d2, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x2 = y2 = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a2 = matrix[0];
      b2 = matrix[1];
      c2 = matrix[2];
      d2 = matrix[3];
      x2 = a12 = matrix[4];
      y2 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a2 * a2 + b2 * b2);
        scaleY = Math.sqrt(d2 * d2 + c2 * c2);
        rotation = a2 || b2 ? _atan2(b2, a2) * _RAD2DEG : 0;
        skewX = c2 || d2 ? _atan2(c2, d2) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x2 -= xOrigin - (xOrigin * a2 + yOrigin * c2);
          y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x2 = matrix[12];
        y2 = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c2, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a2 * cos - a13 * sin;
          t2 = b2 * cos - a23 * sin;
          t3 = c2 * cos - a33 * sin;
          a43 = d2 * sin + a43 * cos;
          a2 = t1;
          b2 = t2;
          c2 = t3;
        }
        angle = _atan2(b2, a2);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a2 * cos + b2 * sin;
          t2 = a12 * cos + a22 * sin;
          b2 = b2 * cos - a2 * sin;
          a22 = a22 * cos - a12 * sin;
          a2 = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x2 - ((cache.xPercent = x2 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y2 - ((cache.yPercent = y2 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
      y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x2, "px");
      ty = _convertToUnit(target, "y", y2, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source3) {
    for (var p2 in source3) {
      target[p2] = source3[p2];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p2, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p2 in _transformProps) {
      startValue = startCache[p2];
      endValue = endCache[p2];
      if (startValue !== endValue && exclude.indexOf(p2) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p2, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p2, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p2);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t2 = "Top", r2 = "Right", b2 = "Bottom", l2 = "Left", props = (index < 3 ? [t2, r2, b2, l2] : [t2 + l2, t2 + r2, b2 + r2, b2 + l2]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a2, vars;
      if (arguments.length < 4) {
        a2 = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a2.join(" ");
        return vars.split(a2[0]).length === 5 ? a2[0] : vars;
      }
      a2 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i2) {
        return vars[prop] = a2[i2] = a2[i2] || a2[(i2 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init4(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p2, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p2 in vars) {
        if (p2 === "autoRound") {
          continue;
        }
        endValue = vars[p2];
        if (_plugins[p2] && _checkPlugin(p2, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p2];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p2, endValue, tween) && (hasPriority = 1);
        } else if (p2.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p2) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p2, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p2);
          props.push(p2);
          inlineProps.push(p2, 0, style[p2]);
        } else if (type !== "undefined") {
          if (startAt && p2 in startAt) {
            startValue = typeof startAt[p2] === "function" ? startAt[p2].call(tween, index, target, targets) : startAt[p2];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p2] || getUnit(_get(target, p2)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p2));
          } else {
            startValue = _get(target, p2);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p2 in _propertyAliases) {
            if (p2 === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p2 !== "scale" && p2 !== "transform") {
              p2 = _propertyAliases[p2];
              ~p2.indexOf(",") && (p2 = p2.split(",")[0]);
            }
          }
          isTransformRelated = p2 in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p2);
            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
              endNum = parseFloat(endValue);
            }
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p2 === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p2);
              p2 += "X";
            } else if (p2 === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p2, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p2 === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p2 in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p2, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p2 === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p2 === "force3D") {
              cache[p2] = endValue;
              continue;
            } else if (p2 === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p2 in style)) {
            p2 = _checkPropPrefix(p2) || p2;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p2 in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p2 in _config.units ? _config.units[p2] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p2, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p2, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p2 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p2 in style)) {
            if (p2 in target) {
              this.add(target, p2, startValue || target[p2], relative ? relative + endValue : endValue, index, targets);
            } else if (p2 !== "parseTransform") {
              _missingPlugin(p2, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p2, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p2 in style ? inlineProps.push(p2, 0, style[p2]) : typeof target[p2] === "function" ? inlineProps.push(p2, 2, target[p2]()) : inlineProps.push(p2, 1, startValue || target[p2]));
          props.push(p2);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p2 = _propertyAliases[property];
      p2 && p2.indexOf(",") < 0 && (property = p2);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // src/addFish.js
  var {Engine, Render, Runner, Bodies, World, Events} = import_matter_js.default;
  var engine = Engine.create();
  var world = engine.world;
  var fish = null;
  var random_posX = null;
  var random_posY = null;
  var random_angle = null;
  var radius = null;
  var dx = null;
  var dy = null;
  var speed = null;
  var border_delay = 100;
  var fishes = [];
  function addFish(app2, state) {
    const fishArray = ["fish1", "fish2", "fish3", "fish4", "fish5"];
    let random_fish = Math.floor(Math.random() * fishArray.length);
    if (state == "init") {
      random_posX = Math.floor(Math.random() * (constant.device.width + 1));
      random_posY = Math.floor(Math.random() * (constant.device.height + 1));
    } else if (state == "new") {
      random_posX = Math.floor(Math.random() * 101) - 200;
      random_posY = Math.floor(Math.random() * 101) - 200;
    }
    random_angle = Math.floor(Math.random() * 361);
    radius = random_angle * Math.PI / 180;
    dx = Math.cos(radius);
    dy = Math.sin(radius);
    speed = Math.floor(Math.random() * 5) + 1;
    fish = Sprite.from(fishArray[random_fish]);
    fish.anchor.set(0.5, 0.5);
    fish.position.set(random_posX, random_posY);
    fish.angle = random_angle;
    fish.dx = dx;
    fish.dy = dy;
    fish.speed = speed;
    fish.hp = 10;
    app2.addChild(fish);
    fishes.push(fish);
    const sprite = Sprite.from("displacement");
    sprite.texture.source.addressMode = "repeat";
    const filter = new DisplacementFilter({
      sprite,
      scale: 50
    });
    fish.filters = [filter];
  }
  function runFish(app2) {
    fishes.forEach(function(item, index) {
      item.x -= item.dx * item.speed;
      item.y -= item.dy * item.speed;
      if (item.x > constant.device.width + border_delay) {
        item.x = 0 - border_delay;
      }
      if (item.x < 0 - border_delay) {
        item.x = constant.device.width + border_delay;
      }
      if (item.y > constant.device.height + border_delay) {
        item.y = 0 - border_delay;
      }
      if (item.y < 0 - border_delay) {
        item.y = constant.device.height + border_delay;
      }
    });
    bullets.forEach((bullet, bi) => {
      const bBounds = bullet.getBounds();
      fishes.forEach((fish2, fi) => {
        const fBounds = fish2.getBounds();
        if (bBounds.x < fBounds.x + fBounds.width && bBounds.x + bBounds.width > fBounds.x && bBounds.y < fBounds.y + fBounds.height && bBounds.y + bBounds.height > fBounds.y) {
          if (bullet.hit.has(fi))
            return;
          bullet.hit.add(fi);
          fish2.hp--;
          hitEffect(fish2);
          if (fish2.hp == 0) {
            gsapWithCSS.to(fish2, {
              alpha: 0,
              duration: 2,
              ease: "power2.out",
              onComplete: () => fishDestroy(fish2, app2)
            });
            fishes.splice(fi, 1);
            constant.score += 10;
          }
        }
      });
    });
  }
  function hitEffect(fish2) {
    fish2.tint = 16711680;
    setTimeout(function() {
      fish2.tint = 16777215;
    }, 100);
  }
  function fishDestroy(fish2, app2) {
    fish2.destroy();
    app2.removeChild(fish2);
  }
  function createNewFish(app2) {
    if (fishes.length < constant.fishCount) {
      addFish(app2, "new");
    }
  }

  // src/number.js
  var label = null;
  function initNumber(app2, string, font, fontsize, posX, posY) {
    label = new BitmapText({
      text: string.toString(),
      style: {
        fontFamily: font.toString(),
        fontSize: fontsize,
        fill: "#ffffff"
      }
    });
    label.x = posX;
    label.y = posY;
    label.anchor.set(0.5, 0.5);
    app2.addChild(label);
    label.setNumber = function(num) {
      label.text = num.toString();
    };
    return label;
  }

  // src/main.js
  var import_matter_js2 = __toModule(require_matter());
  var app = new Application();
  var bg_Layer = new Container();
  app.stage.addChild(bg_Layer);
  var fish_Layer = new Container();
  app.stage.addChild(fish_Layer);
  var bullet_Layer = new Container();
  app.stage.addChild(bullet_Layer);
  var bg_Effect_Layer = new Container();
  app.stage.addChild(bg_Effect_Layer);
  var label_Layer = new Container();
  app.stage.addChild(label_Layer);
  var score = null;
  (async () => {
    await setup();
    await preload();
    addBackground(bg_Layer);
    addWaterOverlay(bg_Effect_Layer);
    for (let i2 = 0; i2 < constant.fishCount; i2++) {
      addFish(fish_Layer, "init");
    }
    score = initNumber(label_Layer, "1230", "dummy_font2", 80, constant.device.width / 2, 50);
    score.setNumber(constant.score);
    app.ticker.add((time) => {
      animateWaterOverlay(app, time);
      runFish(fish_Layer);
      moveBullet(bullet_Layer);
      createNewFish(fish_Layer);
      score.setNumber(constant.score);
    });
  })();
  async function setup() {
    await app.init({background: "#1099bb"});
    app.stage.interactive = true;
    document.body.appendChild(app.canvas);
    app.canvas.style.margin = "auto";
    app.canvas.style.position = "absolute";
    app.canvas.style.top = "0";
    app.canvas.style.bottom = "0";
    app.canvas.style.left = "0";
    app.canvas.style.right = "0";
    app.canvas.width = constant.device.width;
    app.canvas.height = constant.device.height;
    app.canvas.resolution = window.devicePixelRatio || 1;
    app.renderer.resize(constant.device.width, constant.device.height);
    resize();
    window.addEventListener("resize", function() {
      resize();
    });
    app.stage.on("pointerup", (event) => {
      const pos = event.data.global;
      createBullet(bullet_Layer, constant.device.width / 2, constant.device.height, pos.x, pos.y);
    });
  }
  function resize() {
    const canvas = app.canvas;
    const parent = canvas.parentNode;
    const parentWidth = parent.clientWidth;
    const parentHeight = parent.clientHeight;
    const scale = Math.min(parentWidth / constant.device.width, parentHeight / constant.device.height);
    canvas.style.width = `${constant.device.width * scale}px`;
    canvas.style.height = `${constant.device.height * scale}px`;
    canvas.style.display = "block";
    canvas.style.margin = "auto";
  }
  async function preload() {
    const assets = [
      {alias: "background", src: "https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg"},
      {alias: "fish1", src: "https://pixijs.com/assets/tutorials/fish-pond/fish1.png"},
      {alias: "fish2", src: "https://pixijs.com/assets/tutorials/fish-pond/fish2.png"},
      {alias: "fish3", src: "https://pixijs.com/assets/tutorials/fish-pond/fish3.png"},
      {alias: "fish4", src: "https://pixijs.com/assets/tutorials/fish-pond/fish4.png"},
      {alias: "fish5", src: "https://pixijs.com/assets/tutorials/fish-pond/fish5.png"},
      {alias: "overlay", src: "https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png"},
      {alias: "displacement", src: "https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png"},
      {alias: "bunny", src: "assets/bunny.png"},
      {alias: "bullet", src: "assets/bullet.png"},
      {alias: "dummy_font2", src: "assets/dummy_font2.fnt"}
    ];
    await Assets.load(assets);
  }
})();
//# sourceMappingURL=bundle.min.js.map
