{
  "version": 3,
  "sources": ["../node_modules/eventemitter3/index.js", "../node_modules/parse-svg-path/index.js", "../node_modules/pixi.js/lib/environment-browser/browserAll.mjs", "../node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs", "../node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts", "../node_modules/matter-js/build/matter.js", "../node_modules/pixi.js/src/extensions/Extensions.ts", "../node_modules/eventemitter3/index.mjs", "../node_modules/@pixi/colord/index.mjs", "../node_modules/@pixi/colord/plugins/names.mjs", "../node_modules/pixi.js/src/color/Color.ts", "../node_modules/pixi.js/src/culling/cullingMixin.ts", "../node_modules/pixi.js/src/maths/misc/const.ts", "../node_modules/pixi.js/src/maths/point/Point.ts", "../node_modules/pixi.js/src/maths/matrix/Matrix.ts", "../node_modules/pixi.js/src/maths/point/ObservablePoint.ts", "../node_modules/pixi.js/src/utils/data/uid.ts", "../node_modules/pixi.js/src/utils/logging/deprecation.ts", "../node_modules/pixi.js/src/utils/logging/warn.ts", "../node_modules/pixi.js/src/utils/pool/GlobalResourceRegistry.ts", "../node_modules/pixi.js/src/utils/pool/Pool.ts", "../node_modules/pixi.js/src/utils/pool/PoolGroup.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/cacheAsTextureMixin.ts", "../node_modules/pixi.js/src/utils/data/removeItems.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/collectRenderablesMixin.ts", "../node_modules/pixi.js/src/filters/FilterEffect.ts", "../node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts", "../node_modules/pixi.js/src/maths/shapes/Rectangle.ts", "../node_modules/pixi.js/src/scene/container/bounds/Bounds.ts", "../node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/getFastGlobalBoundsMixin.ts", "../node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts", "../node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts", "../node_modules/pixi.js/src/scene/container/utils/multiplyColors.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/getGlobalMixin.ts", "../node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts", "../node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts", "../node_modules/pixi.js/src/maths/misc/pow2.ts", "../node_modules/pixi.js/src/scene/container/utils/definedProps.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts", "../node_modules/pixi.js/src/maths/matrix/groupD8.ts", "../node_modules/pixi.js/src/utils/misc/NOOP.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts", "../node_modules/pixi.js/src/scene/container/RenderGroup.ts", "../node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts", "../node_modules/pixi.js/src/scene/container/Container.ts", "../node_modules/pixi.js/src/ticker/const.ts", "../node_modules/pixi.js/src/ticker/TickerListener.ts", "../node_modules/pixi.js/src/ticker/Ticker.ts", "../node_modules/pixi.js/src/dom/CanvasObserver.ts", "../node_modules/pixi.js/src/events/FederatedEvent.ts", "../node_modules/ismobilejs/src/isMobile.ts", "../node_modules/pixi.js/src/utils/browser/isMobile.ts", "../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts", "../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts", "../node_modules/pixi.js/src/accessibility/init.ts", "../node_modules/pixi.js/src/app/ResizePlugin.ts", "../node_modules/pixi.js/src/app/TickerPlugin.ts", "../node_modules/pixi.js/src/app/init.ts", "../node_modules/pixi.js/src/events/EventTicker.ts", "../node_modules/pixi.js/src/events/FederatedMouseEvent.ts", "../node_modules/pixi.js/src/events/FederatedPointerEvent.ts", "../node_modules/pixi.js/src/events/FederatedWheelEvent.ts", "../node_modules/pixi.js/src/events/EventBoundary.ts", "../node_modules/pixi.js/src/events/EventSystem.ts", "../node_modules/pixi.js/src/events/FederatedEventTarget.ts", "../node_modules/pixi.js/src/events/init.ts", "../node_modules/pixi.js/src/dom/DOMPipe.ts", "../node_modules/pixi.js/src/scene/view/ViewContainer.ts", "../node_modules/pixi.js/src/dom/init.ts", "../node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts", "../node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts", "../node_modules/pixi.js/src/environment/adapter.ts", "../node_modules/pixi.js/src/utils/path.ts", "../node_modules/pixi.js/src/assets/utils/convertToList.ts", "../node_modules/pixi.js/src/assets/utils/createStringVariations.ts", "../node_modules/pixi.js/src/assets/utils/isSingleItem.ts", "../node_modules/pixi.js/src/assets/resolver/Resolver.ts", "../node_modules/pixi.js/src/assets/utils/copySearchParams.ts", "../node_modules/pixi.js/src/spritesheet/Spritesheet.ts", "../node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts", "../node_modules/pixi.js/src/spritesheet/init.ts", "../node_modules/pixi.js/src/utils/data/updateQuadBounds.ts", "../node_modules/pixi.js/src/scene/sprite/Sprite.ts", "../node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts", "../node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts", "../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts", "../node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts", "../node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts", "../node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts", "../node_modules/pixi.js/src/assets/cache/Cache.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts", "../node_modules/pixi.js/src/rendering/init.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts", "../node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts", "../node_modules/pixi.js/src/utils/data/ViewableBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts", "../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts", "../node_modules/pixi.js/src/rendering/renderers/types.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts", "../node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/const.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts", "../node_modules/earcut/src/earcut.js", "../node_modules/pixi.js/src/utils/utils.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/generateTextureFillMatrix.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts", "../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts", "../node_modules/pixi.js/src/scene/graphics/init.ts", "../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts", "../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts", "../node_modules/pixi.js/src/scene/mesh/init.ts", "../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs", "../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/init.ts", "../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts", "../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts", "../node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts", "../node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGPath.ts", "../node_modules/pixi.js/src/maths/shapes/Circle.ts", "../node_modules/pixi.js/src/maths/shapes/Ellipse.ts", "../node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts", "../node_modules/pixi.js/src/maths/shapes/Polygon.ts", "../node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGFloatAttribute.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGDefinitions.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/extractSvgUrlId.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGStyle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/fillOperations.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/pathOperations.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts", "../node_modules/pixi.js/src/scene/text/TextStyle.ts", "../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts", "../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts", "../node_modules/tiny-lru/dist/tiny-lru.js", "../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts", "../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextGenerator.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts", "../node_modules/pixi.js/src/scene/text/init.ts", "../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts", "../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts", "../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts", "../node_modules/pixi.js/src/scene/text-bitmap/init.ts", "../node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts", "../node_modules/pixi.js/src/utils/browser/isSafari.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts", "../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts", "../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts", "../node_modules/pixi.js/src/scene/text-html/init.ts", "../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/init.ts", "../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts", "../node_modules/pixi.js/src/filters/FilterPipe.ts", "../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts", "../node_modules/pixi.js/src/filters/FilterSystem.ts", "../node_modules/pixi.js/src/filters/init.ts", "../node_modules/pixi.js/src/environment-browser/browserExt.ts", "../node_modules/pixi.js/src/environment-webworker/webworkerExt.ts", "../node_modules/pixi.js/src/filters/Filter.ts", "../node_modules/pixi.js/src/environment/autoDetectEnvironment.ts", "../node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts", "../node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts", "../node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts", "../node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts", "../node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts", "../node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts", "../node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts", "../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts", "../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts", "../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts", "../node_modules/pixi.js/src/scene/container/utils/clearList.ts", "../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts", "../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts", "../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts", "../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts", "../node_modules/pixi.js/src/utils/const.ts", "../node_modules/pixi.js/src/utils/global/globalHooks.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts", "../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs", "../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs", "../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs", "../node_modules/pixi.js/src/filters/mask/MaskFilter.ts", "../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts", "../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts", "../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts", "../node_modules/pixi.js/src/utils/sayHello.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts", "../node_modules/pixi.js/src/utils/data/clean.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts", "../node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts", "../node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlLimitsSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboSyncSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlRenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgramData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/compileShader.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/defaultValue.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/mapType.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUboData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUniformData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/logProgramError.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/pixiToGlMaps.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts", "../node_modules/pixi.js/src/app/Application.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts", "../node_modules/pixi.js/src/assets/BackgroundLoader.ts", "../node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts", "../node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts", "../node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts", "../node_modules/pixi.js/src/assets/loader/Loader.ts", "../node_modules/pixi.js/src/assets/utils/checkDataUrl.ts", "../node_modules/pixi.js/src/assets/utils/checkExtension.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts", "../node_modules/pixi.js/src/utils/network/getResolutionOfUrl.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts", "../node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs", "../node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs", "../node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts", "../node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts", "../node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts", "../node_modules/pixi.js/src/assets/Assets.ts", "../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs", "../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs", "../node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs", "../node_modules/pixi.js/src/filters/defaults/displacement/DisplacementFilter.ts", "../node_modules/pixi.js/src/utils/misc/Transform.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/TilingSprite.ts", "../node_modules/pixi.js/src/scene/text/AbstractText.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapText.ts", "../node_modules/pixi.js/src/index.ts", "../src/g_variable.js", "../src/addBackground.js", "../src/addWaterOverlay.js", "../src/bullet.js", "../src/number.js", "../src/addFish.js", "../node_modules/gsap/gsap-core.js", "../node_modules/gsap/CSSPlugin.js", "../node_modules/gsap/index.js", "../src/main.js"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "import '../accessibility/init.mjs';\nimport '../app/init.mjs';\nimport '../events/init.mjs';\nimport '../dom/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=browserAll.mjs.map\n", "import '../app/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=webworkerAll.mjs.map\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlLimitsSystem } from './GlLimitsSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlLimitsSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems>\n& PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @internal\n */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @property {GlUboSystem} ubo - UboSystem instance.\n * @property {GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {GlContextSystem} context - ContextSystem instance.\n * @property {GlBufferSystem} buffer - BufferSystem instance.\n * @property {GlTextureSystem} texture - TextureSystem instance.\n * @property {GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {GlShaderSystem} shader - ShaderSystem instance.\n * @property {GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {GlStateSystem} state - StateSystem instance.\n * @property {GlStencilSystem} stencil - StencilSystem instance.\n * @property {GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends AbstractRenderer\n * @standard\n */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n", "/*!\n * matter-js 0.20.0 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Matter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Matter\"] = factory();\n\telse\n\t\troot[\"Matter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 20);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/\n\nvar Common = {};\n\nmodule.exports = Common;\n\n(function() {\n\n    Common._baseDelta = 1000 / 60;\n    Common._nextId = 0;\n    Common._seed = 0;\n    Common._nowStartTime = +(new Date());\n    Common._warnedOnce = {};\n    Common._decomp = null;\n    \n    /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */\n    Common.extend = function(obj, deep) {\n        var argsStart,\n            args,\n            deepClone;\n\n        if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n        } else {\n            argsStart = 1;\n            deepClone = true;\n        }\n\n        for (var i = argsStart; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source) {\n                for (var prop in source) {\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\n                        if (!obj[prop] || obj[prop].constructor === Object) {\n                            obj[prop] = obj[prop] || {};\n                            Common.extend(obj[prop], deepClone, source[prop]);\n                        } else {\n                            obj[prop] = source[prop];\n                        }\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        \n        return obj;\n    };\n\n    /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */\n    Common.clone = function(obj, deep) {\n        return Common.extend({}, deep, obj);\n    };\n\n    /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */\n    Common.keys = function(obj) {\n        if (Object.keys)\n            return Object.keys(obj);\n\n        // avoid hasOwnProperty for performance\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    };\n\n    /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */\n    Common.values = function(obj) {\n        var values = [];\n        \n        if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n            }\n            return values;\n        }\n        \n        // avoid hasOwnProperty for performance\n        for (var key in obj)\n            values.push(obj[key]);\n        return values;\n    };\n\n    /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */\n    Common.get = function(obj, path, begin, end) {\n        path = path.split('.').slice(begin, end);\n\n        for (var i = 0; i < path.length; i += 1) {\n            obj = obj[path[i]];\n        }\n\n        return obj;\n    };\n\n    /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */\n    Common.set = function(obj, path, val, begin, end) {\n        var parts = path.split('.').slice(begin, end);\n        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n        return val;\n    };\n\n    /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */\n    Common.shuffle = function(array) {\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */\n    Common.choose = function(choices) {\n        return choices[Math.floor(Common.random() * choices.length)];\n    };\n\n    /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */\n    Common.isElement = function(obj) {\n        if (typeof HTMLElement !== 'undefined') {\n            return obj instanceof HTMLElement;\n        }\n\n        return !!(obj && obj.nodeType && obj.nodeName);\n    };\n\n    /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */\n    Common.isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */\n    Common.isFunction = function(obj) {\n        return typeof obj === \"function\";\n    };\n\n    /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */\n    Common.isPlainObject = function(obj) {\n        return typeof obj === 'object' && obj.constructor === Object;\n    };\n\n    /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */\n    Common.isString = function(obj) {\n        return toString.call(obj) === '[object String]';\n    };\n    \n    /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */\n    Common.clamp = function(value, min, max) {\n        if (value < min)\n            return min;\n        if (value > max)\n            return max;\n        return value;\n    };\n    \n    /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */\n    Common.sign = function(value) {\n        return value < 0 ? -1 : 1;\n    };\n    \n    /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */\n    Common.now = function() {\n        if (typeof window !== 'undefined' && window.performance) {\n            if (window.performance.now) {\n                return window.performance.now();\n            } else if (window.performance.webkitNow) {\n                return window.performance.webkitNow();\n            }\n        }\n\n        if (Date.now) {\n            return Date.now();\n        }\n\n        return (new Date()) - Common._nowStartTime;\n    };\n    \n    /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */\n    Common.random = function(min, max) {\n        min = (typeof min !== \"undefined\") ? min : 0;\n        max = (typeof max !== \"undefined\") ? max : 1;\n        return min + _seededRandom() * (max - min);\n    };\n\n    var _seededRandom = function() {\n        // https://en.wikipedia.org/wiki/Linear_congruential_generator\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\n        return Common._seed / 233280;\n    };\n\n    /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */\n    Common.colorToNumber = function(colorString) {\n        colorString = colorString.replace('#','');\n\n        if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0)\n                        + colorString.charAt(1) + colorString.charAt(1)\n                        + colorString.charAt(2) + colorString.charAt(2);\n        }\n\n        return parseInt(colorString, 16);\n    };\n\n    /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @static\n     * @property logLevel\n     * @type {Number}\n     * @default 1\n     */\n    Common.logLevel = 1;\n\n    /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */\n    Common.log = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */\n    Common.info = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */\n    Common.warn = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */\n    Common.warnOnce = function() {\n        var message = Array.prototype.slice.call(arguments).join(' ');\n\n        if (!Common._warnedOnce[message]) {\n            Common.warn(message);\n            Common._warnedOnce[message] = true;\n        }\n    };\n\n    /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */\n    Common.deprecated = function(obj, prop, warning) {\n        obj[prop] = Common.chain(function() {\n            Common.warnOnce('\uD83D\uDD05 deprecated \uD83D\uDD05', warning);\n        }, obj[prop]);\n    };\n\n    /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */\n    Common.nextId = function() {\n        return Common._nextId++;\n    };\n\n    /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */\n    Common.indexOf = function(haystack, needle) {\n        if (haystack.indexOf)\n            return haystack.indexOf(needle);\n\n        for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle)\n                return i;\n        }\n\n        return -1;\n    };\n\n    /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */\n    Common.map = function(list, func) {\n        if (list.map) {\n            return list.map(func);\n        }\n\n        var mapped = [];\n\n        for (var i = 0; i < list.length; i += 1) {\n            mapped.push(func(list[i]));\n        }\n\n        return mapped;\n    };\n\n    /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */\n    Common.topologicalSort = function(graph) {\n        // https://github.com/mgechev/javascript-algorithms\n        // Copyright (c) Minko Gechev (MIT license)\n        // Modifications: tidy formatting and naming\n        var result = [],\n            visited = [],\n            temp = [];\n\n        for (var node in graph) {\n            if (!visited[node] && !temp[node]) {\n                Common._topologicalSort(node, visited, temp, graph, result);\n            }\n        }\n\n        return result;\n    };\n\n    Common._topologicalSort = function(node, visited, temp, graph, result) {\n        var neighbors = graph[node] || [];\n        temp[node] = true;\n\n        for (var i = 0; i < neighbors.length; i += 1) {\n            var neighbor = neighbors[i];\n\n            if (temp[neighbor]) {\n                // skip circular dependencies\n                continue;\n            }\n\n            if (!visited[neighbor]) {\n                Common._topologicalSort(neighbor, visited, temp, graph, result);\n            }\n        }\n\n        temp[node] = false;\n        visited[node] = true;\n\n        result.push(node);\n    };\n\n    /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */\n    Common.chain = function() {\n        var funcs = [];\n\n        for (var i = 0; i < arguments.length; i += 1) {\n            var func = arguments[i];\n\n            if (func._chained) {\n                // flatten already chained functions\n                funcs.push.apply(funcs, func._chained);\n            } else {\n                funcs.push(func);\n            }\n        }\n\n        var chain = function() {\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n            var lastResult,\n                args = new Array(arguments.length);\n\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                args[i] = arguments[i];\n            }\n\n            for (i = 0; i < funcs.length; i += 1) {\n                var result = funcs[i].apply(lastResult, args);\n\n                if (typeof result !== 'undefined') {\n                    lastResult = result;\n                }\n            }\n\n            return lastResult;\n        };\n\n        chain._chained = funcs;\n\n        return chain;\n    };\n\n    /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathBefore = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            func,\n            Common.get(base, path)\n        ));\n    };\n\n    /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathAfter = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            Common.get(base, path),\n            func\n        ));\n    };\n\n    /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */\n    Common.setDecomp = function(decomp) {\n        Common._decomp = decomp;\n    };\n\n    /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */\n    Common.getDecomp = function() {\n        // get user provided decomp if set\n        var decomp = Common._decomp;\n\n        try {\n            // otherwise from window global\n            if (!decomp && typeof window !== 'undefined') {\n                decomp = window.decomp;\n            }\n    \n            // otherwise from node global\n            if (!decomp && typeof global !== 'undefined') {\n                decomp = global.decomp;\n            }\n        } catch (e) {\n            // decomp not available\n            decomp = null;\n        }\n\n        return decomp;\n    };\n})();\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/\n\nvar Bounds = {};\n\nmodule.exports = Bounds;\n\n(function() {\n\n    /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */\n    Bounds.create = function(vertices) {\n        var bounds = { \n            min: { x: 0, y: 0 }, \n            max: { x: 0, y: 0 }\n        };\n\n        if (vertices)\n            Bounds.update(bounds, vertices);\n        \n        return bounds;\n    };\n\n    /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */\n    Bounds.update = function(bounds, vertices, velocity) {\n        bounds.min.x = Infinity;\n        bounds.max.x = -Infinity;\n        bounds.min.y = Infinity;\n        bounds.max.y = -Infinity;\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n        }\n        \n        if (velocity) {\n            if (velocity.x > 0) {\n                bounds.max.x += velocity.x;\n            } else {\n                bounds.min.x += velocity.x;\n            }\n            \n            if (velocity.y > 0) {\n                bounds.max.y += velocity.y;\n            } else {\n                bounds.min.y += velocity.y;\n            }\n        }\n    };\n\n    /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */\n    Bounds.contains = function(bounds, point) {\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\n    };\n\n    /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */\n    Bounds.overlaps = function(boundsA, boundsB) {\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\n    };\n\n    /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */\n    Bounds.translate = function(bounds, vector) {\n        bounds.min.x += vector.x;\n        bounds.max.x += vector.x;\n        bounds.min.y += vector.y;\n        bounds.max.y += vector.y;\n    };\n\n    /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */\n    Bounds.shift = function(bounds, position) {\n        var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n            \n        bounds.min.x = position.x;\n        bounds.max.x = position.x + deltaX;\n        bounds.min.y = position.y;\n        bounds.max.y = position.y + deltaY;\n    };\n    \n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/\n\n// TODO: consider params for reusing vector objects\n\nvar Vector = {};\n\nmodule.exports = Vector;\n\n(function() {\n\n    /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */\n    Vector.create = function(x, y) {\n        return { x: x || 0, y: y || 0 };\n    };\n\n    /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */\n    Vector.clone = function(vector) {\n        return { x: vector.x, y: vector.y };\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */\n    Vector.magnitude = function(vector) {\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */\n    Vector.magnitudeSquared = function(vector) {\n        return (vector.x * vector.x) + (vector.y * vector.y);\n    };\n\n    /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */\n    Vector.rotate = function(vector, angle, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = vector.x * cos - vector.y * sin;\n        output.y = vector.x * sin + vector.y * cos;\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */\n    Vector.rotateAbout = function(vector, angle, point, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */\n    Vector.normalise = function(vector) {\n        var magnitude = Vector.magnitude(vector);\n        if (magnitude === 0)\n            return { x: 0, y: 0 };\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\n    };\n\n    /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */\n    Vector.dot = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\n    };\n\n    /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */\n    Vector.cross = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\n    };\n\n    /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */\n    Vector.cross3 = function(vectorA, vectorB, vectorC) {\n        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n    };\n\n    /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */\n    Vector.add = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x + vectorB.x;\n        output.y = vectorA.y + vectorB.y;\n        return output;\n    };\n\n    /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */\n    Vector.sub = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x - vectorB.x;\n        output.y = vectorA.y - vectorB.y;\n        return output;\n    };\n\n    /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */\n    Vector.mult = function(vector, scalar) {\n        return { x: vector.x * scalar, y: vector.y * scalar };\n    };\n\n    /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */\n    Vector.div = function(vector, scalar) {\n        return { x: vector.x / scalar, y: vector.y / scalar };\n    };\n\n    /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */\n    Vector.perp = function(vector, negate) {\n        negate = negate === true ? -1 : 1;\n        return { x: negate * -vector.y, y: negate * vector.x };\n    };\n\n    /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */\n    Vector.neg = function(vector) {\n        return { x: -vector.x, y: -vector.y };\n    };\n\n    /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */\n    Vector.angle = function(vectorA, vectorB) {\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n    };\n\n    /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */\n    Vector._temp = [\n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create()\n    ];\n\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/\n\nvar Vertices = {};\n\nmodule.exports = Vertices;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */\n    Vertices.create = function(points, body) {\n        var vertices = [];\n\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n                vertex = {\n                    x: point.x,\n                    y: point.y,\n                    index: i,\n                    body: body,\n                    isInternal: false\n                };\n\n            vertices.push(vertex);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */\n    Vertices.fromPath = function(path, body) {\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n            points = [];\n\n        path.replace(pathPattern, function(match, x, y) {\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\n        });\n\n        return Vertices.create(points, body);\n    };\n\n    /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */\n    Vertices.centre = function(vertices) {\n        var area = Vertices.area(vertices, true),\n            centre = { x: 0, y: 0 },\n            cross,\n            temp,\n            j;\n\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n        }\n\n        return Vector.div(centre, 6 * area);\n    };\n\n    /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */\n    Vertices.mean = function(vertices) {\n        var average = { x: 0, y: 0 };\n\n        for (var i = 0; i < vertices.length; i++) {\n            average.x += vertices[i].x;\n            average.y += vertices[i].y;\n        }\n\n        return Vector.div(average, vertices.length);\n    };\n\n    /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */\n    Vertices.area = function(vertices, signed) {\n        var area = 0,\n            j = vertices.length - 1;\n\n        for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n        }\n\n        if (signed)\n            return area / 2;\n\n        return Math.abs(area) / 2;\n    };\n\n    /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */\n    Vertices.inertia = function(vertices, mass) {\n        var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n        // find the polygon's moment of inertia, using second moment of area\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\n        for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n        }\n\n        return (mass / 6) * (numerator / denominator);\n    };\n\n    /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */\n    Vertices.translate = function(vertices, vector, scalar) {\n        scalar = typeof scalar !== 'undefined' ? scalar : 1;\n\n        var verticesLength = vertices.length,\n            translateX = vector.x * scalar,\n            translateY = vector.y * scalar,\n            i;\n        \n        for (i = 0; i < verticesLength; i++) {\n            vertices[i].x += translateX;\n            vertices[i].y += translateY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */\n    Vertices.rotate = function(vertices, angle, point) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex,\n            dx,\n            dy,\n            i;\n\n        for (i = 0; i < verticesLength; i++) {\n            vertex = vertices[i];\n            dx = vertex.x - pointX;\n            dy = vertex.y - pointY;\n            vertex.x = pointX + (dx * cos - dy * sin);\n            vertex.y = pointY + (dx * sin + dy * cos);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */\n    Vertices.contains = function(vertices, point) {\n        var pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex = vertices[verticesLength - 1],\n            nextVertex;\n\n        for (var i = 0; i < verticesLength; i++) {\n            nextVertex = vertices[i];\n\n            if ((pointX - vertex.x) * (nextVertex.y - vertex.y) \n                + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {\n                return false;\n            }\n\n            vertex = nextVertex;\n        }\n\n        return true;\n    };\n\n    /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\n        if (scaleX === 1 && scaleY === 1)\n            return vertices;\n\n        point = point || Vertices.centre(vertices);\n\n        var vertex,\n            delta;\n\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n        if (typeof radius === 'number') {\n            radius = [radius];\n        } else {\n            radius = radius || [8];\n        }\n\n        // quality defaults to -1, which is auto\n        quality = (typeof quality !== 'undefined') ? quality : -1;\n        qualityMin = qualityMin || 2;\n        qualityMax = qualityMax || 14;\n\n        var newVertices = [];\n\n        for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n                vertex = vertices[i],\n                nextVertex = vertices[(i + 1) % vertices.length],\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n            if (currentRadius === 0) {\n                newVertices.push(vertex);\n                continue;\n            }\n\n            var prevNormal = Vector.normalise({ \n                x: vertex.y - prevVertex.y, \n                y: prevVertex.x - vertex.x\n            });\n\n            var nextNormal = Vector.normalise({ \n                x: nextVertex.y - vertex.y, \n                y: vertex.x - nextVertex.x\n            });\n\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n\n            var precision = quality;\n\n            if (quality === -1) {\n                // automatically decide precision\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1)\n                precision += 1;\n\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n                theta = alpha / precision;\n\n            for (var j = 0; j < precision; j++) {\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n        }\n\n        return newVertices;\n    };\n\n    /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */\n    Vertices.clockwiseSort = function(vertices) {\n        var centre = Vertices.mean(vertices);\n\n        vertices.sort(function(vertexA, vertexB) {\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n        });\n\n        return vertices;\n    };\n\n    /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */\n    Vertices.isConvex = function(vertices) {\n        // http://paulbourke.net/geometry/polygonmesh/\n        // Copyright (c) Paul Bourke (use permitted)\n\n        var flag = 0,\n            n = vertices.length,\n            i,\n            j,\n            k,\n            z;\n\n        if (n < 3)\n            return null;\n\n        for (i = 0; i < n; i++) {\n            j = (i + 1) % n;\n            k = (i + 2) % n;\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n            if (z < 0) {\n                flag |= 1;\n            } else if (z > 0) {\n                flag |= 2;\n            }\n\n            if (flag === 3) {\n                return false;\n            }\n        }\n\n        if (flag !== 0){\n            return true;\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */\n    Vertices.hull = function(vertices) {\n        // http://geomalgorithms.com/a10-_hull-1.html\n\n        var upper = [],\n            lower = [], \n            vertex,\n            i;\n\n        // sort vertices on x-axis (y-axis for ties)\n        vertices = vertices.slice(0);\n        vertices.sort(function(vertexA, vertexB) {\n            var dx = vertexA.x - vertexB.x;\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\n        });\n\n        // build lower hull\n        for (i = 0; i < vertices.length; i += 1) {\n            vertex = vertices[i];\n\n            while (lower.length >= 2 \n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n                lower.pop();\n            }\n\n            lower.push(vertex);\n        }\n\n        // build upper hull\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\n            vertex = vertices[i];\n\n            while (upper.length >= 2 \n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n                upper.pop();\n            }\n\n            upper.push(vertex);\n        }\n\n        // concatenation of the lower and upper hulls gives the convex hull\n        // omit last points because they are repeated at the beginning of the other list\n        upper.pop();\n        lower.pop();\n\n        return upper.concat(lower);\n    };\n\n})();\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Body` module contains methods for creating and manipulating rigid bodies.\n* For creating bodies with common configurations such as rectangles, circles and other polygons see the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/\n\nvar Body = {};\n\nmodule.exports = Body;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(11);\n\n(function() {\n\n    Body._timeCorrection = true;\n    Body._inertiaScale = 4;\n    Body._nextCollidingGroupId = 1;\n    Body._nextNonCollidingGroupId = -1;\n    Body._nextCategory = 0x0001;\n    Body._baseDelta = 1000 / 60;\n\n    /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */\n    Body.create = function(options) {\n        var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            parts: [],\n            plugin: {},\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: { x: 0, y: 0 },\n            force: { x: 0, y: 0 },\n            torque: 0,\n            positionImpulse: { x: 0, y: 0 },\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\n            totalContacts: 0,\n            speed: 0,\n            angularSpeed: 0,\n            velocity: { x: 0, y: 0 },\n            angularVelocity: 0,\n            isSensor: false,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionStatic: 0.5,\n            frictionAir: 0.01,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n                visible: true,\n                opacity: 1,\n                strokeStyle: null,\n                fillStyle: null,\n                lineWidth: null,\n                sprite: {\n                    xScale: 1,\n                    yScale: 1,\n                    xOffset: 0,\n                    yOffset: 0\n                }\n            },\n            events: null,\n            bounds: null,\n            chamfer: null,\n            circleRadius: 0,\n            positionPrev: null,\n            anglePrev: 0,\n            parent: null,\n            axes: null,\n            area: 0,\n            mass: 0,\n            inertia: 0,\n            deltaTime: 1000 / 60,\n            _original: null\n        };\n\n        var body = Common.extend(defaults, options);\n\n        _initProperties(body, options);\n\n        return body;\n    };\n\n    /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */\n    Body.nextGroup = function(isNonColliding) {\n        if (isNonColliding)\n            return Body._nextNonCollidingGroupId--;\n\n        return Body._nextCollidingGroupId++;\n    };\n\n    /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */\n    Body.nextCategory = function() {\n        Body._nextCategory = Body._nextCategory << 1;\n        return Body._nextCategory;\n    };\n\n    /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */\n    var _initProperties = function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#14151f' : Common.choose(['#f19648', '#f5d259', '#f55a3c', '#063e7b', '#ececd1'])),\n            defaultStrokeStyle = body.isStatic ? '#555' : '#ccc',\n            defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    };\n\n    /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */\n    Body.set = function(body, settings, value) {\n        var property;\n\n        if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n        }\n\n        for (property in settings) {\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\n                continue;\n\n            value = settings[property];\n            switch (property) {\n\n            case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n            case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n            case 'mass':\n                Body.setMass(body, value);\n                break;\n            case 'density':\n                Body.setDensity(body, value);\n                break;\n            case 'inertia':\n                Body.setInertia(body, value);\n                break;\n            case 'vertices':\n                Body.setVertices(body, value);\n                break;\n            case 'position':\n                Body.setPosition(body, value);\n                break;\n            case 'angle':\n                Body.setAngle(body, value);\n                break;\n            case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n            case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n            case 'speed':\n                Body.setSpeed(body, value);\n                break;\n            case 'angularSpeed':\n                Body.setAngularSpeed(body, value);\n                break;\n            case 'parts':\n                Body.setParts(body, value);\n                break;\n            case 'centre':\n                Body.setCentre(body, value);\n                break;\n            default:\n                body[property] = value;\n\n            }\n        }\n    };\n\n    /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */\n    Body.setStatic = function(body, isStatic) {\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            if (isStatic) {\n                if (!part.isStatic) {\n                    part._original = {\n                        restitution: part.restitution,\n                        friction: part.friction,\n                        mass: part.mass,\n                        inertia: part.inertia,\n                        density: part.density,\n                        inverseMass: part.inverseMass,\n                        inverseInertia: part.inverseInertia\n                    };\n                }\n\n                part.restitution = 0;\n                part.friction = 1;\n                part.mass = part.inertia = part.density = Infinity;\n                part.inverseMass = part.inverseInertia = 0;\n\n                part.positionPrev.x = part.position.x;\n                part.positionPrev.y = part.position.y;\n                part.anglePrev = part.angle;\n                part.angularVelocity = 0;\n                part.speed = 0;\n                part.angularSpeed = 0;\n                part.motion = 0;\n            } else if (part._original) {\n                part.restitution = part._original.restitution;\n                part.friction = part._original.friction;\n                part.mass = part._original.mass;\n                part.inertia = part._original.inertia;\n                part.density = part._original.density;\n                part.inverseMass = part._original.inverseMass;\n                part.inverseInertia = part._original.inverseInertia;\n\n                part._original = null;\n            }\n\n            part.isStatic = isStatic;\n        }\n    };\n\n    /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */\n    Body.setMass = function(body, mass) {\n        var moment = body.inertia / (body.mass / 6);\n        body.inertia = moment * (mass / 6);\n        body.inverseInertia = 1 / body.inertia;\n\n        body.mass = mass;\n        body.inverseMass = 1 / body.mass;\n        body.density = body.mass / body.area;\n    };\n\n    /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */\n    Body.setDensity = function(body, density) {\n        Body.setMass(body, density * body.area);\n        body.density = density;\n    };\n\n    /**\n     * Sets the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */\n    Body.setInertia = function(body, inertia) {\n        body.inertia = inertia;\n        body.inverseInertia = 1 / body.inertia;\n    };\n\n    /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull. Concave vertices must be decomposed into convex parts.\n     * \n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */\n    Body.setVertices = function(body, vertices) {\n        // change vertices\n        if (vertices[0].body === body) {\n            body.vertices = vertices;\n        } else {\n            body.vertices = Vertices.create(vertices, body);\n        }\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // orient vertices around the centre of mass at origin (0, 0)\n        var centre = Vertices.centre(body.vertices);\n        Vertices.translate(body.vertices, centre, -1);\n\n        // update inertia while vertices are at origin (0, 0)\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n        // update geometry\n        Vertices.translate(body.vertices, body.position);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the parts of the `body`. \n     * \n     * See `body.parts` for details and requirements on how parts are used.\n     * \n     * See Bodies.fromVertices for a related utility.\n     * \n     * This function updates `body` mass, inertia and centroid based on the parts geometry.  \n     * Sets each `part.parent` to be this `body`.  \n     * \n     * The convex hull is computed and set on this `body` (unless `autoHull` is `false`).  \n     * Automatically ensures that the first part in `body.parts` is the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param {body[]} parts\n     * @param {bool} [autoHull=true]\n     */\n    Body.setParts = function(body, parts, autoHull) {\n        var i;\n\n        // add all the parts, ensuring that the first part is always the parent body\n        parts = parts.slice(0);\n        body.parts.length = 0;\n        body.parts.push(body);\n        body.parent = body;\n\n        for (i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== body) {\n                part.parent = body;\n                body.parts.push(part);\n            }\n        }\n\n        if (body.parts.length === 1)\n            return;\n\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\n\n        // find the convex hull of all parts to set on the parent body\n        if (autoHull) {\n            var vertices = [];\n            for (i = 0; i < parts.length; i++) {\n                vertices = vertices.concat(parts[i].vertices);\n            }\n\n            Vertices.clockwiseSort(vertices);\n\n            var hull = Vertices.hull(vertices),\n                hullCentre = Vertices.centre(hull);\n\n            Body.setVertices(body, hull);\n            Vertices.translate(body.vertices, hullCentre);\n        }\n\n        // sum the properties of all compound parts of the parent body\n        var total = Body._totalProperties(body);\n\n        body.area = total.area;\n        body.parent = body;\n        body.position.x = total.centre.x;\n        body.position.y = total.centre.y;\n        body.positionPrev.x = total.centre.x;\n        body.positionPrev.y = total.centre.y;\n\n        Body.setMass(body, total.mass);\n        Body.setInertia(body, total.inertia);\n        Body.setPosition(body, total.centre);\n    };\n\n    /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */\n    Body.setCentre = function(body, centre, relative) {\n        if (!relative) {\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n            body.position.x = centre.x;\n            body.position.y = centre.y;\n        } else {\n            body.positionPrev.x += centre.x;\n            body.positionPrev.y += centre.y;\n            body.position.x += centre.x;\n            body.position.y += centre.y;\n        }\n    };\n\n    /**\n     * Sets the position of the body. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.setPosition = function(body, position, updateVelocity) {\n        var delta = Vector.sub(position, body.position);\n\n        if (updateVelocity) {\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n            body.velocity.x = delta.x;\n            body.velocity.y = delta.y;\n            body.speed = Vector.magnitude(delta);\n        } else {\n            body.positionPrev.x += delta.x;\n            body.positionPrev.y += delta.y;\n        }\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.position.x += delta.x;\n            part.position.y += delta.y;\n            Vertices.translate(part.vertices, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Sets the angle of the body. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.setAngle = function(body, angle, updateVelocity) {\n        var delta = angle - body.angle;\n        \n        if (updateVelocity) {\n            body.anglePrev = body.angle;\n            body.angularVelocity = delta;\n            body.angularSpeed = Math.abs(delta);\n        } else {\n            body.anglePrev += delta;\n        }\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.angle += delta;\n            Vertices.rotate(part.vertices, delta, body.position);\n            Axes.rotate(part.axes, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n            if (i > 0) {\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\n            }\n        }\n    };\n\n    /**\n     * Sets the current linear velocity of the body.  \n     * Affects body speed.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */\n    Body.setVelocity = function(body, velocity) {\n        var timeScale = body.deltaTime / Body._baseDelta;\n        body.positionPrev.x = body.position.x - velocity.x * timeScale;\n        body.positionPrev.y = body.position.y - velocity.y * timeScale;\n        body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;\n        body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;\n        body.speed = Vector.magnitude(body.velocity);\n    };\n\n    /**\n     * Gets the current linear velocity of the body.\n     * @method getVelocity\n     * @param {body} body\n     * @return {vector} velocity\n     */\n    Body.getVelocity = function(body) {\n        var timeScale = Body._baseDelta / body.deltaTime;\n\n        return {\n            x: (body.position.x - body.positionPrev.x) * timeScale,\n            y: (body.position.y - body.positionPrev.y) * timeScale\n        };\n    };\n\n    /**\n     * Gets the current linear speed of the body.  \n     * Equivalent to the magnitude of its velocity.\n     * @method getSpeed\n     * @param {body} body\n     * @return {number} speed\n     */\n    Body.getSpeed = function(body) {\n        return Vector.magnitude(Body.getVelocity(body));\n    };\n\n    /**\n     * Sets the current linear speed of the body.  \n     * Direction is maintained. Affects body velocity.\n     * @method setSpeed\n     * @param {body} body\n     * @param {number} speed\n     */\n    Body.setSpeed = function(body, speed) {\n        Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));\n    };\n\n    /**\n     * Sets the current rotational velocity of the body.  \n     * Affects body angular speed.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */\n    Body.setAngularVelocity = function(body, velocity) {\n        var timeScale = body.deltaTime / Body._baseDelta;\n        body.anglePrev = body.angle - velocity * timeScale;\n        body.angularVelocity = (body.angle - body.anglePrev) / timeScale;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Gets the current rotational velocity of the body.\n     * @method getAngularVelocity\n     * @param {body} body\n     * @return {number} angular velocity\n     */\n    Body.getAngularVelocity = function(body) {\n        return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;\n    };\n\n    /**\n     * Gets the current rotational speed of the body.  \n     * Equivalent to the magnitude of its angular velocity.\n     * @method getAngularSpeed\n     * @param {body} body\n     * @return {number} angular speed\n     */\n    Body.getAngularSpeed = function(body) {\n        return Math.abs(Body.getAngularVelocity(body));\n    };\n\n    /**\n     * Sets the current rotational speed of the body.  \n     * Direction is maintained. Affects body angular velocity.\n     * @method setAngularSpeed\n     * @param {body} body\n     * @param {number} speed\n     */\n    Body.setAngularSpeed = function(body, speed) {\n        Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);\n    };\n\n    /**\n     * Moves a body by a given vector relative to its current position. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.translate = function(body, translation, updateVelocity) {\n        Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);\n    };\n\n    /**\n     * Rotates a body by a given angle relative to its current angle. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.rotate = function(body, rotation, point, updateVelocity) {\n        if (!point) {\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n        } else {\n            var cos = Math.cos(rotation),\n                sin = Math.sin(rotation),\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            }, updateVelocity);\n\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n        }\n    };\n\n    /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */\n    Body.scale = function(body, scaleX, scaleY, point) {\n        var totalArea = 0,\n            totalInertia = 0;\n\n        point = point || body.position;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            // scale vertices\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\n\n            // update properties\n            part.axes = Axes.fromVertices(part.vertices);\n            part.area = Vertices.area(part.vertices);\n            Body.setMass(part, body.density * part.area);\n\n            // update inertia (requires vertices to be at origin)\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\n\n            if (i > 0) {\n                totalArea += part.area;\n                totalInertia += part.inertia;\n            }\n\n            // scale position\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\n\n            // update bounds\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n\n        // handle parent body\n        if (body.parts.length > 1) {\n            body.area = totalArea;\n\n            if (!body.isStatic) {\n                Body.setMass(body, body.density * totalArea);\n                Body.setInertia(body, totalInertia);\n            }\n        }\n\n        // handle circles\n        if (body.circleRadius) { \n            if (scaleX === scaleY) {\n                body.circleRadius *= scaleX;\n            } else {\n                // body is no longer a circle\n                body.circleRadius = null;\n            }\n        }\n    };\n\n    /**\n     * Performs an update by integrating the equations of motion on the `body`.\n     * This is applied every update by `Matter.Engine` automatically.\n     * @method update\n     * @param {body} body\n     * @param {number} [deltaTime=16.666]\n     */\n    Body.update = function(body, deltaTime) {\n        deltaTime = (typeof deltaTime !== 'undefined' ? deltaTime : (1000 / 60)) * body.timeScale;\n\n        var deltaTimeSquared = deltaTime * deltaTime,\n            correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;\n\n        // from the previous step\n        var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta),\n            velocityPrevX = (body.position.x - body.positionPrev.x) * correction,\n            velocityPrevY = (body.position.y - body.positionPrev.y) * correction;\n\n        // update velocity with Verlet integration\n        body.velocity.x = (velocityPrevX * frictionAir) + (body.force.x / body.mass) * deltaTimeSquared;\n        body.velocity.y = (velocityPrevY * frictionAir) + (body.force.y / body.mass) * deltaTimeSquared;\n\n        body.positionPrev.x = body.position.x;\n        body.positionPrev.y = body.position.y;\n        body.position.x += body.velocity.x;\n        body.position.y += body.velocity.y;\n        body.deltaTime = deltaTime;\n\n        // update angular velocity with Verlet integration\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\n        body.anglePrev = body.angle;\n        body.angle += body.angularVelocity;\n\n        // transform the body geometry\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            Vertices.translate(part.vertices, body.velocity);\n            \n            if (i > 0) {\n                part.position.x += body.velocity.x;\n                part.position.y += body.velocity.y;\n            }\n\n            if (body.angularVelocity !== 0) {\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                Axes.rotate(part.axes, body.angularVelocity);\n                if (i > 0) {\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                }\n            }\n\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Updates properties `body.velocity`, `body.speed`, `body.angularVelocity` and `body.angularSpeed` which are normalised in relation to `Body._baseDelta`.\n     * @method updateVelocities\n     * @param {body} body\n     */\n    Body.updateVelocities = function(body) {\n        var timeScale = Body._baseDelta / body.deltaTime,\n            bodyVelocity = body.velocity;\n\n        bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;\n        bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;\n        body.speed = Math.sqrt((bodyVelocity.x * bodyVelocity.x) + (bodyVelocity.y * bodyVelocity.y));\n\n        body.angularVelocity = (body.angle - body.anglePrev) * timeScale;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Applies the `force` to the `body` from the force origin `position` in world-space, over a single timestep, including applying any resulting angular torque.\n     * \n     * Forces are useful for effects like gravity, wind or rocket thrust, but can be difficult in practice when precise control is needed. In these cases see `Body.setVelocity` and `Body.setPosition` as an alternative.\n     * \n     * The force from this function is only applied once for the duration of a single timestep, in other words the duration depends directly on the current engine update `delta` and the rate of calls to this function.\n     * \n     * Therefore to account for time, you should apply the force constantly over as many engine updates as equivalent to the intended duration.\n     * \n     * If all or part of the force duration is some fraction of a timestep, first multiply the force by `duration / timestep`.\n     * \n     * The force origin `position` in world-space must also be specified. Passing `body.position` will result in zero angular effect as the force origin would be at the centre of mass.\n     * \n     * The `body` will take time to accelerate under a force, the resulting effect depends on duration of the force, the body mass and other forces on the body including friction combined.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position The force origin in world-space. Pass `body.position` to avoid angular torque.\n     * @param {vector} force\n     */\n    Body.applyForce = function(body, position, force) {\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\n        body.force.x += force.x;\n        body.force.y += force.y;\n        body.torque += offset.x * force.y - offset.y * force.x;\n    };\n\n    /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */\n    Body._totalProperties = function(body) {\n        // from equations at:\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n        // http://output.to/sideway/default.asp?qno=121100087\n\n        var properties = {\n            mass: 0,\n            area: 0,\n            inertia: 0,\n            centre: { x: 0, y: 0 }\n        };\n\n        // sum the properties of all compound parts of the parent body\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n            var part = body.parts[i],\n                mass = part.mass !== Infinity ? part.mass : 1;\n\n            properties.mass += mass;\n            properties.area += part.area;\n            properties.inertia += part.inertia;\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n        }\n\n        properties.centre = Vector.div(properties.centre, properties.mass);\n\n        return properties;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * _Read only_. Set by `Body.create`.\n     * \n     * A `String` denoting the type of object.\n     *\n     * @readOnly\n     * @property type\n     * @type string\n     * @default \"body\"\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */\n\n    /**\n     * _Read only_. Use `Body.setParts` to set. \n     * \n     * See `Bodies.fromVertices` for a related utility.\n     * \n     * An array of bodies (the 'parts') that make up this body (the 'parent'). The first body in this array must always be a self-reference to this `body`.  \n     * \n     * The parts are fixed together and therefore perform as a single unified rigid body.\n     * \n     * Parts in relation to each other are allowed to overlap, as well as form gaps or holes, so can be used to create complex concave bodies unlike when using a single part. \n     * \n     * Use properties and functions on the parent `body` rather than on parts.\n     *   \n     * Outside of their geometry, most properties on parts are not considered or updated.  \n     * As such 'per-part' material properties among others are not currently considered.\n     * \n     * Parts should be created specifically for their parent body.  \n     * Parts should not be shared or reused between bodies, only one parent is supported.  \n     * Parts should not have their own parts, they are not handled recursively.  \n     * Parts should not be added to the world directly or any other composite.  \n     * Parts own vertices must be convex and in clockwise order.   \n     * \n     * A body with more than one part is sometimes referred to as a 'compound' body. \n     * \n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.  \n     *\n     * @readOnly\n     * @property parts\n     * @type body[]\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * _Read only_. Updated by `Body.setParts`.\n     * \n     * A reference to the body that this is a part of. See `body.parts`.\n     * This is a self reference if the body is not a part of another body.\n     *\n     * @readOnly\n     * @property parent\n     * @type body\n     */\n\n    /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setVertices` or `Body.setParts` to set. See also `Bodies.fromVertices`.\n     * \n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     * `[{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]`\n     * \n     * Vertices must always be convex, in clockwise order and must not contain any duplicate points.\n     * \n     * Concave vertices should be decomposed into convex `parts`, see `Bodies.fromVertices` and `Body.setParts`.\n     *\n     * When set the vertices are translated such that `body.position` is at the centre of mass.\n     * Many other body properties are automatically calculated from these vertices when set including `density`, `area` and `inertia`.\n     * \n     * The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @readOnly\n     * @property vertices\n     * @type vector[]\n     */\n\n    /**\n     * _Read only_. Use `Body.setPosition` to set. \n     * \n     * A `Vector` that specifies the current world-space position of the body.\n     * \n     * @readOnly\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that accumulates the total force applied to the body for a single update.\n     * Force is zeroed after every `Engine.update`, so constant forces should be applied for every update they are needed. See also `Body.applyForce`.\n     * \n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that accumulates the total torque (turning force) applied to the body for a single update. See also `Body.applyForce`.\n     * Torque is zeroed after every `Engine.update`, so constant torques should be applied for every update they are needed.\n     *\n     * Torques result in angular acceleration on every update, which depends on body inertia and the engine update delta.\n     * \n     * @property torque\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setSpeed` to set. \n     * \n     * See `Body.getSpeed` for details.\n     * \n     * Equivalent to the magnitude of `body.velocity` (always positive).\n     * \n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setVelocity` to set. \n     * \n     * See `Body.getVelocity` for details.\n     * \n     * Equivalent to the magnitude of `body.angularVelocity` (always positive).\n     * \n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * _Read only_. Use `Body.setAngularSpeed` to set. \n     * \n     * See `Body.getAngularSpeed` for details.\n     * \n     * \n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setAngularVelocity` to set. \n     * \n     * See `Body.getAngularVelocity` for details.\n     * \n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setStatic` to set. \n     * \n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     *\n     * @readOnly\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * _Read only_. Use `Sleeping.set` to set. \n     * \n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     *\n     * @readOnly\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * _Read only_. Calculated during engine update only when sleeping is enabled.\n     * \n     * A `Number` that loosely measures the amount of movement a body currently has.\n     *\n     * Derived from `body.speed^2 + body.angularSpeed^2`. See `Sleeping.update`.\n     * \n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the length of time during which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     * \n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */\n\n    /**\n     * _Read only_. Use `Body.setDensity` to set. \n     * \n     * A `Number` that defines the density of the body (mass per unit area).\n     * \n     * Mass will also be updated when set.\n     *\n     * @readOnly\n     * @property density\n     * @type number\n     * @default 0.001\n     */\n\n    /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the mass of the body.\n     * \n     * Density will also be updated when set.\n     * \n     * @readOnly\n     * @property mass\n     * @type number\n     */\n\n    /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     *\n     * @readOnly\n     * @property inverseMass\n     * @type number\n     */\n\n    /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or set through `Body.setInertia`.\n     * \n     * A `Number` that defines the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * \n     * Can be manually set to `Infinity` to prevent rotation of the body. See `Body.setInertia`.\n     * \n     * @readOnly\n     * @property inertia\n     * @type number\n     */\n\n    /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or calculated by `Body.setInertia`.\n     * \n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * \n     * @readOnly\n     * @property inverseInertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     * `Math.max(bodyA.restitution, bodyB.restitution)`\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     * `Math.min(bodyA.friction, bodyB.friction)`\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */\n\n    /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */\n\n    /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */\n\n    /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n    /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */\n\n    /**\n     * A `Number` that specifies a thin boundary around the body where it is allowed to slightly sink into other bodies.\n     * \n     * This is required for proper collision response, including friction and restitution effects.\n     * \n     * The default should generally suffice in most cases. You may need to decrease this value for very small bodies that are nearing the default value in scale.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */\n\n    /**\n     * A `Number` that specifies per-body time scaling.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * _Read only_. Updated during engine update.\n     * \n     * A `Number` that records the last delta time value used to update this body.\n     * Used to calculate speed and velocity.\n     *\n     * @readOnly\n     * @property deltaTime\n     * @type number\n     * @default 1000 / 60\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */\n\n    /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */\n\n    /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */\n     \n    /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated when vertices are set.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @readOnly\n     * @property axes\n     * @type vector[]\n     */\n     \n    /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * A `Number` that measures the area of the body's convex hull.\n     * \n     * @readOnly\n     * @property area\n     * @type string\n     * @default \n     */\n\n    /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated when vertices are set and constantly updated by `Body.update` during simulation.\n     * \n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * Temporarily may hold parameters to be passed to `Vertices.chamfer` where supported by external functions.\n     * \n     * See `Vertices.chamfer` for possible parameters this object may hold.\n     * \n     * Currently only functions inside `Matter.Bodies` provide a utility using this property as a vertices pre-processing option.\n     * \n     * Alternatively consider using `Vertices.chamfer` directly on vertices before passing them to a body creation function.\n     * \n     * @property chamfer\n     * @type object|null|undefined\n     */\n\n})();\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/\n\nvar Events = {};\n\nmodule.exports = Events;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.on = function(object, eventNames, callback) {\n        var names = eventNames.split(' '),\n            name;\n\n        for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n        }\n\n        return callback;\n    };\n\n    /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.off = function(object, eventNames, callback) {\n        if (!eventNames) {\n            object.events = {};\n            return;\n        }\n\n        // handle Events.off(object, callback)\n        if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n        }\n\n        var names = eventNames.split(' ');\n\n        for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n                newCallbacks = [];\n\n            if (callback && callbacks) {\n                for (var j = 0; j < callbacks.length; j++) {\n                    if (callbacks[j] !== callback)\n                        newCallbacks.push(callbacks[j]);\n                }\n            }\n\n            object.events[names[i]] = newCallbacks;\n        }\n    };\n\n    /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */\n    Events.trigger = function(object, eventNames, event) {\n        var names,\n            name,\n            callbacks,\n            eventClone;\n\n        var events = object.events;\n        \n        if (events && Common.keys(events).length > 0) {\n            if (!event)\n                event = {};\n\n            names = eventNames.split(' ');\n\n            for (var i = 0; i < names.length; i++) {\n                name = names[i];\n                callbacks = events[name];\n\n                if (callbacks) {\n                    eventClone = Common.clone(event, false);\n                    eventClone.name = name;\n                    eventClone.source = object;\n\n                    for (var j = 0; j < callbacks.length; j++) {\n                        callbacks[j].apply(object, [eventClone]);\n                    }\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/\n\nvar Composite = {};\n\nmodule.exports = Composite;\n\nvar Events = __webpack_require__(5);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Body = __webpack_require__(4);\n\n(function() {\n\n    /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */\n    Composite.create = function(options) {\n        return Common.extend({ \n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [], \n            constraints: [], \n            composites: [],\n            label: 'Composite',\n            plugin: {},\n            cache: {\n                allBodies: null,\n                allConstraints: null,\n                allComposites: null\n            }\n        }, options);\n    };\n\n    /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @private\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n        composite.isModified = isModified;\n\n        if (isModified && composite.cache) {\n            composite.cache.allBodies = null;\n            composite.cache.allConstraints = null;\n            composite.cache.allComposites = null;\n        }\n\n        if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n        }\n\n        if (updateChildren) {\n            for (var i = 0; i < composite.composites.length; i++) {\n                var childComposite = composite.composites[i];\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n        }\n    };\n\n    /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */\n    Composite.add = function(composite, object) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeAdd', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                // skip adding compound parts\n                if (obj.parent !== obj) {\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n                    break;\n                }\n\n                Composite.addBody(composite, obj);\n                break;\n            case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n            case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n            case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterAdd', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */\n    Composite.remove = function(composite, object, deep) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeRemove', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n            case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n            case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n            case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterRemove', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */\n    Composite.addComposite = function(compositeA, compositeB) {\n        compositeA.composites.push(compositeB);\n        compositeB.parent = compositeA;\n        Composite.setModified(compositeA, true, true, false);\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\n        var position = Common.indexOf(compositeA.composites, compositeB);\n\n        if (position !== -1) {\n            var bodies = Composite.allBodies(compositeB);\n\n            Composite.removeCompositeAt(compositeA, position);\n\n            for (var i = 0; i < bodies.length; i++) {\n                bodies[i].sleepCounter = 0;\n            }\n        }\n\n        if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++){\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n        }\n\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */\n    Composite.removeCompositeAt = function(composite, position) {\n        composite.composites.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */\n    Composite.addBody = function(composite, body) {\n        composite.bodies.push(body);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBody = function(composite, body, deep) {\n        var position = Common.indexOf(composite.bodies, body);\n\n        if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n            body.sleepCounter = 0;\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeBody(composite.composites[i], body, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBodyAt = function(composite, position) {\n        composite.bodies.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */\n    Composite.addConstraint = function(composite, constraint) {\n        composite.constraints.push(constraint);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraint = function(composite, constraint, deep) {\n        var position = Common.indexOf(composite.constraints, constraint);\n        \n        if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraintAt = function(composite, position) {\n        composite.constraints.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */\n    Composite.clear = function(composite, keepStatic, deep) {\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.clear(composite.composites[i], keepStatic, true);\n            }\n        }\n        \n        if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\n        } else {\n            composite.bodies.length = 0;\n        }\n\n        composite.constraints.length = 0;\n        composite.composites.length = 0;\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */\n    Composite.allBodies = function(composite) {\n        if (composite.cache && composite.cache.allBodies) {\n            return composite.cache.allBodies;\n        }\n\n        var bodies = [].concat(composite.bodies);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allBodies = bodies;\n        }\n\n        return bodies;\n    };\n\n    /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */\n    Composite.allConstraints = function(composite) {\n        if (composite.cache && composite.cache.allConstraints) {\n            return composite.cache.allConstraints;\n        }\n\n        var constraints = [].concat(composite.constraints);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allConstraints = constraints;\n        }\n\n        return constraints;\n    };\n\n    /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */\n    Composite.allComposites = function(composite) {\n        if (composite.cache && composite.cache.allComposites) {\n            return composite.cache.allComposites;\n        }\n\n        var composites = [].concat(composite.composites);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allComposites = composites;\n        }\n\n        return composites;\n    };\n\n    /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */\n    Composite.get = function(composite, id, type) {\n        var objects,\n            object;\n\n        switch (type) {\n        case 'body':\n            objects = Composite.allBodies(composite);\n            break;\n        case 'constraint':\n            objects = Composite.allConstraints(composite);\n            break;\n        case 'composite':\n            objects = Composite.allComposites(composite).concat(composite);\n            break;\n        }\n\n        if (!objects)\n            return null;\n\n        object = objects.filter(function(object) { \n            return object.id.toString() === id.toString(); \n        });\n\n        return object.length === 0 ? null : object[0];\n    };\n\n    /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */\n    Composite.move = function(compositeA, objects, compositeB) {\n        Composite.remove(compositeA, objects);\n        Composite.add(compositeB, objects);\n        return compositeA;\n    };\n\n    /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */\n    Composite.rebase = function(composite) {\n        var objects = Composite.allBodies(composite)\n            .concat(Composite.allConstraints(composite))\n            .concat(Composite.allComposites(composite));\n\n        for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n        }\n\n        return composite;\n    };\n\n    /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */\n    Composite.translate = function(composite, translation, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.rotate = function(composite, rotation, point, recursive) {\n        var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.rotate(body, rotation);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + dx * scaleX,\n                y: point.y + dy * scaleY\n            });\n\n            Body.scale(body, scaleX, scaleY);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */\n    Composite.bounds = function(composite) {\n        var bodies = Composite.allBodies(composite),\n            vertices = [];\n\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i];\n            vertices.push(body.bounds.min, body.bounds.max);\n        }\n\n        return Bounds.create(vertices);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */\n\n    /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * This is automatically managed when bodies, constraints or composites are added or removed.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */\n\n    /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */\n\n    /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * An object used for storing cached results for performance reasons.\n     * This is used internally only and is automatically managed.\n     *\n     * @private\n     * @property cache\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/\n\nvar Sleeping = {};\n\nmodule.exports = Sleeping;\n\nvar Body = __webpack_require__(4);\nvar Events = __webpack_require__(5);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Sleeping._motionWakeThreshold = 0.18;\n    Sleeping._motionSleepThreshold = 0.08;\n    Sleeping._minBias = 0.9;\n\n    /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} delta\n     */\n    Sleeping.update = function(bodies, delta) {\n        var timeScale = delta / Common._baseDelta,\n            motionSleepThreshold = Sleeping._motionSleepThreshold;\n        \n        // update bodies sleeping status\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                speed = Body.getSpeed(body),\n                angularSpeed = Body.getAngularSpeed(body),\n                motion = speed * speed + angularSpeed * angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x !== 0 || body.force.y !== 0) {\n                Sleeping.set(body, false);\n                continue;\n            }\n\n            var minMotion = Math.min(body.motion, motion),\n                maxMotion = Math.max(body.motion, motion);\n        \n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n\n            if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {\n                body.sleepCounter += 1;\n                \n                if (body.sleepCounter >= body.sleepThreshold / timeScale) {\n                    Sleeping.set(body, true);\n                }\n            } else if (body.sleepCounter > 0) {\n                body.sleepCounter -= 1;\n            }\n        }\n    };\n\n    /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     */\n    Sleeping.afterCollisions = function(pairs) {\n        var motionSleepThreshold = Sleeping._motionSleepThreshold;\n\n        // wake up bodies involved in collisions\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            // don't wake inactive pairs\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA.parent, \n                bodyB = collision.bodyB.parent;\n        \n            // don't wake if at least one body is static\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\n                continue;\n        \n            if (bodyA.isSleeping || bodyB.isSleeping) {\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n                if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {\n                    Sleeping.set(sleepingBody, false);\n                }\n            }\n        }\n    };\n  \n    /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */\n    Sleeping.set = function(body, isSleeping) {\n        var wasSleeping = body.isSleeping;\n\n        if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n\n            if (!wasSleeping) {\n                Events.trigger(body, 'sleepStart');\n            }\n        } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n\n            if (wasSleeping) {\n                Events.trigger(body, 'sleepEnd');\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Collision` module contains methods for detecting collisions between a given pair of bodies.\n*\n* For efficient detection between a list of bodies, see `Matter.Detector` and `Matter.Query`.\n*\n* See `Matter.Engine` for collision events.\n*\n* @class Collision\n*/\n\nvar Collision = {};\n\nmodule.exports = Collision;\n\nvar Vertices = __webpack_require__(3);\nvar Pair = __webpack_require__(9);\n\n(function() {\n    var _supports = [];\n\n    var _overlapAB = {\n        overlap: 0,\n        axis: null\n    };\n\n    var _overlapBA = {\n        overlap: 0,\n        axis: null\n    };\n\n    /**\n     * Creates a new collision record.\n     * @method create\n     * @param {body} bodyA The first body part represented by the collision record\n     * @param {body} bodyB The second body part represented by the collision record\n     * @return {collision} A new collision record\n     */\n    Collision.create = function(bodyA, bodyB) {\n        return { \n            pair: null,\n            collided: false,\n            bodyA: bodyA,\n            bodyB: bodyB,\n            parentA: bodyA.parent,\n            parentB: bodyB.parent,\n            depth: 0,\n            normal: { x: 0, y: 0 },\n            tangent: { x: 0, y: 0 },\n            penetration: { x: 0, y: 0 },\n            supports: [null, null],\n            supportCount: 0\n        };\n    };\n\n    /**\n     * Detect collision between two bodies.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {pairs} [pairs] Optionally reuse collision records from existing pairs.\n     * @return {collision|null} A collision record if detected, otherwise null\n     */\n    Collision.collides = function(bodyA, bodyB, pairs) {\n        Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n        if (_overlapAB.overlap <= 0) {\n            return null;\n        }\n\n        Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n        if (_overlapBA.overlap <= 0) {\n            return null;\n        }\n\n        // reuse collision records for gc efficiency\n        var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)],\n            collision;\n\n        if (!pair) {\n            collision = Collision.create(bodyA, bodyB);\n            collision.collided = true;\n            collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n            collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n            collision.parentA = collision.bodyA.parent;\n            collision.parentB = collision.bodyB.parent;\n        } else {\n            collision = pair.collision;\n        }\n\n        bodyA = collision.bodyA;\n        bodyB = collision.bodyB;\n\n        var minOverlap;\n\n        if (_overlapAB.overlap < _overlapBA.overlap) {\n            minOverlap = _overlapAB;\n        } else {\n            minOverlap = _overlapBA;\n        }\n\n        var normal = collision.normal,\n            tangent = collision.tangent,\n            penetration = collision.penetration,\n            supports = collision.supports,\n            depth = minOverlap.overlap,\n            minAxis = minOverlap.axis,\n            normalX = minAxis.x,\n            normalY = minAxis.y,\n            deltaX = bodyB.position.x - bodyA.position.x,\n            deltaY = bodyB.position.y - bodyA.position.y;\n\n        // ensure normal is facing away from bodyA\n        if (normalX * deltaX + normalY * deltaY >= 0) {\n            normalX = -normalX;\n            normalY = -normalY;\n        }\n\n        normal.x = normalX;\n        normal.y = normalY;\n        \n        tangent.x = -normalY;\n        tangent.y = normalX;\n\n        penetration.x = normalX * depth;\n        penetration.y = normalY * depth;\n\n        collision.depth = depth;\n\n        // find support points, there is always either exactly one or two\n        var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1),\n            supportCount = 0;\n\n        // find the supports from bodyB that are inside bodyA\n        if (Vertices.contains(bodyA.vertices, supportsB[0])) {\n            supports[supportCount++] = supportsB[0];\n        }\n\n        if (Vertices.contains(bodyA.vertices, supportsB[1])) {\n            supports[supportCount++] = supportsB[1];\n        }\n\n        // find the supports from bodyA that are inside bodyB\n        if (supportCount < 2) {\n            var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);\n\n            if (Vertices.contains(bodyB.vertices, supportsA[0])) {\n                supports[supportCount++] = supportsA[0];\n            }\n\n            if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {\n                supports[supportCount++] = supportsA[1];\n            }\n        }\n\n        // account for the edge case of overlapping but no vertex containment\n        if (supportCount === 0) {\n            supports[supportCount++] = supportsB[0];\n        }\n\n        // update support count\n        collision.supportCount = supportCount;\n\n        return collision;\n    };\n\n    /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {object} result\n     * @param {vertices} verticesA\n     * @param {vertices} verticesB\n     * @param {axes} axes\n     */\n    Collision._overlapAxes = function(result, verticesA, verticesB, axes) {\n        var verticesALength = verticesA.length,\n            verticesBLength = verticesB.length,\n            verticesAX = verticesA[0].x,\n            verticesAY = verticesA[0].y,\n            verticesBX = verticesB[0].x,\n            verticesBY = verticesB[0].y,\n            axesLength = axes.length,\n            overlapMin = Number.MAX_VALUE,\n            overlapAxisNumber = 0,\n            overlap,\n            overlapAB,\n            overlapBA,\n            dot,\n            i,\n            j;\n\n        for (i = 0; i < axesLength; i++) {\n            var axis = axes[i],\n                axisX = axis.x,\n                axisY = axis.y,\n                minA = verticesAX * axisX + verticesAY * axisY,\n                minB = verticesBX * axisX + verticesBY * axisY,\n                maxA = minA,\n                maxB = minB;\n            \n            for (j = 1; j < verticesALength; j += 1) {\n                dot = verticesA[j].x * axisX + verticesA[j].y * axisY;\n\n                if (dot > maxA) { \n                    maxA = dot;\n                } else if (dot < minA) { \n                    minA = dot;\n                }\n            }\n\n            for (j = 1; j < verticesBLength; j += 1) {\n                dot = verticesB[j].x * axisX + verticesB[j].y * axisY;\n\n                if (dot > maxB) { \n                    maxB = dot;\n                } else if (dot < minB) { \n                    minB = dot;\n                }\n            }\n\n            overlapAB = maxA - minB;\n            overlapBA = maxB - minA;\n            overlap = overlapAB < overlapBA ? overlapAB : overlapBA;\n\n            if (overlap < overlapMin) {\n                overlapMin = overlap;\n                overlapAxisNumber = i;\n\n                if (overlap <= 0) {\n                    // can not be intersecting\n                    break;\n                }\n            } \n        }\n\n        result.axis = axes[overlapAxisNumber];\n        result.overlap = overlapMin;\n    };\n\n    /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {vector} normal\n     * @param {number} direction\n     * @return [vector]\n     */\n    Collision._findSupports = function(bodyA, bodyB, normal, direction) {\n        var vertices = bodyB.vertices,\n            verticesLength = vertices.length,\n            bodyAPositionX = bodyA.position.x,\n            bodyAPositionY = bodyA.position.y,\n            normalX = normal.x * direction,\n            normalY = normal.y * direction,\n            vertexA = vertices[0],\n            vertexB = vertexA,\n            nearestDistance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y),\n            vertexC,\n            distance,\n            j;\n\n        // find deepest vertex relative to the axis\n        for (j = 1; j < verticesLength; j += 1) {\n            vertexB = vertices[j];\n            distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);\n\n            // convex hill-climbing\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                vertexA = vertexB;\n            }\n        }\n\n        // measure next vertex\n        vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];\n        nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);\n\n        // compare with previous vertex\n        vertexB = vertices[(vertexA.index + 1) % verticesLength];\n        if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {\n            _supports[0] = vertexA;\n            _supports[1] = vertexB;\n\n            return _supports;\n        }\n\n        _supports[0] = vertexA;\n        _supports[1] = vertexC;\n\n        return _supports;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A reference to the pair using this collision record, if there is one.\n     *\n     * @property pair\n     * @type {pair|null}\n     * @default null\n     */\n\n    /**\n     * A flag that indicates if the bodies were colliding when the collision was last updated.\n     * \n     * @property collided\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The first body part represented by the collision (see also `collision.parentA`).\n     * \n     * @property bodyA\n     * @type body\n     */\n\n    /**\n     * The second body part represented by the collision (see also `collision.parentB`).\n     * \n     * @property bodyB\n     * @type body\n     */\n\n    /**\n     * The first body represented by the collision (i.e. `collision.bodyA.parent`).\n     * \n     * @property parentA\n     * @type body\n     */\n\n    /**\n     * The second body represented by the collision (i.e. `collision.bodyB.parent`).\n     * \n     * @property parentB\n     * @type body\n     */\n\n    /**\n     * A `Number` that represents the minimum separating distance between the bodies along the collision normal.\n     *\n     * @readOnly\n     * @property depth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance.\n     *\n     * @property normal\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A normalised `Vector` that is the tangent direction to the collision normal.\n     *\n     * @property tangent\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that represents the direction and depth of the collision.\n     *\n     * @property penetration\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * An array of body vertices that represent the support points in the collision.\n     * \n     * _Note:_ Only the first `collision.supportCount` items of `collision.supports` are active.\n     * Therefore use `collision.supportCount` instead of `collision.supports.length` when iterating the active supports.\n     * \n     * These are the deepest vertices (along the collision normal) of each body that are contained by the other body's vertices.\n     *\n     * @property supports\n     * @type vector[]\n     * @default []\n     */\n\n    /**\n     * The number of active supports for this collision found in `collision.supports`.\n     * \n     * _Note:_ Only the first `collision.supportCount` items of `collision.supports` are active.\n     * Therefore use `collision.supportCount` instead of `collision.supports.length` when iterating the active supports.\n     *\n     * @property supportCount\n     * @type number\n     * @default 0\n     */\n\n})();\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/\n\nvar Pair = {};\n\nmodule.exports = Pair;\n\nvar Contact = __webpack_require__(16);\n\n(function() {\n    \n    /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */\n    Pair.create = function(collision, timestamp) {\n        var bodyA = collision.bodyA,\n            bodyB = collision.bodyB;\n\n        var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            collision: collision,\n            contacts: [Contact.create(), Contact.create()],\n            contactCount: 0,\n            separation: 0,\n            isActive: true,\n            isSensor: bodyA.isSensor || bodyB.isSensor,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: 0,\n            friction: 0,\n            frictionStatic: 0,\n            restitution: 0,\n            slop: 0\n        };\n\n        Pair.update(pair, collision, timestamp);\n\n        return pair;\n    };\n\n    /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */\n    Pair.update = function(pair, collision, timestamp) {\n        var supports = collision.supports,\n            supportCount = collision.supportCount,\n            contacts = pair.contacts,\n            parentA = collision.parentA,\n            parentB = collision.parentB;\n        \n        pair.isActive = true;\n        pair.timeUpdated = timestamp;\n        pair.collision = collision;\n        pair.separation = collision.depth;\n        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n        pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;\n        pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;\n        pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;\n        pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;\n\n        pair.contactCount = supportCount;\n        collision.pair = pair;\n\n        var supportA = supports[0],\n            contactA = contacts[0],\n            supportB = supports[1],\n            contactB = contacts[1];\n\n        // match contacts to supports\n        if (contactB.vertex === supportA || contactA.vertex === supportB) {\n            contacts[1] = contactA;\n            contacts[0] = contactA = contactB;\n            contactB = contacts[1];\n        }\n\n        // update contacts\n        contactA.vertex = supportA;\n        contactB.vertex = supportB;\n    };\n    \n    /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */\n    Pair.setActive = function(pair, isActive, timestamp) {\n        if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n        } else {\n            pair.isActive = false;\n            pair.contactCount = 0;\n        }\n    };\n\n    /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */\n    Pair.id = function(bodyA, bodyB) {\n        return bodyA.id < bodyB.id ? bodyA.id.toString(36) + ':' + bodyB.id.toString(36) \n            : bodyB.id.toString(36) + ':' + bodyA.id.toString(36);\n    };\n\n})();\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/\n\nvar Constraint = {};\n\nmodule.exports = Constraint;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(11);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Constraint._warming = 0.4;\n    Constraint._torqueDampen = 1;\n    Constraint._minLength = 0.000001;\n\n    /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */\n    Constraint.create = function(options) {\n        var constraint = options;\n\n        // if bodies defined but no points, use body centre\n        if (constraint.bodyA && !constraint.pointA)\n            constraint.pointA = { x: 0, y: 0 };\n        if (constraint.bodyB && !constraint.pointB)\n            constraint.pointB = { x: 0, y: 0 };\n\n        // calculate static length using initial world space points\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n    \n        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\n\n        // option defaults\n        constraint.id = constraint.id || Common.nextId();\n        constraint.label = constraint.label || 'Constraint';\n        constraint.type = 'constraint';\n        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n        constraint.damping = constraint.damping || 0;\n        constraint.angularStiffness = constraint.angularStiffness || 0;\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n        constraint.plugin = {};\n\n        // render\n        var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#ffffff',\n            type: 'line',\n            anchors: true\n        };\n\n        if (constraint.length === 0 && constraint.stiffness > 0.1) {\n            render.type = 'pin';\n            render.anchors = false;\n        } else if (constraint.stiffness < 0.9) {\n            render.type = 'spring';\n        }\n\n        constraint.render = Common.extend(render, constraint.render);\n\n        return constraint;\n    };\n\n    /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.preSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            body.position.x += impulse.x;\n            body.position.y += impulse.y;\n            body.angle += impulse.angle;\n        }\n    };\n\n    /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} delta\n     */\n    Constraint.solveAll = function(constraints, delta) {\n        var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);\n\n        // Solve fixed constraints first.\n        for (var i = 0; i < constraints.length; i += 1) {\n            var constraint = constraints[i],\n                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),\n                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (fixedA || fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n\n        // Solve free constraints last.\n        for (i = 0; i < constraints.length; i += 1) {\n            constraint = constraints[i];\n            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);\n            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (!fixedA && !fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n    };\n\n    /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */\n    Constraint.solve = function(constraint, timeScale) {\n        var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n\n        if (!bodyA && !bodyB)\n            return;\n\n        // update reference angle\n        if (bodyA && !bodyA.isStatic) {\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n            constraint.angleA = bodyA.angle;\n        }\n        \n        // update reference angle\n        if (bodyB && !bodyB.isStatic) {\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n            constraint.angleB = bodyB.angle;\n        }\n\n        var pointAWorld = pointA,\n            pointBWorld = pointB;\n\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n\n        if (!pointAWorld || !pointBWorld)\n            return;\n\n        var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n        // prevent singularity\n        if (currentLength < Constraint._minLength) {\n            currentLength = Constraint._minLength;\n        }\n\n        // solve distance constraint with Gauss-Siedel method\n        var difference = (currentLength - constraint.length) / currentLength,\n            isRigid = constraint.stiffness >= 1 || constraint.length === 0,\n            stiffness = isRigid ? constraint.stiffness * timeScale \n                : constraint.stiffness * timeScale * timeScale,\n            damping = constraint.damping * timeScale,\n            force = Vector.mult(delta, difference * stiffness),\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\n            resistanceTotal = massTotal + inertiaTotal,\n            torque,\n            share,\n            normal,\n            normalVelocity,\n            relativeVelocity;\n    \n        if (damping > 0) {\n            var zero = Vector.create();\n            normal = Vector.div(delta, currentLength);\n\n            relativeVelocity = Vector.sub(\n                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,\n                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero\n            );\n\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        }\n\n        if (bodyA && !bodyA.isStatic) {\n            share = bodyA.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x * share;\n            bodyA.constraintImpulse.y -= force.y * share;\n\n            // apply forces\n            bodyA.position.x -= force.x * share;\n            bodyA.position.y -= force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n                bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;\n                bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n            bodyA.constraintImpulse.angle -= torque;\n            bodyA.angle -= torque;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            share = bodyB.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x * share;\n            bodyB.constraintImpulse.y += force.y * share;\n            \n            // apply forces\n            bodyB.position.x += force.x * share;\n            bodyB.position.y += force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n                bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;\n                bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n            bodyB.constraintImpulse.angle += torque;\n            bodyB.angle += torque;\n        }\n\n    };\n\n    /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.postSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            Sleeping.set(body, false);\n\n            // update geometry and reset\n            for (var j = 0; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                \n                Vertices.translate(part.vertices, impulse);\n\n                if (j > 0) {\n                    part.position.x += impulse.x;\n                    part.position.y += impulse.y;\n                }\n\n                if (impulse.angle !== 0) {\n                    Vertices.rotate(part.vertices, impulse.angle, body.position);\n                    Axes.rotate(part.axes, impulse.angle);\n                    if (j > 0) {\n                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                    }\n                }\n\n                Bounds.update(part.bounds, part.vertices, body.velocity);\n            }\n\n            // dampen the cached impulse for warming next step\n            impulse.angle *= Constraint._warming;\n            impulse.x *= Constraint._warming;\n            impulse.y *= Constraint._warming;\n        }\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointAWorld = function(constraint) {\n        return {\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) \n                + (constraint.pointA ? constraint.pointA.x : 0),\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) \n                + (constraint.pointA ? constraint.pointA.y : 0)\n        };\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointBWorld = function(constraint) {\n        return {\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) \n                + (constraint.pointB ? constraint.pointB.x : 0),\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) \n                + (constraint.pointB ? constraint.pointB.y : 0)\n        };\n    };\n\n    /**\n     * Returns the current length of the constraint. \n     * This is the distance between both of the constraint's end points.\n     * See `constraint.length` for the target rest length.\n     * @method currentLength\n     * @param {constraint} constraint\n     * @returns {number} the current length\n     */\n    Constraint.currentLength = function(constraint) {\n        var pointAX = (constraint.bodyA ? constraint.bodyA.position.x : 0) \n            + (constraint.pointA ? constraint.pointA.x : 0);\n\n        var pointAY = (constraint.bodyA ? constraint.bodyA.position.y : 0) \n            + (constraint.pointA ? constraint.pointA.y : 0);\n\n        var pointBX = (constraint.bodyB ? constraint.bodyB.position.x : 0) \n            + (constraint.pointB ? constraint.pointB.x : 0);\n            \n        var pointBY = (constraint.bodyB ? constraint.bodyB.position.y : 0) \n            + (constraint.pointB ? constraint.pointB.y : 0);\n\n        var deltaX = pointAX - pointBX;\n        var deltaY = pointAY - pointBY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */\n\n    /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/\n\nvar Axes = {};\n\nmodule.exports = Axes;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */\n    Axes.fromVertices = function(vertices) {\n        var axes = {};\n\n        // find the unique axes, using edge normal gradients\n        for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length, \n                normal = Vector.normalise({ \n                    x: vertices[j].y - vertices[i].y, \n                    y: vertices[i].x - vertices[j].x\n                }),\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\n            \n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n            axes[gradient] = normal;\n        }\n\n        return Common.values(axes);\n    };\n\n    /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */\n    Axes.rotate = function(axes, angle) {\n        if (angle === 0)\n            return;\n        \n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n                xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/\n\n// TODO: true circle bodies\n\nvar Bodies = {};\n\nmodule.exports = Bodies;\n\nvar Vertices = __webpack_require__(3);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(4);\nvar Bounds = __webpack_require__(1);\nvar Vector = __webpack_require__(2);\n\n(function() {\n\n    /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */\n    Bodies.rectangle = function(x, y, width, height, options) {\n        options = options || {};\n\n        var rectangle = { \n            label: 'Rectangle Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, rectangle, options));\n    };\n    \n    /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The `slope` is parameterised as a fraction of `width` and must be < 1 to form a valid trapezoid. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope Must be a number < 1.\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\n        options = options || {};\n\n        if (slope >= 1) {\n            Common.warn('Bodies.trapezoid: slope parameter must be < 1.');\n        }\n\n        slope *= 0.5;\n        var roof = (1 - (slope * 2)) * width;\n        \n        var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1,\n            verticesPath;\n\n        if (slope < 0.5) {\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        } else {\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        }\n\n        var trapezoid = { \n            label: 'Trapezoid Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(verticesPath)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, trapezoid, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */\n    Bodies.circle = function(x, y, radius, options, maxSides) {\n        options = options || {};\n\n        var circle = {\n            label: 'Circle Body',\n            circleRadius: radius\n        };\n        \n        // approximate circles with polygons until true circles implemented in SAT\n        maxSides = maxSides || 25;\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n        // optimisation: always use even number of sides (half the number of unique axes)\n        if (sides % 2 === 1)\n            sides += 1;\n\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */\n    Bodies.polygon = function(x, y, sides, radius, options) {\n        options = options || {};\n\n        if (sides < 3)\n            return Bodies.circle(x, y, radius, options);\n\n        var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n\n        for (var i = 0; i < sides; i += 1) {\n            var angle = offset + (i * theta),\n                xx = Math.cos(angle) * radius,\n                yy = Math.sin(angle) * radius;\n\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n        }\n\n        var polygon = { \n            label: 'Polygon Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(path)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, polygon, options));\n    };\n\n    /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n        var decomp = Common.getDecomp(),\n            canDecomp,\n            body,\n            parts,\n            isConvex,\n            isConcave,\n            vertices,\n            i,\n            j,\n            k,\n            v,\n            z;\n\n        // check decomp is as expected\n        canDecomp = Boolean(decomp && decomp.quickDecomp);\n\n        options = options || {};\n        parts = [];\n\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n        removeDuplicatePoints = typeof removeDuplicatePoints !== 'undefined' ? removeDuplicatePoints : 0.01;\n\n        // ensure vertexSets is an array of arrays\n        if (!Common.isArray(vertexSets[0])) {\n            vertexSets = [vertexSets];\n        }\n\n        for (v = 0; v < vertexSets.length; v += 1) {\n            vertices = vertexSets[v];\n            isConvex = Vertices.isConvex(vertices);\n            isConcave = !isConvex;\n\n            if (isConcave && !canDecomp) {\n                Common.warnOnce(\n                    'Bodies.fromVertices: Install the \\'poly-decomp\\' library and use Common.setDecomp or provide \\'decomp\\' as a global to decompose concave vertices.'\n                );\n            }\n\n            if (isConvex || !canDecomp) {\n                if (isConvex) {\n                    vertices = Vertices.clockwiseSort(vertices);\n                } else {\n                    // fallback to convex hull when decomposition is not possible\n                    vertices = Vertices.hull(vertices);\n                }\n\n                parts.push({\n                    position: { x: x, y: y },\n                    vertices: vertices\n                });\n            } else {\n                // initialise a decomposition\n                var concave = vertices.map(function(vertex) {\n                    return [vertex.x, vertex.y];\n                });\n\n                // vertices are concave and simple, we can decompose into parts\n                decomp.makeCCW(concave);\n                if (removeCollinear !== false)\n                    decomp.removeCollinearPoints(concave, removeCollinear);\n                if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)\n                    decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n\n                // use the quick decomposition algorithm (Bayazit)\n                var decomposed = decomp.quickDecomp(concave);\n\n                // for each decomposed chunk\n                for (i = 0; i < decomposed.length; i++) {\n                    var chunk = decomposed[i];\n\n                    // convert vertices into the correct structure\n                    var chunkVertices = chunk.map(function(vertices) {\n                        return {\n                            x: vertices[0],\n                            y: vertices[1]\n                        };\n                    });\n\n                    // skip small chunks\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\n                        continue;\n\n                    // create a compound part\n                    parts.push({\n                        position: Vertices.centre(chunkVertices),\n                        vertices: chunkVertices\n                    });\n                }\n            }\n        }\n\n        // create body parts\n        for (i = 0; i < parts.length; i++) {\n            parts[i] = Body.create(Common.extend(parts[i], options));\n        }\n\n        // flag internal edges (coincident part edges)\n        if (flagInternal) {\n            var coincident_max_dist = 5;\n\n            for (i = 0; i < parts.length; i++) {\n                var partA = parts[i];\n\n                for (j = i + 1; j < parts.length; j++) {\n                    var partB = parts[j];\n\n                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                        var pav = partA.vertices,\n                            pbv = partB.vertices;\n\n                        // iterate vertices of both parts\n                        for (k = 0; k < partA.vertices.length; k++) {\n                            for (z = 0; z < partB.vertices.length; z++) {\n                                // find distances between the vertices\n                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n\n                                // if both vertices are very close, consider the edge concident (internal)\n                                if (da < coincident_max_dist && db < coincident_max_dist) {\n                                    pav[k].isInternal = true;\n                                    pbv[z].isInternal = true;\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        if (parts.length > 1) {\n            // create the parent body to be returned, that contains generated compound parts\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\n\n            // offset such that body.position is at the centre off mass\n            Body.setPosition(body, { x: x, y: y });\n\n            return body;\n        } else {\n            return parts[0];\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Detector` module contains methods for efficiently detecting collisions between a list of bodies using a broadphase algorithm.\n*\n* @class Detector\n*/\n\nvar Detector = {};\n\nmodule.exports = Detector;\n\nvar Common = __webpack_require__(0);\nvar Collision = __webpack_require__(8);\n\n(function() {\n\n    /**\n     * Creates a new collision detector.\n     * @method create\n     * @param {} options\n     * @return {detector} A new collision detector\n     */\n    Detector.create = function(options) {\n        var defaults = {\n            bodies: [],\n            collisions: [],\n            pairs: null\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * Sets the list of bodies in the detector.\n     * @method setBodies\n     * @param {detector} detector\n     * @param {body[]} bodies\n     */\n    Detector.setBodies = function(detector, bodies) {\n        detector.bodies = bodies.slice(0);\n    };\n\n    /**\n     * Clears the detector including its list of bodies.\n     * @method clear\n     * @param {detector} detector\n     */\n    Detector.clear = function(detector) {\n        detector.bodies = [];\n        detector.collisions = [];\n    };\n\n    /**\n     * Efficiently finds all collisions among all the bodies in `detector.bodies` using a broadphase algorithm.\n     * \n     * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance reasons.\n     * If a specific ordering is required then apply a sort to the resulting array.\n     * @method collisions\n     * @param {detector} detector\n     * @return {collision[]} collisions\n     */\n    Detector.collisions = function(detector) {\n        var pairs = detector.pairs,\n            bodies = detector.bodies,\n            bodiesLength = bodies.length,\n            canCollide = Detector.canCollide,\n            collides = Collision.collides,\n            collisions = detector.collisions,\n            collisionIndex = 0,\n            i,\n            j;\n\n        bodies.sort(Detector._compareBoundsX);\n\n        for (i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n                boundsA = bodyA.bounds,\n                boundXMax = bodyA.bounds.max.x,\n                boundYMax = bodyA.bounds.max.y,\n                boundYMin = bodyA.bounds.min.y,\n                bodyAStatic = bodyA.isStatic || bodyA.isSleeping,\n                partsALength = bodyA.parts.length,\n                partsASingle = partsALength === 1;\n\n            for (j = i + 1; j < bodiesLength; j++) {\n                var bodyB = bodies[j],\n                    boundsB = bodyB.bounds;\n\n                if (boundsB.min.x > boundXMax) {\n                    break;\n                }\n\n                if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {\n                    continue;\n                }\n\n                if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {\n                    continue;\n                }\n\n                if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {\n                    continue;\n                }\n\n                var partsBLength = bodyB.parts.length;\n\n                if (partsASingle && partsBLength === 1) {\n                    var collision = collides(bodyA, bodyB, pairs);\n\n                    if (collision) {\n                        collisions[collisionIndex++] = collision;\n                    }\n                } else {\n                    var partsAStart = partsALength > 1 ? 1 : 0,\n                        partsBStart = partsBLength > 1 ? 1 : 0;\n                    \n                    for (var k = partsAStart; k < partsALength; k++) {\n                        var partA = bodyA.parts[k],\n                            boundsA = partA.bounds;\n\n                        for (var z = partsBStart; z < partsBLength; z++) {\n                            var partB = bodyB.parts[z],\n                                boundsB = partB.bounds;\n\n                            if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x\n                                || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {\n                                continue;\n                            }\n\n                            var collision = collides(partA, partB, pairs);\n\n                            if (collision) {\n                                collisions[collisionIndex++] = collision;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (collisions.length !== collisionIndex) {\n            collisions.length = collisionIndex;\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */\n    Detector.canCollide = function(filterA, filterB) {\n        if (filterA.group === filterB.group && filterA.group !== 0)\n            return filterA.group > 0;\n\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n    };\n\n    /**\n     * The comparison function used in the broadphase algorithm.\n     * Returns the signed delta of the bodies bounds on the x-axis.\n     * @private\n     * @method _sortCompare\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {number} The signed delta used for sorting\n     */\n    Detector._compareBoundsX = function(bodyA, bodyB) {\n        return bodyA.bounds.min.x - bodyB.bounds.min.x;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * The array of `Matter.Body` between which the detector finds collisions.\n     * \n     * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector.\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * The array of `Matter.Collision` found in the last call to `Detector.collisions` on this detector.\n     * @property collisions\n     * @type collision[]\n     * @default []\n     */\n\n    /**\n     * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage.\n     * @property pairs\n     * @type {pairs|null}\n     * @default null\n     */\n\n})();\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/\n\nvar Mouse = {};\n\nmodule.exports = Mouse;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */\n    Mouse.create = function(element) {\n        var mouse = {};\n\n        if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n        }\n        \n        mouse.element = element || document.body;\n        mouse.absolute = { x: 0, y: 0 };\n        mouse.position = { x: 0, y: 0 };\n        mouse.mousedownPosition = { x: 0, y: 0 };\n        mouse.mouseupPosition = { x: 0, y: 0 };\n        mouse.offset = { x: 0, y: 0 };\n        mouse.scale = { x: 1, y: 1 };\n        mouse.wheelDelta = 0;\n        mouse.button = -1;\n        mouse.pixelRatio = parseInt(mouse.element.getAttribute('data-pixel-ratio'), 10) || 1;\n\n        mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n        };\n        \n        mouse.mousemove = function(event) { \n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n        };\n        \n        mouse.mousedown = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            } else {\n                mouse.button = event.button;\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n        };\n        \n        mouse.mouseup = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                event.preventDefault();\n            }\n            \n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n        };\n\n        mouse.mousewheel = function(event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n            mouse.sourceEvents.mousewheel = event;\n        };\n\n        Mouse.setElement(mouse, mouse.element);\n\n        return mouse;\n    };\n\n    /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */\n    Mouse.setElement = function(mouse, element) {\n        mouse.element = element;\n\n        element.addEventListener('mousemove', mouse.mousemove, { passive: true });\n        element.addEventListener('mousedown', mouse.mousedown, { passive: true });\n        element.addEventListener('mouseup', mouse.mouseup, { passive: true });\n        \n        element.addEventListener('wheel', mouse.mousewheel, { passive: false });\n        \n        element.addEventListener('touchmove', mouse.mousemove, { passive: false });\n        element.addEventListener('touchstart', mouse.mousedown, { passive: false });\n        element.addEventListener('touchend', mouse.mouseup, { passive: false });\n    };\n\n    /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */\n    Mouse.clearSourceEvents = function(mouse) {\n        mouse.sourceEvents.mousemove = null;\n        mouse.sourceEvents.mousedown = null;\n        mouse.sourceEvents.mouseup = null;\n        mouse.sourceEvents.mousewheel = null;\n        mouse.wheelDelta = 0;\n    };\n\n    /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */\n    Mouse.setOffset = function(mouse, offset) {\n        mouse.offset.x = offset.x;\n        mouse.offset.y = offset.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */\n    Mouse.setScale = function(mouse, scale) {\n        mouse.scale.x = scale.x;\n        mouse.scale.y = scale.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n    \n    /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */\n    Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n        var elementBounds = element.getBoundingClientRect(),\n            rootNode = (document.documentElement || document.body.parentNode || document.body),\n            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x, y;\n        \n        if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n        } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n        }\n\n        return { \n            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/\n\nvar Plugin = {};\n\nmodule.exports = Plugin;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Plugin._registry = {};\n\n    /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */\n    Plugin.register = function(plugin) {\n        if (!Plugin.isPlugin(plugin)) {\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\n        }\n\n        if (plugin.name in Plugin._registry) {\n            var registered = Plugin._registry[plugin.name],\n                pluginVersion = Plugin.versionParse(plugin.version).number,\n                registeredVersion = Plugin.versionParse(registered.version).number;\n\n            if (pluginVersion > registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\n                Plugin._registry[plugin.name] = plugin;\n            } else if (pluginVersion < registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\n            } else if (plugin !== registered) {\n                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\n            }\n        } else {\n            Plugin._registry[plugin.name] = plugin;\n        }\n\n        return plugin;\n    };\n\n    /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */\n    Plugin.resolve = function(dependency) {\n        return Plugin._registry[Plugin.dependencyParse(dependency).name];\n    };\n\n    /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */\n    Plugin.toString = function(plugin) {\n        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\n    };\n\n    /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */\n    Plugin.isPlugin = function(obj) {\n        return obj && obj.name && obj.version && obj.install;\n    };\n\n    /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */\n    Plugin.isUsed = function(module, name) {\n        return module.used.indexOf(name) > -1;\n    };\n\n    /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */\n    Plugin.isFor = function(plugin, module) {\n        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));\n    };\n\n    /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick \u2705 indicates a dependency was resolved and installed.\n     * - An orange diamond \uD83D\uDD36 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross \u274C indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */\n    Plugin.use = function(module, plugins) {\n        module.uses = (module.uses || []).concat(plugins || []);\n\n        if (module.uses.length === 0) {\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\n            return;\n        }\n\n        var dependencies = Plugin.dependencies(module),\n            sortedDependencies = Common.topologicalSort(dependencies),\n            status = [];\n\n        for (var i = 0; i < sortedDependencies.length; i += 1) {\n            if (sortedDependencies[i] === module.name) {\n                continue;\n            }\n\n            var plugin = Plugin.resolve(sortedDependencies[i]);\n\n            if (!plugin) {\n                status.push('\u274C ' + sortedDependencies[i]);\n                continue;\n            }\n\n            if (Plugin.isUsed(module, plugin.name)) {\n                continue;\n            }\n\n            if (!Plugin.isFor(plugin, module)) {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\n                plugin._warned = true;\n            }\n\n            if (plugin.install) {\n                plugin.install(module);\n            } else {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\n                plugin._warned = true;\n            }\n\n            if (plugin._warned) {\n                status.push('\uD83D\uDD36 ' + Plugin.toString(plugin));\n                delete plugin._warned;\n            } else {\n                status.push('\u2705 ' + Plugin.toString(plugin));\n            }\n\n            module.used.push(plugin.name);\n        }\n\n        if (status.length > 0) {\n            Common.info(status.join('  '));\n        }\n    };\n\n    /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */\n    Plugin.dependencies = function(module, tracked) {\n        var parsedBase = Plugin.dependencyParse(module),\n            name = parsedBase.name;\n\n        tracked = tracked || {};\n\n        if (name in tracked) {\n            return;\n        }\n\n        module = Plugin.resolve(module) || module;\n\n        tracked[name] = Common.map(module.uses || [], function(dependency) {\n            if (Plugin.isPlugin(dependency)) {\n                Plugin.register(dependency);\n            }\n\n            var parsed = Plugin.dependencyParse(dependency),\n                resolved = Plugin.resolve(dependency);\n\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',\n                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'\n                );\n\n                resolved._warned = true;\n                module._warned = true;\n            } else if (!resolved) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',\n                    Plugin.toString(parsedBase), 'could not be resolved.'\n                );\n\n                module._warned = true;\n            }\n\n            return parsed.name;\n        });\n\n        for (var i = 0; i < tracked[name].length; i += 1) {\n            Plugin.dependencies(tracked[name][i], tracked);\n        }\n\n        return tracked;\n    };\n\n    /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */\n    Plugin.dependencyParse = function(dependency) {\n        if (Common.isString(dependency)) {\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-+]+)?))?$/;\n\n            if (!pattern.test(dependency)) {\n                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\n            }\n\n            return {\n                name: dependency.split('@')[0],\n                range: dependency.split('@')[1] || '*'\n            };\n        }\n\n        return {\n            name: dependency.name,\n            range: dependency.range || dependency.version\n        };\n    };\n\n    /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */\n    Plugin.versionParse = function(range) {\n        var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-+]+)?$/;\n\n        if (!pattern.test(range)) {\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\n        }\n\n        var parts = pattern.exec(range);\n        var major = Number(parts[4]);\n        var minor = Number(parts[5]);\n        var patch = Number(parts[6]);\n\n        return {\n            isRange: Boolean(parts[1] || parts[2]),\n            version: parts[3],\n            range: range,\n            operator: parts[1] || parts[2] || '',\n            major: major,\n            minor: minor,\n            patch: patch,\n            parts: [major, minor, patch],\n            prerelease: parts[7],\n            number: major * 1e8 + minor * 1e4 + patch\n        };\n    };\n\n    /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */\n    Plugin.versionSatisfies = function(version, range) {\n        range = range || '*';\n\n        var r = Plugin.versionParse(range),\n            v = Plugin.versionParse(version);\n\n        if (r.isRange) {\n            if (r.operator === '*' || version === '*') {\n                return true;\n            }\n\n            if (r.operator === '>') {\n                return v.number > r.number;\n            }\n\n            if (r.operator === '>=') {\n                return v.number >= r.number;\n            }\n\n            if (r.operator === '~') {\n                return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n            }\n\n            if (r.operator === '^') {\n                if (r.major > 0) {\n                    return v.major === r.major && v.number >= r.number;\n                }\n\n                if (r.minor > 0) {\n                    return v.minor === r.minor && v.patch >= r.patch;\n                }\n\n                return v.patch === r.patch;\n            }\n        }\n\n        return version === range || version === '*';\n    };\n\n})();\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/\n\nvar Contact = {};\n\nmodule.exports = Contact;\n\n(function() {\n\n    /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} [vertex]\n     * @return {contact} A new contact\n     */\n    Contact.create = function(vertex) {\n        return {\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/\n\nvar Engine = {};\n\nmodule.exports = Engine;\n\nvar Sleeping = __webpack_require__(7);\nvar Resolver = __webpack_require__(18);\nvar Detector = __webpack_require__(13);\nvar Pairs = __webpack_require__(19);\nvar Events = __webpack_require__(5);\nvar Composite = __webpack_require__(6);\nvar Constraint = __webpack_require__(10);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(4);\n\n(function() {\n\n    Engine._deltaMax = 1000 / 60;\n\n    /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */\n    Engine.create = function(options) {\n        options = options || {};\n\n        var defaults = {\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            plugin: {},\n            gravity: {\n                x: 0,\n                y: 1,\n                scale: 0.001\n            },\n            timing: {\n                timestamp: 0,\n                timeScale: 1,\n                lastDelta: 0,\n                lastElapsed: 0,\n                lastUpdatesPerFrame: 0\n            }\n        };\n\n        var engine = Common.extend(defaults, options);\n\n        engine.world = options.world || Composite.create({ label: 'World' });\n        engine.pairs = options.pairs || Pairs.create();\n        engine.detector = options.detector || Detector.create();\n        engine.detector.pairs = engine.pairs;\n\n        // for temporary back compatibility only\n        engine.grid = { buckets: [] };\n        engine.world.gravity = engine.gravity;\n        engine.broadphase = engine.grid;\n        engine.metrics = {};\n        \n        return engine;\n    };\n\n    /**\n     * Moves the simulation forward in time by `delta` milliseconds.\n     * Triggers `beforeUpdate`, `beforeSolve` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     */\n    Engine.update = function(engine, delta) {\n        var startTime = Common.now();\n\n        var world = engine.world,\n            detector = engine.detector,\n            pairs = engine.pairs,\n            timing = engine.timing,\n            timestamp = timing.timestamp,\n            i;\n\n        // warn if high delta\n        if (delta > Engine._deltaMax) {\n            Common.warnOnce(\n                'Matter.Engine.update: delta argument is recommended to be less than or equal to', Engine._deltaMax.toFixed(3), 'ms.'\n            );\n        }\n\n        delta = typeof delta !== 'undefined' ? delta : Common._baseDelta;\n        delta *= timing.timeScale;\n\n        // increment timestamp\n        timing.timestamp += delta;\n        timing.lastDelta = delta;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp,\n            delta: delta\n        };\n\n        Events.trigger(engine, 'beforeUpdate', event);\n\n        // get all bodies and all constraints in the world\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n        // if the world has changed\n        if (world.isModified) {\n            // update the detector bodies\n            Detector.setBodies(detector, allBodies);\n\n            // reset all composite modified flags\n            Composite.setModified(world, false, false, true);\n        }\n\n        // update sleeping if enabled\n        if (engine.enableSleeping)\n            Sleeping.update(allBodies, delta);\n\n        // apply gravity to all bodies\n        Engine._bodiesApplyGravity(allBodies, engine.gravity);\n\n        // update all body position and rotation by integration\n        if (delta > 0) {\n            Engine._bodiesUpdate(allBodies, delta);\n        }\n\n        Events.trigger(engine, 'beforeSolve', event);\n\n        // update all constraints (first pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // find all collisions\n        var collisions = Detector.collisions(detector);\n\n        // update collision pairs\n        Pairs.update(pairs, collisions, timestamp);\n\n        // wake up bodies involved in collisions\n        if (engine.enableSleeping)\n            Sleeping.afterCollisions(pairs.list);\n\n        // trigger collision events\n        if (pairs.collisionStart.length > 0) {\n            Events.trigger(engine, 'collisionStart', { \n                pairs: pairs.collisionStart,\n                timestamp: timing.timestamp,\n                delta: delta\n            });\n        }\n\n        // iteratively resolve position between collisions\n        var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);\n        \n        Resolver.preSolvePosition(pairs.list);\n        for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, delta, positionDamping);\n        }\n        Resolver.postSolvePosition(allBodies);\n\n        // update all constraints (second pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // iteratively resolve velocity between collisions\n        Resolver.preSolveVelocity(pairs.list);\n        for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, delta);\n        }\n\n        // update body speed and velocity properties\n        Engine._bodiesUpdateVelocities(allBodies);\n\n        // trigger collision events\n        if (pairs.collisionActive.length > 0) {\n            Events.trigger(engine, 'collisionActive', { \n                pairs: pairs.collisionActive, \n                timestamp: timing.timestamp,\n                delta: delta\n            });\n        }\n\n        if (pairs.collisionEnd.length > 0) {\n            Events.trigger(engine, 'collisionEnd', {\n                pairs: pairs.collisionEnd,\n                timestamp: timing.timestamp,\n                delta: delta\n            });\n        }\n\n        // clear force buffers\n        Engine._bodiesClearForces(allBodies);\n\n        Events.trigger(engine, 'afterUpdate', event);\n\n        // log the time elapsed computing this update\n        engine.timing.lastElapsed = Common.now() - startTime;\n\n        return engine;\n    };\n    \n    /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.merge = function(engineA, engineB) {\n        Common.extend(engineA, engineB);\n        \n        if (engineB.world) {\n            engineA.world = engineB.world;\n\n            Engine.clear(engineA);\n\n            var bodies = Composite.allBodies(engineA.world);\n\n            for (var i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                Sleeping.set(body, false);\n                body.id = Common.nextId();\n            }\n        }\n    };\n\n    /**\n     * Clears the engine pairs and detector.\n     * @method clear\n     * @param {engine} engine\n     */\n    Engine.clear = function(engine) {\n        Pairs.clear(engine.pairs);\n        Detector.clear(engine.detector);\n    };\n\n    /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesClearForces = function(bodies) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n        }\n    };\n\n    /**\n     * Applies gravitational acceleration to all `bodies`.\n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet.\n     * \n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001,\n            bodiesLength = bodies.length;\n\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\n            return;\n        }\n        \n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // add the resultant force of gravity\n            body.force.y += body.mass * gravity.y * gravityScale;\n            body.force.x += body.mass * gravity.x * gravityScale;\n        }\n    };\n\n    /**\n     * Applies `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} delta The amount of time elapsed between updates\n     */\n    Engine._bodiesUpdate = function(bodies, delta) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            Body.update(body, delta);\n        }\n    };\n\n    /**\n     * Applies `Body.updateVelocities` to all given `bodies`.\n     * @method _bodiesUpdateVelocities\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesUpdateVelocities = function(bodies) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            Body.updateVelocities(bodies[i]);\n        }\n    };\n\n    /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */\n\n    /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after bodies updated based on their velocity and forces, but before any collision detection, constraints and resolving etc.\n    *\n    * @event beforeSolve\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */\n\n    /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */\n\n    /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */\n\n    /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     * \n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     * \n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     * \n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Matter.Detector` instance.\n     *\n     * @property detector\n     * @type detector\n     * @default a Matter.Detector instance\n     */\n\n    /**\n     * A `Matter.Grid` instance.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * An optional gravitational acceleration applied to all bodies in `engine.world` on every update.\n     * \n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet. For gravity in other contexts, disable this and apply forces as needed.\n     * \n     * To disable set the `scale` component to `0`.\n     * \n     * This is split into three components for ease of use:  \n     * a normalised direction (`x` and `y`) and magnitude (`scale`).\n     *\n     * @property gravity\n     * @type object\n     */\n\n    /**\n     * The gravitational direction normal `x` component, to be multiplied by `gravity.scale`.\n     * \n     * @property gravity.x\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * The gravitational direction normal `y` component, to be multiplied by `gravity.scale`.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * The magnitude of the gravitational acceleration.\n     * \n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */\n\n})();\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/\n\nvar Resolver = {};\n\nmodule.exports = Resolver;\n\nvar Vertices = __webpack_require__(3);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    Resolver._restingThresh = 2;\n    Resolver._restingThreshTangent = Math.sqrt(6);\n    Resolver._positionDampen = 0.9;\n    Resolver._positionWarming = 0.8;\n    Resolver._frictionNormalMultiplier = 5;\n    Resolver._frictionMaxStatic = Number.MAX_VALUE;\n\n    /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolvePosition = function(pairs) {\n        var i,\n            pair,\n            contactCount,\n            pairsLength = pairs.length;\n\n        // find total contacts on each body\n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive)\n                continue;\n            \n            contactCount = pair.contactCount;\n            pair.collision.parentA.totalContacts += contactCount;\n            pair.collision.parentB.totalContacts += contactCount;\n        }\n    };\n\n    /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} delta\n     * @param {number} [damping=1]\n     */\n    Resolver.solvePosition = function(pairs, delta, damping) {\n        var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            contactShare,\n            positionImpulse,\n            positionDampen = Resolver._positionDampen * (damping || 1),\n            slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1),\n            pairsLength = pairs.length;\n\n        // find impulses required to resolve penetration\n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            pair.separation = \n                collision.depth + normal.x * (bodyB.positionImpulse.x - bodyA.positionImpulse.x)\n                + normal.y * (bodyB.positionImpulse.y - bodyA.positionImpulse.y);\n        }\n        \n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            positionImpulse = pair.separation - pair.slop * slopDampen;\n\n            if (bodyA.isStatic || bodyB.isStatic)\n                positionImpulse *= 2;\n            \n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                contactShare = positionDampen / bodyA.totalContacts;\n                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n            }\n\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                contactShare = positionDampen / bodyB.totalContacts;\n                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n            }\n        }\n    };\n\n    /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */\n    Resolver.postSolvePosition = function(bodies) {\n        var positionWarming = Resolver._positionWarming,\n            bodiesLength = bodies.length,\n            verticesTranslate = Vertices.translate,\n            boundsUpdate = Bounds.update;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i],\n                positionImpulse = body.positionImpulse,\n                positionImpulseX = positionImpulse.x,\n                positionImpulseY = positionImpulse.y,\n                velocity = body.velocity;\n\n            // reset contact count\n            body.totalContacts = 0;\n\n            if (positionImpulseX !== 0 || positionImpulseY !== 0) {\n                // update body geometry\n                for (var j = 0; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n                    verticesTranslate(part.vertices, positionImpulse);\n                    boundsUpdate(part.bounds, part.vertices, velocity);\n                    part.position.x += positionImpulseX;\n                    part.position.y += positionImpulseY;\n                }\n\n                // move the body without changing velocity\n                body.positionPrev.x += positionImpulseX;\n                body.positionPrev.y += positionImpulseY;\n\n                if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {\n                    // reset cached impulse if the body has velocity along it\n                    positionImpulse.x = 0;\n                    positionImpulse.y = 0;\n                } else {\n                    // warm the next iteration\n                    positionImpulse.x *= positionWarming;\n                    positionImpulse.y *= positionWarming;\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolveVelocity = function(pairs) {\n        var pairsLength = pairs.length,\n            i,\n            j;\n        \n        for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var contacts = pair.contacts,\n                contactCount = pair.contactCount,\n                collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                normal = collision.normal,\n                tangent = collision.tangent;\n    \n            // resolve each contact\n            for (j = 0; j < contactCount; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex,\n                    normalImpulse = contact.normalImpulse,\n                    tangentImpulse = contact.tangentImpulse;\n    \n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                    // total impulse from contact\n                    var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse,\n                        impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;\n                    \n                    // apply impulse from contact\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                        bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                        bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                        bodyA.anglePrev += bodyA.inverseInertia * (\n                            (contactVertex.x - bodyA.position.x) * impulseY\n                            - (contactVertex.y - bodyA.position.y) * impulseX\n                        );\n                    }\n    \n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                        bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                        bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                        bodyB.anglePrev -= bodyB.inverseInertia * (\n                            (contactVertex.x - bodyB.position.x) * impulseY \n                            - (contactVertex.y - bodyB.position.y) * impulseX\n                        );\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} delta\n     */\n    Resolver.solveVelocity = function(pairs, delta) {\n        var timeScale = delta / Common._baseDelta,\n            timeScaleSquared = timeScale * timeScale,\n            timeScaleCubed = timeScaleSquared * timeScale,\n            restingThresh = -Resolver._restingThresh * timeScale,\n            restingThreshTangent = Resolver._restingThreshTangent,\n            frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale,\n            frictionMaxStatic = Resolver._frictionMaxStatic,\n            pairsLength = pairs.length,\n            tangentImpulse,\n            maxFriction,\n            i,\n            j;\n\n        for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                normalX = collision.normal.x,\n                normalY = collision.normal.y,\n                tangentX = collision.tangent.x,\n                tangentY = collision.tangent.y,\n                inverseMassTotal = pair.inverseMass,\n                friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier,\n                contacts = pair.contacts,\n                contactCount = pair.contactCount,\n                contactShare = 1 / contactCount;\n\n            // get body velocities\n            var bodyAVelocityX = bodyA.position.x - bodyA.positionPrev.x,\n                bodyAVelocityY = bodyA.position.y - bodyA.positionPrev.y,\n                bodyAAngularVelocity = bodyA.angle - bodyA.anglePrev,\n                bodyBVelocityX = bodyB.position.x - bodyB.positionPrev.x,\n                bodyBVelocityY = bodyB.position.y - bodyB.positionPrev.y,\n                bodyBAngularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (j = 0; j < contactCount; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex;\n\n                var offsetAX = contactVertex.x - bodyA.position.x,\n                    offsetAY = contactVertex.y - bodyA.position.y,\n                    offsetBX = contactVertex.x - bodyB.position.x,\n                    offsetBY = contactVertex.y - bodyB.position.y;\n \n                var velocityPointAX = bodyAVelocityX - offsetAY * bodyAAngularVelocity,\n                    velocityPointAY = bodyAVelocityY + offsetAX * bodyAAngularVelocity,\n                    velocityPointBX = bodyBVelocityX - offsetBY * bodyBAngularVelocity,\n                    velocityPointBY = bodyBVelocityY + offsetBX * bodyBAngularVelocity;\n\n                var relativeVelocityX = velocityPointAX - velocityPointBX,\n                    relativeVelocityY = velocityPointAY - velocityPointBY;\n\n                var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY,\n                    tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;\n\n                // coulomb friction\n                var normalOverlap = pair.separation + normalVelocity;\n                var normalForce = Math.min(normalOverlap, 1);\n                normalForce = normalOverlap < 0 ? 0 : normalForce;\n\n                var frictionLimit = normalForce * friction;\n\n                if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {\n                    maxFriction = (tangentVelocity > 0 ? tangentVelocity : -tangentVelocity);\n                    tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;\n                    \n                    if (tangentImpulse < -maxFriction) {\n                        tangentImpulse = -maxFriction;\n                    } else if (tangentImpulse > maxFriction) {\n                        tangentImpulse = maxFriction;\n                    }\n                } else {\n                    tangentImpulse = tangentVelocity;\n                    maxFriction = frictionMaxStatic;\n                }\n\n                // account for mass, inertia and contact offset\n                var oAcN = offsetAX * normalY - offsetAY * normalX,\n                    oBcN = offsetBX * normalY - offsetBY * normalX,\n                    share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n\n                // raw impulses\n                var normalImpulse = (1 + pair.restitution) * normalVelocity * share;\n                tangentImpulse *= share;\n\n                // handle high velocity and resting collisions separately\n                if (normalVelocity < restingThresh) {\n                    // high normal velocity so clear cached contact normal impulse\n                    contact.normalImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // impulse constraint tends to 0\n                    var contactNormalImpulse = contact.normalImpulse;\n                    contact.normalImpulse += normalImpulse;\n                    if (contact.normalImpulse > 0) contact.normalImpulse = 0;\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                }\n\n                // handle high velocity and resting collisions separately\n                if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {\n                    // high tangent velocity so clear cached contact tangent impulse\n                    contact.tangentImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                    var contactTangentImpulse = contact.tangentImpulse;\n                    contact.tangentImpulse += tangentImpulse;\n                    if (contact.tangentImpulse < -maxFriction) contact.tangentImpulse = -maxFriction;\n                    if (contact.tangentImpulse > maxFriction) contact.tangentImpulse = maxFriction;\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                }\n\n                // total impulse from contact\n                var impulseX = normalX * normalImpulse + tangentX * tangentImpulse,\n                    impulseY = normalY * normalImpulse + tangentY * tangentImpulse;\n                \n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                    bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                    bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/\n\nvar Pairs = {};\n\nmodule.exports = Pairs;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */\n    Pairs.create = function(options) {\n        return Common.extend({ \n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n        }, options);\n    };\n\n    /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */\n    Pairs.update = function(pairs, collisions, timestamp) {\n        var pairUpdate = Pair.update,\n            pairCreate = Pair.create,\n            pairSetActive = Pair.setActive,\n            pairsTable = pairs.table,\n            pairsList = pairs.list,\n            pairsListLength = pairsList.length,\n            pairsListIndex = pairsListLength,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            collisionsLength = collisions.length,\n            collisionStartIndex = 0,\n            collisionEndIndex = 0,\n            collisionActiveIndex = 0,\n            collision,\n            pair,\n            i;\n\n        for (i = 0; i < collisionsLength; i++) {\n            collision = collisions[i];\n            pair = collision.pair;\n\n            if (pair) {\n                // pair already exists (but may or may not be active)\n                if (pair.isActive) {\n                    // pair exists and is active\n                    collisionActive[collisionActiveIndex++] = pair;\n                }\n\n                // update the pair\n                pairUpdate(pair, collision, timestamp);\n            } else {\n                // pair did not exist, create a new pair\n                pair = pairCreate(collision, timestamp);\n                pairsTable[pair.id] = pair;\n\n                // add the new pair\n                collisionStart[collisionStartIndex++] = pair;\n                pairsList[pairsListIndex++] = pair;\n            }\n        }\n\n        // find pairs that are no longer active\n        pairsListIndex = 0;\n        pairsListLength = pairsList.length;\n\n        for (i = 0; i < pairsListLength; i++) {\n            pair = pairsList[i];\n            \n            // pair is active if updated this timestep\n            if (pair.timeUpdated >= timestamp) {\n                // keep active pairs\n                pairsList[pairsListIndex++] = pair;\n            } else {\n                pairSetActive(pair, false, timestamp);\n\n                // keep inactive pairs if both bodies may be sleeping\n                if (pair.collision.bodyA.sleepCounter > 0 && pair.collision.bodyB.sleepCounter > 0) {\n                    pairsList[pairsListIndex++] = pair;\n                } else {\n                    // remove inactive pairs if either body awake\n                    collisionEnd[collisionEndIndex++] = pair;\n                    delete pairsTable[pair.id];\n                }\n            }\n        }\n\n        // update array lengths if changed\n        if (pairsList.length !== pairsListIndex) {\n            pairsList.length = pairsListIndex;\n        }\n\n        if (collisionStart.length !== collisionStartIndex) {\n            collisionStart.length = collisionStartIndex;\n        }\n\n        if (collisionEnd.length !== collisionEndIndex) {\n            collisionEnd.length = collisionEndIndex;\n        }\n\n        if (collisionActive.length !== collisionActiveIndex) {\n            collisionActive.length = collisionActiveIndex;\n        }\n    };\n\n    /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */\n    Pairs.clear = function(pairs) {\n        pairs.table = {};\n        pairs.list.length = 0;\n        pairs.collisionStart.length = 0;\n        pairs.collisionActive.length = 0;\n        pairs.collisionEnd.length = 0;\n        return pairs;\n    };\n\n})();\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Matter = module.exports = __webpack_require__(21);\r\n\r\nMatter.Axes = __webpack_require__(11);\r\nMatter.Bodies = __webpack_require__(12);\r\nMatter.Body = __webpack_require__(4);\r\nMatter.Bounds = __webpack_require__(1);\r\nMatter.Collision = __webpack_require__(8);\r\nMatter.Common = __webpack_require__(0);\r\nMatter.Composite = __webpack_require__(6);\r\nMatter.Composites = __webpack_require__(22);\r\nMatter.Constraint = __webpack_require__(10);\r\nMatter.Contact = __webpack_require__(16);\r\nMatter.Detector = __webpack_require__(13);\r\nMatter.Engine = __webpack_require__(17);\r\nMatter.Events = __webpack_require__(5);\r\nMatter.Grid = __webpack_require__(23);\r\nMatter.Mouse = __webpack_require__(14);\r\nMatter.MouseConstraint = __webpack_require__(24);\r\nMatter.Pair = __webpack_require__(9);\r\nMatter.Pairs = __webpack_require__(19);\r\nMatter.Plugin = __webpack_require__(15);\r\nMatter.Query = __webpack_require__(25);\r\nMatter.Render = __webpack_require__(26);\r\nMatter.Resolver = __webpack_require__(18);\r\nMatter.Runner = __webpack_require__(27);\r\nMatter.SAT = __webpack_require__(28);\r\nMatter.Sleeping = __webpack_require__(7);\r\nMatter.Svg = __webpack_require__(29);\r\nMatter.Vector = __webpack_require__(2);\r\nMatter.Vertices = __webpack_require__(3);\r\nMatter.World = __webpack_require__(30);\r\n\r\n// temporary back compatibility\r\nMatter.Engine.run = Matter.Runner.run;\r\nMatter.Common.deprecated(Matter.Engine, 'run', 'Engine.run \u27A4 use Matter.Runner.run(engine) instead');\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/\r\n\r\nvar Matter = {};\r\n\r\nmodule.exports = Matter;\r\n\r\nvar Plugin = __webpack_require__(15);\r\nvar Common = __webpack_require__(0);\r\n\r\n(function() {\r\n\r\n    /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.name = 'matter-js';\r\n\r\n    /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.version =  true ? \"0.20.0\" : undefined;\r\n\r\n    /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */\r\n    Matter.uses = [];\r\n\r\n    /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */\r\n    Matter.used = [];\r\n\r\n    /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */\r\n    Matter.use = function() {\r\n        Plugin.use(Matter, Array.prototype.slice.call(arguments));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.before = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathBefore(Matter, path, func);\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.after = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathAfter(Matter, path, func);\r\n    };\r\n\r\n})();\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/\n\nvar Composites = {};\n\nmodule.exports = Composites;\n\nvar Composite = __webpack_require__(6);\nvar Constraint = __webpack_require__(10);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(4);\nvar Bodies = __webpack_require__(12);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.stack = function(x, y, columns, rows, columnGap, rowGap, callback) {\n        var stack = Composite.create({ label: 'Stack' }),\n            currentX = x,\n            currentY = y,\n            lastBody,\n            i = 0;\n\n        for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n            \n            for (var column = 0; column < columns; column++) {\n                var body = callback(currentX, currentY, column, row, lastBody, i);\n                    \n                if (body) {\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \n\n                    if (bodyHeight > maxHeight)\n                        maxHeight = bodyHeight;\n                    \n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\n\n                    currentX = body.bounds.max.x + columnGap;\n\n                    Composite.addBody(stack, body);\n                    \n                    lastBody = body;\n                    i += 1;\n                } else {\n                    currentX += columnGap;\n                }\n            }\n            \n            currentY += maxHeight + rowGap;\n            currentX = x;\n        }\n\n        return stack;\n    };\n    \n    /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n        var bodies = composite.bodies;\n        \n        for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n                bodyB = bodies[i],\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n        \n            var defaults = {\n                bodyA: bodyA,\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\n                bodyB: bodyB,\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\n            };\n            \n            var constraint = Common.extend(defaults, options);\n        \n            Composite.addConstraint(composite, Constraint.create(constraint));\n        }\n\n        composite.label += ' Chain';\n        \n        return composite;\n    };\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n        var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n        \n        for (row = 0; row < rows; row++) {\n            for (col = 1; col < columns; col++) {\n                bodyA = bodies[(col - 1) + (row * columns)];\n                bodyB = bodies[col + (row * columns)];\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n            }\n\n            if (row > 0) {\n                for (col = 0; col < columns; col++) {\n                    bodyA = bodies[col + ((row - 1) * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n\n                    if (crossBrace && col > 0) {\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n\n                    if (crossBrace && col < columns - 1) {\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n                }\n            }\n        }\n\n        composite.label += ' Mesh';\n        \n        return composite;\n    };\n    \n    /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.pyramid = function(x, y, columns, rows, columnGap, rowGap, callback) {\n        return Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n            \n            if (row > actualRows)\n                return;\n            \n            // reverse row order\n            row = actualRows - row;\n            \n            var start = row,\n                end = columns - 1 - row;\n\n            if (column < start || column > end)\n                return;\n            \n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\n            }\n\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n            \n            return callback(x + xOffset + column * columnGap, stackY, column, row, lastBody, i);\n        });\n    };\n\n    /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */\n    Composites.newtonsCradle = function(x, y, number, size, length) {\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\n\n        for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n                circle = Bodies.circle(x + i * (size * separation), y + length, size, \n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\n                constraint = Constraint.create({ pointA: { x: x + i * (size * separation), y: y }, bodyB: circle });\n\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n        }\n\n        return newtonsCradle;\n    };\n\n    deprecated(Composites, 'newtonsCradle', 'Composites.newtonsCradle \u27A4 moved to newtonsCradle example');\n    \n    /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */\n    Composites.car = function(x, y, width, height, wheelSize) {\n        var group = Body.nextGroup(true),\n            wheelBase = 20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n    \n        var car = Composite.create({ label: 'Car' }),\n            body = Bodies.rectangle(x, y, width, height, { \n                collisionFilter: {\n                    group: group\n                },\n                chamfer: {\n                    radius: height * 0.5\n                },\n                density: 0.0002\n            });\n    \n        var wheelA = Bodies.circle(x + wheelAOffset, y + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var wheelB = Bodies.circle(x + wheelBOffset, y + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var axelA = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelAOffset, y: wheelYOffset },\n            bodyA: wheelA,\n            stiffness: 1,\n            length: 0\n        });\n                        \n        var axelB = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelBOffset, y: wheelYOffset },\n            bodyA: wheelB,\n            stiffness: 1,\n            length: 0\n        });\n        \n        Composite.addBody(car, body);\n        Composite.addBody(car, wheelA);\n        Composite.addBody(car, wheelB);\n        Composite.addConstraint(car, axelA);\n        Composite.addConstraint(car, axelB);\n\n        return car;\n    };\n\n    deprecated(Composites, 'car', 'Composites.car \u27A4 moved to car example');\n\n    /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */\n    Composites.softBody = function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\n\n        var softBody = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY) {\n            return Bodies.circle(stackX, stackY, particleRadius, particleOptions);\n        });\n\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n\n        softBody.label = 'Soft Body';\n\n        return softBody;\n    };\n\n    deprecated(Composites, 'softBody', 'Composites.softBody \u27A4 moved to softBody and cloth examples');\n})();\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* This module has now been replaced by `Matter.Detector`.\n*\n* All usage should be migrated to `Matter.Detector` or another alternative.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n* @deprecated\n*/\n\nvar Grid = {};\n\nmodule.exports = Grid;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Creates a new grid.\n     * @deprecated replaced by Matter.Detector\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */\n    Grid.create = function(options) {\n        var defaults = {\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * Updates the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\n        var i, col, row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            gridChanged = false;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isSleeping && !forceUpdate)\n                continue;\n\n            // temporary back compatibility bounds check\n            if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y))\n                continue;\n\n            var newRegion = Grid._getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n\n                if (!body.region || forceUpdate)\n                    body.region = newRegion;\n\n                var union = Grid._regionUnion(newRegion, body.region);\n\n                // update grid buckets affected by region change\n                // iterate over the union of both regions\n                for (col = union.startCol; col <= union.endCol; col++) {\n                    for (row = union.startRow; row <= union.endRow; row++) {\n                        bucketId = Grid._getBucketId(col, row);\n                        bucket = buckets[bucketId];\n\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\n\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\n                                                && row >= body.region.startRow && row <= body.region.endRow);\n\n                        // remove from old region buckets\n                        if (!isInsideNewRegion && isInsideOldRegion) {\n                            if (isInsideOldRegion) {\n                                if (bucket)\n                                    Grid._bucketRemoveBody(grid, bucket, body);\n                            }\n                        }\n\n                        // add to new region buckets\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\n                            if (!bucket)\n                                bucket = Grid._createBucket(buckets, bucketId);\n                            Grid._bucketAddBody(grid, bucket, body);\n                        }\n                    }\n                }\n\n                // set the new region\n                body.region = newRegion;\n\n                // flag changes so we can update pairs\n                gridChanged = true;\n            }\n        }\n\n        // update pairs list only if pairs changed (i.e. a body changed region)\n        if (gridChanged)\n            grid.pairsList = Grid._createActivePairsList(grid);\n    };\n\n    deprecated(Grid, 'update', 'Grid.update \u27A4 replaced by Matter.Detector');\n\n    /**\n     * Clears the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method clear\n     * @param {grid} grid\n     */\n    Grid.clear = function(grid) {\n        grid.buckets = {};\n        grid.pairs = {};\n        grid.pairsList = [];\n    };\n\n    deprecated(Grid, 'clear', 'Grid.clear \u27A4 replaced by Matter.Detector');\n\n    /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */\n    Grid._regionUnion = function(regionA, regionB) {\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */\n    Grid._getRegion = function(grid, body) {\n        var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Creates a region.\n     * @method _createRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n        return { \n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol, \n            endCol: endCol, \n            startRow: startRow, \n            endRow: endRow \n        };\n    };\n\n    /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */\n    Grid._getBucketId = function(column, row) {\n        return 'C' + column + 'R' + row;\n    };\n\n    /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */\n    Grid._createBucket = function(buckets, bucketId) {\n        var bucket = buckets[bucketId] = [];\n        return bucket;\n    };\n\n    /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketAddBody = function(grid, bucket, body) {\n        var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            bucketLength = bucket.length,\n            i;\n\n        // add new pairs\n        for (i = 0; i < bucketLength; i++) {\n            var bodyB = bucket[i];\n\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\n                continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var id = pairId(body, bodyB),\n                pair = gridPairs[id];\n\n            if (pair) {\n                pair[2] += 1;\n            } else {\n                gridPairs[id] = [body, bodyB, 1];\n            }\n        }\n\n        // add to bodies (after pairs, otherwise pairs with self)\n        bucket.push(body);\n    };\n\n    /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\n        var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            i;\n\n        // remove from bucket\n        bucket.splice(Common.indexOf(bucket, body), 1);\n\n        var bucketLength = bucket.length;\n\n        // update pair counts\n        for (i = 0; i < bucketLength; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var pair = gridPairs[pairId(body, bucket[i])];\n\n            if (pair)\n                pair[2] -= 1;\n        }\n    };\n\n    /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */\n    Grid._createActivePairsList = function(grid) {\n        var pair,\n            gridPairs = grid.pairs,\n            pairKeys = Common.keys(gridPairs),\n            pairKeysLength = pairKeys.length,\n            pairs = [],\n            k;\n\n        // iterate over grid.pairs\n        for (k = 0; k < pairKeysLength; k++) {\n            pair = gridPairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n                pairs.push(pair);\n            } else {\n                delete gridPairs[pairKeys[k]];\n            }\n        }\n\n        return pairs;\n    };\n    \n})();\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/\n\nvar MouseConstraint = {};\n\nmodule.exports = MouseConstraint;\n\nvar Vertices = __webpack_require__(3);\nvar Sleeping = __webpack_require__(7);\nvar Mouse = __webpack_require__(14);\nvar Events = __webpack_require__(5);\nvar Detector = __webpack_require__(13);\nvar Constraint = __webpack_require__(10);\nvar Composite = __webpack_require__(6);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */\n    MouseConstraint.create = function(engine, options) {\n        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n\n        if (!mouse) {\n            if (engine && engine.render && engine.render.canvas) {\n                mouse = Mouse.create(engine.render.canvas);\n            } else if (options && options.element) {\n                mouse = Mouse.create(options.element);\n            } else {\n                mouse = Mouse.create();\n                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');\n            }\n        }\n\n        var constraint = Constraint.create({ \n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: { x: 0, y: 0 },\n            length: 0.01, \n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n                strokeStyle: '#90EE90',\n                lineWidth: 3\n            }\n        });\n\n        var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            element: null,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            }\n        };\n\n        var mouseConstraint = Common.extend(defaults, options);\n\n        Events.on(engine, 'beforeUpdate', function() {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            MouseConstraint._triggerEvents(mouseConstraint);\n        });\n\n        return mouseConstraint;\n    };\n\n    /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */\n    MouseConstraint.update = function(mouseConstraint, bodies) {\n        var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n\n        if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n                for (var i = 0; i < bodies.length; i++) {\n                    body = bodies[i];\n                    if (Bounds.contains(body.bounds, mouse.position) \n                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {\n                            var part = body.parts[j];\n                            if (Vertices.contains(part.vertices, mouse.position)) {\n                                constraint.pointA = mouse.position;\n                                constraint.bodyB = mouseConstraint.body = body;\n                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };\n                                constraint.angleB = body.angle;\n\n                                Sleeping.set(body, false);\n                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });\n\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Sleeping.set(constraint.bodyB, false);\n                constraint.pointA = mouse.position;\n            }\n        } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n\n            if (body)\n                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });\n        }\n    };\n\n    /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */\n    MouseConstraint._triggerEvents = function(mouseConstraint) {\n        var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n\n        if (mouseEvents.mousemove)\n            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });\n\n        if (mouseEvents.mousedown)\n            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });\n\n        if (mouseEvents.mouseup)\n            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });\n\n        // reset the mouse state ready for the next step\n        Mouse.clearSourceEvents(mouse);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */\n\n    /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */\n\n    /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n})();\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/\n\nvar Query = {};\n\nmodule.exports = Query;\n\nvar Vector = __webpack_require__(2);\nvar Collision = __webpack_require__(8);\nvar Bounds = __webpack_require__(1);\nvar Bodies = __webpack_require__(12);\nvar Vertices = __webpack_require__(3);\n\n(function() {\n\n    /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {collision[]} Collisions\n     */\n    Query.collides = function(body, bodies) {\n        var collisions = [],\n            bodiesLength = bodies.length,\n            bounds = body.bounds,\n            collides = Collision.collides,\n            overlaps = Bounds.overlaps;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n                partsALength = bodyA.parts.length,\n                partsAStart = partsALength === 1 ? 0 : 1;\n            \n            if (overlaps(bodyA.bounds, bounds)) {\n                for (var j = partsAStart; j < partsALength; j++) {\n                    var part = bodyA.parts[j];\n\n                    if (overlaps(part.bounds, bounds)) {\n                        var collision = collides(part, body);\n\n                        if (collision) {\n                            collisions.push(collision);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {collision[]} Collisions\n     */\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n        rayWidth = rayWidth || 1e-100;\n\n        var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\n            collisions = Query.collides(ray, bodies);\n\n        for (var i = 0; i < collisions.length; i += 1) {\n            var collision = collisions[i];\n            collision.body = collision.bodyB = collision.bodyA;            \n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */\n    Query.region = function(bodies, bounds, outside) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                overlaps = Bounds.overlaps(body.bounds, bounds);\n            if ((overlaps && !outside) || (!overlaps && outside))\n                result.push(body);\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */\n    Query.point = function(bodies, point) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            \n            if (Bounds.contains(body.bounds, point)) {\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n\n                    if (Bounds.contains(part.bounds, point)\n                        && Vertices.contains(part.vertices, point)) {\n                        result.push(body);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n})();\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Render` module is a lightweight, optional utility which provides a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/\n\nvar Render = {};\n\nmodule.exports = Render;\n\nvar Body = __webpack_require__(4);\nvar Common = __webpack_require__(0);\nvar Composite = __webpack_require__(6);\nvar Bounds = __webpack_require__(1);\nvar Events = __webpack_require__(5);\nvar Vector = __webpack_require__(2);\nvar Mouse = __webpack_require__(14);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };\n\n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    Render._goodFps = 30;\n    Render._goodDelta = 1000 / 60;\n\n    /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */\n    Render.create = function(options) {\n        var defaults = {\n            engine: null,\n            element: null,\n            canvas: null,\n            mouse: null,\n            frameRequestId: null,\n            timing: {\n                historySize: 60,\n                delta: 0,\n                deltaHistory: [],\n                lastTime: 0,\n                lastTimestamp: 0,\n                lastElapsed: 0,\n                timestampElapsed: 0,\n                timestampElapsedHistory: [],\n                engineDeltaHistory: [],\n                engineElapsedHistory: [],\n                engineUpdatesHistory: [],\n                elapsedHistory: []\n            },\n            options: {\n                width: 800,\n                height: 600,\n                pixelRatio: 1,\n                background: '#14151f',\n                wireframeBackground: '#14151f',\n                wireframeStrokeStyle: '#bbb',\n                hasBounds: !!options.bounds,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showStats: false,\n                showPerformance: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showSeparations: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showVertexNumbers: false,\n                showConvexHulls: false,\n                showInternalEdges: false,\n                showMousePosition: false\n            }\n        };\n\n        var render = Common.extend(defaults, options);\n\n        if (render.canvas) {\n            render.canvas.width = render.options.width || render.canvas.width;\n            render.canvas.height = render.options.height || render.canvas.height;\n        }\n\n        render.mouse = options.mouse;\n        render.engine = options.engine;\n        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n        render.context = render.canvas.getContext('2d');\n        render.textures = {};\n\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.canvas.width,\n                y: render.canvas.height\n            }\n        };\n\n        // for temporary back compatibility only\n        render.controller = Render;\n        render.options.showBroadphase = false;\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        }\n\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        }\n\n        return render;\n    };\n\n    /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */\n    Render.run = function(render) {\n        (function loop(time){\n            render.frameRequestId = _requestAnimationFrame(loop);\n            \n            _updateTiming(render, time);\n\n            Render.world(render, time);\n\n            render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n\n            if (render.options.showStats || render.options.showDebug) {\n                Render.stats(render, render.context, time);\n            }\n\n            if (render.options.showPerformance || render.options.showDebug) {\n                Render.performance(render, render.context, time);\n            }\n\n            render.context.setTransform(1, 0, 0, 1, 0, 0);\n        })();\n    };\n\n    /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */\n    Render.stop = function(render) {\n        _cancelAnimationFrame(render.frameRequestId);\n    };\n\n    /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */\n    Render.setPixelRatio = function(render, pixelRatio) {\n        var options = render.options,\n            canvas = render.canvas;\n\n        if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n        }\n\n        options.pixelRatio = pixelRatio;\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\n        canvas.width = options.width * pixelRatio;\n        canvas.height = options.height * pixelRatio;\n        canvas.style.width = options.width + 'px';\n        canvas.style.height = options.height + 'px';\n    };\n\n    /**\n     * Sets the render `width` and `height`.\n     * \n     * Updates the canvas accounting for `render.options.pixelRatio`.  \n     * \n     * Updates the bottom right render bound `render.bounds.max` relative to the provided `width` and `height`.\n     * The top left render bound `render.bounds.min` isn't changed.\n     * \n     * Follow this call with `Render.lookAt` if you need to change the render bounds.\n     * \n     * See also `Render.setPixelRatio`.\n     * @method setSize\n     * @param {render} render\n     * @param {number} width The width (in CSS pixels)\n     * @param {number} height The height (in CSS pixels)\n     */\n    Render.setSize = function(render, width, height) {\n        render.options.width = width;\n        render.options.height = height;\n        render.bounds.max.x = render.bounds.min.x + width;\n        render.bounds.max.y = render.bounds.min.y + height;\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        } else {\n            render.canvas.width = width;\n            render.canvas.height = height;\n        }\n    };\n\n    /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */\n    Render.lookAt = function(render, objects, padding, center) {\n        center = typeof center !== 'undefined' ? center : true;\n        objects = Common.isArray(objects) ? objects : [objects];\n        padding = padding || {\n            x: 0,\n            y: 0\n        };\n\n        // find bounds of all objects\n        var bounds = {\n            min: { x: Infinity, y: Infinity },\n            max: { x: -Infinity, y: -Infinity }\n        };\n\n        for (var i = 0; i < objects.length; i += 1) {\n            var object = objects[i],\n                min = object.bounds ? object.bounds.min : (object.min || object.position || object),\n                max = object.bounds ? object.bounds.max : (object.max || object.position || object);\n\n            if (min && max) {\n                if (min.x < bounds.min.x)\n                    bounds.min.x = min.x;\n\n                if (max.x > bounds.max.x)\n                    bounds.max.x = max.x;\n\n                if (min.y < bounds.min.y)\n                    bounds.min.y = min.y;\n\n                if (max.y > bounds.max.y)\n                    bounds.max.y = max.y;\n            }\n        }\n\n        // find ratios\n        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,\n            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,\n            viewHeight = render.canvas.height,\n            viewWidth = render.canvas.width,\n            outerRatio = viewWidth / viewHeight,\n            innerRatio = width / height,\n            scaleX = 1,\n            scaleY = 1;\n\n        // find scale factor\n        if (innerRatio > outerRatio) {\n            scaleY = innerRatio / outerRatio;\n        } else {\n            scaleX = outerRatio / innerRatio;\n        }\n\n        // enable bounds\n        render.options.hasBounds = true;\n\n        // position and size\n        render.bounds.min.x = bounds.min.x;\n        render.bounds.max.x = bounds.min.x + width * scaleX;\n        render.bounds.min.y = bounds.min.y;\n        render.bounds.max.y = bounds.min.y + height * scaleY;\n\n        // center\n        if (center) {\n            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;\n            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;\n        }\n\n        // padding\n        render.bounds.min.x -= padding.x;\n        render.bounds.max.x -= padding.x;\n        render.bounds.min.y -= padding.y;\n        render.bounds.max.y -= padding.y;\n\n        // update mouse\n        if (render.mouse) {\n            Mouse.setScale(render.mouse, {\n                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n            });\n\n            Mouse.setOffset(render.mouse, render.bounds.min);\n        }\n    };\n\n    /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */\n    Render.startViewTransform = function(render) {\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n\n        render.context.setTransform(\n            render.options.pixelRatio / boundsScaleX, 0, 0, \n            render.options.pixelRatio / boundsScaleY, 0, 0\n        );\n        \n        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n    };\n\n    /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */\n    Render.endViewTransform = function(render) {\n        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n    };\n\n    /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */\n    Render.world = function(render, time) {\n        var startTime = Common.now(),\n            engine = render.engine,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            timing = render.timing;\n\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(render, 'beforeRender', event);\n\n        // apply background if it has changed\n        if (render.currentBackground !== background)\n            _applyBackground(render, background);\n\n        // clear the canvas with a transparent fill, to allow the canvas background to show\n        context.globalCompositeOperation = 'source-in';\n        context.fillStyle = \"transparent\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.globalCompositeOperation = 'source-over';\n\n        // handle bounds\n        if (options.hasBounds) {\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n                var body = allBodies[i];\n                if (Bounds.overlaps(body.bounds, render.bounds))\n                    bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            Render.startViewTransform(render);\n\n            // update mouse\n            if (render.mouse) {\n                Mouse.setScale(render.mouse, {\n                    x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                    y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                });\n\n                Mouse.setOffset(render.mouse, render.bounds.min);\n            }\n        } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n\n            if (render.options.pixelRatio !== 1) {\n                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n            }\n        }\n\n        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {\n            // fully featured rendering of bodies\n            Render.bodies(render, bodies, context);\n        } else {\n            if (options.showConvexHulls)\n                Render.bodyConvexHulls(render, bodies, context);\n\n            // optimised method for wireframes only\n            Render.bodyWireframes(render, bodies, context);\n        }\n\n        if (options.showBounds)\n            Render.bodyBounds(render, bodies, context);\n\n        if (options.showAxes || options.showAngleIndicator)\n            Render.bodyAxes(render, bodies, context);\n\n        if (options.showPositions)\n            Render.bodyPositions(render, bodies, context);\n\n        if (options.showVelocity)\n            Render.bodyVelocity(render, bodies, context);\n\n        if (options.showIds)\n            Render.bodyIds(render, bodies, context);\n\n        if (options.showSeparations)\n            Render.separations(render, engine.pairs.list, context);\n\n        if (options.showCollisions)\n            Render.collisions(render, engine.pairs.list, context);\n\n        if (options.showVertexNumbers)\n            Render.vertexNumbers(render, bodies, context);\n\n        if (options.showMousePosition)\n            Render.mousePosition(render, render.mouse, context);\n\n        Render.constraints(constraints, context);\n\n        if (options.hasBounds) {\n            // revert view transforms\n            Render.endViewTransform(render);\n        }\n\n        Events.trigger(render, 'afterRender', event);\n\n        // log the time elapsed computing this update\n        timing.lastElapsed = Common.now() - startTime;\n    };\n\n    /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */\n    Render.stats = function(render, context, time) {\n        var engine = render.engine,\n            world = engine.world,\n            bodies = Composite.allBodies(world),\n            parts = 0,\n            width = 55,\n            height = 44,\n            x = 0,\n            y = 0;\n        \n        // count parts\n        for (var i = 0; i < bodies.length; i += 1) {\n            parts += bodies[i].parts.length;\n        }\n\n        // sections\n        var sections = {\n            'Part': parts,\n            'Body': bodies.length,\n            'Cons': Composite.allConstraints(world).length,\n            'Comp': Composite.allComposites(world).length,\n            'Pair': engine.pairs.list.length\n        };\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(x, y, width * 5.5, height);\n\n        context.font = '12px Arial';\n        context.textBaseline = 'top';\n        context.textAlign = 'right';\n\n        // sections\n        for (var key in sections) {\n            var section = sections[key];\n            // label\n            context.fillStyle = '#aaa';\n            context.fillText(key, x + width, y + 8);\n\n            // value\n            context.fillStyle = '#eee';\n            context.fillText(section, x + width, y + 26);\n\n            x += width;\n        }\n    };\n\n    /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */\n    Render.performance = function(render, context) {\n        var engine = render.engine,\n            timing = render.timing,\n            deltaHistory = timing.deltaHistory,\n            elapsedHistory = timing.elapsedHistory,\n            timestampElapsedHistory = timing.timestampElapsedHistory,\n            engineDeltaHistory = timing.engineDeltaHistory,\n            engineUpdatesHistory = timing.engineUpdatesHistory,\n            engineElapsedHistory = timing.engineElapsedHistory,\n            lastEngineUpdatesPerFrame = engine.timing.lastUpdatesPerFrame,\n            lastEngineDelta = engine.timing.lastDelta;\n        \n        var deltaMean = _mean(deltaHistory),\n            elapsedMean = _mean(elapsedHistory),\n            engineDeltaMean = _mean(engineDeltaHistory),\n            engineUpdatesMean = _mean(engineUpdatesHistory),\n            engineElapsedMean = _mean(engineElapsedHistory),\n            timestampElapsedMean = _mean(timestampElapsedHistory),\n            rateMean = (timestampElapsedMean / deltaMean) || 0,\n            neededUpdatesPerFrame = Math.round(deltaMean / lastEngineDelta),\n            fps = (1000 / deltaMean) || 0;\n\n        var graphHeight = 4,\n            gap = 12,\n            width = 60,\n            height = 34,\n            x = 10,\n            y = 69;\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(0, 50, gap * 5 + width * 6 + 22, height);\n\n        // show FPS\n        Render.status(\n            context, x, y, width, graphHeight, deltaHistory.length, \n            Math.round(fps) + ' fps', \n            fps / Render._goodFps,\n            function(i) { return (deltaHistory[i] / deltaMean) - 1; }\n        );\n\n        // show engine delta\n        Render.status(\n            context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length,\n            lastEngineDelta.toFixed(2) + ' dt', \n            Render._goodDelta / lastEngineDelta,\n            function(i) { return (engineDeltaHistory[i] / engineDeltaMean) - 1; }\n        );\n\n        // show engine updates per frame\n        Render.status(\n            context, x + (gap + width) * 2, y, width, graphHeight, engineUpdatesHistory.length,\n            lastEngineUpdatesPerFrame + ' upf', \n            Math.pow(Common.clamp((engineUpdatesMean / neededUpdatesPerFrame) || 1, 0, 1), 4),\n            function(i) { return (engineUpdatesHistory[i] / engineUpdatesMean) - 1; }\n        );\n\n        // show engine update time\n        Render.status(\n            context, x + (gap + width) * 3, y, width, graphHeight, engineElapsedHistory.length,\n            engineElapsedMean.toFixed(2) + ' ut', \n            1 - (lastEngineUpdatesPerFrame * engineElapsedMean / Render._goodFps),\n            function(i) { return (engineElapsedHistory[i] / engineElapsedMean) - 1; }\n        );\n\n        // show render time\n        Render.status(\n            context, x + (gap + width) * 4, y, width, graphHeight, elapsedHistory.length,\n            elapsedMean.toFixed(2) + ' rt', \n            1 - (elapsedMean / Render._goodFps),\n            function(i) { return (elapsedHistory[i] / elapsedMean) - 1; }\n        );\n\n        // show effective speed\n        Render.status(\n            context, x + (gap + width) * 5, y, width, graphHeight, timestampElapsedHistory.length, \n            rateMean.toFixed(2) + ' x', \n            rateMean * rateMean * rateMean,\n            function(i) { return (((timestampElapsedHistory[i] / deltaHistory[i]) / rateMean) || 0) - 1; }\n        );\n    };\n\n    /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */\n    Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n        // background\n        context.strokeStyle = '#888';\n        context.fillStyle = '#444';\n        context.lineWidth = 1;\n        context.fillRect(x, y + 7, width, 1);\n\n        // chart\n        context.beginPath();\n        context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n        for (var i = 0; i < width; i += 1) {\n            context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n        }\n        context.stroke();\n\n        // indicator\n        context.fillStyle = 'hsl(' + Common.clamp(25 + 95 * indicator, 0, 120) + ',100%,60%)';\n        context.fillRect(x, y - 7, 4, 4);\n\n        // label\n        context.font = '12px Arial';\n        context.textBaseline = 'middle';\n        context.textAlign = 'right';\n        context.fillStyle = '#eee';\n        context.fillText(label, x + width, y - 5);\n    };\n\n    /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */\n    Render.constraints = function(constraints, context) {\n        var c = context;\n\n        for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\n                continue;\n\n            var bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB,\n                start,\n                end;\n\n            if (bodyA) {\n                start = Vector.add(bodyA.position, constraint.pointA);\n            } else {\n                start = constraint.pointA;\n            }\n\n            if (constraint.render.type === 'pin') {\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n            } else {\n                if (bodyB) {\n                    end = Vector.add(bodyB.position, constraint.pointB);\n                } else {\n                    end = constraint.pointB;\n                }\n\n                c.beginPath();\n                c.moveTo(start.x, start.y);\n\n                if (constraint.render.type === 'spring') {\n                    var delta = Vector.sub(end, start),\n                        normal = Vector.perp(Vector.normalise(delta)),\n                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\n                        offset;\n\n                    for (var j = 1; j < coils; j += 1) {\n                        offset = j % 2 === 0 ? 1 : -1;\n\n                        c.lineTo(\n                            start.x + delta.x * (j / coils) + normal.x * offset * 4,\n                            start.y + delta.y * (j / coils) + normal.y * offset * 4\n                        );\n                    }\n                }\n\n                c.lineTo(end.x, end.y);\n            }\n\n            if (constraint.render.lineWidth) {\n                c.lineWidth = constraint.render.lineWidth;\n                c.strokeStyle = constraint.render.strokeStyle;\n                c.stroke();\n            }\n\n            if (constraint.render.anchors) {\n                c.fillStyle = constraint.render.strokeStyle;\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n                c.fill();\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodies = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            showInternalEdges = options.showInternalEdges || !options.wireframes,\n            body,\n            part,\n            i,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                if (!part.render.visible)\n                    continue;\n\n                if (options.showSleeping && body.isSleeping) {\n                    c.globalAlpha = 0.5 * part.render.opacity;\n                } else if (part.render.opacity !== 1) {\n                    c.globalAlpha = part.render.opacity;\n                }\n\n                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                    // part sprite\n                    var sprite = part.render.sprite,\n                        texture = _getTexture(render, sprite.texture);\n\n                    c.translate(part.position.x, part.position.y);\n                    c.rotate(part.angle);\n\n                    c.drawImage(\n                        texture,\n                        texture.width * -sprite.xOffset * sprite.xScale,\n                        texture.height * -sprite.yOffset * sprite.yScale,\n                        texture.width * sprite.xScale,\n                        texture.height * sprite.yScale\n                    );\n\n                    // revert translation, hopefully faster than save / restore\n                    c.rotate(-part.angle);\n                    c.translate(-part.position.x, -part.position.y);\n                } else {\n                    // part polygon\n                    if (part.circleRadius) {\n                        c.beginPath();\n                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                    } else {\n                        c.beginPath();\n                        c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                        for (var j = 1; j < part.vertices.length; j++) {\n                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                            } else {\n                                c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                            }\n\n                            if (part.vertices[j].isInternal && !showInternalEdges) {\n                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                            }\n                        }\n\n                        c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        c.closePath();\n                    }\n\n                    if (!options.wireframes) {\n                        c.fillStyle = part.render.fillStyle;\n\n                        if (part.render.lineWidth) {\n                            c.lineWidth = part.render.lineWidth;\n                            c.strokeStyle = part.render.strokeStyle;\n                            c.stroke();\n                        }\n\n                        c.fill();\n                    } else {\n                        c.lineWidth = 1;\n                        c.strokeStyle = render.options.wireframeStrokeStyle;\n                        c.stroke();\n                    }\n                }\n\n                c.globalAlpha = 1;\n            }\n        }\n    };\n\n    /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyWireframes = function(render, bodies, context) {\n        var c = context,\n            showInternalEdges = render.options.showInternalEdges,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render all bodies\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                for (j = 1; j < part.vertices.length; j++) {\n                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                        c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                    } else {\n                        c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                    }\n\n                    if (part.vertices[j].isInternal && !showInternalEdges) {\n                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                    }\n                }\n\n                c.lineTo(part.vertices[0].x, part.vertices[0].y);\n            }\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = render.options.wireframeStrokeStyle;\n        c.stroke();\n    };\n\n    /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyConvexHulls = function(render, bodies, context) {\n        var c = context,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render convex hulls\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible || body.parts.length === 1)\n                continue;\n\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n            for (j = 1; j < body.vertices.length; j++) {\n                c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = 'rgba(255,255,255,0.2)';\n        c.stroke();\n    };\n\n    /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.vertexNumbers = function(render, bodies, context) {\n        var c = context,\n            i,\n            j,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            var parts = bodies[i].parts;\n            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {\n                var part = parts[k];\n                for (j = 0; j < part.vertices.length; j++) {\n                    c.fillStyle = 'rgba(255,255,255,0.2)';\n                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                }\n            }\n        }\n    };\n\n    /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */\n    Render.mousePosition = function(render, mouse, context) {\n        var c = context;\n        c.fillStyle = 'rgba(255,255,255,0.8)';\n        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n    };\n\n    /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyBounds = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.render.visible) {\n                var parts = bodies[i].parts;\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    var part = parts[j];\n                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyAxes = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                parts = body.parts;\n\n            if (!body.render.visible)\n                continue;\n\n            if (options.showAxes) {\n                // render all axes\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        var axis = part.axes[k];\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                    }\n                }\n            } else {\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        // render a single axis indicator\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2,\n                            (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);\n                    }\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n            c.lineWidth = 1;\n        } else {\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n            c.globalCompositeOperation = 'overlay';\n            c.lineWidth = 2;\n        }\n\n        c.stroke();\n        c.globalCompositeOperation = 'source-over';\n    };\n\n    /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyPositions = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            body,\n            part,\n            i,\n            k;\n\n        c.beginPath();\n\n        // render current positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'indianred';\n        } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render previous positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        c.fillStyle = 'rgba(255,165,0,0.8)';\n        c.fill();\n    };\n\n    /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyVelocity = function(render, bodies, context) {\n        var c = context;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            var velocity = Body.getVelocity(body);\n\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);\n        }\n\n        c.lineWidth = 3;\n        c.strokeStyle = 'cornflowerblue';\n        c.stroke();\n    };\n\n    /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyIds = function(render, bodies, context) {\n        var c = context,\n            i,\n            j;\n\n        for (i = 0; i < bodies.length; i++) {\n            if (!bodies[i].render.visible)\n                continue;\n\n            var parts = bodies[i].parts;\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                var part = parts[j];\n                c.font = \"12px Arial\";\n                c.fillStyle = 'rgba(255,255,255,0.5)';\n                c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.collisions = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render collision positions\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            for (j = 0; j < pair.contactCount; j++) {\n                var contact = pair.contacts[j],\n                    vertex = contact.vertex;\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n        } else {\n            c.fillStyle = 'orange';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render collision normals\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n\n            if (pair.contactCount > 0) {\n                var normalPosX = pair.contacts[0].vertex.x,\n                    normalPosY = pair.contacts[0].vertex.y;\n\n                if (pair.contactCount === 2) {\n                    normalPosX = (pair.contacts[0].vertex.x + pair.contacts[1].vertex.x) / 2;\n                    normalPosY = (pair.contacts[0].vertex.y + pair.contacts[1].vertex.y) / 2;\n                }\n\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                } else {\n                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                }\n\n                c.lineTo(normalPosX, normalPosY);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.separations = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render separations\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n\n            var k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyB.isStatic) k = 0;\n\n            c.moveTo(bodyB.position.x, bodyB.position.y);\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n\n            k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyA.isStatic) k = 0;\n\n            c.moveTo(bodyA.position.x, bodyA.position.y);\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */\n    Render.inspector = function(inspector, context) {\n        var engine = inspector.engine,\n            selected = inspector.selected,\n            render = inspector.render,\n            options = render.options,\n            bounds;\n\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / render.options.width,\n                boundsScaleY = boundsHeight / render.options.height;\n\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        }\n\n        for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1,2]);\n\n            switch (item.type) {\n\n            case 'body':\n\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),\n                    Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            case 'constraint':\n\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA)\n                    point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            }\n\n            context.setLineDash([]);\n            context.translate(-0.5, -0.5);\n        }\n\n        // render selection region\n        if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),\n                Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n        }\n\n        if (options.hasBounds)\n            context.setTransform(1, 0, 0, 1, 0, 0);\n    };\n\n    /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */\n    var _updateTiming = function(render, time) {\n        var engine = render.engine,\n            timing = render.timing,\n            historySize = timing.historySize,\n            timestamp = engine.timing.timestamp;\n\n        timing.delta = time - timing.lastTime || Render._goodDelta;\n        timing.lastTime = time;\n\n        timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n        timing.lastTimestamp = timestamp;\n\n        timing.deltaHistory.unshift(timing.delta);\n        timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n\n        timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n        timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n\n        timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n        timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n\n        timing.engineUpdatesHistory.unshift(engine.timing.lastUpdatesPerFrame);\n        timing.engineUpdatesHistory.length = Math.min(timing.engineUpdatesHistory.length, historySize);\n\n        timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n        timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n\n        timing.elapsedHistory.unshift(timing.lastElapsed);\n        timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n    };\n\n    /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */\n    var _mean = function(values) {\n        var result = 0;\n        for (var i = 0; i < values.length; i += 1) {\n            result += values[i];\n        }\n        return (result / values.length) || 0;\n    };\n\n    /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */\n    var _createCanvas = function(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.oncontextmenu = function() { return false; };\n        canvas.onselectstart = function() { return false; };\n        return canvas;\n    };\n\n    /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */\n    var _getPixelRatio = function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    };\n\n    /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var image = render.textures[imagePath];\n\n        if (image)\n            return image;\n\n        image = render.textures[imagePath] = new Image();\n        image.src = imagePath;\n\n        return image;\n    };\n\n    /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */\n    var _applyBackground = function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @deprecated\n     * @property controller\n     * @type render\n     */\n\n    /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */\n\n    /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */\n\n    /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */\n\n    /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n\n    /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */\n\n    /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */\n\n    /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */\n\n    /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */\n\n    /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */\n\n    /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A CSS color string to use for background when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A CSS color string to use for stroke when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeStrokeStyle\n     * @type string\n     * @default '#bbb'\n     */\n\n    /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average updates per frame (e.g. 1)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */\n    \n    /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @deprecated no longer implemented\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */\n\n})();\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Runner` module is an optional utility that provides a game loop for running a `Matter.Engine` inside a browser environment.\n* A runner will continuously update a `Matter.Engine` whilst synchronising engine updates with the browser frame rate.\n* This runner favours a smoother user experience over perfect time keeping.\n* This runner is optional and is used for development and debugging but could be useful as a starting point for implementing some games and experiences.\n* Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation as may be needed inside other environments.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/\n\nvar Runner = {};\n\nmodule.exports = Runner;\n\nvar Events = __webpack_require__(5);\nvar Engine = __webpack_require__(17);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Runner._maxFrameDelta = 1000 / 15;\n    Runner._frameDeltaFallback = 1000 / 60;\n    Runner._timeBufferMargin = 1.5;\n    Runner._elapsedNextEstimate = 1;\n    Runner._smoothingLowerBound = 0.1;\n    Runner._smoothingUpperBound = 0.9;\n\n    /**\n     * Creates a new Runner. \n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     */\n    Runner.create = function(options) {\n        var defaults = {\n            delta: 1000 / 60,\n            frameDelta: null,\n            frameDeltaSmoothing: true,\n            frameDeltaSnapping: true,\n            frameDeltaHistory: [],\n            frameDeltaHistorySize: 100,\n            frameRequestId: null,\n            timeBuffer: 0,\n            timeLastTick: null,\n            maxUpdates: null,\n            maxFrameTime: 1000 / 30,\n            lastUpdatesDeferred: 0,\n            enabled: true\n        };\n\n        var runner = Common.extend(defaults, options);\n\n        // for temporary back compatibility only\n        runner.fps = 0;\n\n        return runner;\n    };\n\n    /**\n     * Runs a `Matter.Engine` whilst synchronising engine updates with the browser frame rate. \n     * See module and properties descriptions for more information on this runner.\n     * Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation.\n     * @method run\n     * @param {runner} runner\n     * @param {engine} [engine]\n     * @return {runner} runner\n     */\n    Runner.run = function(runner, engine) {\n        // initial time buffer for the first frame\n        runner.timeBuffer = Runner._frameDeltaFallback;\n\n        (function onFrame(time){\n            runner.frameRequestId = Runner._onNextFrame(runner, onFrame);\n\n            if (time && runner.enabled) {\n                Runner.tick(runner, engine, time);\n            }\n        })();\n\n        return runner;\n    };\n\n    /**\n     * Performs a single runner tick as used inside `Runner.run`.\n     * See module and properties descriptions for more information on this runner.\n     * Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */\n    Runner.tick = function(runner, engine, time) {\n        var tickStartTime = Common.now(),\n            engineDelta = runner.delta,\n            updateCount = 0;\n\n        // find frame delta time since last call\n        var frameDelta = time - runner.timeLastTick;\n\n        // fallback for unusable frame delta values (e.g. 0, NaN, on first frame or long pauses)\n        if (!frameDelta || !runner.timeLastTick || frameDelta > Math.max(Runner._maxFrameDelta, runner.maxFrameTime)) {\n            // reuse last accepted frame delta else fallback\n            frameDelta = runner.frameDelta || Runner._frameDeltaFallback;\n        }\n\n        if (runner.frameDeltaSmoothing) {\n            // record frame delta over a number of frames\n            runner.frameDeltaHistory.push(frameDelta);\n            runner.frameDeltaHistory = runner.frameDeltaHistory.slice(-runner.frameDeltaHistorySize);\n\n            // sort frame delta history\n            var deltaHistorySorted = runner.frameDeltaHistory.slice(0).sort();\n\n            // sample a central window to limit outliers\n            var deltaHistoryWindow = runner.frameDeltaHistory.slice(\n                deltaHistorySorted.length * Runner._smoothingLowerBound, \n                deltaHistorySorted.length * Runner._smoothingUpperBound\n            );\n\n            // take the mean of the central window\n            var frameDeltaSmoothed = _mean(deltaHistoryWindow);\n            frameDelta = frameDeltaSmoothed || frameDelta;\n        }\n\n        if (runner.frameDeltaSnapping) {\n            // snap frame delta to the nearest 1 Hz\n            frameDelta = 1000 / Math.round(1000 / frameDelta);\n        }\n\n        // update runner values for next call\n        runner.frameDelta = frameDelta;\n        runner.timeLastTick = time;\n\n        // accumulate elapsed time\n        runner.timeBuffer += runner.frameDelta;\n\n        // limit time buffer size to a single frame of updates\n        runner.timeBuffer = Common.clamp(\n            runner.timeBuffer, 0, runner.frameDelta + engineDelta * Runner._timeBufferMargin\n        );\n\n        // reset count of over budget updates\n        runner.lastUpdatesDeferred = 0;\n\n        // get max updates per frame\n        var maxUpdates = runner.maxUpdates || Math.ceil(runner.maxFrameTime / engineDelta);\n\n        // create event object\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        // tick events before update\n        Events.trigger(runner, 'beforeTick', event);\n        Events.trigger(runner, 'tick', event);\n\n        var updateStartTime = Common.now();\n\n        // simulate time elapsed between calls\n        while (engineDelta > 0 && runner.timeBuffer >= engineDelta * Runner._timeBufferMargin) {\n            // update the engine\n            Events.trigger(runner, 'beforeUpdate', event);\n            Engine.update(engine, engineDelta);\n            Events.trigger(runner, 'afterUpdate', event);\n\n            // consume time simulated from buffer\n            runner.timeBuffer -= engineDelta;\n            updateCount += 1;\n\n            // find elapsed time during this tick\n            var elapsedTimeTotal = Common.now() - tickStartTime,\n                elapsedTimeUpdates = Common.now() - updateStartTime,\n                elapsedNextEstimate = elapsedTimeTotal + Runner._elapsedNextEstimate * elapsedTimeUpdates / updateCount;\n\n            // defer updates if over performance budgets for this frame\n            if (updateCount >= maxUpdates || elapsedNextEstimate > runner.maxFrameTime) {\n                runner.lastUpdatesDeferred = Math.round(Math.max(0, (runner.timeBuffer / engineDelta) - Runner._timeBufferMargin));\n                break;\n            }\n        }\n\n        // track timing metrics\n        engine.timing.lastUpdatesPerFrame = updateCount;\n\n        // tick events after update\n        Events.trigger(runner, 'afterTick', event);\n\n        // show useful warnings if needed\n        if (runner.frameDeltaHistory.length >= 100) {\n            if (runner.lastUpdatesDeferred && Math.round(runner.frameDelta / engineDelta) > maxUpdates) {\n                Common.warnOnce('Matter.Runner: runner reached runner.maxUpdates, see docs.');\n            } else if (runner.lastUpdatesDeferred) {\n                Common.warnOnce('Matter.Runner: runner reached runner.maxFrameTime, see docs.');\n            }\n\n            if (typeof runner.isFixed !== 'undefined') {\n                Common.warnOnce('Matter.Runner: runner.isFixed is now redundant, see docs.');\n            }\n\n            if (runner.deltaMin || runner.deltaMax) {\n                Common.warnOnce('Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs.');\n            }\n\n            if (runner.fps !== 0) {\n                Common.warnOnce('Matter.Runner: runner.fps was replaced by runner.delta, see docs.');\n            }\n        }\n    };\n\n    /**\n     * Ends execution of `Runner.run` on the given `runner` by canceling the frame loop.\n     * Alternatively to temporarily pause the runner, see `runner.enabled`.\n     * @method stop\n     * @param {runner} runner\n     */\n    Runner.stop = function(runner) {\n        Runner._cancelNextFrame(runner);\n    };\n\n    /**\n     * Schedules the `callback` on this `runner` for the next animation frame.\n     * @private\n     * @method _onNextFrame\n     * @param {runner} runner\n     * @param {function} callback\n     * @return {number} frameRequestId\n     */\n    Runner._onNextFrame = function(runner, callback) {\n        if (typeof window !== 'undefined' && window.requestAnimationFrame) {\n            runner.frameRequestId = window.requestAnimationFrame(callback);\n        } else {\n            throw new Error('Matter.Runner: missing required global window.requestAnimationFrame.');\n        }\n\n        return runner.frameRequestId;\n    };\n\n    /**\n     * Cancels the last callback scheduled by `Runner._onNextFrame` on this `runner`.\n     * @private\n     * @method _cancelNextFrame\n     * @param {runner} runner\n     */\n    Runner._cancelNextFrame = function(runner) {\n        if (typeof window !== 'undefined' && window.cancelAnimationFrame) {\n            window.cancelAnimationFrame(runner.frameRequestId);\n        } else {\n            throw new Error('Matter.Runner: missing required global window.cancelAnimationFrame.');\n        }\n    };\n\n    /**\n     * Returns the mean of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values.\n     */\n    var _mean = function(values) {\n        var result = 0,\n            valuesLength = values.length;\n\n        for (var i = 0; i < valuesLength; i += 1) {\n            result += values[i];\n        }\n\n        return (result / valuesLength) || 0;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired once at the start of the browser frame, before any engine updates.\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired once at the start of the browser frame, after `beforeTick`.\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired once at the end of the browser frame, after `beforeTick`, `tick` and after any engine updates.\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired before each and every engine update in this browser frame (if any). \n    * There may be multiple engine update calls per browser frame (or none) depending on framerate and timestep delta.\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after each and every engine update in this browser frame (if any). \n    * There may be multiple engine update calls per browser frame (or none) depending on framerate and timestep delta.\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * The fixed timestep size used for `Engine.update` calls in milliseconds, known as `delta`.\n     * \n     * This value is recommended to be `1000 / 60` ms or smaller (i.e. equivalent to at least 60hz).\n     * \n     * Smaller `delta` values provide higher quality results at the cost of performance.\n     * \n     * You should usually avoid changing `delta` during running, otherwise quality may be affected. \n     * \n     * For smoother frame pacing choose a `delta` that is an even multiple of each display FPS you target, i.e. `1000 / (n * fps)` as this helps distribute an equal number of updates over each display frame.\n     * \n     * For example with a 60 Hz `delta` i.e. `1000 / 60` the runner will on average perform one update per frame on displays running 60 FPS and one update every two frames on displays running 120 FPS, etc.\n     * \n     * Where as e.g. using a 240 Hz `delta` i.e. `1000 / 240` the runner will on average perform four updates per frame on displays running 60 FPS and two updates per frame on displays running 120 FPS, etc.\n     * \n     * Therefore `Runner.run` will call multiple engine updates (or none) as needed to simulate the time elapsed between browser frames. \n     * \n     * In practice the number of updates in any particular frame may be restricted to respect the runner's performance budgets. These are specified by `runner.maxFrameTime` and `runner.maxUpdates`, see those properties for details.\n     * \n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */\n\n    /**\n     * A flag that can be toggled to enable or disable tick calls on this runner, therefore pausing engine updates and events while the runner loop remains running.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * The accumulated time elapsed that has yet to be simulated in milliseconds.\n     * This value is clamped within certain limits (see `Runner.tick` code).\n     *\n     * @private\n     * @property timeBuffer\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * The measured time elapsed between the last two browser frames measured in milliseconds.\n     * This is useful e.g. to estimate the current browser FPS using `1000 / runner.frameDelta`.\n     *\n     * @readonly\n     * @property frameDelta\n     * @type number\n     */\n\n    /**\n     * Enables averaging to smooth frame rate measurements and therefore stabilise play rate.\n     *\n     * @property frameDeltaSmoothing\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * Rounds measured browser frame delta to the nearest 1 Hz.\n     * This option can help smooth frame rate measurements and simplify handling hardware timing differences e.g. 59.94Hz and 60Hz displays.\n     * For best results you should also round your `runner.delta` equivalent to the nearest 1 Hz.\n     *\n     * @property frameDeltaSnapping\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A performance budget that limits execution time allowed for this runner per browser frame in milliseconds.\n     * \n     * To calculate the effective browser FPS at which this throttle is applied use `1000 / runner.maxFrameTime`.\n     * \n     * This performance budget is intended to help maintain browser interactivity and help improve framerate recovery during temporary high CPU usage.\n     * \n     * This budget only covers the measured time elapsed executing the functions called in the scope of the runner tick, including `Engine.update` and its related user event callbacks.\n     * \n     * You may also reduce this budget to allow for any significant additional processing you perform on the same thread outside the scope of this runner tick, e.g. rendering time.\n     * \n     * See also `runner.maxUpdates`.\n     *\n     * @property maxFrameTime\n     * @type number\n     * @default 1000 / 30\n     */\n\n    /**\n     * An optional limit for maximum engine update count allowed per frame tick in addition to `runner.maxFrameTime`.\n     * \n     * Unless you set a value it is automatically chosen based on `runner.delta` and `runner.maxFrameTime`.\n     * \n     * See also `runner.maxFrameTime`.\n     * \n     * @property maxUpdates\n     * @type number\n     * @default null\n     */\n\n    /**\n     * The timestamp of the last call to `Runner.tick` used to measure `frameDelta`.\n     *\n     * @private\n     * @property timeLastTick\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * The id of the last call to `Runner._onNextFrame`.\n     *\n     * @private\n     * @property frameRequestId\n     * @type number\n     * @default null\n     */\n\n})();\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* This module has now been replaced by `Matter.Collision`.\n*\n* All usage should be migrated to `Matter.Collision`.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n* @deprecated\n*/\n\nvar SAT = {};\n\nmodule.exports = SAT;\n\nvar Collision = __webpack_require__(8);\nvar Common = __webpack_require__(0);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @deprecated replaced by Collision.collides\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {collision} collision\n     */\n    SAT.collides = function(bodyA, bodyB) {\n        return Collision.collides(bodyA, bodyB);\n    };\n\n    deprecated(SAT, 'collides', 'SAT.collides \u27A4 replaced by Collision.collides');\n\n})();\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/\n\nvar Svg = {};\n\nmodule.exports = Svg;\n\nvar Bounds = __webpack_require__(1);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */\n    Svg.pathToVertices = function(path, sampleLength) {\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n        }\n\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n        var i, il, total, point, segment, segments, \n            segmentsQueue, lastSegment, \n            lastPoint, segmentIndex, points = [],\n            lx, ly, length = 0, x = 0, y = 0;\n\n        sampleLength = sampleLength || 15;\n\n        var addPoint = function(px, py, pathSegType) {\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n\n            // when the last point doesn't equal the current point add the current point\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                if (lastPoint && isRelative) {\n                    lx = lastPoint.x;\n                    ly = lastPoint.y;\n                } else {\n                    lx = 0;\n                    ly = 0;\n                }\n\n                var point = {\n                    x: lx + px,\n                    y: ly + py\n                };\n\n                // set last point\n                if (isRelative || !lastPoint) {\n                    lastPoint = point;\n                }\n\n                points.push(point);\n\n                x = lx + px;\n                y = ly + py;\n            }\n        };\n\n        var addSegmentPoint = function(segment) {\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\n\n            // skip path ends\n            if (segType === 'Z') \n                return;\n\n            // map segment to x and y\n            switch (segType) {\n\n            case 'M':\n            case 'L':\n            case 'T':\n            case 'C':\n            case 'S':\n            case 'Q':\n                x = segment.x;\n                y = segment.y;\n                break;\n            case 'H':\n                x = segment.x;\n                break;\n            case 'V':\n                y = segment.y;\n                break;\n            }\n\n            addPoint(x, y, segment.pathSegType);\n        };\n\n        // ensure path is absolute\n        Svg._svgPathToAbsolute(path);\n\n        // get total length\n        total = path.getTotalLength();\n\n        // queue segments\n        segments = [];\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\n            segments.push(path.pathSegList.getItem(i));\n\n        segmentsQueue = segments.concat();\n\n        // sample through path\n        while (length < total) {\n            // get segment at position\n            segmentIndex = path.getPathSegAtLength(length);\n            segment = segments[segmentIndex];\n\n            // new segment\n            if (segment != lastSegment) {\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\n                    addSegmentPoint(segmentsQueue.shift());\n\n                lastSegment = segment;\n            }\n\n            // add points in between when curving\n            // TODO: adaptive sampling\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n\n            case 'C':\n            case 'T':\n            case 'S':\n            case 'Q':\n            case 'A':\n                point = path.getPointAtLength(length);\n                addPoint(point.x, point.y, 0);\n                break;\n\n            }\n\n            // increment by sample value\n            length += sampleLength;\n        }\n\n        // add remaining segments not passed by sampling\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\n            addSegmentPoint(segmentsQueue[i]);\n\n        return points;\n    };\n\n    Svg._svgPathToAbsolute = function(path) {\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n        // Copyright (c) Gavin Kistner\n        // http://phrogz.net/js/_ReuseLicense.txt\n        // Modifications: tidy formatting and naming\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\n            x = 0, y = 0, len = segs.numberOfItems;\n\n        for (var i = 0; i < len; ++i) {\n            var seg = segs.getItem(i),\n                segType = seg.pathSegTypeAsLetter;\n\n            if (/[MLHVCSQTA]/.test(segType)) {\n                if ('x' in seg) x = seg.x;\n                if ('y' in seg) y = seg.y;\n            } else {\n                if ('x1' in seg) x1 = x + seg.x1;\n                if ('x2' in seg) x2 = x + seg.x2;\n                if ('y1' in seg) y1 = y + seg.y1;\n                if ('y2' in seg) y2 = y + seg.y2;\n                if ('x' in seg) x += seg.x;\n                if ('y' in seg) y += seg.y;\n\n                switch (segType) {\n\n                case 'm':\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                    break;\n                case 'l':\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                    break;\n                case 'h':\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                    break;\n                case 'v':\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                    break;\n                case 'c':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                    break;\n                case 's':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                    break;\n                case 'q':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                    break;\n                case 't':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                    break;\n                case 'a':\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                    break;\n                case 'z':\n                case 'Z':\n                    x = x0;\n                    y = y0;\n                    break;\n\n                }\n            }\n\n            if (segType == 'M' || segType == 'm') {\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n\n})();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/\n\nvar World = {};\n\nmodule.exports = World;\n\nvar Composite = __webpack_require__(6);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * See above, aliases for back compatibility only\n     */\n    World.create = Composite.create;\n    World.add = Composite.add;\n    World.remove = Composite.remove;\n    World.clear = Composite.clear;\n    World.addComposite = Composite.addComposite;\n    World.addBody = Composite.addBody;\n    World.addConstraint = Composite.addConstraint;\n\n})();\n\n\n/***/ })\n/******/ ]);\n});", "/**\n * Collection of valid extension types.\n * @category extensions\n * @advanced\n */\nenum ExtensionType\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n\n    /** A type of extension for creating custom batchers used in rendering. */\n    Batcher = 'batcher',\n}\n\n/**\n * The metadata for an extension.\n * @category extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @category extensions\n * @advanced\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @category extensions\n * @advanced\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @category extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\n/**\n * The function that is called when an extension is added or removed.\n * @category extensions\n * @ignore\n */\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @category extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration system for all PixiJS extensions. Provides a centralized way to add, remove,\n * and manage functionality across the engine.\n *\n * Features:\n * - Register custom extensions and plugins\n * - Handle multiple extension types\n * - Priority-based ordering\n * @example\n * ```ts\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // Register a simple object extension\n * extensions.add({\n *   extension: {\n *       type: ExtensionType.LoadParser,\n *       name: 'my-loader',\n *       priority: 100, // Optional priority for ordering\n *   },\n *   // add load parser functions\n * });\n *\n * // Register a class-based extension\n * class MyRendererPlugin {\n *     static extension = {\n *         type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n *         name: 'myRendererPlugin'\n *     };\n *\n *    // add renderer plugin methods\n * }\n * extensions.add(MyRendererPlugin);\n *\n * // Remove extensions\n * extensions.remove(MyRendererPlugin);\n * ```\n * @remarks\n * - Extensions must have a type from {@link ExtensionType}\n * - Can be registered before or after their handlers\n * - Supports priority-based ordering\n * - Automatically normalizes extension formats\n * @see {@link ExtensionType} For all available extension types\n * @see {@link ExtensionFormat} For extension registration format\n * @see {@link Application} For application plugin system\n * @see {@link LoaderParser} For asset loading extensions\n * @category extensions\n * @standard\n * @class\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed. Can be:\n     * - Extension class with static `extension` property\n     * - Extension format object with `type` and `ref`\n     * - Multiple extensions as separate arguments\n     * @returns {extensions} this for chaining\n     * @example\n     * ```ts\n     * // Remove a single extension\n     * extensions.remove(MyRendererPlugin);\n     *\n     * // Remove multiple extensions\n     * extensions.remove(\n     *     MyRendererPlugin,\n     *     MySystemPlugin\n     * );\n     * ```\n     * @see {@link ExtensionType} For available extension types\n     * @see {@link ExtensionFormat} For extension format details\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS. Extensions can be registered in multiple formats:\n     * - As a class with a static `extension` property\n     * - As an extension format object\n     * - As multiple extensions passed as separate arguments\n     * @param extensions - Extensions to add to PixiJS. Each can be:\n     * - A class with static `extension` property\n     * - An extension format object with `type` and `ref`\n     * - Multiple extensions as separate arguments\n     * @returns This extensions instance for chaining\n     * @example\n     * ```ts\n     * // Register a simple extension\n     * extensions.add(MyRendererPlugin);\n     *\n     * // Register multiple extensions\n     * extensions.add(\n     *     MyRendererPlugin,\n     *     MySystemPlugin,\n     * });\n     * ```\n     * @see {@link ExtensionType} For available extension types\n     * @see {@link ExtensionFormat} For extension format details\n     * @see {@link extensions.remove} For removing registered extensions\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns this for chaining.\n     * @internal\n     * @ignore\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Mixin the source object(s) properties into the target class's prototype.\n     * Copies all property descriptors from source objects to the target's prototype.\n     * @param Target - The target class to mix properties into\n     * @param sources - One or more source objects containing properties to mix in\n     * @example\n     * ```ts\n     * // Create a mixin with shared properties\n     * const moveable = {\n     *     x: 0,\n     *     y: 0,\n     *     move(x: number, y: number) {\n     *         this.x += x;\n     *         this.y += y;\n     *     }\n     * };\n     *\n     * // Create a mixin with computed properties\n     * const scalable = {\n     *     scale: 1,\n     *     get scaled() {\n     *         return this.scale > 1;\n     *     }\n     * };\n     *\n     * // Apply mixins to a class\n     * extensions.mixin(Sprite, moveable, scalable);\n     *\n     * // Use mixed-in properties\n     * const sprite = new Sprite();\n     * sprite.move(10, 20);\n     * console.log(sprite.x, sprite.y); // 10, 20\n     * ```\n     * @remarks\n     * - Copies all properties including getters/setters\n     * - Does not modify source objects\n     * - Preserves property descriptors\n     * @see {@link Object.defineProperties} For details on property descriptors\n     * @see {@link Object.getOwnPropertyDescriptors} For details on property copying\n     */\n    mixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][])\n    {\n        // Apply each source's properties to the target prototype\n        for (const source of sources)\n        {\n            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));\n        }\n    }\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n", "export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n", "import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Array of RGBA color components, where each component is a number between 0 and 1.\n * The array must contain exactly 4 numbers in the order: red, green, blue, alpha.\n * @example\n * ```ts\n * // Full white (opaque)\n * const white: RgbaArray = [1, 1, 1, 1];\n *\n * // Semi-transparent red\n * const transparentRed: RgbaArray = [1, 0, 0, 0.5];\n * ```\n * @remarks\n * - All components must be between 0 and 1\n * - Array must contain exactly 4 values\n * - Order is [red, green, blue, alpha]\n * @see {@link Color} For the main color utility class\n * @category color\n * @standard\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid color formats supported by PixiJS. These types extend from [colord](https://www.npmjs.com/package/colord)\n * with additional PixiJS-specific formats.\n *\n * Common Formats:\n * ```ts\n * // CSS Color Names\n * new Color('red');\n * new Color('blue');\n * new Color('green');\n *\n * // Hex Values\n * new Color(0xff0000);     // RGB integer\n * new Color('#ff0000');    // 6-digit hex\n * new Color('#f00');       // 3-digit hex\n * new Color('#ff0000ff');  // 8-digit hex (with alpha)\n * new Color('#f00f');      // 4-digit hex (with alpha)\n *\n * // RGB/RGBA Objects\n * new Color({ r: 255, g: 0, b: 0 });\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 });\n *\n * // RGB/RGBA Strings\n * new Color('rgb(255, 0, 0)');\n * new Color('rgba(255, 0, 0, 0.5)');\n * new Color('rgb(100% 0% 0%)');\n * new Color('rgba(100% 0% 0% / 50%)');\n *\n * // Arrays (normalized 0-1)\n * new Color([1, 0, 0]);           // RGB\n * new Color([1, 0, 0, 0.5]);      // RGBA\n * new Color(new Float32Array([1, 0, 0, 0.5]));\n *\n * // Arrays (0-255)\n * new Color(new Uint8Array([255, 0, 0]));\n * new Color(new Uint8ClampedArray([255, 0, 0, 128]));\n *\n * // HSL/HSLA\n * new Color({ h: 0, s: 100, l: 50 });\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 });\n * new Color('hsl(0, 100%, 50%)');\n * new Color('hsla(0deg 100% 50% / 50%)');\n *\n * // HSV/HSVA\n * new Color({ h: 0, s: 100, v: 100 });\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 });\n * ```\n * @remarks\n * - All color values are normalized internally to 0-1 range\n * - Alpha is always between 0-1\n * - Invalid colors will throw an error\n * - Original format is preserved when possible\n * @see {@link Color} For the main color utility class\n * @see {@link https://www.w3.org/TR/css-color-4} CSS Color Level 4 Specification\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    | number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class for managing colors in various formats. Provides a unified way to work\n * with colors across your PixiJS application.\n *\n * Features:\n * - Accepts multiple color formats (hex, RGB, HSL, etc.)\n * - Automatic format conversion\n * - Color manipulation methods\n * - Component access (r,g,b,a)\n * - Chainable operations\n * @example\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n *\n * // Convert between formats\n * const color = new Color('red');\n * color.toHex();        // \"#ff0000\"\n * color.toRgbString();  // \"rgb(255,0,0,1)\"\n * color.toNumber();     // 0xff0000\n *\n * // Access components\n * color.red;    // 1\n * color.green;  // 0\n * color.blue;   // 0\n * color.alpha;  // 1\n *\n * // Chain operations\n * color\n *   .setAlpha(0.5)\n *   .multiply([0.5, 0.5, 0.5])\n *   .premultiply(0.8);\n * ```\n * @remarks\n * The Color class automatically normalizes all color values internally:\n * - RGB components are stored as floats between 0-1\n * - Alpha is always between 0-1\n * - Color operations clamp values to valid ranges\n * - Original input format is preserved when possible\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport class Color\n{\n    /**\n     * Static shared Color instance used for utility operations. This is a singleton color object\n     * that can be reused to avoid creating unnecessary Color instances.\n     * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be\n     * > changed by any code that uses it.\n     * >\n     * > It is best used for one-off color operations or temporary transformations.\n     * > For persistent colors, create your own Color instance instead.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Use shared instance for one-off color operations\n     * Color.shared.setValue(0xff0000);\n     * const redHex = Color.shared.toHex();     // \"#ff0000\"\n     * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]\n     *\n     * // Temporary color transformations\n     * const colorNumber = Color.shared\n     *     .setValue('#ff0000')     // Set to red\n     *     .setAlpha(0.5)          // Make semi-transparent\n     *     .premultiply(0.8)       // Apply premultiplication\n     *     .toNumber();            // Convert to number\n     *\n     * // Chain multiple operations\n     * const result = Color.shared\n     *     .setValue(someColor)\n     *     .multiply(tintColor)\n     *     .toPremultiplied(alpha);\n     * ```\n     * @remarks\n     * - This is a shared instance - be careful about multiple code paths using it simultaneously\n     * - Use for temporary color operations to avoid allocating new Color instances\n     * - The value is preserved between operations, so reset if needed\n     * - For persistent colors, create your own Color instance instead\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /**\n     * Get the red component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('red');\n     * console.log(color.red); // 1\n     *\n     * const green = new Color('#00ff00');\n     * console.log(green.red); // 0\n     * ```\n     */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /**\n     * Get the green component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('lime');\n     * console.log(color.green); // 1\n     *\n     * const red = new Color('#ff0000');\n     * console.log(red.green); // 0\n     * ```\n     */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /**\n     * Get the blue component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('blue');\n     * console.log(color.blue); // 1\n     *\n     * const yellow = new Color('#ffff00');\n     * console.log(yellow.blue); // 0\n     * ```\n     */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /**\n     * Get the alpha component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('red');\n     * console.log(color.alpha); // 1 (fully opaque)\n     *\n     * const transparent = new Color('rgba(255, 0, 0, 0.5)');\n     * console.log(transparent.alpha); // 0.5 (semi-transparent)\n     * ```\n     */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Sets the color value and returns the instance for chaining.\n     *\n     * This is a chainable version of setting the `value` property.\n     * @param value - The color to set. Accepts various formats:\n     * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n     * - RGB/RGBA values (arrays, objects)\n     * - CSS color names\n     * - HSL/HSLA values\n     * - HSV/HSVA values\n     * @returns The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic usage\n     * const color = new Color();\n     * color.setValue('#ff0000')\n     *     .setAlpha(0.5)\n     *     .premultiply(0.8);\n     *\n     * // Different formats\n     * color.setValue(0xff0000);          // Hex number\n     * color.setValue('#ff0000');         // Hex string\n     * color.setValue([1, 0, 0]);         // RGB array\n     * color.setValue([1, 0, 0, 0.5]);    // RGBA array\n     * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object\n     *\n     * // Copy from another color\n     * const red = new Color('red');\n     * color.setValue(red);\n     * ```\n     * @throws {Error} If the color value is invalid or null\n     * @see {@link Color.value} For the underlying value property\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source. This property allows getting and setting the color value\n     * while preserving the original format where possible.\n     * @remarks\n     * When setting:\n     * - Setting to a `Color` instance copies its source and components\n     * - Setting to other valid sources normalizes and stores the value\n     * - Setting to `null` throws an Error\n     * - The color remains unchanged if normalization fails\n     *\n     * When getting:\n     * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}\n     * - Otherwise returns the original color source\n     * @example\n     * ```ts\n     * // Setting different color formats\n     * const color = new Color();\n     *\n     * color.value = 0xff0000;         // Hex number\n     * color.value = '#ff0000';        // Hex string\n     * color.value = [1, 0, 0];        // RGB array\n     * color.value = [1, 0, 0, 0.5];   // RGBA array\n     * color.value = { r: 1, g: 0, b: 0 }; // RGB object\n     *\n     * // Copying from another color\n     * const red = new Color('red');\n     * color.value = red;  // Copies red's components\n     *\n     * // Getting the value\n     * console.log(color.value);  // Returns original format\n     *\n     * // After modifications\n     * color.multiply([0.5, 0.5, 0.5]);\n     * console.log(color.value);  // Returns null\n     * ```\n     * @throws {Error} When attempting to set `null`\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._value = this._cloneSource(value);\n            this._normalize(this._value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object with normalized components (0-1).\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGBA objects\n     * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }\n     * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }\n     *\n     * // With transparency\n     * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }\n     * ```\n     * @returns An RGBA object with normalized components\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object with normalized components (0-1).\n     *\n     * Alpha component is omitted in the output.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGB objects\n     * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }\n     * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }\n     *\n     * // Alpha is ignored\n     * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }\n     * ```\n     * @returns An RGB object with normalized components\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /**\n     * Convert to a CSS-style rgba string representation.\n     *\n     * RGB components are scaled to 0-255 range, alpha remains 0-1.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGBA strings\n     * new Color('white').toRgbaString();     // returns \"rgba(255,255,255,1)\"\n     * new Color('#ff0000').toRgbaString();   // returns \"rgba(255,0,0,1)\"\n     *\n     * // With transparency\n     * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns \"rgba(255,0,0,0.5)\"\n     * ```\n     * @returns A CSS-compatible rgba string\n     */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGB components as integers between 0-255\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]\n     *\n     * // Using custom output array\n     * const rgb = new Uint8Array(3);\n     * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]\n     *\n     * // Using different array types\n     * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]\n     * new Color('red').toUint8RgbArray([]); // [255, 0, 0]\n     * ```\n     * @remarks\n     * - Output values are always clamped between 0-255\n     * - Alpha component is not included in output\n     * - Reuses internal cache array if no output array provided\n     */\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray = number[]>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGBA components as floats between 0-1\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toArray();  // returns [1, 1, 1, 1]\n     * new Color('red').toArray();    // returns [1, 0, 0, 1]\n     *\n     * // With alpha\n     * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]\n     *\n     * // Using custom output array\n     * const rgba = new Float32Array(4);\n     * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]\n     * ```\n     * @remarks\n     * - Output values are normalized between 0-1\n     * - Includes alpha component as the fourth value\n     * - Reuses internal cache array if no output array provided\n     */\n    public toArray<T extends number[] | Float32Array = number[]>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out ||= this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGB components as floats between 0-1\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * new Color('red').toRgbArray();   // returns [1, 0, 0]\n     *\n     * // Using custom output array\n     * const rgb = new Float32Array(3);\n     * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]\n     * ```\n     * @remarks\n     * - Output values are normalized between 0-1\n     * - Alpha component is omitted from output\n     * - Reuses internal cache array if no output array provided\n     */\n    public toRgbArray<T extends number[] | Float32Array = number[]>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @returns The color as a 24-bit RGB integer\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toNumber(); // returns 0xffffff\n     * new Color('red').toNumber();   // returns 0xff0000\n     *\n     * // Store as hex\n     * const color = new Color('blue');\n     * const hex = color.toNumber(); // 0x0000ff\n     * ```\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number.\n     *\n     * Useful for platforms that expect colors in BGR format.\n     * @returns The color as a 24-bit BGR integer\n     * @example\n     * ```ts\n     * // Convert RGB to BGR\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     *\n     * // Common use case: platform-specific color format\n     * const color = new Color('orange');\n     * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels\n     * ```\n     * @remarks\n     * This swaps the red and blue channels compared to the normal RGB format:\n     * - RGB 0xRRGGBB becomes BGR 0xBBGGRR\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     *\n     * Useful for platforms that expect colors in little endian byte order.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert RGB color to little endian format\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     *\n     * // Common use cases:\n     * const color = new Color('orange');\n     * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems\n     *\n     * // Multiple conversions\n     * const colors = {\n     *     normal: 0xffcc99,\n     *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff\n     *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99\n     * };\n     * ```\n     * @remarks\n     * - Swaps R and B channels in the color value\n     * - RGB 0xRRGGBB becomes 0xBBGGRR\n     * - Useful for systems that use little endian byte order\n     * - Can be used to convert back and forth between formats\n     * @returns The color as a number in little endian format (BBGGRR)\n     * @see {@link Color.toBgrNumber} For BGR format without byte swapping\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color.\n     *\n     * This action is destructive and modifies the original color.\n     * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:\n     * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n     * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])\n     * - Color objects ({ r: 1, g: 0, b: 0 })\n     * - CSS color names ('red', 'blue')\n     * @returns this - The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic multiplication\n     * const color = new Color('#ff0000');\n     * color.multiply(0x808080); // 50% darker red\n     *\n     * // With transparency\n     * color.multiply([1, 1, 1, 0.5]); // 50% transparent\n     *\n     * // Chain operations\n     * color\n     *     .multiply('#808080')\n     *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });\n     * ```\n     * @remarks\n     * - Multiplies each RGB component and alpha separately\n     * - Values are clamped between 0-1\n     * - Original color format is lost (value becomes null)\n     * - Operation cannot be undone\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format.\n     *\n     * This action is destructive and modifies the original color.\n     * @param alpha - The alpha value to multiply by (0-1)\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n     * @returns {Color} The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic premultiplication\n     * const color = new Color('red');\n     * color.premultiply(0.5); // 50% transparent red with premultiplied RGB\n     *\n     * // Alpha only (RGB unchanged)\n     * color.premultiply(0.5, false); // 50% transparent, original RGB\n     *\n     * // Chain with other operations\n     * color\n     *     .multiply(0x808080)\n     *     .premultiply(0.5)\n     *     .toNumber();\n     * ```\n     * @remarks\n     * - RGB channels are multiplied by alpha when applyToRGB is true\n     * - Alpha is always set to the provided value\n     * - Values are clamped between 0-1\n     * - Original color format is lost (value becomes null)\n     * - Operation cannot be undone\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Returns the color as a 32-bit premultiplied alpha integer.\n     *\n     * Format: 0xAARRGGBB\n     * @param {number} alpha - The alpha value to multiply by (0-1)\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n     * @returns {number} The premultiplied color as a 32-bit integer\n     * @example\n     * ```ts\n     * // Convert to premultiplied format\n     * const color = new Color('red');\n     *\n     * // Full opacity (0xFFRRGGBB)\n     * color.toPremultiplied(1.0); // 0xFFFF0000\n     *\n     * // 50% transparency with premultiplied RGB\n     * color.toPremultiplied(0.5); // 0x7F7F0000\n     *\n     * // 50% transparency without RGB premultiplication\n     * color.toPremultiplied(0.5, false); // 0x7FFF0000\n     * ```\n     * @remarks\n     * - Returns full opacity (0xFF000000) when alpha is 1.0\n     * - Returns 0 when alpha is 0.0 and applyToRGB is true\n     * - RGB values are rounded during premultiplication\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexadecimal string (6 characters).\n     * @returns A CSS-compatible hex color string (e.g., \"#ff0000\")\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Basic colors\n     * new Color('red').toHex();    // returns \"#ff0000\"\n     * new Color('white').toHex();  // returns \"#ffffff\"\n     * new Color('black').toHex();  // returns \"#000000\"\n     *\n     * // From different formats\n     * new Color(0xff0000).toHex(); // returns \"#ff0000\"\n     * new Color([1, 0, 0]).toHex(); // returns \"#ff0000\"\n     * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns \"#ff0000\"\n     * ```\n     * @remarks\n     * - Always returns a 6-character hex string\n     * - Includes leading \"#\" character\n     * - Alpha channel is ignored\n     * - Values are rounded to nearest hex value\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexadecimal string with alpha (8 characters).\n     * @returns A CSS-compatible hex color string with alpha (e.g., \"#ff0000ff\")\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Fully opaque colors\n     * new Color('red').toHexa();   // returns \"#ff0000ff\"\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     *\n     * // With transparency\n     * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns \"#ff00007f\"\n     * new Color([1, 0, 0, 0]).toHexa(); // returns \"#ff000000\"\n     * ```\n     * @remarks\n     * - Returns an 8-character hex string\n     * - Includes leading \"#\" character\n     * - Alpha is encoded in last two characters\n     * - Values are rounded to nearest hex value\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha (transparency) value while preserving color components.\n     *\n     * Provides a chainable interface for setting alpha.\n     * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)\n     * @returns The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic alpha setting\n     * const color = new Color('red');\n     * color.setAlpha(0.5);  // 50% transparent red\n     *\n     * // Chain with other operations\n     * color\n     *     .setValue('#ff0000')\n     *     .setAlpha(0.8)    // 80% opaque\n     *     .premultiply(0.5); // Further modify alpha\n     *\n     * // Reset to fully opaque\n     * color.setAlpha(1);\n     * ```\n     * @remarks\n     * - Alpha value is clamped between 0-1\n     * - Can be chained with other color operations\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primitive so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if a value can be interpreted as a valid color format.\n     * Supports all color formats that can be used with the Color class.\n     * @param value - Value to check\n     * @returns True if the value can be used as a color\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // CSS colors and hex values\n     * Color.isColorLike('red');          // true\n     * Color.isColorLike('#ff0000');      // true\n     * Color.isColorLike(0xff0000);       // true\n     *\n     * // Arrays (RGB/RGBA)\n     * Color.isColorLike([1, 0, 0]);      // true\n     * Color.isColorLike([1, 0, 0, 0.5]); // true\n     *\n     * // TypedArrays\n     * Color.isColorLike(new Float32Array([1, 0, 0]));          // true\n     * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true\n     * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true\n     *\n     * // Object formats\n     * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)\n     * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)\n     * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)\n     * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)\n     * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)\n     * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)\n     *\n     * // Color instances\n     * Color.isColorLike(new Color('red')); // true\n     *\n     * // Invalid values\n     * Color.isColorLike(null);           // false\n     * Color.isColorLike(undefined);      // false\n     * Color.isColorLike({});             // false\n     * Color.isColorLike([]);             // false\n     * Color.isColorLike('not-a-color');  // false\n     * ```\n     * @remarks\n     * Checks for the following formats:\n     * - Numbers (0x000000 to 0xffffff)\n     * - CSS color strings\n     * - RGB/RGBA arrays and objects\n     * - HSL/HSLA objects\n     * - HSV/HSVA objects\n     * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)\n     * - Color instances\n     * @see {@link ColorSource} For supported color format types\n     * @see {@link Color.setValue} For setting color values\n     * @category utility\n     */\n    public static isColorLike(value: unknown): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\n\n/**\n * The CullingMixin interface provides properties and methods for managing culling behavior\n * of a display object. Culling is the process of determining whether an object should be rendered\n * based on its visibility within the current view or frame.\n *\n * Key Features:\n * - Custom culling areas for better performance\n * - Per-object culling control\n * - Child culling management\n * @example\n * ```ts\n * // Enable culling for a container\n * const container = new Container();\n * container.cullable = true;\n *\n * // Set custom cull area for better performance\n * container.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Disable child culling for static scenes\n * container.cullableChildren = false;\n * ```\n * @category scene\n * @standard\n */\nexport interface CullingMixinConstructor\n{\n    /**\n     * Custom shape used for culling calculations instead of object bounds.\n     * Defined in local space coordinates relative to the object.\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for culling,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Define custom culling boundary\n     * container.cullArea = new Rectangle(0, 0, 800, 600);\n     *\n     * // Reset to use object bounds\n     * container.cullArea = null;\n     * ```\n     * @remarks\n     * - Improves performance by avoiding bounds calculations\n     * - Useful for containers with many children\n     * - Set to null to use object bounds\n     * @default null\n     */\n    cullArea: Rectangle;\n\n    /**\n     * Controls whether this object should be culled when out of view.\n     * When true, the object will not be rendered if its bounds are outside the visible area.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable culling\n     * sprite.cullable = true;\n     *\n     * // Force object to always render\n     * sprite.cullable = false;\n     * ```\n     * @remarks\n     * - Does not affect transform updates\n     * - Applies to this object only\n     * - Children follow their own cullable setting\n     * @default false\n     */\n    cullable: boolean;\n\n    /**\n     * Controls whether children of this container can be culled.\n     * When false, skips recursive culling checks for better performance.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Enable container culling\n     * container.cullable = true;\n     *\n     * // Disable child culling for performance\n     * container.cullableChildren = false;\n     *\n     * // Children will always render if container is visible\n     * container.addChild(sprite1, sprite2, sprite3);\n     * ```\n     * @remarks\n     * - Improves performance for static scenes\n     * - Useful when children are always within container bounds\n     * - Parent culling still applies\n     * @default true\n     */\n    cullableChildren: boolean;\n}\n\n/** @internal */\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n", "/**\n * Two Pi.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @type {number} RAD_TO_DEG\n * @category maths\n * @standard\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @category maths\n * @advanced\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @example\n * ```ts\n * // Basic point creation\n * const point = new Point(100, 200);\n *\n * // Using with transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Point arithmetic\n * const start = new Point(0, 0);\n * const end = new Point(100, 100);\n * const middle = new Point(\n *     (start.x + end.x) / 2,\n *     (start.y + end.y) / 2\n * );\n * ```\n * @see {@link PointData} For basic x,y interface\n * @see {@link PointLike} For point manipulation interface\n * @see {@link ObservablePoint} For observable version\n * @category maths\n * @standard\n */\nexport class Point implements PointLike\n{\n    /**\n     * Position of the point on the x axis\n     * @example\n     * ```ts\n     * // Set x position\n     * const point = new Point();\n     * point.x = 100;\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     */\n    public x = 0;\n    /**\n     * Position of the point on the y axis\n     * @example\n     * ```ts\n     * // Set y position\n     * const point = new Point();\n     * point.y = 200;\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point, which is a new instance with the same `x` and `y` values.\n     * @example\n     * ```ts\n     * // Basic point cloning\n     * const original = new Point(100, 200);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.set(300, 400);\n     *\n     * // Verify independence\n     * console.log(original); // Point(100, 200)\n     * console.log(modified); // Point(300, 400)\n     * ```\n     * @remarks\n     * - Creates new Point instance\n     * - Deep copies x and y values\n     * - Independent from original\n     * - Useful for preserving values\n     * @returns A clone of this point\n     * @see {@link Point.copyFrom} For copying into existing point\n     * @see {@link Point.copyTo} For copying to existing point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies x and y from the given point into this point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Point(100, 200);\n     * const target = new Point();\n     * target.copyFrom(source);\n     *\n     * // Copy and chain operations\n     * const point = new Point()\n     *     .copyFrom(source)\n     *     .set(x + 50, y + 50);\n     *\n     * // Copy from any PointData\n     * const data = { x: 10, y: 20 };\n     * point.copyFrom(data);\n     * ```\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     * @see {@link Point.copyTo} For copying to another point\n     * @see {@link Point.clone} For creating new point copy\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Point(100, 200);\n     * const target = new Point();\n     * source.copyTo(target);\n     * ```\n     * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n     * @returns The point (`p`) with values updated\n     * @see {@link Point.copyFrom} For copying from another point\n     * @see {@link Point.clone} For creating new point copy\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * Compares x and y values using strict equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const p1 = new Point(100, 200);\n     * const p2 = new Point(100, 200);\n     * console.log(p1.equals(p2)); // true\n     *\n     * // Compare with PointData\n     * const data = { x: 100, y: 200 };\n     * console.log(p1.equals(data)); // true\n     *\n     * // Check different points\n     * const p3 = new Point(200, 300);\n     * console.log(p1.equals(p3)); // false\n     * ```\n     * @param p - The point to check\n     * @returns `true` if both `x` and `y` are equal\n     * @see {@link Point.copyFrom} For making points equal\n     * @see {@link PointData} For point data interface\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new x and y position.\n     *\n     * If y is omitted, both x and y will be set to x.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * const point = new Point();\n     * point.set(100, 200);\n     *\n     * // Set both x and y to same value\n     * point.set(50); // x=50, y=50\n     *\n     * // Chain with other operations\n     * point\n     *     .set(10, 20)\n     *     .copyTo(otherPoint);\n     * ```\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis, defaults to x\n     * @returns The point instance itself\n     * @see {@link Point.copyFrom} For copying from another point\n     * @see {@link Point.equals} For comparing positions\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`.\n     *\n     * This shared instance is reset to zero values when accessed.\n     *\n     * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.\n     * @example\n     * ```ts\n     * // Use for temporary calculations\n     * const tempPoint = Point.shared;\n     * tempPoint.set(100, 200);\n     * matrix.apply(tempPoint);\n     *\n     * // Will be reset to (0,0) on next access\n     * const fresh = Point.shared; // x=0, y=0\n     * ```\n     * @readonly\n     * @returns A fresh zeroed point for temporary use\n     * @see {@link Point.constructor} For creating new points\n     * @see {@link PointData} For basic point interface\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\n/**\n * The data structure that contains the position, scale, pivot, skew and rotation of an object.\n * This is used by the {@link Matrix} class to decompose the matrix into its components.\n * @category maths\n * @advanced\n */\nexport interface TransformableObject\n{\n    /** The position of the object */\n    position: PointData;\n    /** The scale of the object */\n    scale: PointData;\n    /** The pivot of the object */\n    pivot: PointData;\n    /** The skew of the object */\n    skew: PointData;\n    /** The rotation of the object */\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * Represents a 3x3 transformation matrix:\n *\n * ```js\n * | a  c  tx |\n * | b  d  ty |\n * | 0  0  1  |\n * ```\n * @example\n * ```ts\n * // Create identity matrix\n * const matrix = new Matrix();\n *\n * // Create matrix with custom values\n * const transform = new Matrix(2, 0, 0, 2, 100, 100); // Scale 2x, translate 100,100\n *\n * // Transform a point\n * const point = { x: 10, y: 20 };\n * const transformed = transform.apply(point);\n *\n * // Chain transformations\n * matrix\n *     .translate(100, 50)\n *     .rotate(Math.PI / 4)\n *     .scale(2, 2);\n * ```\n * @remarks\n * - Used for transform hierarchies\n * - Supports scale, rotation, position\n * - Can be concatenated with append/prepend\n * - Efficient for batched transformations\n * @category maths\n * @standard\n */\nexport class Matrix\n{\n    /**\n     * Scale on the x axis.\n     * @default 1\n     */\n    public a: number;\n\n    /**\n     * Shear on the y axis.\n     * @default 0\n     */\n    public b: number;\n\n    /**\n     * Shear on the x axis.\n     * @default 0\n     */\n    public c: number;\n\n    /**\n     * Scale on the y axis.\n     * @default 1\n     */\n    public d: number;\n\n    /**\n     * Translation on the x axis.\n     * @default 0\n     */\n    public tx: number;\n\n    /**\n     * Translation on the y axis.\n     * @default 0\n     */\n    public ty: number;\n\n    /**\n     * Array representation of the matrix.\n     * Only populated when `toArray()` is called.\n     * @default null\n     * @see {@link Matrix.toArray} For filling this array\n     */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array.\n     * Populates matrix components from a flat array in column-major order.\n     *\n     * > [!NOTE] Array mapping order:\n     * > ```\n     * > array[0] = a  (x scale)\n     * > array[1] = b  (y skew)\n     * > array[2] = tx (x translation)\n     * > array[3] = c  (x skew)\n     * > array[4] = d  (y scale)\n     * > array[5] = ty (y translation)\n     * > ```\n     * @example\n     * ```ts\n     * // Create matrix from array\n     * const matrix = new Matrix();\n     * matrix.fromArray([\n     *     2, 0,  100,  // a, b, tx\n     *     0, 2,  100   // c, d, ty\n     * ]);\n     *\n     * // Create matrix from typed array\n     * const float32Array = new Float32Array([\n     *     1, 0, 0,     // Scale x1, no skew\n     *     0, 1, 0      // No skew, scale x1\n     * ]);\n     * matrix.fromArray(float32Array);\n     * ```\n     * @param array - The array to populate the matrix from\n     * @see {@link Matrix.toArray} For converting matrix to array\n     * @see {@link Matrix.set} For setting values directly\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties directly.\n     * All matrix components can be set in one call.\n     * @example\n     * ```ts\n     * // Set to identity matrix\n     * matrix.set(1, 0, 0, 1, 0, 0);\n     *\n     * // Set to scale matrix\n     * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n     *\n     * // Set to translation matrix\n     * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n     * ```\n     * @param a - Scale on x axis\n     * @param b - Shear on y axis\n     * @param c - Shear on x axis\n     * @param d - Scale on y axis\n     * @param tx - Translation on x axis\n     * @param ty - Translation on y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.fromArray} For setting from array\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     *\n     * > [!NOTE] The array format is:\n     * > ```\n     * > Non-transposed:\n     * > [a, c, tx,\n     * > b, d, ty,\n     * > 0, 0, 1]\n     * >\n     * > Transposed:\n     * > [a, b, 0,\n     * > c, d, 0,\n     * > tx,ty,1]\n     * > ```\n     * @example\n     * ```ts\n     * // Basic array conversion\n     * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n     * const array = matrix.toArray();\n     *\n     * // Using existing array\n     * const float32Array = new Float32Array(9);\n     * matrix.toArray(false, float32Array);\n     *\n     * // Get transposed array\n     * const transposed = matrix.toArray(true);\n     * ```\n     * @param transpose - Whether to transpose the matrix\n     * @param out - Optional Float32Array to store the result\n     * @returns The array containing the matrix values\n     * @see {@link Matrix.fromArray} For creating matrix from array\n     * @see {@link Matrix.array} For cached array storage\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     *\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @example\n     * ```ts\n     * // Basic point transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const point = new Point(10, 20);\n     * const transformed = matrix.apply(point);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.apply(point, output);\n     * ```\n     * @param pos - The origin point to transform\n     * @param newPos - Optional point to store the result\n     * @returns The transformed point\n     * @see {@link Matrix.applyInverse} For inverse transformation\n     * @see {@link Point} For point operations\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     *\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @example\n     * ```ts\n     * // Basic inverse transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const worldPoint = new Point(150, 100);\n     * const localPoint = matrix.applyInverse(worldPoint);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.applyInverse(worldPoint, output);\n     *\n     * // Convert mouse position to local space\n     * const mousePoint = new Point(mouseX, mouseY);\n     * const localMouse = matrix.applyInverse(mousePoint);\n     * ```\n     * @param pos - The origin point to inverse-transform\n     * @param newPos - Optional point to store the result\n     * @returns The inverse-transformed point\n     * @see {@link Matrix.apply} For forward transformation\n     * @see {@link Matrix.invert} For getting inverse matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y axes.\n     * Adds to the position values while preserving scale, rotation and skew.\n     * @example\n     * ```ts\n     * // Basic translation\n     * const matrix = new Matrix();\n     * matrix.translate(100, 50); // Move right 100, down 50\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .scale(2, 2)\n     *     .translate(100, 0)\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - How much to translate on the x axis\n     * @param y - How much to translate on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.set} For setting position directly\n     * @see {@link Matrix.setTransform} For complete transform setup\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * Multiplies the scale values with existing matrix components.\n     * @example\n     * ```ts\n     * // Basic scaling\n     * const matrix = new Matrix();\n     * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100)\n     *     .scale(2, 2)     // Scales after translation\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting scale directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     *\n     * Rotates around the origin (0,0) by the given angle in radians.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * const matrix = new Matrix();\n     * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100) // Move to rotation center\n     *     .rotate(Math.PI)     // Rotate 180 degrees\n     *     .scale(2, 2);        // Scale after rotation\n     *\n     * // Common angles\n     * matrix.rotate(Math.PI / 2);  // 90 degrees\n     * matrix.rotate(Math.PI);      // 180 degrees\n     * matrix.rotate(Math.PI * 2);  // 360 degrees\n     * ```\n     * @remarks\n     * - Rotates around origin point (0,0)\n     * - Affects position if translation was set\n     * - Uses counter-clockwise rotation\n     * - Order of operations matters when chaining\n     * @param angle - The angle in radians\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting rotation directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = this * matrix\n     * @example\n     * ```ts\n     * // Basic matrix combination\n     * const matrix = new Matrix();\n     * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n     * matrix.append(other);\n     * ```\n     * @remarks\n     * - Order matters: A.append(B) !== B.append(A)\n     * - Modifies current matrix\n     * - Preserves transformation order\n     * - Commonly used for combining transforms\n     * @param matrix - The matrix to append\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.prepend} For prepending transformations\n     * @see {@link Matrix.appendFrom} For appending two external matrices\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrices and sets the result to this matrix.\n     * Performs matrix multiplication: this = A * B\n     * @example\n     * ```ts\n     * // Basic matrix multiplication\n     * const result = new Matrix();\n     * const matrixA = new Matrix().scale(2, 2);\n     * const matrixB = new Matrix().rotate(Math.PI / 4);\n     * result.appendFrom(matrixA, matrixB);\n     * ```\n     * @remarks\n     * - Order matters: A * B !== B * A\n     * - Creates a new transformation from two others\n     * - More efficient than append() for multiple operations\n     * - Does not modify input matrices\n     * @param a - The first matrix to multiply\n     * @param b - The second matrix to multiply\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For single matrix combination\n     * @see {@link Matrix.prepend} For reverse order multiplication\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties.\n     * Combines position, scale, rotation, skew and pivot in a single operation.\n     * @example\n     * ```ts\n     * // Basic transform setup\n     * const matrix = new Matrix();\n     * matrix.setTransform(\n     *     100, 100,    // position\n     *     0, 0,        // pivot\n     *     2, 2,        // scale\n     *     Math.PI / 4, // rotation (45 degrees)\n     *     0, 0         // skew\n     * );\n     * ```\n     * @remarks\n     * - Updates all matrix components at once\n     * - More efficient than separate transform calls\n     * - Uses radians for rotation and skew\n     * - Pivot affects rotation center\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.decompose} For extracting transform properties\n     * @see {@link TransformableObject} For transform data structure\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = matrix * this\n     * @example\n     * ```ts\n     * // Basic matrix prepend\n     * const matrix = new Matrix().scale(2, 2);\n     * const other = new Matrix().translate(100, 0);\n     * matrix.prepend(other); // Translation happens before scaling\n     * ```\n     * @remarks\n     * - Order matters: A.prepend(B) !== B.prepend(A)\n     * - Modifies current matrix\n     * - Reverses transformation order compared to append()\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For appending transformations\n     * @see {@link Matrix.appendFrom} For combining external matrices\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix into its individual transform components.\n     * Extracts position, scale, rotation and skew values from the matrix.\n     * @example\n     * ```ts\n     * // Basic decomposition\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * const transform = {\n     *     position: new Point(),\n     *     scale: new Point(),\n     *     pivot: new Point(),\n     *     skew: new Point(),\n     *     rotation: 0\n     * };\n     *\n     * matrix.decompose(transform);\n     * console.log(transform.position); // Point(100, 100)\n     * console.log(transform.rotation); // ~0.785 (PI/4)\n     * console.log(transform.scale); // Point(2, 2)\n     * ```\n     * @remarks\n     * - Handles combined transformations\n     * - Accounts for pivot points\n     * - Chooses between rotation/skew based on transform type\n     * - Uses radians for rotation and skew\n     * @param transform - The transform object to store the decomposed values\n     * @returns The transform with the newly applied properties\n     * @see {@link Matrix.setTransform} For composing from components\n     * @see {@link TransformableObject} For transform structure\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix.\n     * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n     * @example\n     * ```ts\n     * // Basic matrix inversion\n     * const matrix = new Matrix()\n     *     .translate(100, 50)\n     *     .scale(2, 2);\n     *\n     * matrix.invert(); // Now transforms in opposite direction\n     *\n     * // Verify inversion\n     * const point = new Point(50, 50);\n     * const transformed = matrix.apply(point);\n     * const original = matrix.invert().apply(transformed);\n     * // original \u2248 point\n     * ```\n     * @remarks\n     * - Modifies the current matrix\n     * - Useful for reversing transformations\n     * - Cannot invert matrices with zero determinant\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.applyInverse} For inverse transformations\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix is an identity matrix.\n     *\n     * An identity matrix has no transformations applied (default state).\n     * @example\n     * ```ts\n     * // Check if matrix is identity\n     * const matrix = new Matrix();\n     * console.log(matrix.isIdentity()); // true\n     *\n     * // Check after transformations\n     * matrix.translate(100, 0);\n     * console.log(matrix.isIdentity()); // false\n     *\n     * // Reset and verify\n     * matrix.identity();\n     * console.log(matrix.isIdentity()); // true\n     * ```\n     * @remarks\n     * - Verifies a = 1, d = 1 (no scale)\n     * - Verifies b = 0, c = 0 (no skew)\n     * - Verifies tx = 0, ty = 0 (no translation)\n     * @returns True if matrix has no transformations\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * Sets all components to their default values: scale=1, no skew, no translation.\n     * @example\n     * ```ts\n     * // Reset transformed matrix\n     * const matrix = new Matrix()\n     *     .scale(2, 2)\n     *     .rotate(Math.PI / 4);\n     * matrix.identity(); // Back to default state\n     *\n     * // Chain after reset\n     * matrix\n     *     .identity()\n     *     .translate(100, 100)\n     *     .scale(2, 2);\n     *\n     * // Compare with identity constant\n     * const isDefault = matrix.equals(Matrix.IDENTITY);\n     * ```\n     * @remarks\n     * - Sets a=1, d=1 (default scale)\n     * - Sets b=0, c=0 (no skew)\n     * - Sets tx=0, ty=0 (no translation)\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     * @see {@link Matrix.isIdentity} For checking identity state\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @param matrix\n     * @example\n     * ```ts\n     * // Basic matrix cloning\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const copy = matrix.clone();\n     *\n     * // Clone and modify\n     * const modified = matrix.clone()\n     *     .scale(2, 2);\n     *\n     * // Compare matrices\n     * console.log(matrix.equals(copy));     // true\n     * console.log(matrix.equals(modified)); // false\n     * ```\n     * @returns A copy of this matrix. Good for chaining method calls.\n     * @see {@link Matrix.copyTo} For copying to existing matrix\n     * @see {@link Matrix.copyFrom} For copying from another matrix\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix.\n     * @example\n     * ```ts\n     * // Basic matrix copying\n     * const source = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const target = new Matrix();\n     * target.copyFrom(source);\n     * ```\n     * @param matrix - The matrix to copy from\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.clone} For creating new matrix copy\n     * @see {@link Matrix.copyTo} For copying to another matrix\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix equals another matrix.\n     * Compares all components for exact equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const m1 = new Matrix();\n     * const m2 = new Matrix();\n     * console.log(m1.equals(m2)); // true\n     *\n     * // Compare transformed matrices\n     * const transform = new Matrix()\n     *     .translate(100, 100)\n     * const clone = new Matrix()\n     *     .scale(2, 2);\n     * console.log(transform.equals(clone)); // false\n     * ```\n     * @param matrix - The matrix to compare to\n     * @returns True if matrices are identical\n     * @see {@link Matrix.copyFrom} For copying matrix values\n     * @see {@link Matrix.isIdentity} For identity comparison\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix with no transformations applied.\n     *\n     * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n     * @example\n     * ```ts\n     * // Get identity matrix reference\n     * const identity = Matrix.IDENTITY;\n     * console.log(identity.isIdentity()); // true\n     *\n     * // Compare with identity\n     * const matrix = new Matrix();\n     * console.log(matrix.equals(Matrix.IDENTITY)); // true\n     *\n     * // Create new matrix instead of modifying IDENTITY\n     * const transform = new Matrix()\n     *     .copyFrom(Matrix.IDENTITY)\n     *     .translate(100, 100);\n     * ```\n     * @readonly\n     * @returns A read-only identity matrix\n     * @see {@link Matrix.shared} For temporary calculations\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     *\n     * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n     * @example\n     * ```ts\n     * // Use for temporary calculations\n     * const tempMatrix = Matrix.shared;\n     * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n     * const point = tempMatrix.apply({ x: 10, y: 20 });\n     *\n     * // Will be reset to identity on next access\n     * const fresh = Matrix.shared; // Back to identity\n     * ```\n     * @remarks\n     * - Always returns identity matrix\n     * - Safe to modify temporarily\n     * - Not safe to store references\n     * - Useful for one-off calculations\n     * @readonly\n     * @returns A fresh identity matrix for temporary use\n     * @see {@link Matrix.IDENTITY} For immutable identity matrix\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n", "import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * Provides callback mechanism for point value updates.\n * @example\n * ```ts\n * // Basic observer implementation\n * const observer: Observer<ObservablePoint> = {\n *     _onUpdate: (point) => {\n *         console.log(`Point updated to (${point.x}, ${point.y})`);\n *     }\n * };\n *\n * // Create observable point with observer\n * const point = new ObservablePoint(observer, 100, 100);\n *\n * // Observer will be notified on changes\n * point.x = 200; // Logs: Point updated to (200, 100)\n * ```\n * @remarks\n * - Used internally by ObservablePoint\n * - Triggered on x/y changes\n * - Can track multiple points\n * - Useful for change detection\n * @typeParam T - The type of point being observed\n * @see {@link ObservablePoint} The observable point class\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport interface Observer<T>\n{\n    /**\n     * Callback to call when the point has updated.\n     * Triggered whenever x or y coordinates change.\n     * @param point - The point that was updated\n     */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system.\n * Triggers a callback when its position changes.\n *\n * The x and y properties represent the position on the horizontal and vertical axes, respectively.\n * @example\n * ```ts\n * // Basic observable point usage\n * const point = new ObservablePoint(\n *     { _onUpdate: (p) => console.log(`Updated to (${p.x}, ${p.y})`) },\n *     100, 100\n * );\n *\n * // Update triggers callback\n * point.x = 200; // Logs: Updated to (200, 100)\n * point.y = 300; // Logs: Updated to (200, 300)\n *\n * // Set both coordinates\n * point.set(50, 50); // Logs: Updated to (50, 50)\n * ```\n * @see {@link Point} For non-observable version\n * @see {@link Observer} For observer interface\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const point = new ObservablePoint(observer, 100, 200);\n     * const copy = point.clone();\n     *\n     * // Clone with new observer\n     * const newObserver = {\n     *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n     * };\n     * const watched = point.clone(newObserver);\n     *\n     * // Verify independence\n     * watched.set(300, 400); // Only triggers new observer\n     * ```\n     * @param observer - Optional observer to pass to the new observable point\n     * @returns A copy of this observable point\n     * @see {@link ObservablePoint.copyFrom} For copying into existing point\n     * @see {@link Observer} For observer interface details\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new x and y position.\n     *\n     * If y is omitted, both x and y will be set to x.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * const point = new ObservablePoint(observer);\n     * point.set(100, 200);\n     *\n     * // Set both x and y to same value\n     * point.set(50); // x=50, y=50\n     * ```\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis, defaults to x\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.equals} For comparing positions\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point into this point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(observer, 100, 200);\n     * const target = new ObservablePoint();\n     * target.copyFrom(source);\n     *\n     * // Copy and chain operations\n     * const point = new ObservablePoint()\n     *     .copyFrom(source)\n     *     .set(x + 50, y + 50);\n     *\n     * // Copy from any PointData\n     * const data = { x: 10, y: 20 };\n     * point.copyFrom(data);\n     * ```\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyTo} For copying to another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(100, 200);\n     * const target = new ObservablePoint();\n     * source.copyTo(target);\n     * ```\n     * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n     * @returns The point (`p`) with values updated\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * Compares x and y values using strict equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const p1 = new ObservablePoint(100, 200);\n     * const p2 = new ObservablePoint(100, 200);\n     * console.log(p1.equals(p2)); // true\n     *\n     * // Compare with PointData\n     * const data = { x: 100, y: 200 };\n     * console.log(p1.equals(data)); // true\n     *\n     * // Check different points\n     * const p3 = new ObservablePoint(200, 300);\n     * console.log(p1.equals(p3)); // false\n     * ```\n     * @param p - The point to check\n     * @returns `true` if both `x` and `y` are equal\n     * @see {@link ObservablePoint.copyFrom} For making points equal\n     * @see {@link PointData} For point data interface\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /**\n     * Position of the observable point on the x axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic x position\n     * const point = new ObservablePoint(observer);\n     * point.x = 100; // Triggers observer\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     * @default 0\n     */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /**\n     * Position of the observable point on the y axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic y position\n     * const point = new ObservablePoint(observer);\n     * point.y = 200; // Triggers observer\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     * @default 0\n     */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n", "const uidCache: Record<string, number> = {\n    default: -1,\n};\n\n/**\n * The names of the unique identifiers. These are used to create unique identifiers for different types of objects.\n * @category utils\n * @internal\n */\nexport type UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView' //\n    | 'shader' //\n    | 'renderer' //\n    | 'textStyle'\n    | (string & {});\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @returns {number} The next unique identifier to use.\n * @category utils\n * @internal\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/**\n * Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :)\n * @internal\n */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n", "// A set of warning messages already fired\nconst warnings: Set<string> = new Set();\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n * @internal\n */\nexport const v8_0_0 = '8.0.0';\n/**\n * deprecation name for version 8.1.0\n * @ignore\n * @internal\n */\nexport const v8_3_4 = '8.3.4';\n\n/**\n * Options for managing deprecation messages behavior globally\n * @category utils\n * @standard\n */\ninterface DeprecationOptions\n{\n    /**\n     * When set to true, all deprecation warning messages will be hidden.\n     * Use this if you want to silence deprecation notifications.\n     * @default false\n     * @standard\n     */\n    quiet: boolean;\n    /**\n     * When set to true, deprecation messages will be displayed as plain text without color formatting.\n     * Use this if you want to disable colored console output for deprecation warnings.\n     * @default false\n     * @standard\n     */\n    noColor: boolean;\n}\n\n/** @internal */\nexport type DeprecationFn = ((version: string, message: string, ignoreDepth?: number) => void) & DeprecationOptions;\n\nconst deprecationState: DeprecationOptions = {\n    quiet: false,\n    noColor: false\n};\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n *\n * Deprecation messages can be configured globally:\n * ```ts\n * // Suppress all deprecation messages\n * deprecation.quiet = true;\n *\n * // Put plain text to console instead of colorful messages\n * deprecation.noColor = true;\n * ```\n * @category utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport const deprecation: DeprecationFn = ((version: string, message: string, ignoreDepth: number = 3) =>\n{\n    // Suppress if is in quiet mode and ignore duplicate\n    if (deprecationState.quiet || warnings.has(message)) return;\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    const deprecationMessage = `${message}\\nDeprecated since v${version}`;\n    const useGroup = typeof console.groupCollapsed === 'function' && !deprecationState.noColor;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', deprecationMessage);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (useGroup)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                deprecationMessage\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', deprecationMessage);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings.add(message);\n}) as DeprecationFn;\n\nObject.defineProperties(deprecation, {\n    quiet: {\n        get: () => deprecationState.quiet,\n        set: (value: boolean) =>\n        {\n            deprecationState.quiet = value;\n        },\n        enumerable: true,\n        configurable: false\n    },\n    noColor: {\n        get: () => deprecationState.noColor,\n        set: (value: boolean) =>\n        {\n            deprecationState.noColor = value;\n        },\n        enumerable: true,\n        configurable: false\n    }\n} satisfies {[key in keyof DeprecationOptions]: PropertyDescriptor});\n", "let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @category utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n", "/** Interface for objects that can be cleaned up by the PoolCollector. */\ninterface Cleanable\n{\n    clear(): void;\n}\n\n/**\n * A singleton collector that manages and provides cleanup for registered pools and caches.\n * Useful for cleaning up all pools/caches at once during application shutdown or reset.\n * @category utils\n * @internal\n */\nexport const GlobalResourceRegistry = {\n    /**\n     * Set of registered pools and cleanable objects.\n     * @private\n     */\n    _registeredResources: new Set<Cleanable>(),\n\n    /**\n     * Registers a pool or cleanable object for cleanup.\n     * @param {Cleanable} pool - The pool or object to register.\n     */\n    register(pool: Cleanable): void\n    {\n        this._registeredResources.add(pool);\n    },\n\n    /**\n     * Unregisters a pool or cleanable object from cleanup.\n     * @param {Cleanable} pool - The pool or object to unregister.\n     */\n    unregister(pool: Cleanable): void\n    {\n        this._registeredResources.delete(pool);\n    },\n\n    /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */\n    release(): void\n    {\n        this._registeredResources.forEach((pool) => pool.clear());\n    },\n\n    /**\n     * Gets the number of registered pools and cleanable objects.\n     * @returns {number} The count of registered items.\n     */\n    get registeredCount(): number\n    {\n        return this._registeredResources.size;\n    },\n\n    /**\n     * Checks if a specific pool or cleanable object is registered.\n     * @param {Cleanable} pool - The pool or object to check.\n     * @returns {boolean} True if the item is registered, false otherwise.\n     */\n    isRegistered(pool: Cleanable): boolean\n    {\n        return this._registeredResources.has(pool);\n    },\n\n    /**\n     * Removes all registrations without clearing the pools.\n     * Useful if you want to reset the collector without affecting the pools.\n     */\n    reset(): void\n    {\n        this._registeredResources.clear();\n    }\n};\n", "/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link PoolItem}.\n * @category utils\n * @advanced\n */\nexport class Pool<T extends PoolItem>\n{\n    /** @internal */\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n\n    /** clears the pool */\n    public clear()\n    {\n        if (this._pool.length > 0 && this._pool[0].destroy)\n        {\n            for (let i = 0; i < this._index; i++)\n            {\n                this._pool[i].destroy();\n            }\n        }\n        this._pool.length = 0;\n        this._count = 0;\n        this._index = 0;\n    }\n}\n\n/**\n * An object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    destroy?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n", "import { GlobalResourceRegistry } from './GlobalResourceRegistry';\nimport { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @category utils\n * @advanced\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @category utils\n * @advanced\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n\n    /** Clears all pools in the group. This will reset all pools and free their resources. */\n    public clear(): void\n    {\n        this._poolsByClass.forEach((pool) => pool.clear());\n        this._poolsByClass.clear();\n    }\n}\n\n/**\n * A singleton instance of the PoolGroupClass that can be used throughout the application.\n * @internal\n */\nexport const BigPool = new PoolGroupClass();\nGlobalResourceRegistry.register(BigPool);\n", "import { deprecation } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\nimport type { CacheAsTextureOptions } from '../RenderGroup';\n\n/** @ignore */\nexport interface CacheAsTextureMixinConstructor\n{\n    cacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n\n/**\n * The CacheAsTextureMixin interface provides methods and properties for caching a container as a texture.\n * This can improve rendering performance for complex static containers by allowing them to be rendered as a single texture.\n * It includes methods to enable or disable caching, update the cached texture, and check\n * 1if the container is currently cached.\n * @category scene\n * @advanced\n */\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor>\n{\n    /**\n     * Caches this container as a texture. This allows the container to be rendered as a single texture,\n     * which can improve performance for complex static containers.\n     * @example\n     * ```ts\n     * // Basic caching\n     * container.cacheAsTexture(true);\n     *\n     * // With custom options\n     * container.cacheAsTexture({\n     *     resolution: 2,\n     *     antialias: true,\n     * });\n     *\n     * // Disable caching\n     * container.cacheAsTexture(false);\n     *\n     * // Cache a complex UI\n     * const ui = new Container();\n     * // Add multiple children...\n     * ui.cacheAsTexture(true);\n     * ui.updateCacheTexture(); // Update if contents change\n     * ```\n     * @param val - If true, enables caching with default options.\n     *             If false, disables caching.\n     *             Can also pass options object to configure caching behavior.\n     * @see {@link Container#updateCacheTexture} For updating cached content\n     * @see {@link Container#isCachedAsTexture} For checking cache state\n     */\n    cacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\n    /**\n     * Updates the cached texture of this container. This will flag the container's cached texture\n     * to be redrawn on the next render.\n     * @example\n     * ```ts\n     * // Basic update after changes\n     * container.updateCacheTexture();\n     * ```\n     */\n    updateCacheTexture: () => void;\n\n    /**\n     * Legacy property for backwards compatibility with PixiJS v7 and below.\n     * Use `cacheAsTexture` instead.\n     * @deprecated since 8.0.0\n     */\n    cacheAsBitmap: boolean;\n\n    /**\n     * Whether this container is currently cached as a texture.\n     * @example\n     * ```ts\n     * // Check cache state\n     * if (container.isCachedAsTexture) {\n     *     console.log('Container is cached');\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#cacheAsTexture} For enabling caching\n     * @see {@link Container#updateCacheTexture} For updating cache\n     */\n    readonly isCachedAsTexture: boolean;\n}\n\n/** @internal */\nexport const cacheAsTextureMixin: Partial<Container> = {\n    get isCachedAsTexture(): boolean\n    {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n\n    cacheAsTexture(val: boolean | CacheAsTextureOptions): void\n    {\n        if (typeof val === 'boolean' && val === false)\n        {\n            this.disableRenderGroup();\n        }\n        else\n        {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n        }\n    },\n\n    updateCacheTexture(): void\n    {\n        this.renderGroup?.updateCacheTexture();\n    },\n\n    get cacheAsBitmap(): boolean\n    {\n        return this.isCachedAsTexture;\n    },\n\n    set cacheAsBitmap(val: boolean)\n    {\n        // #if _DEBUG\n        deprecation('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.');\n        // #endif\n        this.cacheAsTexture(val);\n    },\n} as Container;\n", "/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @category utils\n * @internal\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n", "import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { IRenderLayer } from '../../layers/RenderLayer';\nimport type { Container, ContainerChild } from '../Container';\n\n/**\n * Mixin interface for containers that allows them to manage children.\n * It provides methods for adding, removing, and manipulating child containers.\n * @category scene\n * @advanced\n */\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    /** @internal */\n    allowChildren: boolean;\n    addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @example\n     * ```ts\n     * // Remove all children\n     * container.removeChildren();\n     *\n     * // Remove first 3 children\n     * const removed = container.removeChildren(0, 3);\n     * console.log('Removed:', removed.length); // 3\n     *\n     * // Remove children from index 2 onwards\n     * container.removeChildren(2);\n     *\n     * // Remove specific range\n     * const middle = container.removeChildren(1, 4);\n     * ```\n     * @param {number} beginIndex - The beginning position\n     * @param {number} endIndex - The ending position. Default is container size\n     * @returns List of removed children\n     * @throws {RangeError} If begin/end indexes are invalid\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing specific children\n     */\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    /**\n     * Removes a child from the specified index position.\n     * @example\n     * ```ts\n     * // Remove first child\n     * const removed = container.removeChildAt(0);\n     *\n     * // type safe access\n     * const sprite = container.removeChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.removeChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to remove the child from\n     * @returns The child that was removed\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#removeChild} For removing specific children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    removeChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    /**\n     * Returns the child at the specified index.\n     * @example\n     * ```ts\n     * // Get first child\n     * const first = container.getChildAt(0);\n     *\n     * // Type-safe access\n     * const sprite = container.getChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.getChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to get the child from\n     * @returns The child at the given index\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#children} For direct array access\n     * @see {@link Container#getChildByLabel} For name-based lookup\n     */\n    getChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    /**\n     * Changes the position of an existing child in the container.\n     * @example\n     * ```ts\n     * // Basic index change\n     * container.setChildIndex(sprite, 0); // Move to front\n     * container.setChildIndex(sprite, container.children.length - 1); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.setChildIndex(sprite, 5);\n     * } catch (e) {\n     *     console.warn('Invalid index or child not found');\n     * }\n     * ```\n     * @param {Container}child - The child Container instance to reposition\n     * @param {number}index - The resulting index number for the child\n     * @throws {Error} If index is out of bounds\n     * @throws {Error} If child is not in container\n     * @see {@link Container#getChildIndex} For getting current index\n     * @see {@link Container#swapChildren} For swapping positions\n     */\n    setChildIndex(child: C | IRenderLayer, index: number): void;\n    /**\n     * Returns the index position of a child Container instance.\n     * @example\n     * ```ts\n     * // Basic index lookup\n     * const index = container.getChildIndex(sprite);\n     * console.log(`Sprite is at index ${index}`);\n     *\n     * // With error handling\n     * try {\n     *     const index = container.getChildIndex(sprite);\n     * } catch (e) {\n     *     console.warn('Child not found in container');\n     * }\n     * ```\n     * @param {Container} child - The Container instance to identify\n     * @returns The index position of the child container\n     * @throws {Error} If child is not in this container\n     * @see {@link Container#setChildIndex} For changing index\n     * @see {@link Container#children} For direct array access\n     */\n    getChildIndex(child: C | IRenderLayer): number;\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @example\n     * ```ts\n     * // Add at specific index\n     * container.addChildAt(sprite, 0); // Add to front\n     *\n     * // Move existing child\n     * const index = container.children.length - 1;\n     * container.addChildAt(existingChild, index); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.addChildAt(sprite, 1000);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {Container} child - The child to add\n     * @param {number} index - The index where the child will be placed\n     * @returns The child that was added\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#addChild} For adding to the end\n     * @see {@link Container#setChildIndex} For moving existing children\n     */\n    addChildAt<U extends(C | IRenderLayer)>(child: U, index: number): U;\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @example\n     * ```ts\n     * // Basic swap\n     * container.swapChildren(sprite1, sprite2);\n     *\n     * // With error handling\n     * try {\n     *     container.swapChildren(sprite1, sprite2);\n     * } catch (e) {\n     *     console.warn('One or both children not found in container');\n     * }\n     * ```\n     * @remarks\n     * - Updates render groups\n     * - No effect if same child\n     * - Triggers container changes\n     * - Common in z-ordering\n     * @param {Container} child - First container to swap\n     * @param {Container} child2 - Second container to swap\n     * @throws {Error} If either child is not in container\n     * @see {@link Container#setChildIndex} For direct index placement\n     * @see {@link Container#getChildIndex} For getting current positions\n     */\n    swapChildren<U extends(C | IRenderLayer)>(child: U, child2: U): void;\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @example\n     * ```ts\n     * // Basic removal\n     * sprite.removeFromParent();\n     *\n     * // With validation\n     * if (sprite.parent) {\n     *     sprite.removeFromParent();\n     * }\n     * ```\n     * @see {@link Container#addChild} For adding to a new parent\n     * @see {@link Container#removeChild} For parent removing children\n     */\n    removeFromParent(): void;\n    /**\n     * Reparent a child or multiple children to this container while preserving their world transform.\n     * This ensures that the visual position and rotation of the children remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent, keeping visual position\n     * newContainer.reparentChild(sprite);\n     *\n     * // Reparent multiple children\n     * const batch = [sprite1, sprite2, sprite3];\n     * newContainer.reparentChild(...batch);\n     * ```\n     * @param {Container} child - The child or children to reparent\n     * @returns The first child that was reparented\n     * @see {@link Container#reparentChildAt} For index-specific reparenting\n     * @see {@link Container#addChild} For simple parenting\n     */\n    reparentChild<U extends C[]>(...child: U): U[0];\n    /**\n     * Reparent the child to this container at the specified index while preserving its world transform.\n     * This ensures that the visual position and rotation of the child remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic index-specific reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent at index 0 (front)\n     * newContainer.reparentChildAt(sprite, 0);\n     * ```\n     * @param {Container} child - The child to reparent\n     * @param {number} index - The index to reparent the child to\n     * @returns The reparented child\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#reparentChild} For appending reparented children\n     * @see {@link Container#addChildAt} For simple indexed parenting\n     */\n    reparentChildAt<U extends C>(child: U, index: number): U;\n    /**\n     * Replace a child in the container with a new child. Copying the local transform from the old child to the new one.\n     * @param {Container} oldChild - The child to replace.\n     * @param {Container} newChild - The new child to add.\n     */\n    replaceChild<U extends(C), T extends(C)>(oldChild: U, newChild: T): void;\n}\n\n/** @internal */\nexport const childrenHelperMixin: ChildrenHelperMixin<ContainerChild> = {\n\n    allowChildren: true,\n\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                const child = removed[i];\n\n                child.parentRenderLayer?.detach(child);\n\n                this.emit('childRemoved', child, this, i);\n                removed[i].emit('removed', this);\n            }\n\n            if (removed.length > 0)\n            {\n                this._didViewChangeTick++;\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    removeChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    getChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    setChildIndex(child: ContainerChild | IRenderLayer, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    getChildIndex(child: ContainerChild | IRenderLayer): number\n    {\n        const index = this.children.indexOf(child as ContainerChild);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    addChildAt<U extends(ContainerChild | IRenderLayer)>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child as ContainerChild);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child as ContainerChild);\n        }\n        else\n        {\n            children.splice(index, 0, child as ContainerChild);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child as ContainerChild);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child as ContainerChild, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n\n    swapChildren<U extends(ContainerChild | IRenderLayer)>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2 as ContainerChild;\n        this.children[index2] = child as ContainerChild;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    },\n\n    replaceChild<U extends(ContainerChild), T extends(ContainerChild)>(oldChild: U, newChild: T)\n    {\n        oldChild.updateLocalTransform();\n        this.addChildAt(newChild, this.getChildIndex(oldChild));\n\n        newChild.setFromMatrix(oldChild.localTransform);\n        newChild.updateLocalTransform();\n        this.removeChild(oldChild);\n    },\n} as Container;\n", "import { type InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer, type RenderPipes } from '../../../rendering/renderers/types';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\n\nimport type { Container } from '../Container';\n\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n * @category scene\n * @internal\n */\nexport interface CollectRenderablesMixin\n{\n    /**\n     * Collects all renderables from the container and its children, adding them to the instruction set.\n     * This method decides whether to use a simple or advanced collection method based on the container's properties.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using a simple method, suitable for containers marked as simple.\n     * This method iterates over the container's children and adds their renderables to the instruction set.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n     * This method handles additional effects and transformations that may be applied to the renderables.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n * @internal\n */\nexport const collectRenderablesMixin: Partial<Container> = {\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void\n    {\n        // Skip processing if the container is not in the current render layer or is not fully visible.\n        if ((this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n            || this.globalDisplayStatus < 0b111 || !this.includeInBuild) return;\n\n        // Sort children if the container has sortable children.\n        if (this.sortableChildren)\n        {\n            this.sortChildren();\n        }\n\n        // Choose the appropriate method for collecting renderables based on the container's properties.\n        if (this.isSimple)\n        {\n            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        }\n        else if (this.renderGroup)\n        {\n            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        }\n        else\n        {\n            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const children = this.children;\n        const length = children.length;\n\n        // Iterate over each child and collect their renderables.\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        // Apply each effect to the renderables before collecting them.\n        for (let i = 0; i < this.effects.length; i++)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.push(effect, this, instructionSet);\n        }\n\n        // Collect renderables using the simple method after applying effects.\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n\n        // Remove effects from the renderables after collection, processing in reverse order.\n        for (let i = this.effects.length - 1; i >= 0; i--)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n} as Container;\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container.\n * @internal\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * Represents a mask effect that can be applied to a container.\n * @category rendering\n * @advanced\n */\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @category rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /** @private */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @class\n * @category rendering\n * @advanced\n */\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n", "import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\n/** @ignore */\nexport interface EffectsMixinConstructor\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * new Container({\n     *     filters: [new BlurFilter(2), new ColorMatrixFilter()],\n     * });\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    filters?: Filter | readonly Filter[];\n}\n\n/**\n * The Mask type represents different ways to mask a display object.\n * - A number represents a mask ID.\n * - A Container represents a mask object, such as a Graphics or Sprite.\n * - null indicates that no mask is applied.\n * @example\n * ```ts\n * // Using a Container as a mask\n * const maskContainer: Mask = new Graphics();\n * // Using a mask ID\n * const maskId: Mask = 123;\n * // No mask applied\n * const noMask: Mask = null;\n * ```\n * @category scene\n * @standard\n */\nexport type Mask = number | Container | null;\n\n/**\n * Options for configuring mask behavior on a display object.\n * @example\n * ```ts\n * // Basic mask inversion\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true\n * });\n * ```\n * @see {@link Container#setMask} For applying masks with options\n * @see {@link Container#mask} For basic masking\n * @category scene\n * @standard\n */\nexport interface MaskOptions\n{\n    /**\n     * Whether the mask should be inverted.\n     * When true, the masked area becomes transparent and the unmasked area becomes visible.\n     * @default false\n     * @example\n     * ```ts\n     * // Invert the mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true\n     * });\n     * ```\n     */\n    inverse: boolean;\n}\n\n/**\n * MaskOptionsAndMask combines MaskOptions with a Mask for configuring masking behavior.\n * Used when setting up complex masking effects with additional options.\n * @example\n * ```ts\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true,\n * });\n *\n * // Clear existing mask\n * sprite.setMask({\n *     mask: null,\n *     inverse: false,\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link Container#setMask} For applying masks\n * @see {@link MaskOptions} For base options\n */\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask: Mask;\n}\n\n/**\n * The EffectsMixin interface provides methods and properties for managing effects\n * such as masks and filters on a display object.\n * It allows for adding, removing, and configuring effects, as well as setting a mask for the display object.\n * @category scene\n * @advanced\n */\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    /** @private */\n    _maskEffect?: MaskEffect;\n    /** @private */\n    _maskOptions?: MaskOptions;\n    /** @private */\n    _filterEffect?: FilterEffect,\n    /** @private */\n    _markStructureAsChanged(): void;\n\n    /**\n     * The area the filter is applied to. This is used as an optimization to define a specific region\n     * for filter effects instead of calculating the display object bounds each frame.\n     *\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for filter effects,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * // Set specific filter area\n     * container.filterArea = new Rectangle(0, 0, 100, 100);\n     *\n     * // Optimize filter region\n     * const screen = app.screen;\n     * container.filterArea = new Rectangle(\n     *     screen.x,\n     *     screen.y,\n     *     screen.width,\n     *     screen.height\n     * );\n     * ```\n     * @see {@link Container#filters} For applying filters\n     * @see {@link Rectangle} For area definition\n     */\n    filterArea?: Rectangle,\n    /**\n     * todo Needs docs\n     * @advanced\n     */\n    effects?: Effect[];\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to add.\n     * @ignore\n     */\n    addEffect(effect: Effect): void;\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to remove.\n     * @ignore\n     */\n    removeEffect(effect: Effect): void;\n    /**\n     * Used to set mask and control mask options on a display object.\n     * Allows for more detailed control over masking behavior compared to the mask property.\n     * @example\n     * ```ts\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * // Create a circular mask\n     * const graphics = new Graphics()\n     *     .beginFill(0xFF3300)\n     *     .drawCircle(100, 100, 50)\n     *     .endFill();\n     *\n     * // Apply mask with options\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true, // Create a hole effect\n     * });\n     *\n     * // Clear existing mask\n     * sprite.setMask({ mask: null });\n     * ```\n     * @param {Partial<MaskOptionsAndMask>} options - Configuration options for the mask\n     * @see {@link Container#mask} For simple masking\n     * @see {@link MaskOptionsAndMask} For full options API\n     */\n    setMask(options: Partial<MaskOptionsAndMask>): void;\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it.\n     *\n     * > [!IMPORTANT] In PixiJS a regular mask must be a {@link Graphics} or a {@link Sprite} object.\n     * > This allows for much faster masking in canvas as it utilities shape clipping.\n     * > Furthermore, a mask of an object must be in the subtree of its parent.\n     * > Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * ```ts\n     * // Apply mask to sprite\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     *\n     * // Remove mask\n     * sprite.mask = null;\n     * ```\n     * @see {@link Graphics} For creating mask shapes\n     * @see {@link Sprite} For texture-based masks\n     * @see {@link Container#setMask} For advanced mask options\n     */\n    mask: Mask;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * // Add a single filter\n     * sprite.filters = new BlurFilter(2);\n     *\n     * // Apply multiple filters\n     * container.filters = [\n     *     new BlurFilter(2),\n     *     new ColorMatrixFilter(),\n     * ];\n     *\n     * // Remove filters\n     * sprite.filters = null;\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    set filters(value: Filter | Filter[] | null | undefined);\n    get filters(): readonly Filter[];\n}\n\n/** @internal */\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\n/** @ignore */\nexport interface FindMixinConstructor\n{\n    /**\n     * The instance label of the object.\n     * @default null\n     */\n    label?: string;\n}\n\n/**\n * The FindMixin interface provides methods for finding children within a container by their label.\n * It allows for searching for a single child or multiple children with a specific label,\n * either directly or recursively through the container's hierarchy.\n * @category scene\n * @advanced\n */\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see Container#label\n     * @default null\n     */\n    name: string;\n    /**\n     * @deprecated since 8.0.0\n     * @param {string} label - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see Container#getChildByLabel\n     */\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns the first child in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const child = container.getChildByLabel('player');\n     *\n     * // Search with regular expression\n     * const enemy = container.getChildByLabel(/enemy-\\d+/);\n     *\n     * // Deep search through children\n     * const deepChild = container.getChildByLabel('powerup', true);\n     * ```\n     * @param {RegExp|string} label - Instance label to search for\n     * @param {boolean} deep - Whether to search recursively through children\n     * @returns The first child with the specified label, or null if none found\n     * @see {@link Container#getChildrenByLabel} For finding all matches\n     * @see {@link Container#label} For setting labels\n     */\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns all children in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const enemies = container.getChildrenByLabel('enemy');\n     * // Search with regular expression\n     * const powerups = container.getChildrenByLabel(/powerup-\\d+/);\n     * // Deep search with collection\n     * const buttons = [];\n     * container.getChildrenByLabel('button', true, buttons);\n     * ```\n     * @param {string|RegExp} label  - Instance label to search for\n     * @param {boolean}[deep=false] - Whether to search recursively through children\n     * @param {Container[]} [out=[]]  - Optional array to store matching children in\n     * @returns An array of children with the specified label\n     * @see {@link Container#getChildByLabel} For finding first match\n     * @see {@link Container#label} For setting labels\n     */\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\n/** @internal */\nexport const findMixin: Partial<Container> = {\n    label: null,\n\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n", "// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object represents a rectangular area defined by its position and dimensions.\n * Used for hit testing, bounds calculation, and general geometric operations.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new Rectangle(100, 100, 200, 150);\n *\n * // Use as container bounds\n * container.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n *\n * // Manipulate dimensions\n * rect.width *= 2;\n * rect.height += 50;\n * ```\n * @remarks\n * - Position defined by top-left corner (x,y)\n * - Dimensions defined by width and height\n * - Supports point and rectangle containment\n * - Common in UI and layout calculations\n * @see {@link Circle} For circular shapes\n * @see {@link Polygon} For complex shapes\n * @see {@link RoundedRectangle} For rounded corners\n * @category maths\n * @standard\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Rectangle(0, 0, 100, 100);\n     * console.log(shape.type); // 'rectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'rectangle') {\n     *     console.log(shape.width, shape.height);\n     * }\n     * ```\n     * @readonly\n     * @default 'rectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new Rectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new Rectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new Rectangle();\n     * rect.width = 200;\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new Rectangle();\n     * rect.height = 150;\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /**\n     * Returns the left edge (x-coordinate) of the rectangle.\n     * @example\n     * ```ts\n     * // Get left edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.left); // 100\n     *\n     * // Use in alignment calculations\n     * sprite.x = rect.left + padding;\n     *\n     * // Compare positions\n     * if (point.x > rect.left) {\n     *     console.log('Point is right of rectangle');\n     * }\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the left edge\n     * @see {@link Rectangle.right} For right edge position\n     * @see {@link Rectangle.x} For direct x-coordinate access\n     */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /**\n     * Returns the right edge (x + width) of the rectangle.\n     * @example\n     * ```ts\n     * // Get right edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.right); // 300\n     *\n     * // Align to right edge\n     * sprite.x = rect.right - sprite.width;\n     *\n     * // Check boundaries\n     * if (point.x < rect.right) {\n     *     console.log('Point is inside right bound');\n     * }\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the right edge\n     * @see {@link Rectangle.left} For left edge position\n     * @see {@link Rectangle.width} For width value\n     */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /**\n     * Returns the top edge (y-coordinate) of the rectangle.\n     * @example\n     * ```ts\n     * // Get top edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.top); // 100\n     *\n     * // Position above rectangle\n     * sprite.y = rect.top - sprite.height;\n     *\n     * // Check vertical position\n     * if (point.y > rect.top) {\n     *     console.log('Point is below top edge');\n     * }\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the top edge\n     * @see {@link Rectangle.bottom} For bottom edge position\n     * @see {@link Rectangle.y} For direct y-coordinate access\n     */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /**\n     * Returns the bottom edge (y + height) of the rectangle.\n     * @example\n     * ```ts\n     * // Get bottom edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.bottom); // 250\n     *\n     * // Stack below rectangle\n     * sprite.y = rect.bottom + margin;\n     *\n     * // Check vertical bounds\n     * if (point.y < rect.bottom) {\n     *     console.log('Point is above bottom edge');\n     * }\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the bottom edge\n     * @see {@link Rectangle.top} For top edge position\n     * @see {@link Rectangle.height} For height value\n     */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /**\n     * Determines whether the Rectangle is empty (has no area).\n     * @example\n     * ```ts\n     * // Check zero dimensions\n     * const rect = new Rectangle(100, 100, 0, 50);\n     * console.log(rect.isEmpty()); // true\n     * ```\n     * @returns True if the rectangle has no area\n     * @see {@link Rectangle.width} For width value\n     * @see {@link Rectangle.height} For height value\n     */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /**\n     * A constant empty rectangle. This is a new object every time the property is accessed.\n     * @example\n     * ```ts\n     * // Get fresh empty rectangle\n     * const empty = Rectangle.EMPTY;\n     * console.log(empty.isEmpty()); // true\n     * ```\n     * @returns A new empty rectangle instance\n     * @see {@link Rectangle.isEmpty} For empty state testing\n     */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Rectangle(100, 100, 200, 150);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.width *= 2;\n     * modified.height += 50;\n     *\n     * // Verify independence\n     * console.log(original.width);  // 200\n     * console.log(modified.width);  // 400\n     * ```\n     * @returns A copy of the rectangle\n     * @see {@link Rectangle.copyFrom} For copying into existing rectangle\n     * @see {@link Rectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @example\n     * ```ts\n     * // Convert bounds to rectangle\n     * const bounds = container.getBounds();\n     * const rect = new Rectangle().copyFromBounds(bounds);\n     * ```\n     * @param bounds - The bounds to copy and convert to a rectangle\n     * @returns Returns itself\n     * @see {@link Bounds} For bounds object structure\n     * @see {@link Rectangle.getBounds} For getting rectangle bounds\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Rectangle(100, 100, 200, 150);\n     * const target = new Rectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new Rectangle()\n     *     .copyFrom(source)\n     *     .pad(10);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link Rectangle.copyTo} For copying to another rectangle\n     * @see {@link Rectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Rectangle(100, 100, 200, 150);\n     * const target = new Rectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new Rectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link Rectangle.copyFrom} For copying from another rectangle\n     * @see {@link Rectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check edge cases\n     * console.log(rect.contains(100, 100)); // true (on edge)\n     * console.log(rect.contains(300, 250)); // false (outside)\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     * @see {@link Rectangle.containsRect} For rectangle containment\n     * @see {@link Rectangle.strokeContains} For checking stroke intersection\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link Rectangle.contains} For checking fill containment\n     * @see {@link Rectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n            && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     *\n     * Returns true only if the area of the intersection is greater than 0.\n     * This means that rectangles sharing only a side are not considered intersecting.\n     * @example\n     * ```ts\n     * // Basic intersection check\n     * const rect1 = new Rectangle(0, 0, 100, 100);\n     * const rect2 = new Rectangle(50, 50, 100, 100);\n     * console.log(rect1.intersects(rect2)); // true\n     *\n     * // With transformation matrix\n     * const matrix = new Matrix();\n     * matrix.rotate(Math.PI / 4); // 45 degrees\n     * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation\n     *\n     * // Edge cases\n     * const zeroWidth = new Rectangle(0, 0, 0, 100);\n     * console.log(rect1.intersects(zeroWidth)); // false (no area)\n     * ```\n     * @remarks\n     * - Returns true only if intersection area is > 0\n     * - Rectangles sharing only a side are not intersecting\n     * - Zero-area rectangles cannot intersect anything\n     * - Supports optional transformation matrix\n     * @param other - The Rectangle to intersect with `this`\n     * @param transform - Optional transformation matrix of `other`\n     * @returns True if the transformed `other` Rectangle intersects with `this`\n     * @see {@link Rectangle.containsRect} For containment testing\n     * @see {@link Rectangle.contains} For point testing\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     *\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @example\n     * ```ts\n     * // Basic padding\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * rect.pad(10); // Adds 10px padding on all sides\n     *\n     * // Different horizontal and vertical padding\n     * const uiRect = new Rectangle(0, 0, 100, 50);\n     * uiRect.pad(20, 10); // 20px horizontal, 10px vertical\n     * ```\n     * @remarks\n     * - Adjusts x/y by subtracting padding\n     * - Increases width/height by padding * 2\n     * - Common in UI layout calculations\n     * - Chainable with other methods\n     * @param paddingX - The horizontal padding amount\n     * @param paddingY - The vertical padding amount\n     * @returns Returns itself\n     * @see {@link Rectangle.enlarge} For growing to include another rectangle\n     * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @example\n     * ```ts\n     * // Basic fitting\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const content = new Rectangle(25, 25, 200, 200);\n     * content.fit(container); // Clips to container bounds\n     * ```\n     * @param rectangle - The rectangle to fit around\n     * @returns Returns itself\n     * @see {@link Rectangle.enlarge} For growing to include another rectangle\n     * @see {@link Rectangle.pad} For adding padding around the rectangle\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle so that its corners lie on a grid defined by resolution.\n     * @example\n     * ```ts\n     * // Basic grid alignment\n     * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);\n     * rect.ceil(); // Aligns to whole pixels\n     *\n     * // Custom resolution grid\n     * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);\n     * uiRect.ceil(0.5); // Aligns to half pixels\n     *\n     * // Use with precision value\n     * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);\n     * preciseRect.ceil(1, 0.01); // Handles small decimal variations\n     * ```\n     * @param resolution - The grid size to align to (1 = whole pixels)\n     * @param eps - Small number to prevent floating point errors\n     * @returns Returns itself\n     * @see {@link Rectangle.fit} For constraining to bounds\n     * @see {@link Rectangle.enlarge} For growing dimensions\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Scales the rectangle's dimensions and position by the specified factors.\n     * @example\n     * ```ts\n     * const rect = new Rectangle(50, 50, 100, 100);\n     *\n     * // Scale uniformly\n     * rect.scale(0.5, 0.5);\n     * // rect is now: x=25, y=25, width=50, height=50\n     *\n     * // non-uniformly\n     * rect.scale(0.5, 1);\n     * // rect is now: x=25, y=50, width=50, height=100\n     * ```\n     * @param x - The factor by which to scale the horizontal properties (x, width).\n     * @param y - The factor by which to scale the vertical properties (y, height).\n     * @returns Returns itself\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.x *= x;\n        this.y *= y;\n        this.width *= x;\n        this.height *= y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @example\n     * ```ts\n     * // Basic enlargement\n     * const rect = new Rectangle(50, 50, 100, 100);\n     * const other = new Rectangle(0, 0, 200, 75);\n     * rect.enlarge(other);\n     * // rect is now: x=0, y=0, width=200, height=150\n     *\n     * // Use for bounding box calculation\n     * const bounds = new Rectangle();\n     * objects.forEach((obj) => {\n     *     bounds.enlarge(obj.getBounds());\n     * });\n     * ```\n     * @param rectangle - The rectangle to include\n     * @returns Returns itself\n     * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n     * @see {@link Rectangle.pad} For adding padding around the rectangle\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds retrieval\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const bounds = rect.getBounds();\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle.copyFrom} For direct copying\n     * @see {@link Rectangle.clone} For creating new copy\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    /**\n     * Determines whether another Rectangle is fully contained within this Rectangle.\n     *\n     * Rectangles that occupy the same space are considered to be containing each other.\n     *\n     * Rectangles without area (width or height equal to zero) can't contain anything,\n     * not even other arealess rectangles.\n     * @example\n     * ```ts\n     * // Check if one rectangle contains another\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const inner = new Rectangle(25, 25, 50, 50);\n     *\n     * console.log(container.containsRect(inner)); // true\n     *\n     * // Check overlapping rectangles\n     * const partial = new Rectangle(75, 75, 50, 50);\n     * console.log(container.containsRect(partial)); // false\n     *\n     * // Zero-area rectangles\n     * const empty = new Rectangle(0, 0, 0, 100);\n     * console.log(container.containsRect(empty)); // false\n     * ```\n     * @param other - The Rectangle to check for containment\n     * @returns True if other is fully contained within this Rectangle\n     * @see {@link Rectangle.contains} For point containment\n     * @see {@link Rectangle.intersects} For overlap testing\n     */\n    public containsRect(other: Rectangle): boolean\n    {\n        if (this.width <= 0 || this.height <= 0) return false;\n\n        const x1 = other.x;\n        const y1 = other.y;\n        const x2 = other.x + other.width;\n        const y2 = other.y + other.height;\n\n        return x1 >= this.x && x1 < this.x + this.width\n            && y1 >= this.y && y1 < this.y + this.height\n            && x2 >= this.x && x2 < this.x + this.width\n            && y2 >= this.y && y2 < this.y + this.height;\n    }\n\n    /**\n     * Sets the position and dimensions of the rectangle.\n     * @example\n     * ```ts\n     * // Basic usage\n     * const rect = new Rectangle();\n     * rect.set(100, 100, 200, 150);\n     *\n     * // Chain with other operations\n     * const bounds = new Rectangle()\n     *     .set(0, 0, 100, 100)\n     *     .pad(10);\n     * ```\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     * @returns Returns itself for method chaining\n     * @see {@link Rectangle.copyFrom} For copying from another rectangle\n     * @see {@link Rectangle.clone} For creating a new copy\n     */\n    public set(x: number, y: number, width: number, height: number): this\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * A simple axis-aligned bounding box (AABB) data structure used to define rectangular boundaries.\n * Provides a clearer alternative to array-based bounds representation [minX, minY, maxX, maxY].\n * @example\n * ```ts\n * // Create bounds data\n * const bounds: BoundsData = {\n *     minX: 0,\n *     minY: 0,\n *     maxX: 100,\n *     maxY: 100\n * };\n *\n * // Calculate dimensions\n * const width = bounds.maxX - bounds.minX;\n * const height = bounds.maxY - bounds.minY;\n *\n * // Check if point is inside\n * const isInside = (x: number, y: number) =>\n *     x >= bounds.minX && x <= bounds.maxX &&\n *     y >= bounds.minY && y <= bounds.maxY;\n * ```\n * @see {@link Bounds} For full bounds implementation\n * @see {@link Container#getBounds} For getting bounds\n * @category rendering\n * @standard\n */\nexport interface BoundsData\n{\n    /** The minimum X coordinate of the bounds */\n    minX: number;\n    /** The minimum Y coordinate of the bounds */\n    minY: number;\n    /** The maximum X coordinate of the bounds */\n    maxX: number;\n    /** The maximum Y coordinate of the bounds */\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an axis-aligned bounding box (AABB) used for efficient collision detection and culling.\n * Stores minimum and maximum coordinates to define a rectangular boundary.\n * @example\n * ```ts\n * // Create bounds\n * const bounds = new Bounds();\n *\n * // Add a rectangular frame\n * bounds.addFrame(0, 0, 100, 100);\n * console.log(bounds.width, bounds.height); // 100, 100\n *\n * // Transform bounds\n * const matrix = new Matrix()\n *     .translate(50, 50)\n *     .rotate(Math.PI / 4);\n * bounds.applyMatrix(matrix);\n *\n * // Check point intersection\n * if (bounds.containsPoint(75, 75)) {\n *     console.log('Point is inside bounds!');\n * }\n * ```\n * @category rendering\n * @standard\n */\nexport class Bounds\n{\n    /**\n     * The minimum X coordinate of the bounds.\n     * Represents the leftmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set left edge\n     * bounds.minX = 100;\n     * ```\n     * @default Infinity\n     */\n    public minX = Infinity;\n\n    /**\n     * The minimum Y coordinate of the bounds.\n     * Represents the topmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set top edge\n     * bounds.minY = 100;\n     * ```\n     * @default Infinity\n     */\n    public minY = Infinity;\n\n    /**\n     * The maximum X coordinate of the bounds.\n     * Represents the rightmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set right edge\n     * bounds.maxX = 200;\n     * // Get width\n     * const width = bounds.maxX - bounds.minX;\n     * ```\n     * @default -Infinity\n     */\n    public maxX = -Infinity;\n\n    /**\n     * The maximum Y coordinate of the bounds.\n     * Represents the bottommost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set bottom edge\n     * bounds.maxY = 200;\n     * // Get height\n     * const height = bounds.maxY - bounds.minY;\n     * ```\n     * @default -Infinity\n     */\n    public maxY = -Infinity;\n\n    /**\n     * The transformation matrix applied to this bounds object.\n     * Used when calculating bounds with transforms.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Apply translation matrix\n     * bounds.matrix = new Matrix()\n     *     .translate(100, 100);\n     *\n     * // Combine transformations\n     * bounds.matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * // Use in bounds calculations\n     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix\n     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix\n     * ```\n     * @advanced\n     */\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    /**\n     * Creates a new Bounds object.\n     * @param minX - The minimum X coordinate of the bounds.\n     * @param minY - The minimum Y coordinate of the bounds.\n     * @param maxX - The maximum X coordinate of the bounds.\n     * @param maxY - The maximum Y coordinate of the bounds.\n     */\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty, meaning either width or height is zero or negative.\n     * Empty bounds occur when min values exceed max values on either axis.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Check if newly created bounds are empty\n     * console.log(bounds.isEmpty()); // true, default bounds are empty\n     *\n     * // Add frame and check again\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false, bounds now have area\n     *\n     * // Clear bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true, bounds are empty again\n     * ```\n     * @returns True if bounds are empty (have no area)\n     * @see {@link Bounds#clear} For resetting bounds\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /**\n     * The bounding rectangle representation of these bounds.\n     * Lazily creates and updates a Rectangle instance based on the current bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Get rectangle representation\n     * const rect = bounds.rectangle;\n     * console.log(rect.x, rect.y, rect.width, rect.height);\n     *\n     * // Use for hit testing\n     * if (bounds.rectangle.contains(mouseX, mouseY)) {\n     *     console.log('Mouse is inside bounds!');\n     * }\n     * ```\n     * @see {@link Rectangle} For rectangle methods\n     * @see {@link Bounds.isEmpty} For bounds validation\n     */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /**\n     * Clears the bounds and resets all coordinates to their default values.\n     * Resets the transformation matrix back to identity.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false\n     * // Clear the bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true\n     * ```\n     * @returns This bounds object for chaining\n     */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds directly using coordinate values.\n     * Provides a way to set all bounds values at once.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(0, 0, 100, 100);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @see {@link Bounds#addFrame} For matrix-aware bounds setting\n     * @see {@link Bounds#clear} For resetting bounds\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the new frame coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.addFrame(0, 0, 100, 100);\n     *\n     * // Add transformed frame\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addFrame(0, 0, 100, 100, matrix);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addRect} For adding Rectangle objects\n     * @see {@link Bounds#addBounds} For adding other Bounds\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the given rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Add simple rectangle\n     * const rect = new Rectangle(0, 0, 100, 100);\n     * bounds.addRect(rect);\n     *\n     * // Add transformed rectangle\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addRect(rect, matrix);\n     * ```\n     * @param rect - The rectangle to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addBounds} For adding other bounds\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds another bounds object to this one, optionally transformed by a matrix.\n     * Expands the bounds to include the given bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add child bounds\n     * const childBounds = sprite.getBounds();\n     * bounds.addBounds(childBounds);\n     *\n     * // Add transformed bounds\n     * const matrix = new Matrix()\n     *     .scale(2, 2);\n     * bounds.addBounds(childBounds, matrix);\n     * ```\n     * @param bounds - The bounds to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addRect} For adding rectangles\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds as a mask, creating an intersection of the two bounds.\n     * Only keeps the overlapping region between current bounds and mask bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Create mask bounds\n     * const mask = new Bounds();\n     * mask.addFrame(50, 50, 150, 150);\n     * // Apply mask - results in bounds of (50,50,100,100)\n     * bounds.addBoundsMask(mask);\n     * ```\n     * @param mask - The Bounds to use as a mask\n     * @see {@link Bounds#addBounds} For union operation\n     * @see {@link Bounds#fit} For fitting to rectangle\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Applies a transformation matrix to the bounds, updating its coordinates.\n     * Transforms all corners of the bounds using the given matrix.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Apply translation\n     * const translateMatrix = new Matrix()\n     *     .translate(50, 50);\n     * bounds.applyMatrix(translateMatrix);\n     * ```\n     * @param matrix - The matrix to apply to the bounds\n     * @see {@link Matrix} For matrix operations\n     * @see {@link Bounds#addFrame} For adding transformed frames\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to fit within the given rectangle.\n     * Clips the bounds if they extend beyond the rectangle's edges.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit within viewport\n     * const viewport = new Rectangle(50, 50, 100, 100);\n     * bounds.fit(viewport);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param rect - The rectangle to fit within\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#addBoundsMask} For intersection\n     * @see {@link Bounds#pad} For expanding bounds\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit to specific coordinates\n     * bounds.fitBounds(50, 150, 50, 150);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param left - The left value of the bounds\n     * @param right - The right value of the bounds\n     * @param top - The top value of the bounds\n     * @param bottom - The bottom value of the bounds\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For fitting to Rectangle\n     * @see {@link Bounds#addBoundsMask} For intersection\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Add equal padding\n     * bounds.pad(10);\n     * // bounds are now (-10, -10, 110, 110)\n     *\n     * // Add different padding for x and y\n     * bounds.pad(20, 10);\n     * // bounds are now (-30, -20, 130, 120)\n     * ```\n     * @param paddingX - The horizontal padding amount\n     * @param paddingY - The vertical padding amount\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For constraining bounds\n     * @see {@link Bounds#scale} For uniform scaling\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /**\n     * Ceils the bounds by rounding up max values and rounding down min values.\n     * Useful for pixel-perfect calculations and avoiding fractional pixels.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(10.2, 10.9, 50.1, 50.8);\n     *\n     * // Round to whole pixels\n     * bounds.ceil();\n     * // bounds are now (10, 10, 51, 51)\n     * ```\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#scale} For size adjustments\n     * @see {@link Bounds#fit} For constraining bounds\n     */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /**\n     * Creates a new Bounds instance with the same values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Create a copy\n     * const copy = bounds.clone();\n     *\n     * // Original and copy are independent\n     * bounds.pad(10);\n     * console.log(copy.width === bounds.width); // false\n     * ```\n     * @returns A new Bounds instance with the same values\n     * @see {@link Bounds#copyFrom} For reusing existing bounds\n     */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values, adjusting all edges proportionally.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Scale uniformly\n     * bounds.scale(2);\n     * // bounds are now (0, 0, 200, 200)\n     *\n     * // Scale non-uniformly\n     * bounds.scale(0.5, 2);\n     * // bounds are now (0, 0, 100, 400)\n     * ```\n     * @param x - The X value to scale by\n     * @param y - The Y value to scale by (defaults to x)\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#pad} For adding padding\n     * @see {@link Bounds#fit} For constraining size\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /**\n     * The x position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its width.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get x position\n     * console.log(bounds.x); // 0\n     *\n     * // Move bounds horizontally\n     * bounds.x = 50;\n     * console.log(bounds.minX, bounds.maxX); // 50, 150\n     *\n     * // Width stays the same\n     * console.log(bounds.width); // Still 100\n     * ```\n     */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /**\n     * The y position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its height.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get y position\n     * console.log(bounds.y); // 0\n     *\n     * // Move bounds vertically\n     * bounds.y = 50;\n     * console.log(bounds.minY, bounds.maxY); // 50, 150\n     *\n     * // Height stays the same\n     * console.log(bounds.height); // Still 100\n     * ```\n     */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /**\n     * The width value of the bounds.\n     * Represents the distance between minX and maxX coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get width\n     * console.log(bounds.width); // 100\n     * // Resize width\n     * bounds.width = 200;\n     * console.log(bounds.maxX - bounds.minX); // 200\n     * ```\n     */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /**\n     * The height value of the bounds.\n     * Represents the distance between minY and maxY coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get height\n     * console.log(bounds.height); // 100\n     * // Resize height\n     * bounds.height = 150;\n     * console.log(bounds.maxY - bounds.minY); // 150\n     * ```\n     */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /**\n     * The left edge coordinate of the bounds.\n     * Alias for minX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(50, 0, 150, 100);\n     * console.log(bounds.left); // 50\n     * console.log(bounds.left === bounds.minX); // true\n     * ```\n     * @readonly\n     */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /**\n     * The right edge coordinate of the bounds.\n     * Alias for maxX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.right); // 100\n     * console.log(bounds.right === bounds.maxX); // true\n     * ```\n     * @readonly\n     */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /**\n     * The top edge coordinate of the bounds.\n     * Alias for minY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 25, 100, 125);\n     * console.log(bounds.top); // 25\n     * console.log(bounds.top === bounds.minY); // true\n     * ```\n     * @readonly\n     */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /**\n     * The bottom edge coordinate of the bounds.\n     * Alias for maxY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 200);\n     * console.log(bounds.bottom); // 200\n     * console.log(bounds.bottom === bounds.maxY); // true\n     * ```\n     * @readonly\n     */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /**\n     * Whether the bounds has positive width and height.\n     * Checks if both dimensions are greater than zero.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Check if bounds are positive\n     * console.log(bounds.isPositive); // true\n     *\n     * // Negative bounds\n     * bounds.maxX = bounds.minX;\n     * console.log(bounds.isPositive); // false, width is 0\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    /**\n     * Whether the bounds has valid coordinates.\n     * Checks if the bounds has been initialized with real values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * console.log(bounds.isValid); // false, default state\n     *\n     * // Set valid bounds\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isValid); // true\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isPositive} For checking dimensions\n     */\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n     * Used for efficiently updating bounds from raw vertex data.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add vertices from geometry\n     * const vertices = new Float32Array([\n     *     0, 0,    // Vertex 1\n     *     100, 0,  // Vertex 2\n     *     100, 100 // Vertex 3\n     * ]);\n     * bounds.addVertexData(vertices, 0, 6);\n     *\n     * // Add transformed vertices\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addVertexData(vertices, 0, 6, matrix);\n     *\n     * // Add subset of vertices\n     * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n     * ```\n     * @param vertexData - The array of vertices to add\n     * @param beginOffset - Starting index in the vertex array\n     * @param endOffset - Ending index in the vertex array (excluded)\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding rectangular frames\n     * @see {@link Matrix} For transformation details\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if a point is contained within the bounds.\n     * Returns true if the point's coordinates fall within the bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Basic point check\n     * console.log(bounds.containsPoint(50, 50)); // true\n     * console.log(bounds.containsPoint(150, 150)); // false\n     *\n     * // Check edges\n     * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n     * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n     * ```\n     * @param x - x coordinate to check\n     * @param y - y coordinate to check\n     * @returns True if the point is inside the bounds\n     * @see {@link Bounds#isPositive} For valid bounds check\n     * @see {@link Bounds#rectangle} For Rectangle representation\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a string representation of the bounds.\n     * Useful for debugging and logging bounds information.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n     * ```\n     * @returns A string describing the bounds\n     * @see {@link Bounds#copyFrom} For copying bounds\n     * @see {@link Bounds#clone} For creating a new instance\n     */\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n\n    /**\n     * Copies the bounds from another bounds object.\n     * Useful for reusing bounds objects and avoiding allocations.\n     * @example\n     * ```ts\n     * const sourceBounds = new Bounds(0, 0, 100, 100);\n     * // Copy bounds\n     * const targetBounds = new Bounds();\n     * targetBounds.copyFrom(sourceBounds);\n     * ```\n     * @param bounds - The bounds to copy from\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#clone} For creating new instances\n     */\n    public copyFrom(bounds: Bounds): this\n    {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n\n        return this;\n    }\n}\n\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\n/** @internal */\nexport const matrixPool = BigPool.getPool<MatrixPoolItem>(Matrix);\n/** @internal */\nexport const boundsPool = BigPool.getPool<BoundsPoolItem>(Bounds);\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n * @category scene\n * @advanced\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @advanced\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n * @internal\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * Gets the global bounds of a container, including all its children\n * @param target - The target container to get the bounds from\n * @param skipUpdateTransform - If true, the transform will not be updated before calculating bounds.\n * @param bounds - The output bounds object.\n * @returns The bounds.\n * @internal\n */\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        const renderableBounds = (target as Renderable).bounds;\n\n        if (renderableBounds && !renderableBounds.isEmpty())\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n            bounds.addBounds(renderableBounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\n/**\n * @param target\n * @param parentTransform\n * @internal\n */\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n", "/**\n * @param color1\n * @param color2\n * @internal\n */\nexport function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = ((r1 * r2) / 255) | 0;\n    const g = ((g1 * g2) / 255) | 0;\n    const b = ((b1 * b2) / 255) | 0;\n\n    return (r << 16) + (g << 8) + b;\n}\n", "import { multiplyHexColors } from './multiplyHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\n/**\n * @param localBGRColor\n * @param parentBGRColor\n * @internal\n */\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR)\n    {\n        return parentBGRColor;\n    }\n\n    if (parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor;\n    }\n\n    return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Container } from '../Container';\n\n/**\n * Converts a color from BGR format to RGB format.\n * @param color - The color in BGR format (0xBBGGRR).\n * @returns The color in RGB format (0xRRGGBB).\n * @category utils\n * @internal\n */\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\n/**\n * Interface for a mixin that provides methods to retrieve global properties of a container.\n * This mixin allows you to get the global alpha, transform matrix, and tint color of a container,\n * taking into account its parent containers and render groups.\n * It includes methods to optimize performance by using cached values when available.\n * @category scene\n * @advanced\n */\nexport interface GetGlobalMixin\n{\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     * ```\n     */\n    getGlobalAlpha(skipUpdate?: boolean): number;\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param {Matrix} matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     * ```\n     */\n    getGlobalTransform(matrix?: Matrix, skipUpdate?: boolean): Matrix;\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     * ```\n     */\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\n/** @internal */\nexport const getGlobalMixin: Partial<Container> = {\n    getGlobalAlpha(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n    getGlobalTransform(matrix = new Matrix(), skipUpdate?: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * @param target\n * @param bounds\n * @param relativeMatrix\n * @internal\n */\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\n", "import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n * @internal\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\n/**\n * A utility type that makes all properties of T optional except for the specified keys K.\n * @category utils\n * @internal\n */\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/** @ignore */\nexport interface MeasureMixinConstructor\n{\n    /**\n     * The width of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ width: 100});\n     * ```\n     * @default 0\n     */\n    width?: number;\n    /**\n     * The height of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ height: 100});\n     * ```\n     * @default 0\n     */\n    height?: number;\n}\n/**\n * The MeasureMixin interface provides methods for measuring and manipulating the size and bounds of a display object.\n * It includes methods to get and set the size of the object, retrieve its local bounds,\n * and calculate its global bounds.\n * @category scene\n * @advanced\n */\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * Uses cached values when possible for better performance.\n     * @example\n     * ```ts\n     * // Basic bounds check\n     * const bounds = container.getLocalBounds();\n     * console.log(`Width: ${bounds.width}, Height: ${bounds.height}`);\n     * // subsequent calls will reuse the cached bounds\n     * const cachedBounds = container.getLocalBounds();\n     * console.log(bounds === cachedBounds); // true\n     * ```\n     * @returns The bounding area\n     * @see {@link Container#getBounds} For world space bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getLocalBounds(): Bounds;\n    /**\n     * Calculates and returns the (world) bounds of the display object as a Rectangle.\n     * Takes into account transforms and child bounds.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const bounds = sprite.getBounds();\n     * console.log(`World bounds: ${bounds.x}, ${bounds.y}, ${bounds.width}, ${bounds.height}`);\n     *\n     * // Reuse bounds object for performance\n     * const recycleBounds = new Bounds();\n     * sprite.getBounds(false, recycleBounds);\n     *\n     * // Skip update for performance\n     * const fastBounds = sprite.getBounds(true);\n     * ```\n     * @remarks\n     * - Includes transform calculations\n     * - Updates scene graph by default\n     * - Can reuse bounds objects\n     * - Common in hit testing\n     * @param {boolean} skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param {Bounds} bounds - Optional bounds to store the result of the bounds calculation\n     * @returns The minimum axis-aligned rectangle in world space that fits around this object\n     * @see {@link Container#getLocalBounds} For untransformed bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    /** @private */\n    _localBoundsCacheData: LocalBoundsCacheData;\n    /** @private */\n    _localBoundsCacheId: number;\n    /** @private */\n    _setWidth(width: number, localWidth: number): void;\n    /** @private */\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\n/** @internal */\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n", "import type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\n\n/** @internal */\nexport interface OnRenderMixinConstructor\n{\n    /**\n     * This callback is used when the container is rendered. It runs every frame during the render process,\n     * making it ideal for per-frame updates and animations.\n     *\n     * > [!NOTE] In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * > and \"updateTransform\" is no longer called every frame\n     * @example\n     * ```ts\n     * // Basic rotation animation\n     * const container = new Container();\n     * container.onRender = () => {\n     *     container.rotation += 0.01;\n     * };\n     *\n     * // Cleanup when done\n     * container.onRender = null; // Removes callback\n     * ```\n     * @param renderer - The renderer instance\n     * @see {@link Renderer} For renderer capabilities\n     */\n    onRender?: ((renderer: Renderer) => void) | null;\n}\n\n/**\n * The OnRenderMixin interface provides a way to define a callback that is executed\n * every time the container is rendered. This is useful for adding custom rendering logic\n * or animations that need to be updated each frame.\n * @category scene\n * @advanced\n */\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    /** @private */\n    _onRender: ((renderer: Renderer) => void) | null;\n}\n\n/** @internal */\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: (renderer: Renderer) => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    get onRender(): (renderer: Renderer) => void\n    {\n        return this._onRender;\n    }\n} as Container;\n", "import type { Container } from '../Container';\n\n/** @ignore */\nexport interface SortMixinConstructor\n{\n    /**\n     * The zIndex of the container.\n     *\n     * Controls the rendering order of children within their parent container.\n     *\n     * A higher value will mean it will be moved towards the front of the rendering order.\n     * @example\n     * ```ts\n     * // Add in any order\n     * container.addChild(character, background, foreground);\n     *\n     * // Adjust rendering order\n     * background.zIndex = 0;\n     * character.zIndex = 1;\n     * foreground.zIndex = 2;\n     * ```\n     * @see {@link Container#sortableChildren} For enabling sorting\n     * @see {@link Container#sortChildren} For manual sorting\n     * @default 0\n     */\n    zIndex?: number;\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @default false\n     * @internal\n     */\n    sortDirty?: boolean;\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array of children,\n     * so it will affect the rendering order.\n     *\n     * > [!NOTE] Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * > as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @example\n     * ```ts\n     * container.sortableChildren = true;\n     * ```\n     * @default false\n     */\n    sortableChildren?: boolean;\n}\n\n/**\n * The SortMixin interface provides methods and properties for sorting children of a container\n * based on their `zIndex` values. It allows for automatic sorting of children when their `zIndex`\n * changes or when new children are added. The mixin includes properties to manage sorting state\n * and methods to sort children explicitly.\n * @category scene\n * @advanced\n */\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    /** @internal */\n    _zIndex: number;\n    /**\n     * Sorts children by zIndex value. Only sorts if container is marked as dirty.\n     * @example\n     * ```ts\n     * // Basic sorting\n     * particles.zIndex = 2;     // Will mark as dirty\n     * container.sortChildren();\n     * ```\n     * @see {@link Container#sortableChildren} For enabling automatic sorting\n     * @see {@link Container#zIndex} For setting child order\n     */\n    sortChildren: () => void;\n    /** @internal */\n    depthOfChildModified: () => void;\n}\n\n/** @internal */\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    sortDirty: false,\n    sortableChildren: false,\n\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n", "import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\n/**\n * Interface for a mixin that provides methods to convert between local and global coordinates.\n * This mixin allows you to get the global position of a container,\n * convert a point from local to global coordinates,\n * and convert a point from global to local coordinates.\n *\n * It includes methods to optimize performance by using cached matrices when available.\n * @category scene\n * @advanced\n */\nexport interface ToLocalGlobalMixin\n{\n    /**\n     * Returns the global position of the container, taking into account the container hierarchy.\n     * @example\n     * ```ts\n     * // Basic position check\n     * const globalPos = sprite.getGlobalPosition();\n     * console.log(`Global: (${globalPos.x}, ${globalPos.y})`);\n     *\n     * // Reuse point object\n     * const point = new Point();\n     * sprite.getGlobalPosition(point);\n     *\n     * // Skip transform update for performance\n     * const fastPos = container.getGlobalPosition(undefined, true);\n     * ```\n     * @param {Point} point - The optional point to write the global value to\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns The updated point\n     * @see {@link Container#toGlobal} For converting specific points\n     * @see {@link Container#toLocal} For converting to local space\n     */\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    /**\n     * Calculates the global position of a point relative to this container.\n     * Takes into account the container hierarchy and transforms.\n     * @example\n     * ```ts\n     * // Basic point conversion\n     * const localPoint = { x: 10, y: 20 };\n     * const globalPoint = container.toGlobal(localPoint);\n     *\n     * // With point reuse\n     * const reusePoint = new Point();\n     * container.toGlobal(localPoint, reusePoint);\n     *\n     * // Performance optimization\n     * const fastPoint = container.toGlobal(\n     *     { x: 50, y: 50 },\n     *     undefined,\n     *     true // Skip transform update\n     * );\n     * ```\n     * @param {PointData} position - The local point to convert\n     * @param {P} point - Optional point to store the result\n     * @param {boolean} skipUpdate - Whether to skip transform updates\n     * @returns The global position\n     * @see {@link Container#toLocal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    /**\n     * Calculates the local position of the container relative to another point.\n     * Converts coordinates from any coordinate space to this container's local coordinate space.\n     * @example\n     * ```ts\n     * // Basic coordinate conversion\n     * const worldPoint = { x: 100, y: 100 };\n     * const localPos = container.toLocal(worldPoint);\n     *\n     * // Convert from another container\n     * const fromSprite = new Sprite(texture);\n     * fromSprite.position.set(50, 50);\n     * const pointInSprite = { x: 10, y: 10 };\n     * const localPoint = container.toLocal(pointInSprite, fromSprite);\n     *\n     * // With point reuse for performance\n     * const reusePoint = new Point();\n     * container.toLocal(worldPoint, undefined, reusePoint);\n     *\n     * // Skip transform update for static objects\n     * const fastLocal = container.toLocal(\n     *     worldPoint,\n     *     undefined,\n     *     undefined,\n     *     true\n     * );\n     * ```\n     * @param {PointData} position - The world origin to calculate from\n     * @param {Container} from - The Container to calculate the global position from\n     * @param {P} point - A Point object in which to store the value\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns A point object representing the position in local space\n     * @see {@link Container#toGlobal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\n/** @internal */\nexport const toLocalGlobalMixin: Partial<Container> = {\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n", "import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @category rendering\n * @advanced\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    public gcTick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Destroy the instruction set, clearing the instructions and renderables.\n     * @internal\n     */\n    public destroy()\n    {\n        this.instructions.length = 0;\n        this.renderables.length = 0;\n\n        this.renderPipes = null;\n        this.gcTick = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n", "// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @category maths\n * @advanced\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @category maths\n * @advanced\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @category maths\n * @advanced\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n", "/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @category utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\n/**\n * The options for the texture style.\n * @category rendering\n * @advanced\n */\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @category rendering\n * @advanced\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    /** @internal */\n    public _resourceType = 'textureSampler';\n    /** @internal */\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @category rendering\n * @advanced\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @category rendering\n * @advanced\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    /** @internal */\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._style.maxAnisotropy = value;\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._style.maxAnisotropy;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n", "// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { type RectangleLike } from '../../culling/Culler';\nimport { type Rectangle } from '../shapes/Rectangle';\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/** Alias for `Math.sign`. */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n * @author Ivan: ivanpopelyshev\n * @groupDescription groupD8\n * @category maths\n * @advanced\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0\u00B0       | East      |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45\u00B0\u21BB     | Southeast |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90\u00B0\u21BB     | South     |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135\u00B0\u21BB    | Southwest |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180\u00B0     | West      |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135\u00B0/225\u00B0\u21BB | Northwest    |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90\u00B0/270\u00B0\u21BB  | North        |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45\u00B0/315\u00B0\u21BB  | Northeast    |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @group groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @group groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @group groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @group groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @group groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @group groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n\n    /**\n     * Transforms rectangle coordinates based on texture packer rotation.\n     * Used when texture atlas pages are rotated and coordinates need to be adjusted.\n     * @group groupD8\n     * @param {RectangleLike} rect - Rectangle with original coordinates to transform\n     * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)\n     * @param {GD8Symmetry} rotation - The groupD8 rotation value\n     * @param {Rectangle} out - Rectangle to store the result\n     * @returns {Rectangle} Transformed coordinates (includes source frame offset)\n     */\n    transformRectCoords: (\n        rect: RectangleLike,\n        sourceFrame: RectangleLike,\n        rotation: GD8Symmetry,\n        out: Rectangle\n    ): Rectangle =>\n    {\n        const { x, y, width, height } = rect;\n        const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;\n\n        if (rotation === groupD8.E)\n        {\n            // No rotation\n            out.set(x + frameX, y + frameY, width, height);\n\n            return out;\n        }\n        else if (rotation === groupD8.S)\n        {\n            // 90\u00B0 clockwise rotation\n            return out.set(\n                (frameWidth - y - height) + frameX,\n                x + frameY,\n                height,\n                width\n            );\n        }\n        else if (rotation === groupD8.W)\n        {\n            // 180\u00B0 rotation\n            return out.set(\n                (frameWidth - x - width) + frameX,\n                (frameHeight - y - height) + frameY,\n                width,\n                height\n            );\n        }\n        else if (rotation === groupD8.N)\n        {\n            // 270\u00B0 clockwise rotation (90\u00B0 counter-clockwise)\n            return out.set(\n                y + frameX,\n                (frameHeight - x - width) + frameY,\n                height,\n                width\n            );\n        }\n\n        // For other rotations (diagonal and reflections), fall back to no rotation\n        // These are less common in typical texture atlases\n        return out.set(x + frameX, y + frameY, width, height);\n    },\n};\n", "/** @internal */\nexport const NOOP = () =>\n{\n    // empty!\n};\n", "import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a BufferImageSource.\n * @category rendering\n * @advanced\n */\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\n/**\n * A texture source that uses a TypedArray or ArrayBuffer as its resource.\n * It automatically determines the format based on the type of TypedArray provided.\n * @category rendering\n * @advanced\n */\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @category rendering\n * @advanced\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link NineSlicePlane} texture.\n * @category rendering\n * @advanced\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @category rendering\n * @advanced\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @category rendering\n * @standard\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource>\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSourceType;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /**\n     * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n     * This is false by default as it improves performance. Generally, it's recommended to create new\n     * textures and swap those rather than modifying an existing texture's properties unless you are\n     * working with a dynamic frames.\n     * Not setting this to true when modifying the texture can lead to visual artifacts.\n     *\n     * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n     * `sprite.onViewUpdate()`.\n     */\n    dynamic?: boolean;\n}\n\n/**\n * A texture that can be bound to a shader as it has a texture source.\n * @category rendering\n * @advanced\n */\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\n/**\n * A texture source can be a string, an image, a video, a canvas, or a texture resource.\n * @category rendering\n * @advanced\n * @see {@link TextureSource}\n * @see {@link TextureResourceOrOptions}\n * @see {@link Texture.from}\n */\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Assets.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @category rendering\n * @class\n * @standard\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /** @internal */\n    public _source: TextureSourceType;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions<TextureSourceType> = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = (source?.source ?? new TextureSource()) as TextureSourceType;\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSourceType)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSourceType\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Call this if you have modified the `texture outside` of the constructor.\n     *\n     * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n     */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture<BufferImageSource>;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n", "import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\nimport { TextureStyle } from './TextureStyle';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @category rendering\n * @advanced\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /** The default texture style for the pool */\n    public textureStyle: TextureStyle;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n        this.textureStyle = new TextureStyle(this.textureOptions);\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n     * useful if you modified the style of the texture after getting it from the pool.\n     * @param renderTexture - The renderTexture to free\n     * @param resetStyle - Whether to reset the style of the texture to the default texture style\n     */\n    public returnTexture(renderTexture: Texture, resetStyle = false): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        // we can skip the copy if we don't need to reset the style\n        if (resetStyle)\n        {\n            renderTexture.source.style = this.textureStyle;\n        }\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\n/**\n * The default texture pool instance.\n * @category rendering\n * @advanced\n */\nexport const TexturePool = new TexturePoolClass();\nGlobalResourceRegistry.register(TexturePool);\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type SCALE_MODE } from '../../rendering/renderers/shared/texture/const';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @category rendering\n * @advanced\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n    /**\n     * Scale Mode to use for the cached texture\n     * @type {SCALE_MODE}\n     * @default 'linear'\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.cacheAsTexture({ scaleMode: 'nearest' });\n     * ```\n     * @see {@link SCALE_MODE}\n     */\n    scaleMode?: SCALE_MODE;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @category rendering\n * @advanced\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture, true);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n\n        const cachedParent = this._parentCacheAsTextureRenderGroup;\n\n        // It's worth going bottom-up and notify all parents cached as texture\n        // that cached child was updated.\n        if (cachedParent && !cachedParent.textureNeedsUpdate)\n        {\n            cachedParent.updateCacheTexture();\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (this.isCachedAsTexture)\n        {\n            return this.textureOffsetInverseTransform;\n        }\n\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n", "/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n * @category utils\n * @internal\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { extensions } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { type IRenderLayer } from '../layers/RenderLayer';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\n/**\n * The type of child that can be added to a {@link Container}.\n * This is a generic type that extends the {@link Container} class.\n * @category scene\n * @standard\n */\nexport type ContainerChild = Container;\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst defaultOrigin = new ObservablePoint(null);\n\n/**\n * Events that can be emitted by a Container. These events provide lifecycle hooks and notifications\n * for container state changes.\n * @example\n * ```ts\n * import { Container, Sprite } from 'pixi.js';\n *\n * // Setup container with event listeners\n * const container = new Container();\n *\n * // Listen for child additions\n * container.on('childAdded', (child, container, index) => {\n *     console.log(`Child added at index ${index}:`, child);\n * });\n *\n * // Listen for child removals\n * container.on('childRemoved', (child, container, index) => {\n *     console.log(`Child removed from index ${index}:`, child);\n * });\n *\n * // Listen for when container is added to parent\n * container.on('added', (parent) => {\n *     console.log('Added to parent:', parent);\n * });\n *\n * // Listen for when container is removed from parent\n * container.on('removed', (parent) => {\n *     console.log('Removed from parent:', parent);\n * });\n *\n * // Listen for container destruction\n * container.on('destroyed', (container) => {\n *     console.log('Container destroyed:', container);\n * });\n * ```\n * @category scene\n * @standard\n */\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    /**\n     * Emitted when this container is added to a new container.\n     * Useful for setting up parent-specific behaviors.\n     * @param container - The parent container this was added to\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('added', (parent) => {\n     *     console.log('Child added to parent:', parent.label);\n     * });\n     * parentContainer.addChild(child);\n     * ```\n     */\n    added: [container: Container];\n\n    /**\n     * Emitted when a child is added to this container.\n     * Useful for tracking container composition changes.\n     * @param child - The child that was added\n     * @param container - The container the child was added to (this container)\n     * @param index - The index at which the child was added\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childAdded', (child, container, index) => {\n     *     console.log(`New child at index ${index}:`, child);\n     * });\n     * ```\n     */\n    childAdded: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when this container is removed from its parent.\n     * Useful for cleanup and state management.\n     * @param container - The parent container this was removed from\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('removed', (oldParent) => {\n     *     console.log('Child removed from parent:', oldParent.label);\n     * });\n     * ```\n     */\n    removed: [container: Container];\n\n    /**\n     * Emitted when a child is removed from this container.\n     * Useful for cleanup and maintaining container state.\n     * @param child - The child that was removed\n     * @param container - The container the child was removed from (this container)\n     * @param index - The index from which the child was removed\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childRemoved', (child, container, index) => {\n     *     console.log(`Child removed from index ${index}:`, child);\n     * });\n     * ```\n     */\n    childRemoved: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when the container is destroyed.\n     * Useful for final cleanup and resource management.\n     * @param container - The container that was destroyed\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.on('destroyed', (container) => {\n     *     console.log('Container destroyed:', container.label);\n     * });\n     * ```\n     */\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\n/** @internal */\nexport const UPDATE_COLOR = 0b0001;\n/** @internal */\nexport const UPDATE_BLEND = 0b0010;\n/** @internal */\nexport const UPDATE_VISIBLE = 0b0100;\n/** @internal */\nexport const UPDATE_TRANSFORM = 0b1000;\n\n/**\n * Options for updating the transform of a container.\n * @category scene\n * @standard\n */\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n    originX: number;\n    originY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @category scene\n * @standard\n * @see Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * new Container({ blendMode: 'normal' }); // Default blending\n     * new Container({ blendMode: 'add' });    // Additive blending\n     * new Container({ blendMode: 'multiply' }); // Multiply colors\n     * new Container({ blendMode: 'screen' }); // Screen blend\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    blendMode?: BLEND_MODES;\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * new Container({ tint: 0xff0000 }); // Red tint\n     * new Container({ tint: 'blue' }); // Blue tint\n     * new Container({ tint: '#00ff00' }); // Green tint\n     * new Container({ tint: 'rgb(0,0,255)' }); // Blue tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    tint?: ColorSource;\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * new Container({ alpha: 0.5 }); // 50% opacity\n     * new Container({ alpha: 1 }); // Fully opaque\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    alpha?: number;\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ angle: 45 }); // Rotate 45 degrees\n     * new Container({ angle: 90 }); // Rotate 90 degrees\n     * ```\n     */\n    angle?: number;\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * new Container({\n     *    children: [\n     *        new Container(), // First child\n     *        new Container(), // Second child\n     *    ],\n     * });\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    children?: C[];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    parent?: Container;\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * new Container({ renderable: false }); // Will not be drawn, but transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    renderable?: boolean;\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ rotation: Math.PI / 4 }); // Rotate 45 degrees\n     * new Container({ rotation: Math.PI / 2 }); // Rotate 90 degrees\n     * ```\n     */\n    rotation?: number;\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * new Container({ scale: new Point(2, 2) }); // Scale by 2x\n     * new Container({ scale: 0.5 }); // Scale by 0.5x\n     * new Container({ scale: { x: 1.5, y: 1.5 } }); // Scale by 1.5x\n     * ```\n     */\n    scale?: PointData | number;\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * new Container({ pivot: new Point(100, 200) }); // Set pivot to (100, 200)\n     * new Container({ pivot: 50 }); // Set pivot to (50, 50)\n     * new Container({ pivot: { x: 150, y: 150 } }); // Set pivot to (150, 150)\n     * ```\n     */\n    pivot?: PointData | number;\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @example\n     * ```ts\n     * new Container({ origin: new Point(100, 100) }); // Rotate around point (100,100)\n     * new Container({ origin: 50 }); // Rotate around point (50, 50)\n     * new Container({ origin: { x: 150, y: 150 } }); // Rotate around point (150, 150)\n     * ```\n     */\n    origin?: PointData | number;\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * new Container({ position: new Point(100, 200) }); // Set position to (100, 200)\n     * new Container({ position: { x: 150, y: 150 } }); // Set position to (150, 150)\n     * ```\n     */\n    position?: PointData;\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * new Container({ skew: new Point(0.1, 0.2) }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * new Container({ skew: { x: 0.1, y: 0.2 } }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    skew?: PointData;\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * new Container({ visible: false }); // Will not be drawn and transforms will not update\n     * new Container({ visible: true }); // Will be drawn and transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    visible?: boolean;\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * new Container({ x: 100 }); // Set x position to 100\n     * ```\n     */\n    x?: number;\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * new Container({ y: 200 }); // Set y position to 200\n     * ```\n     */\n    y?: number;\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container({\n     *    boundsArea: new Rectangle(0, 0, 500, 500) // Set a fixed bounds area\n     * });\n     * ```\n     */\n    boundsArea?: Rectangle;\n}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link Container#localTransform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         \u237A and \"skew.y\" is \u03B2, then the line x = 0 will be rotated by \u237A (y = -x*cot\u237A) and the line y = 0 will be\n *         rotated by \u03B2 (y = x*tan\u03B2). A line y = x*tan\u03F4 (i.e. a line at angle \u03F4 to the x-axis in local-space) will\n *         be rotated by an angle between \u237A and \u03B2.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -\u03F4 and \"skew.y\" = \u03F4, it will produce an equivalent of \"rotation\" = \u03F4.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS\u2019s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @category scene\n * @standard\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     * @deprecated since 8.8.0\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        // #if _DEBUG\n        deprecation('8.8.0', 'Container.mixin is deprecated, please use extensions.mixin instead.');\n        // #endif\n        extensions.mixin(Container, source);\n    }\n\n    /**\n     * unique id for this container\n     * @internal\n     */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * // Access children\n     * const firstChild = container.children[0];\n     * const lastChild = container.children[container.children.length - 1];\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    public children: C[] = [];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @example\n     * ```ts\n     * // Basic parent access\n     * const parent = sprite.parent;\n     *\n     * // Walk up the tree\n     * let current = sprite;\n     * while (current.parent) {\n     *     console.log('Level up:', current.parent.constructor.name);\n     *     current = current.parent;\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    public parent: Container | null = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    /**\n     * The RenderLayer this container belongs to, if any.\n     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n     * @readonly\n     * @advanced\n     */\n    public parentRenderLayer: IRenderLayer;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /** @internal */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * This matrix represents the local transformation without any parent influence.\n     * @example\n     * ```ts\n     * // Basic transform access\n     * const localMatrix = sprite.localTransform;\n     * console.log(localMatrix.toString());\n     * ```\n     * @readonly\n     * @see {@link Container#worldTransform} For global transform\n     * @see {@link Container#groupTransform} For render group transform\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     * @advanced\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     * @advanced\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /**\n     * Whether this object has been destroyed. If true, the object should no longer be used.\n     * After an object is destroyed, all of its functionality is disabled and references are removed.\n     * @example\n     * ```ts\n     * // Cleanup with destroy\n     * sprite.destroy();\n     * console.log(sprite.destroyed); // true\n     * ```\n     * @default false\n     * @see {@link Container#destroy} For destroying objects\n     */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @private\n     */\n    public _origin: ObservablePoint = defaultOrigin;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    /** @internal */\n    public localColor = 0xFFFFFF;\n    /** @internal */\n    public localAlpha = 1;\n\n    /** @internal */\n    public groupAlpha = 1; // A\n    /** @internal */\n    public groupColor = 0xFFFFFF; // BGR\n    /** @internal */\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /** @internal */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /** @internal */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /** @internal */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    /** @internal */\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.boundsArea = new Rectangle(0, 0, 500, 500);\n     * ```\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    /** @internal */\n    public layerParentId: string;// = 'default';\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n    /** @ignore */\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     * The children will be rendered as part of this container's display list.\n     * @example\n     * ```ts\n     * // Add a single child\n     * container.addChild(sprite);\n     *\n     * // Add multiple children\n     * container.addChild(background, player, foreground);\n     *\n     * // Add with type checking\n     * const sprite = container.addChild<Sprite>(new Sprite(texture));\n     * sprite.tint = 'red';\n     * ```\n     * @param children - The Container(s) to add to the container\n     * @returns The first child that was added\n     * @see {@link Container#removeChild} For removing children\n     * @see {@link Container#addChildAt} For adding at specific index\n     */\n    public addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n\n        // TODO - Optimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * When removing multiple children, events will be triggered for each child in sequence.\n     * @example\n     * ```ts\n     * // Remove a single child\n     * const removed = container.removeChild(sprite);\n     *\n     * // Remove multiple children\n     * const bg = container.removeChild(background, player, userInterface);\n     *\n     * // Remove with type checking\n     * const sprite = container.removeChild<Sprite>(childSprite);\n     * sprite.texture = newTexture;\n     * ```\n     * @param children - The Container(s) to remove\n     * @returns The first child that was removed\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    public removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            if (child.parentRenderLayer)\n            {\n                child.parentRenderLayer.detach(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     * @advanced\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     * @advanced\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /**\n     * This will disable the render group for this container.\n     * @advanced\n     */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * This matrix represents the absolute transformation in the scene graph.\n     * @example\n     * ```ts\n     * // Get world position\n     * const worldPos = container.worldTransform;\n     * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n     * ```\n     * @readonly\n     * @see {@link Container#localTransform} For local space transform\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * // Basic position\n     * container.x = 100;\n     * ```\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * // Basic position\n     * container.y = 200;\n     * ```\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * container.position.set(100, 200);\n     * container.position.set(100); // Sets both x and y to 100\n     * // Using point data\n     * container.position = { x: 50, y: 75 };\n     * ```\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     *\n     * // Convert from degrees\n     * const degrees = 45;\n     * container.rotation = degrees * Math.PI / 180;\n     *\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     *\n     * // Rotate around center with origin\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     * ```\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic angle rotation\n     * sprite.angle = 45; // 45 degrees\n     *\n     * // Rotate around center\n     * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Rotate around center with origin\n     * sprite.origin.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Reset rotation\n     * sprite.angle = 0;\n     * ```\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     * ```\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._origin !== defaultOrigin)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * // Basic skewing\n     * container.skew.set(0.5, 0); // Skew horizontally\n     * container.skew.set(0, 0.5); // Skew vertically\n     *\n     * // Skew with point data\n     * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n     *\n     * // Reset skew\n     * container.skew.set(0, 0);\n     *\n     * // Animate skew\n     * app.ticker.add(() => {\n     *     // Create wave effect\n     *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n     * });\n     *\n     * // Combine with rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     * container.skew.set(0.2, 0.2); // Skew the rotated object\n     * ```\n     * @since 4.0.0\n     * @type {ObservablePoint} Point-like object with x/y properties in radians\n     * @default {x: 0, y: 0}\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * // Basic scaling\n     * container.scale.set(2, 2); // Scales to double size\n     * container.scale.set(2); // Scales uniformly to double size\n     * container.scale = 2; // Scales uniformly to double size\n     * // Scale to a specific width and height\n     * container.setSize(200, 100); // Sets width to 200 and height to 100\n     * ```\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number | string)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        if (typeof value === 'string')\n        {\n            value = parseFloat(value);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * @experimental\n     * The origin point around which the container rotates and scales without affecting its position.\n     * Unlike pivot, changing the origin will not move the container's position.\n     * @example\n     * ```ts\n     * // Rotate around center point\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     *\n     * // Reset origin\n     * container.origin.set(0, 0);\n     * ```\n     */\n    get origin(): ObservablePoint\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._origin;\n    }\n\n    set origin(value: PointData | number)\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._pivot !== defaultPivot)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._origin.set(value) : this._origin.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic width setting\n     * container.width = 100;\n     * // Optimized width setting\n     * container.setSize(100, 100);\n     * ```\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container,\n     * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic height setting\n     * container.height = 200;\n     * // Optimized height setting\n     * container.setSize(100, 200);\n     * ```\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     *\n     * This is faster than get the width and height separately.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const size = container.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * container.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in.\n     * @returns The size of the container.\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is more efficient than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * container.setSize(100, 200);\n     *\n     * // Set uniform size\n     * container.setSize(100); // Sets both width and height to 100\n     * ```\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container.\n     * Allows partial updates of transform properties for optimized manipulation.\n     * @example\n     * ```ts\n     * // Basic transform update\n     * container.updateTransform({\n     *     x: 100,\n     *     y: 200,\n     *     rotation: Math.PI / 4\n     * });\n     *\n     * // Scale and rotate around center\n     * sprite.updateTransform({\n     *     pivotX: sprite.width / 2,\n     *     pivotY: sprite.height / 2,\n     *     scaleX: 2,\n     *     scaleY: 2,\n     *     rotation: Math.PI\n     * });\n     *\n     * // Update position only\n     * button.updateTransform({\n     *     x: button.x + 10, // Move right\n     *     y: button.y      // Keep same y\n     * });\n     * ```\n     * @param opts - Transform options to update\n     * @param opts.x - The x position\n     * @param opts.y - The y position\n     * @param opts.scaleX - The x-axis scale factor\n     * @param opts.scaleY - The y-axis scale factor\n     * @param opts.rotation - The rotation in radians\n     * @param opts.skewX - The x-axis skew factor\n     * @param opts.skewY - The y-axis skew factor\n     * @param opts.pivotX - The x-axis pivot point\n     * @param opts.pivotY - The y-axis pivot point\n     * @returns This container, for chaining\n     * @see {@link Container#setFromMatrix} For matrix-based transforms\n     * @see {@link Container#position} For direct position access\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n        this.origin.set(\n            typeof opts.originX === 'number' ? opts.originX : this.origin.x,\n            typeof opts.originY === 'number' ? opts.originY : this.origin.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform properties by decomposing the given matrix.\n     * Extracts position, scale, rotation, and skew from a transformation matrix.\n     * @example\n     * ```ts\n     * // Basic matrix transform\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * container.setFromMatrix(matrix);\n     *\n     * // Copy transform from another container\n     * const source = new Container();\n     * source.position.set(100, 100);\n     * source.rotation = Math.PI / 2;\n     *\n     * target.setFromMatrix(source.localTransform);\n     *\n     * // Reset transform\n     * container.setFromMatrix(Matrix.IDENTITY);\n     * ```\n     * @param matrix - The matrix to use for updating the transform\n     * @see {@link Container#updateTransform} For property-based updates\n     * @see {@link Matrix#decompose} For matrix decomposition details\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const origin = this._origin;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        const ox = -origin._x;\n        const oy = -origin._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c)) // Pivot offset\n            + ((ox * lt.a) + (oy * lt.c)) // Origin offset for rotation and scaling\n            - ox; // Remove origin to maintain position\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d)) // Pivot offset\n            + ((ox * lt.b) + (oy * lt.d)) // Origin offset for rotation and scaling\n            - oy; // Remove origin to maintain position\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * // Basic transparency\n     * sprite.alpha = 0.5; // 50% opacity\n     *\n     * // Inherited opacity\n     * container.alpha = 0.5;\n     * const child = new Sprite(texture);\n     * child.alpha = 0.5;\n     * container.addChild(child);\n     * // child's effective opacity is 0.25 (0.5 * 0.5)\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * // Basic color tinting\n     * container.tint = 0xff0000; // Red tint\n     * container.tint = 'red';    // Same as above\n     * container.tint = '#00ff00'; // Green\n     * container.tint = 'rgb(0,0,255)'; // Blue\n     *\n     * // Remove tint\n     * container.tint = 0xffffff; // White = no tint\n     * container.tint = null;     // Also removes tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    get tint(): number\n    {\n        // convert bgr to rgb..\n        return bgr2rgb(this.localColor);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * sprite.blendMode = 'add';        // Additive blending\n     * sprite.blendMode = 'multiply';   // Multiply colors\n     * sprite.blendMode = 'screen';     // Screen blend\n     *\n     * // Reset blend mode\n     * sprite.blendMode = 'normal';     // Normal blending\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * // Basic visibility toggle\n     * sprite.visible = false; // Hide sprite\n     * sprite.visible = true;  // Show sprite\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * // Basic render control\n     * sprite.renderable = false; // Skip rendering\n     * sprite.renderable = true;  // Enable rendering\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /**\n     * Whether or not the object should be rendered.\n     * @advanced\n     */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * ```ts\n     * container.destroy();\n     * container.destroy(true);\n     * container.destroy({ children: true });\n     * container.destroy({ children: true, texture: true, textureSource: true });\n     * ```\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n\n        let oldChildren: ContainerChild[];\n\n        // we add this check as calling removeChildren on particle container will throw an error\n        // As we know it does cannot have any children, check before calling the function.\n        if (this.children.length)\n        {\n            oldChildren = this.removeChildren(0, this.children.length);\n        }\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._origin = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren && oldChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nextensions.mixin(\n    Container,\n    childrenHelperMixin,\n    getFastGlobalBoundsMixin,\n    toLocalGlobalMixin,\n    onRenderMixin,\n    measureMixin,\n    effectsMixin,\n    findMixin,\n    sortMixin,\n    cullingMixin,\n    cacheAsTextureMixin,\n    getGlobalMixin,\n    collectRenderablesMixin,\n);\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @enum {number}\n * @category ticker\n * @standard\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link PrepareBase} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * The callback receives the Ticker instance as its parameter, providing access to timing properties.\n * @example\n * ```ts\n * ticker.add((ticker) => {\n *    // Access deltaTime (dimensionless scalar ~1.0 at 60fps)\n *    sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *    // Access deltaMS (milliseconds elapsed)\n *    const progress = ticker.deltaMS / animationDuration;\n * });\n * ```\n * @category ticker\n * @standard\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * Used for managing animation frames and timing in a PixiJS application.\n *\n * It provides a way to add listeners that will be called on each frame,\n * allowing for smooth animations and updates.\n *\n * ## Time Units\n * - `deltaTime`: Dimensionless scalar (typically ~1.0 at 60 FPS) for frame-independent animations\n * - `deltaMS`: Milliseconds elapsed (capped and speed-scaled) for time-based calculations\n * - `elapsedMS`: Raw milliseconds elapsed (uncapped, unscaled) for measurements\n * - `lastTime`: Timestamp in milliseconds since epoch (performance.now() format)\n *\n * Animation frames are requested\n * only when necessary, e.g., when the ticker is started and the emitter has listeners.\n * @example\n * ```ts\n * // Basic ticker usage with different time units\n * const ticker = new Ticker();\n * ticker.add((ticker) => {\n *     // Frame-independent animation using dimensionless deltaTime\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *     // Time-based animation using deltaMS (milliseconds)\n *     sprite.x += (100 / 1000) * ticker.deltaMS; // 100 pixels per second\n * });\n * ticker.start();\n *\n * // Control update priority\n * ticker.add(\n *     (ticker) => {\n *         // High priority updates run first\n *         physics.update(ticker.deltaTime);\n *     },\n *     undefined,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // One-time updates\n * ticker.addOnce(() => {\n *     console.log('Runs on next frame only');\n * });\n * ```\n * @see {@link TickerPlugin} For use with Application\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @see {@link TickerCallback} For listener function type\n * @category ticker\n * @standard\n */\nexport class Ticker\n{\n    /**\n     * Target frame rate in frames per millisecond.\n     * Used for converting deltaTime to a scalar time delta.\n     * @example\n     * ```ts\n     * // Default is 0.06 (60 FPS)\n     * console.log(Ticker.targetFPMS); // 0.06\n     *\n     * // Calculate target frame duration\n     * const frameDuration = 1 / Ticker.targetFPMS; // \u2248 16.67ms\n     *\n     * // Use in custom timing calculations\n     * const deltaTime = elapsedMS * Ticker.targetFPMS;\n     * ```\n     * @remarks\n     * - Default is 0.06 (equivalent to 60 FPS)\n     * - Used in deltaTime calculations\n     * - Affects all ticker instances\n     * @default 0.06\n     * @see {@link Ticker#deltaTime} For time scaling\n     * @see {@link Ticker#FPS} For actual frame rate\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n     * automatically when a listener is added.\n     * @example\n     * ```ts\n     * // Default behavior (manual start)\n     * const ticker = new Ticker();\n     * ticker.autoStart = false;\n     * ticker.add(() => {\n     *     // Won't run until ticker.start() is called\n     * });\n     *\n     * // Auto-start behavior\n     * const autoTicker = new Ticker();\n     * autoTicker.autoStart = true;\n     * autoTicker.add(() => {\n     *     // Runs immediately when added\n     * });\n     * ```\n     * @default false\n     * @see {@link Ticker#start} For manually starting the ticker\n     * @see {@link Ticker#stop} For manually stopping the ticker\n     */\n    public autoStart = false;\n    /**\n     * Scalar representing the delta time factor.\n     * This is a dimensionless value representing the fraction of a frame at the target framerate.\n     * At 60 FPS, this value is typically around 1.0.\n     *\n     * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.\n     * For actual milliseconds, use {@link Ticker#deltaMS}.\n     * @member {number}\n     * @example\n     * ```ts\n     * // Frame-independent animation using deltaTime scalar\n     * ticker.add((ticker) => {\n     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     * });\n     * ```\n     */\n    public deltaTime: number = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * Provides precise timing for animations and updates.\n     *\n     * This value is capped by setting {@link Ticker#minFPS|minFPS}\n     * and is scaled with {@link Ticker#speed|speed}.\n     *\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 \u00B5s.\n     *\n     * Defaults to target frame time\n     *\n     * > [!NOTE] The cap may be exceeded by scaling.\n     * @example\n     * ```ts\n     * // Animation timing\n     * ticker.add((ticker) => {\n     *     // Use millisecond timing for precise animations\n     *     const progress = (ticker.deltaMS / animationDuration);\n     *     sprite.alpha = Math.min(1, progress);\n     * });\n     * ```\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from the last frame to this frame.\n     * This value is not capped or scaled and provides raw timing information.\n     *\n     * Unlike {@link Ticker#deltaMS}, this value is unmodified by speed scaling or FPS capping.\n     * @member {number}\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public elapsedMS: number;\n    /**\n     * The last time update was invoked, in milliseconds since epoch.\n     * Similar to performance.now() timestamp format.\n     *\n     * Used internally for calculating time deltas between frames.\n     * @member {number}\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     const currentTime = performance.now();\n     *     const timeSinceLastFrame = currentTime - ticker.lastTime;\n     *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);\n     * });\n     * ```\n     */\n    public lastTime: number = -1;\n    /**\n     * Factor of current {@link Ticker#deltaTime|deltaTime}.\n     * Used to scale time for slow motion or fast-forward effects.\n     * @example\n     * ```ts\n     * // Basic speed adjustment\n     * ticker.speed = 0.5; // Half speed (slow motion)\n     * ticker.speed = 2.0; // Double speed (fast forward)\n     *\n     * // Temporary speed changes\n     * function slowMotion() {\n     *     const normalSpeed = ticker.speed;\n     *     ticker.speed = 0.2;\n     *     setTimeout(() => {\n     *         ticker.speed = normalSpeed;\n     *     }, 1000);\n     * }\n     * ```\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     *\n     * `true` if {@link Ticker#start|start} has been called.\n     * `false` if {@link Ticker#stop|Stop} has been called.\n     *\n     * While `false`, this value may change to `true` in the\n     * event of {@link Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     * @example\n     * ```ts\n     * // Check ticker state\n     * const ticker = new Ticker();\n     * console.log(ticker.started); // false\n     *\n     * // Start and verify\n     * ticker.start();\n     * console.log(ticker.started); // true\n     * ```\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /** Conditionally cancels a pending animation frame. */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events.\n     * @param fn - The listener function to add. Receives the Ticker instance as parameter\n     * @param context - The context for the listener\n     * @param priority - The priority of the listener\n     * @example\n     * ```ts\n     * // Access time properties through the ticker parameter\n     * ticker.add((ticker) => {\n     *     // Use deltaTime (dimensionless scalar) for frame-independent animations\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     *\n     *     // Use deltaMS (milliseconds) for time-based calculations\n     *     const progress = ticker.deltaMS / animationDuration;\n     *\n     *     // Use elapsedMS for raw timing measurements\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only executed once on the next frame.\n     * @example\n     * ```ts\n     * // Basic one-time update\n     * ticker.addOnce(() => {\n     *     console.log('Runs next frame only');\n     * });\n     *\n     * // With specific context\n     * const game = {\n     *     init(ticker) {\n     *         this.loadResources();\n     *         console.log('Game initialized');\n     *     }\n     * };\n     * ticker.addOnce(game.init, game);\n     *\n     * // With priority\n     * ticker.addOnce(\n     *     () => {\n     *         // High priority one-time setup\n     *         physics.init();\n     *     },\n     *     undefined,\n     *     UPDATE_PRIORITY.HIGH\n     * );\n     * ```\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For continuous updates\n     * @see {@link Ticker#remove} For removing handlers\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @example\n     * ```ts\n     * // Basic removal\n     * const onTick = () => {\n     *     sprite.rotation += 0.1;\n     * };\n     * ticker.add(onTick);\n     * ticker.remove(onTick);\n     *\n     * // Remove with context\n     * const game = {\n     *     update(ticker) {\n     *         this.physics.update(ticker.deltaTime);\n     *     }\n     * };\n     * ticker.add(game.update, game);\n     * ticker.remove(game.update, game);\n     *\n     * // Remove all matching handlers\n     * // (if same function was added multiple times)\n     * ticker.add(onTick);\n     * ticker.add(onTick);\n     * ticker.remove(onTick); // Removes all instances\n     * ```\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For adding handlers\n     * @see {@link Ticker#addOnce} For one-time handlers\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list.\n     * @example\n     * ```ts\n     * // Check number of active listeners\n     * const ticker = new Ticker();\n     * console.log(ticker.count); // 0\n     *\n     * // Add some listeners\n     * ticker.add(() => {});\n     * ticker.add(() => {});\n     * console.log(ticker.count); // 2\n     *\n     * // Check after cleanup\n     * ticker.destroy();\n     * console.log(ticker.count); // 0\n     * ```\n     * @readonly\n     * @see {@link Ticker#add} For adding listeners\n     * @see {@link Ticker#remove} For removing listeners\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n     * @example\n     * ```ts\n     * // Basic manual start\n     * const ticker = new Ticker();\n     * ticker.add(() => {\n     *     // Animation code here\n     * });\n     * ticker.start();\n     * ```\n     * @see {@link Ticker#stop} For stopping the ticker\n     * @see {@link Ticker#autoStart} For automatic starting\n     * @see {@link Ticker#started} For checking ticker state\n     */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n     * @example\n     * ```ts\n     * // Basic stop\n     * const ticker = new Ticker();\n     * ticker.stop();\n     * ```\n     * @see {@link Ticker#start} For starting the ticker\n     * @see {@link Ticker#started} For checking ticker state\n     * @see {@link Ticker#destroy} For cleaning up the ticker\n     */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n     * @example\n     * ```ts\n     * // Clean up with active listeners\n     * const ticker = new Ticker();\n     * ticker.add(() => {});\n     * ticker.destroy(); // Removes all listeners\n     * ```\n     * @see {@link Ticker#stop} For stopping without destroying\n     * @see {@link Ticker#remove} For removing specific listeners\n     */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update.\n     *\n     * An update entails setting the\n     * current {@link Ticker#elapsedMS|elapsedMS},\n     * the current {@link Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     *\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @example\n     * ```ts\n     * // Basic manual update\n     * const ticker = new Ticker();\n     * ticker.update(performance.now());\n     * ```\n     * @param currentTime - The current time of execution (defaults to performance.now())\n     * @see {@link Ticker#deltaTime} For frame delta value\n     * @see {@link Ticker#elapsedMS} For raw elapsed time\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * > [!NOTE] This does not factor in the value of\n     * > {@link Ticker#speed|speed}, which is specific\n     * > to scaling {@link Ticker#deltaTime|deltaTime}.\n     * @example\n     * ```ts\n     * // Basic FPS monitoring\n     * ticker.add(() => {\n     *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n     * });\n     * ```\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.minFPS = 30; // Never go below 30 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on minFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This will effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.maxFPS = 60; // Never go above 60 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on maxFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoSource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @type {Ticker}\n     * @readonly\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link PrepareBase} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @type {Ticker}\n     * @readonly\n     * @advanced\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n", "import { type Renderer } from '../rendering/renderers/types';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\n/**\n * CanvasObserver class synchronizes the DOM element's transform with the canvas size and position.\n * It uses ResizeObserver for efficient updates and requestAnimationFrame for fallback.\n * This ensures that the DOM element is always correctly positioned and scaled relative to the canvas.\n * @internal\n */\nexport class CanvasObserver\n{\n    /** A cached value of the last transform applied to the DOM element. */\n    private _lastTransform = '';\n    /** A ResizeObserver instance to observe changes in the canvas size. */\n    private _observer: ResizeObserver | null = null;\n    /** The canvas element that this observer is associated with. */\n    private _canvas: HTMLCanvasElement;\n    /** The DOM element that will be transformed based on the canvas size and position. */\n    private readonly _domElement: HTMLElement;\n    /** The renderer instance that this observer is associated with. */\n    private readonly _renderer: Renderer;\n    /** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n    private _lastScaleX: number;\n    /** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n    private _lastScaleY: number;\n    /** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */\n    private _tickerAttached = false;\n\n    constructor(options: { domElement: HTMLElement; renderer: Renderer })\n    {\n        this._domElement = options.domElement;\n        this._renderer = options.renderer;\n\n        // We need to ensure that the canvas is not an OffscreenCanvas\n        if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) return;\n        this._canvas = this._renderer.canvas;\n        this._attachObserver();\n    }\n\n    /** The canvas element that this CanvasObserver is associated with. */\n    public get canvas(): HTMLCanvasElement\n    {\n        return this._canvas;\n    }\n\n    /** Attaches the DOM element to the canvas parent if it is not already attached. */\n    public ensureAttached()\n    {\n        if (!this._domElement.parentNode && this._canvas.parentNode)\n        {\n            this._canvas.parentNode.appendChild(this._domElement);\n            this.updateTranslation();\n        }\n    }\n\n    /**\n     * Updates the transform of the DOM element based on the canvas size and position.\n     * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.\n     */\n    public readonly updateTranslation = () =>\n    {\n        if (!this._canvas) return;\n\n        const rect = this._canvas.getBoundingClientRect(); // still needed for left/top\n        const contentWidth = this._canvas.width;\n        const contentHeight = this._canvas.height;\n\n        const sx = (rect.width / contentWidth) * this._renderer.resolution;\n        const sy = (rect.height / contentHeight) * this._renderer.resolution;\n        const tx = rect.left;\n        const ty = rect.top;\n\n        const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;\n\n        if (newTransform !== this._lastTransform)\n        {\n            this._domElement.style.transform = newTransform;\n            this._lastTransform = newTransform;\n        }\n    };\n\n    /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */\n    private _attachObserver()\n    {\n        if ('ResizeObserver' in globalThis)\n        {\n            if (this._observer)\n            {\n                this._observer.disconnect();\n                this._observer = null;\n            }\n\n            this._observer = new ResizeObserver((entries) =>\n            {\n                for (const entry of entries)\n                {\n                    if (entry.target !== this._canvas)\n                    {\n                        continue;\n                    }\n\n                    const contentWidth = this.canvas.width;\n                    const contentHeight = this.canvas.height;\n                    const sx = (entry.contentRect.width / contentWidth) * this._renderer.resolution;\n                    const sy = (entry.contentRect.height / contentHeight) * this._renderer.resolution;\n\n                    // Only refetch position if scale actually changed\n                    const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;\n\n                    if (needsUpdate)\n                    {\n                        this.updateTranslation(); // safely fetch `left` and `top` only when needed\n                        this._lastScaleX = sx;\n                        this._lastScaleY = sy;\n                    }\n                }\n            });\n            this._observer.observe(this._canvas);\n        }\n        else if (!this._tickerAttached)\n        {\n            Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);\n        }\n    }\n\n    /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */\n    public destroy()\n    {\n        if (this._observer)\n        {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n        else if (this._tickerAttached)\n        {\n            Ticker.shared.remove(this.updateTranslation);\n        }\n\n        (this._domElement as null) = null;\n        (this._renderer as null) = null;\n        this._canvas = null;\n        this._tickerAttached = false;\n        this._lastTransform = '';\n        this._lastScaleX = null;\n        this._lastScaleY = null;\n    }\n}\n", "import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * ```ts\n * // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n * ```\n * @category events\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} DOM Touch Interface\n * @standard\n */\nexport interface PixiTouch extends Touch\n{\n    /** The button being pressed (0: left, 1: middle, 2: right) */\n    button: number;\n\n    /** Bitmap of currently pressed buttons */\n    buttons: number;\n\n    /** Whether this is the primary touch point */\n    isPrimary: boolean;\n\n    /** The width of the touch contact area */\n    width: number;\n\n    /** The height of the touch contact area */\n    height: number;\n\n    /** The angle of tilt along the x-axis (in degrees) */\n    tiltX: number;\n\n    /** The angle of tilt along the y-axis (in degrees) */\n    tiltY: number;\n\n    /** The type of pointer that triggered this event */\n    pointerType: string;\n\n    /** Unique identifier for this touch point */\n    pointerId: number;\n\n    /** The normalized pressure of the pointer (0 to 1) */\n    pressure: number;\n\n    /** The rotation angle of the pointer (e.g., pen) */\n    twist: number;\n\n    /** The normalized tangential pressure of the pointer */\n    tangentialPressure: number;\n\n    /** The x coordinate relative to the current layer */\n    layerX: number;\n\n    /** The y coordinate relative to the current layer */\n    layerY: number;\n\n    /** The x coordinate relative to the target's offset parent */\n    offsetX: number;\n\n    /** The y coordinate relative to the target's offset parent */\n    offsetY: number;\n\n    /** Whether the event was normalized by PixiJS */\n    isNormalized: boolean;\n\n    /** The type of touch event */\n    type: string;\n}\n\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * ```ts\n * // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n * ```\n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n * @see {@link https://dom.spec.whatwg.org/#event} DOM Event Specification\n * @see {@link FederatedPointerEvent} For pointer-specific events\n * @see {@link FederatedMouseEvent} For mouse-specific events\n * @see {@link FederatedWheelEvent} For wheel-specific events\n * @category events\n * @standard\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. `\"mouseup\"`. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The `target` is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated `InteractionEvent.data`.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /**\n     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n     * @advanced\n     */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n     * @deprecated\n     * @ignore\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n     * @ignore\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Prevent default behavior of both PixiJS and the user agent.\n     * @example\n     * ```ts\n     * sprite.on('click', (event) => {\n     *     // Prevent both browser's default click behavior\n     *     // and PixiJS's default handling\n     *     event.preventDefault();\n     *\n     *     // Custom handling\n     *     customClickHandler();\n     * });\n     * ```\n     * @remarks\n     * - Only works if the native event is cancelable\n     * - Does not stop event propagation\n     */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any additional listeners, including those\n     * on the current target and any following targets in the propagation path.\n     * @example\n     * ```ts\n     * container.on('pointerdown', (event) => {\n     *     // Stop all further event handling\n     *     event.stopImmediatePropagation();\n     *\n     *     // These handlers won't be called:\n     *     // - Other pointerdown listeners on this container\n     *     // - Any pointerdown listeners on parent containers\n     * });\n     * ```\n     * @remarks\n     * - Immediately stops all event propagation\n     * - Prevents other listeners on same target from being called\n     * - More aggressive than stopPropagation()\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next target in the propagation path.\n     * The rest of the listeners on the current target will still be notified.\n     * @example\n     * ```ts\n     * child.on('pointermove', (event) => {\n     *     // Handle event on child\n     *     updateChild();\n     *\n     *     // Prevent parent handlers from being called\n     *     event.stopPropagation();\n     * });\n     *\n     * // This won't be called if child handles the event\n     * parent.on('pointermove', (event) => {\n     *     updateParent();\n     * });\n     * ```\n     * @remarks\n     * - Stops event bubbling to parent containers\n     * - Does not prevent other listeners on same target\n     * - Less aggressive than stopImmediatePropagation()\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    public readonly NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    public readonly CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    public readonly AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    public readonly BUBBLING_PHASE = 3;\n}\n", null, "import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * ```ts\n * // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n * ```\n * @category utils\n * @standard\n */\nexport type isMobileResult = {\n    /**\n     * Apple device detection information.\n     * Provides detailed iOS device categorization.\n     * @example\n     * ```ts\n     * // iOS device checks\n     * if (isMobile.apple.device) {\n     *     if (isMobile.apple.tablet) {\n     *         // iPad-specific code\n     *         useTabletLayout();\n     *     } else if (isMobile.apple.phone) {\n     *         // iPhone-specific code\n     *         usePhoneLayout();\n     *     }\n     * }\n     * ```\n     */\n    apple: {\n        /** Whether the device is an iPhone */\n        phone: boolean;\n        /** Whether the device is an iPod Touch */\n        ipod: boolean;\n        /** Whether the device is an iPad */\n        tablet: boolean;\n        /** Whether app is running in iOS universal mode */\n        universal: boolean;\n        /** Whether device is any Apple mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Amazon device detection information.\n     * Identifies Amazon Fire tablets and phones.\n     * @example\n     * ```ts\n     * // Amazon Fire tablet detection\n     * if (isMobile.amazon.tablet) {\n     *     // Fire tablet optimizations\n     *     optimizeForFireTablet();\n     * }\n     * ```\n     */\n    amazon: {\n        /** Whether device is a Fire Phone */\n        phone: boolean;\n        /** Whether device is a Fire Tablet */\n        tablet: boolean;\n        /** Whether device is any Amazon mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Android device detection information.\n     * Categorizes Android phones and tablets.\n     * @example\n     * ```ts\n     * // Android device handling\n     * if (isMobile.android.device) {\n     *     // Check specific type\n     *     const deviceType = isMobile.android.tablet ?\n     *         'tablet' : 'phone';\n     *     console.log(`Android ${deviceType} detected`);\n     * }\n     * ```\n     */\n    android: {\n        /** Whether device is an Android phone */\n        phone: boolean;\n        /** Whether device is an Android tablet */\n        tablet: boolean;\n        /** Whether device is any Android device */\n        device: boolean;\n    };\n\n    /**\n     * Windows device detection information.\n     * Identifies Windows phones and tablets.\n     * @example\n     * ```ts\n     * // Windows device checks\n     * if (isMobile.windows.tablet) {\n     *     // Surface tablet optimizations\n     *     enableTouchFeatures();\n     * }\n     * ```\n     */\n    windows: {\n        /** Whether device is a Windows Phone */\n        phone: boolean;\n        /** Whether device is a Windows tablet */\n        tablet: boolean;\n        /** Whether device is any Windows mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Other device detection information.\n     * Covers additional platforms and browsers.\n     * @example\n     * ```ts\n     * // Check other platforms\n     * if (isMobile.other.blackberry10) {\n     *     // BlackBerry 10 specific code\n     * } else if (isMobile.other.chrome) {\n     *     // Chrome mobile specific code\n     * }\n     * ```\n     */\n    other: {\n        /** Whether device is a BlackBerry */\n        blackberry: boolean;\n        /** Whether device is a BlackBerry 10 */\n        blackberry10: boolean;\n        /** Whether browser is Opera Mobile */\n        opera: boolean;\n        /** Whether browser is Firefox Mobile */\n        firefox: boolean;\n        /** Whether browser is Chrome Mobile */\n        chrome: boolean;\n        /** Whether device is any other mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Whether the device is any type of phone.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a phone\n     * if (isMobile.phone) {\n     *     console.log('Running on a mobile phone');\n     * }\n     * ```\n     */\n    phone: boolean;\n\n    /**\n     * Whether the device is any type of tablet.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a tablet\n     * if (isMobile.tablet) {\n     *     console.log('Running on a mobile tablet');\n     * }\n     * ```\n     */\n    tablet: boolean;\n\n    /**\n     * Whether the device is any type of mobile device.\n     * True if any mobile platform is detected.\n     * @example\n     * ```ts\n     * // Check if device is mobile\n     * if (isMobile.any) {\n     *     console.log('Running on a mobile device');\n     * }\n     * ```\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * ```ts\n * import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n * ```\n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n * @category utils\n * @standard\n * @see {@link isMobileResult} For full type definition\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n", "/* eslint-disable no-restricted-globals */\nimport { CanvasObserver } from '../dom/CanvasObserver';\nimport { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/**\n * Initialisation options for the accessibility system when used with an Application.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilitySystemOptions\n{\n    /** Options for the accessibility system */\n    accessibilityOptions?: AccessibilityOptions;\n}\n\n/**\n * The options for the accessibility system.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilityOptions\n{\n    /** Whether to enable accessibility features on initialization instead of waiting for tab key */\n    enabledByDefault?: boolean;\n    /** Whether to visually show the accessibility divs for debugging */\n    debug?: boolean;\n    /** Whether to allow tab key press to activate accessibility features */\n    activateOnTab?: boolean;\n    /** Whether to deactivate accessibility when mouse moves */\n    deactivateOnMouseMove?: boolean;\n}\n\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n * ```\n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n * @category accessibility\n * @standard\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /**\n     * The default options used by the system.\n     * You can set these before initializing the {@link Application} to change the default behavior.\n     * @example\n     * ```js\n     * import { AccessibilitySystem } from 'pixi.js';\n     *\n     * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n     *\n     * const app = new Application()\n     * app.init()\n     * ```\n     */\n    public static defaultOptions: AccessibilityOptions = {\n        /**\n         * Whether to enable accessibility features on initialization\n         * @default false\n         */\n        enabledByDefault: false,\n        /**\n         * Whether to visually show the accessibility divs for debugging\n         * @default false\n         */\n        debug: false,\n        /**\n         * Whether to activate accessibility when tab key is pressed\n         * @default true\n         */\n        activateOnTab: true,\n        /**\n         * Whether to deactivate accessibility when mouse moves\n         * @default true\n         */\n        deactivateOnMouseMove: true,\n    };\n\n    /** Whether accessibility divs are visible for debugging */\n    public debug = false;\n\n    /** Whether to activate on tab key press */\n    private _activateOnTab = true;\n\n    /** Whether to deactivate accessibility when mouse moves */\n    private _deactivateOnMouseMove = true;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement | null = null;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n    private _canvasObserver: CanvasObserver;\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        this._renderer = renderer;\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @type {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @type {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    /**\n     * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n     * @readonly\n     */\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        // Create and add div if needed\n        if (!this._div)\n        {\n            this._div = document.createElement('div');\n            this._div.style.position = 'absolute';\n            this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n            this._div.style.pointerEvents = 'none';\n            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n\n            // Initialize the CanvasTransformSync to keep the DOM element in sync with the canvas\n            this._canvasObserver = new CanvasObserver({\n                domElement: this._div,\n                renderer: this._renderer,\n            });\n        }\n\n        // Bind event handlers and add listeners when activating\n        if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        if (this._deactivateOnMouseMove)\n        {\n            this._onMouseMove = this._onMouseMove.bind(this);\n            globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        }\n\n        // Check if canvas is in DOM\n        const canvas = this._renderer.view.canvas;\n\n        if (!canvas.parentNode)\n        {\n            const observer = new MutationObserver(() =>\n            {\n                if (canvas.parentNode)\n                {\n                    observer.disconnect();\n\n                    // Add to DOM\n                    this._canvasObserver.ensureAttached();\n                    // Only start the postrender runner after div is ready\n                    this._initAccessibilitySetup();\n                }\n            });\n\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n        else\n        {\n            // Add to DOM\n            this._canvasObserver.ensureAttached();\n            // Div is ready, initialize accessibility\n            this._initAccessibilitySetup();\n        }\n    }\n\n    // New method to handle initialization after div is ready\n    private _initAccessibilitySetup(): void\n    {\n        // Add the postrender runner to start processing accessible objects\n        this._renderer.runners.postrender.add(this);\n\n        // Force an initial update of accessible objects\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n    }\n\n    /**\n     * Deactivates the accessibility system. Removes listeners and accessibility elements.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        // Switch listeners\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n\n        // Remove all active accessibility elements\n        for (const child of this._children)\n        {\n            if (child._accessibleDiv && child._accessibleDiv.parentNode)\n            {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n\n        // Clear the pool of divs\n        this._pool.forEach((div) =>\n        {\n            if (div.parentNode)\n            {\n                div.parentNode.removeChild(div);\n            }\n        });\n\n        // Remove parent div from DOM\n        if (this._div && this._div.parentNode)\n        {\n            this._div.parentNode.removeChild(this._div);\n        }\n\n        this._pool = [];\n        this._children = [];\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        // Separate check for accessibility without requiring interactivity\n        if (container.accessible)\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilitySystemOptions): void\n    {\n        // Ensure we have the accessibilityOptions object\n        const defaultOpts = AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...(options?.accessibilityOptions || {})\n            }\n        };\n\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n\n        if (mergedOptions.accessibilityOptions.enabledByDefault)\n        {\n            this._activate();\n        }\n        else if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Updates the accessibility layer during rendering.\n     * - Removes divs for containers no longer in the scene\n     * - Updates the position and dimensions of the root div\n     * - Updates positions of active accessibility divs\n     * Only fires while the accessibility system is active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // Track which containers are still active this frame\n        const activeIds = new Set<number>();\n\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n\n            // Mark all updated containers as active\n            for (const child of this._children)\n            {\n                if (child._renderId === this._renderId)\n                {\n                    activeIds.add(this._children.indexOf(child));\n                }\n            }\n        }\n\n        // Remove any containers that weren't updated this frame\n        for (let i = this._children.length - 1; i >= 0; i--)\n        {\n            const child = this._children[i];\n\n            if (!activeIds.has(i))\n            {\n                // Container was removed, clean up its accessibility div\n                if (child._accessibleDiv && child._accessibleDiv.parentNode)\n                {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n\n                    this._pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                removeItems(this._children, i, 1);\n            }\n        }\n\n        // Update root div dimensions if needed\n        if (this._renderer.renderingToScreen)\n        {\n            // Ensure the main DOM element is attached to the same parent as the canvas\n            this._canvasObserver.ensureAttached();\n        }\n\n        // Update positions of existing divs\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (!child._accessibleActive || !child._accessibleDiv)\n            {\n                continue;\n            }\n\n            // Only update position-related properties\n            const div = child._accessibleDiv;\n            const hitArea = (child.hitArea || child.getBounds().rectangle) as Rectangle;\n\n            if (child.hitArea)\n            {\n                const wt = child.worldTransform;\n\n                div.style.left = `${(wt.tx + (hitArea.x * wt.a))}px`;\n                div.style.top = `${(wt.ty + (hitArea.y * wt.d))}px`;\n                div.style.width = `${hitArea.width * wt.a}px`;\n                div.style.height = `${hitArea.height * wt.d}px`;\n            }\n            else\n            {\n                this._capHitArea(hitArea);\n                div.style.left = `${hitArea.x}px`;\n                div.style.top = `${hitArea.y}px`;\n                div.style.width = `${hitArea.width}px`;\n                div.style.height = `${hitArea.height}px`;\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n     * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            if (container.accessibleType === 'button')\n            {\n                div = document.createElement('button');\n            }\n            else\n            {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText)\n                {\n                    div.innerText = container.accessibleText;\n                }\n            }\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (container.interactive)\n        {\n            div.tabIndex = container.tabIndex;\n        }\n        else\n        {\n            // reset tabIndex back to 0 in case this div instance was pulled from the pool and already had a value\n            div.tabIndex = 0;\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /**\n     * Destroys the accessibility system. Removes all elements and listeners.\n     * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n     * > A typically user should not need to call this method directly.\n     */\n    public destroy(): void\n    {\n        this._deactivate();\n        this._destroyTouchHook();\n\n        this._canvasObserver?.destroy();\n        this._canvasObserver = null;\n\n        this._div = null;\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n\n        if (this._activateOnTab)\n        {\n            globalThis.removeEventListener('keydown', this._onKeyDown);\n        }\n    }\n\n    /**\n     * Enables or disables the accessibility system.\n     * @param enabled - Whether to enable or disable accessibility.\n     * @example\n     * ```js\n     * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n     * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n     * ```\n     */\n    public setAccessibilityEnabled(enabled: boolean): void\n    {\n        if (enabled)\n        {\n            this._activate();\n        }\n        else\n        {\n            this._deactivate();\n        }\n    }\n}\n", "import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * @category accessibility\n * @standard\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n * @category accessibility\n * @standard\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * ```\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @type {string}\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleTitle = 'My Container';\n     * ```\n     */\n    accessibleTitle: string | null;\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @default null\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleHint = 'This is a container';\n     * ```\n     */\n    accessibleHint: string | null;\n    /**\n     * Sets the tabIndex of the shadow div. You can use this to set the order of the\n     * elements when using the tab key to navigate.\n     * @default 0\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.tabIndex = 0;\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true;\n     * sprite.tabIndex = 1;\n     * ```\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     * @type {string}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleType = 'button'; // or 'link', 'checkbox', etc.\n     * ```\n     */\n    accessibleType: keyof HTMLElementTagNameMap;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {PointerEvents}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessiblePointerEvents = 'none'; // or 'auto', 'visiblePainted', etc.\n     * ```\n     */\n    accessiblePointerEvents: PointerEvents;\n\n    /**\n     * Sets the text content of the shadow\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleText = 'This is a container';\n     * ```\n     */\n    accessibleText: string | null;\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleChildren = false; // This will prevent any children from being accessible\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true; // This will not work since accessibleChildren is false\n     * ```\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    /** @private */\n    _accessibleActive: boolean;\n    /** @private */\n    _accessibleDiv: AccessibleHTMLElement | null;\n    /** @private */\n    _renderId: number;\n}\n\n/** @internal */\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @internal\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    accessible: false,\n    accessibleTitle: null,\n    accessibleHint: null,\n    tabIndex: 0,\n    accessibleType: 'button',\n    accessibleText: null,\n    accessiblePointerEvents: 'auto',\n    accessibleChildren: true,\n    _accessibleActive: false,\n    _accessibleDiv: null,\n    _renderId: -1,\n};\n", "import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { AccessibilitySystem } from './AccessibilitySystem';\nimport { accessibilityTarget } from './accessibilityTarget';\n\nextensions.add(AccessibilitySystem);\nextensions.mixin(Container, accessibilityTarget);\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n", "import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n", "import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/** @advanced */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }) : new MouseEvent('mousemove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n\n    /** Destroys the event ticker. */\n    public destroy(): void\n    {\n        this.removeTickerListener();\n        this.events = null;\n        this.domElement = null;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n}\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @category events\n * @class\n * @advanced\n */\nexport const EventsTicker = new EventsTickerClass();\n", "import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * ```ts\n * // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n * ```\n * @category events\n * @see {@link FederatedEvent} For base event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} DOM MouseEvent Interface\n * @standard\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * Converts global coordinates into container-local coordinates.\n     *\n     * This method transforms coordinates from world space to a container's local space,\n     * useful for precise positioning and hit testing.\n     * @param container - The Container to get local coordinates for\n     * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n     * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n     * @returns The local coordinates as a Point object\n     * @example\n     * ```ts\n     * // Basic usage - get local coordinates relative to a container\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Get position relative to the sprite\n     *     const localPos = event.getLocalPosition(sprite);\n     *     console.log('Local position:', localPos.x, localPos.y);\n     * });\n     * // Using custom global coordinates\n     * const customGlobal = new Point(100, 100);\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Transform custom coordinates\n     *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n     *     console.log('Custom local position:', localPos.x, localPos.y);\n     * });\n     * ```\n     * @see {@link Container.worldTransform} For the transformation matrix\n     * @see {@link Point} For the point class used to store coordinates\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * ```ts\n * // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} DOM PointerEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring the vertical angle between\n     * the device's surface to the pointer or stylus.\n     * A stylus at 0 degrees would be directly parallel whereas at \u03C0/2 degrees it would be perpendicular.\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n     */\n    public altitudeAngle: number;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n     * the pointer or stylus projected onto the screen's plane.\n     * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at \u03C0/2 degrees it would be pointing at \"6 o'clock\".\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n     */\n    public azimuthAngle: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * ```ts\n * // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent} DOM WheelEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @category events\n * @advanced\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | (string & {});\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target `e.target`.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * `target`. The last element in the path is `target`.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type ??= e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The `originalEvent` for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose `originalEvent` is `from`.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event `from`, with an optional `type` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     * @returns An event of the given type.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/**\n * Options for configuring the PixiJS event system. These options control how the event system\n * handles different types of interactions and event propagation.\n * @example\n * ```ts\n * // Basic event system configuration\n * const app = new Application();\n * await app.init({\n *     // Configure default interaction mode\n *     eventMode: 'static',\n *\n *     // Configure event features\n *     eventFeatures: {\n *         move: true,           // Enable pointer movement events\n *         globalMove: false,    // Disable global move events\n *         click: true,          // Enable click events\n *         wheel: true          // Enable wheel/scroll events\n *     }\n * });\n *\n * // Access event system after initialization\n * const eventSystem = app.renderer.events;\n * console.log(eventSystem.features); // Check enabled features\n * ```\n * @see {@link EventSystem} For the main event system implementation\n * @see {@link EventMode} For interaction mode details\n * @see {@link EventSystemFeatures} For all available feature options\n * @advanced\n * @category events\n */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode for all display objects.\n     * Controls how objects respond to interaction events.\n     *\n     * Possible values:\n     * - `'none'`: No interaction events\n     * - `'passive'`: Only container's children receive events (default)\n     * - `'auto'`: Receives events when parent is interactive\n     * - `'static'`: Standard interaction events\n     * - `'dynamic'`: Like static but with additional synthetic events\n     * @default 'passive'\n     */\n    eventMode?: EventMode;\n\n    /**\n     * Configuration for enabling/disabling specific event features.\n     * Use this to optimize performance by turning off unused functionality.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     eventFeatures: {\n     *         // Core interaction events\n     *         move: true,        // Pointer/mouse/touch movement\n     *         click: true,       // Click/tap events\n     *         wheel: true,       // Mouse wheel/scroll events\n     *         // Global tracking\n     *         globalMove: false  // Global pointer movement\n     *     }\n     * });\n     * ```\n     */\n    eventFeatures?: Partial<EventSystemFeatures>;\n}\n\n/**\n * The event features that are enabled by the EventSystem. These features control\n * different types of interaction events in your PixiJS application.\n * @example\n * ```ts\n * // Configure features during application initialization\n * const app = new Application();\n * await app.init({\n *     eventFeatures: {\n *         // Basic interaction events\n *         move: true,        // Enable pointer movement tracking\n *         click: true,       // Enable click/tap events\n *         wheel: true,       // Enable mouse wheel/scroll events\n *         // Advanced features\n *         globalMove: false  // Disable global move tracking for performance\n *     }\n * });\n *\n * // Or configure after initialization\n * app.renderer.events.features.move = false;      // Disable movement events\n * app.renderer.events.features.globalMove = true; // Enable global tracking\n * ```\n * @since 7.2.0\n * @category events\n * @advanced\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement.\n     *\n     * When enabled, these events will fire:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     * @example\n     * ```ts\n     * // Enable movement events\n     * app.renderer.events.features.move = true;\n     *\n     * // Listen for movement\n     * sprite.on('pointermove', (event) => {\n     *     console.log('Pointer position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    move: boolean;\n\n    /**\n     * Enables global pointer move events that fire regardless of target.\n     *\n     * When enabled, these events will fire:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchmove`\n     * @example\n     * ```ts\n     * // Enable global tracking\n     * app.renderer.events.features.globalMove = true;\n     *\n     * // Track pointer globally\n     * sprite.on('globalpointermove', (event) => {\n     *     // Fires even when pointer is not over sprite\n     *     console.log('Global position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking/tapping.\n     *\n     * When enabled, these events will fire:\n     * - `pointerdown` / `mousedown` / `touchstart` / `rightdown`\n     * - `pointerup` / `mouseup` / `touchend` / `rightup`\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / `rightupoutside`\n     * - `click` / `tap`\n     * @example\n     * ```ts\n     * // Enable click events\n     * app.renderer.events.features.click = true;\n     *\n     * // Handle clicks\n     * sprite.on('click', (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    click: boolean;\n    /**\n     * Enables mouse wheel/scroll events.\n     * @example\n     * ```ts\n     * // Enable wheel events\n     * app.renderer.events.features.wheel = true;\n     *\n     * // Handle scrolling\n     * sprite.on('wheel', (event) => {\n     *     // Zoom based on scroll direction\n     *     const scale = 1 + (event.deltaY / 1000);\n     *     sprite.scale.set(sprite.scale.x * scale);\n     * });\n     * ```\n     * @default true\n     */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * ```ts\n * // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n * ```\n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n * @see {@link EventBoundary} For event propagation and handling\n * @see {@link FederatedEvent} For the base event class\n * @see {@link EventMode} For interaction modes\n * @category events\n * @standard\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * ```ts\n     * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n     * // Access the default event features\n     * EventSystem.defaultEventFeatures = {\n     *     // Enable pointer movement events\n     *     move: true,\n     *     // Enable global pointer move events\n     *     globalMove: true,\n     *     // Enable click events\n     *     click: true,\n     *     // Enable wheel events\n     *     wheel: true,\n     * };\n     * ```\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     * @advanced\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Controls whether default browser actions are automatically prevented on pointer events.\n     * When true, prevents default browser actions from occurring on pointer events.\n     * @remarks\n     * - Does not apply to pointer events for backwards compatibility\n     * - preventDefault on pointer events stops mouse events from firing\n     * - For every pointer event, there will always be either a mouse or touch event alongside it\n     * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n     * @example\n     * ```ts\n     * // Allow default browser actions\n     * app.renderer.events.autoPreventDefault = false;\n     *\n     * // Block default actions (default)\n     * app.renderer.events.autoPreventDefault = true;\n     *\n     * // Example with text selection\n     * const text = new Text('Selectable text');\n     * text.eventMode = 'static';\n     * app.renderer.events.autoPreventDefault = false; // Allow text selection\n     * ```\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of custom cursor styles that can be used across the application.\n     * Used to define how different cursor modes are handled when interacting with display objects.\n     * @example\n     * ```ts\n     * // Access event system through renderer\n     * const eventSystem = app.renderer.events;\n     *\n     * // Set string-based cursor styles\n     * eventSystem.cursorStyles.default = 'pointer';\n     * eventSystem.cursorStyles.hover = 'grab';\n     * eventSystem.cursorStyles.drag = 'grabbing';\n     *\n     * // Use CSS object for complex styling\n     * eventSystem.cursorStyles.custom = {\n     *     cursor: 'url(\"custom.png\") 2 2, auto',\n     *     userSelect: 'none'\n     * };\n     *\n     * // Use a url for custom cursors\n     * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n     * eventSystem.cursorStyles.icon = defaultIcon;\n     *\n     * // Use callback function for dynamic cursors\n     * eventSystem.cursorStyles.dynamic = (mode) => {\n     *     // Update cursor based on mode\n     *     document.body.style.cursor = mode === 'hover'\n     *         ? 'pointer'\n     *         : 'default';\n     * };\n     *\n     * // Apply cursor style to a sprite\n     * sprite.cursor = 'hover'; // Will use the hover style defined above\n     * sprite.cursor = 'icon'; // Will apply the icon cursor\n     * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n     * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n     * sprite.cursor = 'default'; // Will apply the default pointer cursor\n     * sprite.cursor = 'dynamic'; // Will call the dynamic function\n     * ```\n     * @remarks\n     * - Strings are treated as CSS cursor values\n     * - Objects are applied as CSS styles to the DOM element\n     * - Functions are called directly for custom cursor handling\n     * - Default styles for 'default' and 'pointer' are provided\n     * @default\n     * ```ts\n     * {\n     *     default: 'inherit',\n     *     pointer: 'pointer' // Default cursor styles\n     * }\n     * ```\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        EventsTicker.destroy();\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n     * @param mode - Cursor mode to set. Can be:\n     * - A CSS cursor string (e.g., 'pointer', 'grab')\n     * - A key from the cursorStyles dictionary\n     * - null/undefined to reset to default\n     * @example\n     * ```ts\n     * // Using predefined cursor styles\n     * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n     * app.renderer.events.setCursor('grab');       // Set grab cursor\n     * app.renderer.events.setCursor(null);         // Reset to default\n     *\n     * // Using custom cursor styles\n     * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n     * app.renderer.events.setCursor('custom');     // Apply custom cursor\n     *\n     * // Using callback-based cursor\n     * app.renderer.events.cursorStyles.dynamic = (mode) => {\n     *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n     * };\n     * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n     * ```\n     * @remarks\n     * - Has no effect on OffscreenCanvas except for callback-based cursors\n     * - Caches current cursor to avoid unnecessary DOM updates\n     * - Supports CSS cursor values, style objects, and callback functions\n     * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n     */\n    public setCursor(mode: string): void\n    {\n        mode ||= 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event instance containing the most recent pointer state.\n     * This is useful for accessing pointer information without listening to events.\n     * @example\n     * ```ts\n     * // Access current pointer position at any time\n     * const eventSystem = app.renderer.events;\n     * const pointer = eventSystem.pointer;\n     *\n     * // Get global coordinates\n     * console.log('Position:', pointer.global.x, pointer.global.y);\n     *\n     * // Check button state\n     * console.log('Buttons pressed:', pointer.buttons);\n     *\n     * // Get pointer type and pressure\n     * console.log('Type:', pointer.pointerType);\n     * console.log('Pressure:', pointer.pressure);\n     * ```\n     * @readonly\n     * @since 7.2.0\n     * @see {@link FederatedPointerEvent} For all available pointer properties\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     * This method manages the DOM event bindings for the event system, allowing you to\n     * change or remove the target element that receives input events.\n     * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n     * > should not need to call this unless you are using a custom element.\n     * @param element - The new DOM element to bind events to, or null to remove all event bindings\n     * @example\n     * ```ts\n     * // Set a new canvas element as the target\n     * const canvas = document.createElement('canvas');\n     * app.renderer.events.setTargetElement(canvas);\n     *\n     * // Remove all event bindings\n     * app.renderer.events.setTargetElement(null);\n     *\n     * // Switch to a different canvas\n     * const newCanvas = document.querySelector('#game-canvas');\n     * app.renderer.events.setTargetElement(newCanvas);\n     * ```\n     * @remarks\n     * - Automatically removes event listeners from previous element\n     * - Required for the event system to function\n     * - Safe to call multiple times\n     * @see {@link EventSystem#domElement} The current DOM element\n     * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n     * This takes into account the current scale, position, and resolution of the DOM element.\n     * @param point - The point to store the mapped coordinates in\n     * @param x - The x coordinate in DOM/client space\n     * @param y - The y coordinate in DOM/client space\n     * @example\n     * ```ts\n     * // Map mouse coordinates to PixiJS space\n     * const point = new Point();\n     * app.renderer.events.mapPositionToPoint(\n     *     point,\n     *     event.clientX,\n     *     event.clientY\n     * );\n     * console.log('Mapped position:', point.x, point.y);\n     *\n     * // Using with pointer events\n     * sprite.on('pointermove', (event) => {\n     *     // event.global already contains mapped coordinates\n     *     console.log('Global:', event.global.x, event.global.y);\n     *\n     *     // Map to local coordinates\n     *     const local = event.getLocalPosition(sprite);\n     *     console.log('Local:', local.x, local.y);\n     * });\n     * ```\n     * @remarks\n     * - Accounts for element scaling and positioning\n     * - Adjusts for device pixel ratio/resolution\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n", "import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * ```ts\n * // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n * ```\n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n * @category events\n * @standard\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * ```ts\n * // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n * ```\n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n * @see {@link Container.eventMode} For enabling interactivity\n * @see {@link Container.interactive} For backwards compatibility\n * @category events\n * @standard\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the given coordinates are inside this hit area.\n     * @param {number} x - The x coordinate to check\n     * @param {number} y - The y coordinate to check\n     * @returns True if the coordinates are inside the hit area\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @category events\n * @advanced\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * ```ts\n * // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n * ```\n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n * @category events\n * @standard\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * ```ts\n * // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n * ```\n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n * @see {@link EventMode} For interaction mode details\n * @see {@link Cursor} For cursor style options\n * @see {@link IHitArea} For hit area implementation\n * @category events\n * @standard\n */\nexport interface FederatedOptions\n{\n    /**\n     * The cursor style to display when the mouse pointer is hovering over the object.\n     * Accepts any valid CSS cursor value or custom cursor URL.\n     * @example\n     * ```ts\n     * // Common cursor types\n     * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n     * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n     * sprite.cursor = 'crosshair';   // Precise cursor for selection\n     * sprite.cursor = 'not-allowed'; // Indicate disabled state\n     *\n     * // Direction cursors\n     * sprite.cursor = 'n-resize';    // North resize\n     * sprite.cursor = 'ew-resize';   // East-west resize\n     * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n     *\n     * // Custom cursor with fallback\n     * sprite.cursor = 'url(\"custom.png\"), auto';\n     * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n     * ```\n     * @type {Cursor | string}\n     * @default undefined\n     * @see {@link EventSystem.cursorStyles} For setting global cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n     */\n    cursor?: Cursor | (string & {});\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable standard interaction (like buttons)\n     * sprite.eventMode = 'static';\n     * sprite.on('pointerdown', () => console.log('clicked!'));\n     *\n     * // Enable for moving objects\n     * sprite.eventMode = 'dynamic';\n     * sprite.on('pointermove', () => updatePosition());\n     *\n     * // Disable all interaction\n     * sprite.eventMode = 'none';\n     *\n     * // Only allow child interactions\n     * sprite.eventMode = 'passive';\n     * ```\n     *\n     * Available modes:\n     *\n     * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n     * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n     * children. Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n     * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n     * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n     *\n     * Performance tips:\n     * - Use `'none'` for pure visual elements\n     * - Use `'passive'` for containers with some interactive children\n     * - Use `'static'` for standard UI elements\n     * - Use `'dynamic'` only when needed for moving/animated elements\n     * @since 7.2.0\n     */\n    eventMode?: EventMode;\n    /**\n     * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n     * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n     * Setting it to false will disable all interaction events on this object.\n     * @see {@link Container.eventMode}\n     * @example\n     * ```ts\n     * // Enable interaction events\n     * sprite.interactive = true;  // Sets eventMode = 'static'\n     * sprite.interactive = false; // Sets eventMode = 'passive'\n     * ```\n     */\n    interactive?: boolean\n    /**\n     * Controls whether children of this container can receive pointer events.\n     *\n     * Setting this to false allows PixiJS to skip hit testing on all children,\n     * improving performance for containers with many non-interactive children.\n     * @default true\n     * @example\n     * ```ts\n     * // Container with many visual-only children\n     * const container = new Container();\n     * container.interactiveChildren = false; // Skip hit testing children\n     *\n     * // Menu with interactive buttons\n     * const menu = new Container();\n     * menu.interactiveChildren = true; // Test all children\n     * menu.addChild(button1, button2, button3);\n     *\n     * // Performance optimization\n     * background.interactiveChildren = false;\n     * foreground.interactiveChildren = true;\n     * ```\n     */\n    interactiveChildren?: boolean;\n    /**\n     * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n     * for hit testing instead of the container's standard bounds.\n     * @example\n     * ```ts\n     * import { Rectangle, Circle, Sprite } from 'pixi.js';\n     *\n     * // Rectangular hit area\n     * const button = new Sprite(texture);\n     * button.eventMode = 'static';\n     * button.hitArea = new Rectangle(0, 0, 100, 50);\n     *\n     * // Circular hit area\n     * const icon = new Sprite(texture);\n     * icon.eventMode = 'static';\n     * icon.hitArea = new Circle(32, 32, 32);\n     *\n     * // Custom hit area with polygon\n     * const custom = new Sprite(texture);\n     * custom.eventMode = 'static';\n     * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n     *\n     * // Custom hit testing logic\n     * sprite.hitArea = {\n     *     contains(x: number, y: number) {\n     *         // Custom collision detection\n     *         return x >= 0 && x <= width && y >= 0 && y <= height;\n     *     }\n     * };\n     * ```\n     * @remarks\n     * - Takes precedence over the container's bounds for hit testing\n     * - Can improve performance by simplifying collision checks\n     * - Useful for irregular shapes or precise click areas\n     */\n    hitArea?: IHitArea | null;\n\n    /**\n     * Property-based event handler for the `click` event.\n     * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('click', (event) => {\n     *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onclick = (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * Fired when a mouse button is pressed while the pointer is over the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousedown', (event) => {\n     *    sprite.alpha = 0.5; // Visual feedback\n     *    console.log('Mouse button:', event.button);\n     * });\n     * // Using property-based handler\n     * sprite.onmousedown = (event) => {\n     *     sprite.alpha = 0.5; // Visual feedback\n     *     console.log('Mouse button:', event.button);\n     * };\n     * ```\n     * @default null\n     */\n    onmousedown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseenter', (event) => {\n     *     sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseenter = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseleave', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * Fired when the pointer moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousemove', (event) => {\n     *    // Get coordinates relative to the sprite\n     *   console.log('Local:', event.getLocalPosition(sprite));\n     * });\n     * // Using property-based handler\n     * sprite.onmousemove = (event) => {\n     *     // Get coordinates relative to the sprite\n     *     console.log('Local:', event.getLocalPosition(sprite));\n     * };\n     * ```\n     * @default null\n     */\n    onmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     *\n     * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalmousemove', (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalmousemove = (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseout = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * Fired when the pointer moves onto the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseover', (event) => {\n     *      sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseover = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * Fired when a mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseup = (event) => {\n     *      sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * Fired when a mouse button is released outside the display object that initially\n     * registered a mousedown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * Fired when a pointer device interaction is canceled or lost.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointercancel', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointercancel = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointercancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerdown', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerdown = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerenter', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerenter = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * // Using emitter handler\n     * sprite.on('pointerleave', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * Fired when a pointer device moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     *\n     * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalpointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerout = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * Fired when the pointer moves over the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerover', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerover = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointertap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointertap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointertap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * Fired when a pointer device button is released outside the bounds of the display object\n     * that initially registered a pointerdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * Fired when a right-click (context menu) action is performed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightclick', (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onrightclick = (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onrightclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * Fired when a right mouse button is pressed down over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightdown', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.onrightdown = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    onrightdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * Fired when a right mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * Fired when a right mouse button is released outside the bounds of the display object\n     * that initially registered a rightdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * Fired when a tap action (touch) is completed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('tap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchcancel', (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchcancel = (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchcancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchend', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchend = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchend?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * Fired when a touch interaction ends outside the bounds of the display object\n     * that initially registered a touchstart.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchendoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchendoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchendoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * Fired when a touch interaction moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     *\n     * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globaltouchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobaltouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the touch is outside the object's bounds\n     * - Useful for drag operations or global touch tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n     */\n    onglobaltouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * Fired when a touch interaction starts, such as when a finger touches the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchstart', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchstart = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchstart?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * Fired when the mouse wheel is scrolled while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('wheel', (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * });\n     * // Using property-based handler\n     * sprite.onwheel = (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * };\n     * ```\n     * @default null\n     */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\n/**\n * The options for the `addEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @category events\n * @advanced\n */\nexport type AddListenerOptions = boolean | AddEventListenerOptions;\n/**\n * The options for the `removeEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @category events\n * @advanced\n */\nexport type RemoveListenerOptions = boolean | EventListenerOptions;\n\n/**\n * Additional properties for a Container that is used for interaction events.\n * @category events\n * @advanced\n */\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container | null;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    /** @private */\n    _internalEventMode: EventMode;\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive: () => boolean;\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @param {any} type - The type of event to listen to.\n     * @param {any} listener - The listener callback or object.\n     * @param {any} options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @param {K} type - The type of event the listener is bound to.\n     * @param {any} listener - The listener callback or object.\n     * @param {RemoveListenerOptions} options - The original listener options.\n     * This is required to deregister a capture phase listener.\n     */\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @param {FederatedEvent} e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\n/** @internal */\nexport const FederatedContainer: IFederatedContainer = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover:  null,\n    onmouseup:  null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown:  null,\n    onpointerenter: null,\n    onpointerleave:  null,\n    onpointermove:  null,\n    onglobalpointermove:  null,\n    onpointerout:  null,\n    onpointerover:  null,\n    onpointertap:  null,\n    onpointerup:  null,\n    onpointerupoutside:  null,\n    onrightclick:  null,\n    onrightdown:  null,\n    onrightup:  null,\n    onrightupoutside:  null,\n    ontap:  null,\n    ontouchcancel:  null,\n    ontouchend:  null,\n    ontouchendoutside:  null,\n    ontouchmove:  null,\n    onglobaltouchmove:  null,\n    ontouchstart:  null,\n    onwheel:  null,\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    _internalEventMode: undefined,\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n    interactiveChildren: true,\n    hitArea: null,\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n", "import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { EventSystem } from './EventSystem';\nimport { FederatedContainer } from './FederatedEventTarget';\n\nextensions.add(EventSystem);\nextensions.mixin(Container, FederatedContainer);\n", "/* eslint-disable no-restricted-globals */\nimport { ExtensionType } from '../extensions/Extensions';\nimport { CanvasObserver } from './CanvasObserver';\nimport { type DOMContainer } from './DOMContainer';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\n\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n * @internal\n */\nexport class DOMPipe implements RenderPipe<DOMContainer>\n{\n    /**\n     * Static property defining the extension type and name for the DOMPipe.\n     * This is used to register the DOMPipe with different rendering pipelines.\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'dom',\n    } as const;\n\n    private _renderer: Renderer;\n\n    /** Array to keep track of attached DOM elements */\n    private readonly _attachedDomElements: DOMContainer[] = [];\n    /** The main DOM element that acts as a container for other DOM elements */\n    private readonly _domElement: HTMLDivElement;\n    /** The CanvasTransformSync instance that keeps the DOM element in sync with the canvas */\n    private _canvasObserver: CanvasObserver;\n\n    /**\n     * Constructor for the DOMPipe class.\n     * @param renderer - The renderer instance that this DOMPipe will be associated with.\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        // Add this DOMPipe to the postrender runner of the renderer\n        // we want to dom elements are calculated after all things have been rendered\n        this._renderer.runners.postrender.add(this);\n\n        // add DOMPipe to init runners\n        this._renderer.runners.init.add(this);\n\n        // Create a main DOM element to contain other DOM elements\n        this._domElement = document.createElement('div');\n        this._domElement.style.position = 'absolute';\n        this._domElement.style.top = '0';\n        this._domElement.style.left = '0';\n        this._domElement.style.pointerEvents = 'none';\n        this._domElement.style.zIndex = '1000';\n    }\n\n    /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */\n    public init(): void\n    {\n        // Initialize the CanvasTransformSync to keep the DOM element in sync with the canvas\n        this._canvasObserver = new CanvasObserver({\n            domElement: this._domElement,\n            renderer: this._renderer,\n        });\n    }\n\n    /**\n     * Adds a renderable DOM container to the list of attached elements.\n     * @param domContainer - The DOM container to be added.\n     * @param _instructionSet - The instruction set (unused).\n     */\n    public addRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void\n    {\n        if (!this._attachedDomElements.includes(domContainer))\n        {\n            this._attachedDomElements.push(domContainer);\n        }\n    }\n\n    /**\n     * Updates a renderable DOM container.\n     * @param _domContainer - The DOM container to be updated (unused).\n     */\n    public updateRenderable(_domContainer: DOMContainer): void\n    {\n        // Updates happen in postrender\n    }\n\n    /**\n     * Validates a renderable DOM container.\n     * @param _domContainer - The DOM container to be validated (unused).\n     * @returns Always returns true as validation is not required.\n     */\n    public validateRenderable(_domContainer: DOMContainer): boolean\n    {\n        return true;\n    }\n\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n    public postrender(): void\n    {\n        const attachedDomElements = this._attachedDomElements;\n\n        if (attachedDomElements.length === 0)\n        {\n            this._domElement.remove();\n\n            return;\n        }\n\n        // Ensure the main DOM element is attached to the same parent as the canvas\n        this._canvasObserver.ensureAttached();\n\n        for (let i = 0; i < attachedDomElements.length; i++)\n        {\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 0b111)\n            {\n                element?.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            }\n            else\n            {\n                if (!this._domElement.contains(element))\n                {\n                    element.style.position = 'absolute';\n                    element.style.pointerEvents = 'auto';\n                    this._domElement.appendChild(element);\n                }\n\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n    public destroy(): void\n    {\n        this._renderer.runners.postrender.remove(this);\n\n        for (let i = 0; i < this._attachedDomElements.length; i++)\n        {\n            const domContainer = this._attachedDomElements[i];\n\n            domContainer.element?.remove();\n        }\n\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._canvasObserver.destroy();\n        this._renderer = null;\n    }\n}\n", "import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container, type ContainerOptions } from '../container/Container';\nimport { type IRenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/** @internal */\nexport interface GPUData\n{\n    destroy: () => void;\n}\n\n/**\n * Options for the construction of a ViewContainer.\n * @category scene\n * @advanced\n */\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions {}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ViewContainer<GPU_DATA extends GPUData = any> extends PixiMixins.ViewContainer, Container\n{\n    // eslint-disable-next-line requireMemberAPI/require-member-api-doc\n    _gpuData: Record<number, GPU_DATA>;\n}\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @category scene\n * @advanced\n */\nexport abstract class ViewContainer<GPU_DATA extends GPUData = any> extends Container implements View\n{\n    /** @internal */\n    public override readonly renderPipeId: string;\n    /** @internal */\n    public readonly canBundle = true;\n    /** @internal */\n    public override allowChildren = false;\n\n    /** @internal */\n    public _roundPixels: 0 | 1 = 0;\n    /** @internal */\n    public _lastUsed = -1;\n\n    /** @internal */\n    public _gpuData: Record<number, GPU_DATA> = Object.create(null);\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view in its own coordinate space.\n     * Bounds are automatically updated when the view's content changes.\n     * @example\n     * ```ts\n     * // Get bounds dimensions\n     * const bounds = view.bounds;\n     * console.log(`Width: ${bounds.maxX - bounds.minX}`);\n     * console.log(`Height: ${bounds.maxY - bounds.minY}`);\n     * ```\n     * @returns The rectangular bounds of the view\n     * @see {@link Bounds} For bounds operations\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @example\n     * ```ts\n     * // Enable pixel rounding for crisp rendering\n     * view.roundPixels = true;\n     * ```\n     * @default false\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(options: ViewContainerOptions)\n    {\n        super(options);\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the view's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = view.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the view's bounds\n     * @see {@link ViewContainer#bounds} For the bounds used in hit testing\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n\n        for (const key in this._gpuData)\n        {\n            (this._gpuData[key] as GPU_DATA).destroy?.();\n        }\n\n        this._gpuData = null;\n    }\n\n    /**\n     * Collects renderables for the view container.\n     * @param instructionSet - The instruction set to collect renderables for.\n     * @param renderer - The renderer to collect renderables for.\n     * @param currentLayer - The current render layer.\n     * @internal\n     */\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n        renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n}\n", "import { extensions } from '../extensions/Extensions';\nimport { DOMPipe } from './DOMPipe';\n\nexport * from './index';\n\nextensions.add(DOMPipe);\n", "import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /**\n     * @deprecated Use `id` instead.\n     */\n    name?: string;\n    /** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n    id: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n", "/* eslint-disable no-restricted-globals */\nimport { type Adapter } from '../environment/adapter';\nimport { type ImageLike } from '../environment/ImageLike';\n\n/**\n * This is an implementation of the {@link Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @category environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n * @advanced\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    createImage: (): ImageLike => new Image(),\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n", "import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\nimport { type ImageLike } from './ImageLike';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @category environment\n * @advanced\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns an IImage (HTMLImageElement) that can be used to create a texture. */\n    createImage: () => ImageLike;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link Adapter} interface to abstract away the differences between these environments\n * and uses the {@link BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @category environment\n * @advanced\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n", "import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param baseUrl - The base URL to use\n     * @param rootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param paths - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     * @example\n     * ```ts\n     * // Convert a Windows path to POSIX format\n     * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n     * // -> 'C:/Users/User/Documents/file.txt'\n     * ```\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a URL\n     * path.isUrl('http://www.example.com');\n     * // -> true\n     * path.isUrl('C:/Users/User/Documents/file.txt');\n     * // -> false\n     * ```\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a data URL\n     * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n     * // -> true\n     * ```\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a blob URL\n     * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n     * // -> true\n     * ```\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path has a protocol\n     * path.hasProtocol('http://www.example.com');\n     * // -> true\n     * path.hasProtocol('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     * @example\n     * ```ts\n     * // Get the protocol from a URL\n     * path.getProtocol('http://www.example.com/path/to/resource');\n     * // -> 'http://'\n     * // Get the protocol from a file path\n     * path.getProtocol('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     * @example\n     * ```ts\n     * // Convert a relative URL to an absolute path\n     * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n     * // -> 'http://example.com/assets/images/texture.png'\n     * ```\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     * @example\n     * ```ts\n     * // Normalize a path with relative segments\n     * path.normalize('http://www.example.com/foo/bar/../baz');\n     * // -> 'http://www.example.com/foo/baz'\n     * // Normalize a file path with relative segments\n     * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n     * // -> 'C:/Users/User/file.txt'\n     * ```\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     * @example\n     * ```ts\n     * // Check if a path is absolute\n     * path.isAbsolute('http://www.example.com/foo/bar');\n     * // -> true\n     * path.isAbsolute('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     * @example\n     * ```ts\n     * // Join multiple path segments\n     * path.join('assets', 'images', 'sprite.png');\n     * // -> 'assets/images/sprite.png'\n     * // Join with relative segments\n     * path.join('assets', 'images', '../textures', 'sprite.png');\n     * // -> 'assets/textures/sprite.png'\n     * ```\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the directory name of a path\n     * path.dirname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/foo/bar'\n     * // Get the directory name of a file path\n     * path.dirname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/Users/User/Documents'\n     * ```\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the root of a URL\n     * path.rootname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/'\n     * // Get the root of a file path\n     * path.rootname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     * @example\n     * ```ts\n     * // Get the basename of a URL\n     * path.basename('http://www.example.com/foo/bar/baz.png');\n     * // -> 'baz.png'\n     * // Get the basename of a file path\n     * path.basename('C:/Users/User/Documents/file.txt');\n     * // -> 'file.txt'\n     * ```\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the extension of a URL\n     * path.extname('http://www.example.com/foo/bar/baz.png');\n     * // -> '.png'\n     * // Get the extension of a file path\n     * path.extname('C:/Users/User/Documents/file.txt');\n     * // -> '.txt'\n     * ```\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Parse a URL\n     * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n     * // -> {\n     * //   root: 'http://www.example.com/',\n     * //   dir: 'http://www.example.com/foo/bar',\n     * //   base: 'baz.png',\n     * //   ext: '.png',\n     * //   name: 'baz'\n     * // }\n     * // Parse a file path\n     * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n     * // -> {\n     * //   root: 'C:/',\n     * //   dir: 'C:/Users/User/Documents',\n     * //   base: 'file.txt',\n     * //   ext: '.txt',\n     * //   name: 'file'\n     * // }\n     * ```\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n", "/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n", "function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n", "/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser: userDefinedLoadParser, parser: userDefinedParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        if (src.loadParser || src.parser)\n                        {\n                            userDefinedLoadParser = src.loadParser ?? userDefinedLoadParser;\n                            userDefinedParser = src.parser ?? userDefinedParser;\n                        }\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser: userDefinedLoadParser,\n                        parser: userDefinedParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        parser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, parser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.parser = parser ?? formattedAsset.parser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n", "/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n", "import { Rectangle } from '../maths/shapes/Rectangle';\nimport { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Options for loading a spritesheet from an atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData>\n{\n    /** Reference to Texture */\n    texture: BindableTexture;\n    /** JSON data for the atlas. */\n    data: S;\n    /** The filename to consider when determining the resolution of the spritesheet. */\n    resolutionFilename?: string;\n    /**\n     * Prefix to add to texture names when adding to global TextureCache,\n     * using this option can be helpful if you have multiple texture atlases\n     * that share texture names and you need to disambiguate them.\n     */\n    cachePrefix?: string;\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @category assets\n * @standard\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /**\n     * The maximum number of Textures to build per process.\n     * @advanced\n     */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /** Prefix string to add to global cache */\n    public readonly cachePrefix: string;\n\n    /**\n     * @class\n     * @param options - Options to use when constructing a new Spritesheet.\n     */\n    constructor(options: SpritesheetOptions<S>);\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S);\n\n    constructor(optionsOrTexture: SpritesheetOptions<S> | BindableTexture, arg1?: S)\n    {\n        let options = optionsOrTexture as SpritesheetOptions<S>;\n\n        if ((optionsOrTexture as BindableTexture)?.source instanceof TextureSource)\n        {\n            options = {\n                texture: optionsOrTexture as BindableTexture,\n                data: arg1,\n            };\n        }\n        const { texture, data, cachePrefix = '' } = options;\n\n        this.cachePrefix = cachePrefix;\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n", "import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { TextureSourceOptions } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { SpritesheetData } from './Spritesheet';\n\n/**\n * Interface for the JSON data structure of a spritesheet.\n * This is used to define the structure of the JSON file that describes a spritesheet.\n * It includes metadata about the spritesheet and the frames it contains.\n * @see {@link Spritesheet}\n * @see {@link SpritesheetData}\n * @category assets\n * @advanced\n */\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @category assets\n * @advanced\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        /** used for deprecation purposes */\n        name: 'spritesheetLoader',\n        id: 'spritesheet',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{\n                texture?: Texture,\n                imageFilename?: string,\n                ignoreMultiPack?: boolean,\n                textureOptions?: TextureSourceOptions,\n                cachePrefix?: string,\n            }>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)\n                textureOptions, // if user need to set texture options on texture\n                cachePrefix, // if user need to use custom cache prefix\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([{ src: imagePath, data: textureOptions }]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet({\n                texture: texture.source,\n                data: asset,\n                cachePrefix\n            });\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            textureOptions,\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n", "import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n", "import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n * @internal\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type BatchableSprite } from './BatchableSprite';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n * ```ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ```\n * @extends ViewContainerOptions\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions\n{\n    /**\n     * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n     * @default Texture.EMPTY\n     * @example\n     * ```ts\n     * // Create a sprite with a texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('path/to/image.png')\n     * });\n     * // Update the texture later\n     * sprite.texture = Texture.from('path/to/another-image.png');\n     * ```\n     */\n    texture?: Texture;\n\n    /**\n     * The anchor point of the sprite (0-1 range).\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @default 0\n     * @example\n     * ```ts\n     * // Centered anchor\n     * anchor: 0.5\n     * // Separate x/y anchor\n     * anchor: { x: 0.5, y: 0.5 }\n     * // Right-aligned anchor\n     * anchor: { x: 1, y: 0 }\n     * ```\n     */\n    anchor?: PointData | number;\n\n    /**\n     * Whether or not to round the x/y position to whole pixels.\n     * Useful for crisp pixel art style rendering.\n     * @default false\n     * @example\n     * ```ts\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png'),\n     *     roundPixels: true // Ensures crisp rendering\n     * });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n * ```ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link SpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class Sprite extends ViewContainer<BatchableSprite>\n{\n    /**\n     * Creates a new sprite based on a source texture, image, video, or canvas element.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create from path or URL\n     * const sprite = Sprite.from('assets/image.png');\n     *\n     * // Create from existing texture\n     * const sprite = Sprite.from(texture);\n     *\n     * // Create from canvas\n     * const canvas = document.createElement('canvas');\n     * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n     * or any valid texture source (canvas, video, etc.)\n     * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n     * @returns A new sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'sprite';\n\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public readonly _anchor: ObservablePoint;\n\n    /** @internal */\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture that is displayed by the sprite. When changed, automatically updates\n     * the sprite dimensions and manages texture event listeners.\n     * @example\n     * ```ts\n     * // Create sprite with texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png')\n     * });\n     *\n     * // Update texture\n     * sprite.texture = Texture.from('newSprite.png');\n     *\n     * // Use texture from spritesheet\n     * const sheet = await Assets.load('spritesheet.json');\n     * sprite.texture = sheet.textures['frame1.png'];\n     *\n     * // Reset to empty texture\n     * sprite.texture = Texture.EMPTY;\n     * ```\n     * @see {@link Texture} For texture creation and management\n     * @see {@link Assets} For asset loading\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking into account the texture's trim area.\n     * @example\n     * ```ts\n     * const texture = new Texture({\n     *     source: new TextureSource({ width: 300, height: 300 }),\n     *     frame: new Rectangle(196, 66, 58, 56),\n     *     trim: new Rectangle(4, 4, 58, 56),\n     *     orig: new Rectangle(0, 0, 64, 64),\n     *     rotate: 2,\n     * });\n     * const sprite = new Sprite(texture);\n     * const visualBounds = sprite.visualBounds;\n     * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * sprite.destroy();\n     * sprite.destroy(true);\n     * sprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n        this._gpuData = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * sprite.width = 200;\n     * console.log(sprite.scale.x); // Scale adjusted to match width\n     *\n     * // Set width while preserving aspect ratio\n     * const ratio = sprite.height / sprite.width;\n     * sprite.width = 300;\n     * sprite.height = 300 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.width = sprite.texture.orig.width;\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * sprite.height = 150;\n     * console.log(sprite.scale.y); // Scale adjusted to match height\n     *\n     * // Set height while preserving aspect ratio\n     * const ratio = sprite.width / sprite.height;\n     * sprite.height = 200;\n     * sprite.width = 200 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.height = sprite.texture.orig.height;\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Sprite#width} For getting just the width\n     * @see {@link Sprite#height} For getting just the height\n     * @see {@link Sprite#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * sprite.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * sprite.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * sprite.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     *\n     * // Reset to texture size\n     * sprite.setSize(\n     *     sprite.texture.orig.width,\n     *     sprite.texture.orig.height\n     * );\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Sprite#width} For setting width only\n     * @see {@link Sprite#height} For setting height only\n     * @see {@link Sprite#texture} For the source dimensions\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n", "import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n", "import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nfunction getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a CanvasSource.\n * @category rendering\n * @advanced\n */\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\n/**\n * A texture source that uses a canvas as its resource.\n * It automatically resizes the canvas based on the width, height, and resolution.\n * It also provides a 2D rendering context for drawing.\n * @category rendering\n * @advanced\n */\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n", "import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n", "/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\n\nimport type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @category utils\n * @internal\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = DOMAdapter.get().createCanvas(1, 1);\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n", "// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n", "import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/** @internal */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set<T = any>(key: any | any[], value: T): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /**\n     * All loader parsers registered\n     * @advanced\n     */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\nexport const Cache = new CacheClass();\n", "import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n", "import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n", "import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @category rendering\n * @advanced\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource?.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n", "import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\n/**\n * @param textures\n * @param size\n * @param maxTextures\n * @internal\n */\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number, maxTextures: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);\n}\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number, maxTextures: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n", "import { type TypedArray } from '../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @category utils\n * @advanced\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    /** View on the raw binary data as a `Uint16Array`. */\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n", "/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n", "/**\n * Various blend modes supported by Pixi\n * @category filters\n * @standard\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @category rendering\n * @advanced\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @category rendering\n * @advanced\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @category rendering\n * @advanced\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n", "import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n * @internal\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n", "import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\n/**\n * @param maxIfs\n * @param gl\n * @internal\n */\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n", "import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @deprecated Use `Renderer.limits.maxBatchableTextures` instead.\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n", "import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @category rendering\n * @advanced\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n", "import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../utils/pool/GlobalResourceRegistry';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\n/**\n * The action types for a batch.\n * @category rendering\n * @advanced\n */\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @category rendering\n * @advanced\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nGlobalResourceRegistry.register({\n    clear: () =>\n    {\n        // check if the first element has a destroy method\n        if (batchPool.length > 0)\n        {\n            for (const item of batchPool)\n            {\n                if (item) item.destroy();\n            }\n        }\n        batchPool.length = 0; // clear the array\n        batchPoolIndex = 0;\n    },\n});\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @category rendering\n * @advanced\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @category rendering\n * @advanced\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures: number;\n    /** The initial size of the attribute buffer. */\n    attributesInitialSize?: number;\n    /** The initial size of the index buffer. */\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @category rendering\n * @advanced\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions)\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        if (!options.maxTextures)\n        {\n            deprecation('v8.8.0', 'maxTextures is a required option for Batcher now, please pass it in the options');\n            options.maxTextures = getMaxTexturesPerBatch();\n        }\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        if (this.batches === null) return;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            if (this._elements[i]) this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n", "/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @category rendering\n * @advanced\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/**\n * All the various typed arrays that exist in js\n * @category rendering\n * @advanced\n */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/**\n * Options for creating a buffer\n *\n * This interface defines the options that can be passed to the Buffer constructor.\n * It includes the data to initialize the buffer with, the size of the buffer,\n * the usage of the buffer, a label for debugging, and whether the buffer should shrink to fit\n * when the data becomes smaller.\n * @category rendering\n * @advanced\n */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\n/** @internal */\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @category rendering\n * @advanced\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /** @internal */\n    public _updateID = 1;\n\n    /** @internal */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n", "import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @category rendering\n * @internal\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n", "import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n * @internal\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\n/**\n * The index buffer array type used in geometries.\n * @category rendering\n * @advanced\n */\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @category rendering\n * @advanced\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute option used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @category rendering\n * @advanced\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @category rendering\n * @advanced\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n", "import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\n/**\n * This class represents a geometry used for batching in the rendering system.\n * It defines the structure of vertex attributes and index buffers for batched rendering.\n * @category rendering\n * @advanced\n */\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n", "const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * @param value\n * @param groupId\n * @internal\n */\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n", "import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\n/** @internal */\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n", "/**\n * @param src\n * @param isES300\n * @param isFragment\n * @internal\n */\nexport function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n", "import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n", "/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n", "const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\n/**\n * @param src\n * @param root0\n * @param root0.name\n * @param isFragment\n * @internal\n */\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n", "/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\n/** @internal */\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\n/** @internal */\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @category rendering\n * @advanced\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     */\n    public readonly _key: number;\n    /**\n     * A cache key used to identify the program instance.\n     * @internal\n     */\n    public _cacheKey: string;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n", "import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\n/**\n * @param root0\n * @param root0.source\n * @param root0.entryPoint\n * @internal\n */\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n", "/**\n * Defines the structure of the extracted WGSL structs and groups.\n * @category rendering\n * @advanced\n */\nexport interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\n/**\n * @param wgsl\n * @internal\n */\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n", "/** @internal */\nexport enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n", "import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n", "import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n", "import type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param vertexStructsAndGroups\n * @param fragmentStructsAndGroups\n * @internal\n */\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @category rendering\n * @advanced\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @category rendering\n * @advanced\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @category rendering\n * @advanced\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @category rendering\n * @advanced\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @category rendering\n * @advanced\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /** @internal */\n    public _layoutKey = 0;\n    /** @internal */\n    public _cacheKey: string;\n\n    /** @internal */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n\n", "import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n * @internal\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n", "const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n * @internal\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n", "function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\n/**\n * @param fragments\n * @param template\n * @param sort\n * @internal\n */\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n", "function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\n/**\n * @param fragments\n * @param template\n * @internal\n */\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n", "/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n * @internal\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n", "import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/**\n * A high template consists of vertex and fragment source\n * @internal\n */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\n/** @internal */\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n * @internal\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * It is specifically for WebGL and does not compile inputs and outputs.\n * @param options\n * @param options.template - The HighShader template containing vertex and fragment source.\n * @param options.bits - An array of HighShaderBit objects to be compiled into the shader.\n * @returns A HighShaderSource object containing the compiled vertex and fragment shaders.\n * @internal\n */\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n", "/** @ignore */\nconst vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\n/** @ignore */\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\n/** @ignore */\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\n/** @ignore */\nconst fragmentGlTemplate = /* glsl */`\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n", "/** @internal */\nexport const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n", "import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n", "/** @internal */\nexport const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n/** @internal */\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n", "import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n", "/** @internal */\nexport const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n/** @internal */\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n", "// TODO add more types as required\n/** @internal */\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/**\n * useful for checking if a type is supported - a map of supported types with a true value.\n * @internal\n */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\n/** @internal */\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\n/** @internal */\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\n/** @internal */\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\n/**\n * This is the type of the uniform structures that are used in the UniformGroup.\n * @category rendering\n * @advanced\n */\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\n/** @internal */\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\n/** @internal */\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/** @internal */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n", "/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n/**\n * Extracts the value type from a uniform data object.\n * @internal\n */\nexport type ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @category rendering\n * @advanced\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```ts\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n * ```\n * @category rendering\n * @advanced\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public _resourceType = 'uniformGroup';\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                const arrayMatch = uniformData.type.match(/^array<(\\w+(?:<\\w+>)?),\\s*(\\d+)>$/);\n\n                if (arrayMatch)\n                {\n                    const [, innerType, size] = arrayMatch;\n\n                    throw new Error(\n                        `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`\n                    );\n                }\n\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n", "import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n * @internal\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n", "import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/**\n * A generic renderer that can be either a WebGL or WebGPU renderer.\n * @category rendering\n * @extends WebGLRenderer\n * @extends WebGPURenderer\n * @standard\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\n/**\n * Generic pipes for the renderer.\n * @category rendering\n * @advanced\n */\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * Options for the renderer.\n * @extends WebGLOptions\n * @extends WebGPUOptions\n * @category rendering\n * @standard\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n * @category rendering\n * @internal\n */\nexport enum RendererType\n{\n    /** The WebGL renderer */\n    WEBGL = 0b01,\n    /** The WebGPU renderer */\n    WEBGPU = 0b10,\n    /** Either WebGL or WebGPU renderer */\n    BOTH = 0b11\n}\n\n/**\n * The GPU power preference for the WebGPU context.\n * This is an optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n *\n * - `'high-performance'` will prioritize rendering performance over power consumption,\n * - `'low-power'` will prioritize power saving over rendering performance.\n * @category rendering\n * @advanced\n */\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @category rendering\n * @advanced\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\n/**\n * A descriptor for a shader with groups.\n * This is used to define a shader that uses {@link BindGroup}'s.\n * @category rendering\n * @advanced\n */\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @category rendering\n * @advanced\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @category rendering\n * @advanced\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @category rendering\n * @advanced\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\n/**\n * A shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\n/**\n * A descriptor for a shader with resources and groups.\n * @category rendering\n */\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\n/**\n * A descriptor for a shader with groups and resources.\n * @category rendering\n */\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @category rendering\n * @advanced\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** A unique identifier for the shader */\n    public readonly uid: number = uid('shader');\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param options - The options for the shader\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @category rendering\n * @advanced\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement, BatcherOptions } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @category rendering\n * @advanced\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader: DefaultShader;\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    constructor(options: BatcherOptions)\n    {\n        super(options);\n\n        defaultShader ??= new DefaultShader(options.maxTextures);\n\n        this.shader = defaultShader;\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.renderable && this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n\n    public destroy()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.geometryData = null;\n        this._batcher = null;\n        this._batch = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/** @internal */\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @internal\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[]): boolean\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            rx = ry = circle.radius;\n            if (rx <= 0)\n            {\n                return false;\n            }\n            x = circle.x;\n            y = circle.y;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            if (rx <= 0 || ry <= 0)\n            { // skip zero ellipse\n                return false;\n            }\n            x = ellipse.x;\n            y = ellipse.y;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (dx < 0 || dy < 0)\n        {\n            return false;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return false;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return true;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return true;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\n/** @internal */\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\n/** @internal */\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n", "/**\n * The line cap styles for strokes.\n *\n * It can be:\n * - `butt`: The ends of the stroke are squared off at the endpoints.\n * - `round`: The ends of the stroke are rounded.\n * @category scene\n * @standard\n */\nexport type LineCap = 'butt' | 'round' | 'square';\n/**\n * The line join styles for strokes.\n *\n * It can be:\n * - `round`: The corners of the stroke are rounded.\n * - `bevel`: The corners of the stroke are squared off.\n * - `miter`: The corners of the stroke are extended to meet at a point.\n * @category scene\n * @standard\n */\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\n/** @internal */\nexport const closePointEps = 1e-4;\n/** @internal */\nexport const curveEps = 0.0001;\n", "/**\n * @param points\n * @internal\n */\nexport function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n", "import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n", "\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n", "import earcutModule from 'earcut';\n\n/**\n * A high performance event emitter\n * @see {@link https://github.com/primus/eventemitter3}\n * @class EventEmitter\n * @category utils\n */\nexport { default as EventEmitter } from 'eventemitter3';\n\n/**\n * A polygon triangulation library\n * @see {@link https://github.com/mapbox/earcut}\n * @param {number[]} vertices - A flat array of vertex coordinates\n * @param {number[]} [holes] - An array of hole indices\n * @param {number} [dimensions=2] - The number of coordinates per vertex in the input array\n * @returns {number[]} Triangulated polygon\n * @category utils\n * @advanced\n */\nexport const earcut = ((earcutModule as any).default || earcutModule) as typeof earcutModule;\n", "import { earcut } from '../../../../utils/utils';\n\n/**\n * @param points\n * @param holes\n * @param vertices\n * @param verticesStride\n * @param verticesOffset\n * @param indices\n * @param indicesOffset\n * @internal\n */\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): boolean\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): boolean\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width > 0 && height > 0))\n        {\n            return false;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): boolean\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { type WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { definedProps } from '../../../container/utils/definedProps';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { CanvasAndContext } from '../../../../rendering/renderers/shared/texture/CanvasPool';\nimport type { TextureSpace } from '../FillTypes';\n\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n * @category scene\n * @standard\n */\nexport type GradientType = 'linear' | 'radial';\n\n/**\n * Represents the style options for a linear gradient fill.\n * @category scene\n * @standard\n */\nexport interface BaseGradientOptions\n{\n    /** The type of gradient */\n    type?: GradientType;\n    /** Array of colors stops to use in the gradient */\n    colorStops?: { offset: number, color: ColorSource }[];\n    /** Whether coordinates are 'global' or 'local' */\n    textureSpace?: TextureSpace;\n    /**\n     * The size of the texture to use for the gradient - this is for advanced usage.\n     * The texture size does not need to match the size of the object being drawn.\n     * Due to GPU interpolation, gradient textures can be relatively small!\n     * Consider using a larger texture size if your gradient has a lot of very tight color steps\n     */\n    textureSize?: number;\n    /**\n     * The wrap mode of the gradient.\n     * This can be 'clamp-to-edge' or 'repeat'.\n     * @default 'clamp-to-edge'\n     */\n    wrapMode?: WRAP_MODE\n}\n\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n * @category scene\n * @standard\n */\nexport interface LinearGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'linear' for linear gradients. */\n    type?: 'linear';\n\n    /**\n     * The start point of the gradient.\n     * This point defines where the gradient begins.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    start?: PointData;\n\n    /**\n     * The end point of the gradient.\n     * This point defines where the gradient ends.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    end?: PointData;\n}\n\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n * @category scene\n * @standard\n */\nexport interface RadialGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'radial' for radial gradients. */\n    type?: 'radial';\n    /** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n    center?: PointData;\n    /** The radius of the inner circle where the gradient begins. */\n    innerRadius?: number;\n    /** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n    outerCenter?: PointData;\n    /** The radius of the outer circle where the gradient ends. */\n    outerRadius?: number;\n    /**\n     * The y scale of the gradient, use this to make the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    scale?: number;\n    /**\n     * The rotation of the gradient in radians, useful for making the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    rotation?: number;\n}\n\n/**\n * Options for creating a gradient fill.\n * @category scene\n * @standard\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n\n/**\n * If no color stops are provided, we use a default gradient of white to black - this is to avoid a blank gradient if a dev\n * forgets to set them.\n */\nconst emptyColorStops: { offset: number, color: string }[] = [{ offset: 0, color: 'white' }, { offset: 1, color: 'black' }];\n\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * ```ts\n * // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n * ```\n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n * @category scene\n * @standard\n */\nexport class FillGradient implements CanvasGradient\n{\n    /** Default options for creating a gradient fill */\n    public static readonly defaultLinearOptions: LinearGradientOptions = {\n        start: { x: 0, y: 0 },\n        end: { x: 0, y: 1 },\n        colorStops: [],\n        textureSpace: 'local',\n        type: 'linear',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /** Default options for creating a radial gradient fill */\n    public static readonly defaultRadialOptions: RadialGradientOptions = {\n        center: { x: 0.5, y: 0.5 },\n        innerRadius: 0,\n        outerRadius: 0.5,\n        colorStops: [],\n        scale: 1,\n        textureSpace: 'local',\n        type: 'radial',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    public readonly uid: number = uid('fillGradient');\n    /**\n     * Internal tick counter to track changes in the gradient.\n     * This is used to invalidate the gradient when the texture changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** Type of gradient - currently only supports 'linear' */\n    public readonly type: GradientType = 'linear';\n\n    /** Internal texture used to render the gradient */\n    public texture: Texture;\n    /** Transform matrix for positioning the gradient */\n    public transform: Matrix;\n    /** Array of color stops defining the gradient */\n    public colorStops: Array<{ offset: number, color: string }> = [];\n\n    /** Whether gradient coordinates are in local or global space */\n    public textureSpace: TextureSpace;\n    private readonly _textureSize: number;\n\n    /** The start point of the linear gradient */\n    public start: PointData;\n    /** The end point of the linear gradient */\n    public end: PointData;\n    /** The wrap mode of the gradient texture */\n    private readonly _wrapMode: WRAP_MODE;\n\n    /** The center point of the inner circle of the radial gradient */\n    public center: PointData;\n    /** The center point of the outer circle of the radial gradient */\n    public outerCenter: PointData;\n    /** The radius of the inner circle of the radial gradient */\n    public innerRadius: number;\n    /** The radius of the outer circle of the radial gradient */\n    public outerRadius: number;\n    /** The scale of the radial gradient */\n    public scale: number;\n    /** The rotation of the radial gradient */\n    public rotation: number;\n\n    /**\n     * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n     * @param {GradientOptions} options - The options for the gradient\n     * @see {@link LinearGradientOptions}\n     * @see {@link RadialGradientOptions}\n     */\n    constructor(options: GradientOptions);\n    /**\n     * Deprecated: Use the options object instead.\n     * @deprecated since 8.5.2\n     * @ignore\n     */\n    constructor(\n        x0?: number,\n        y0?: number,\n        x1?: number,\n        y1?: number,\n        textureSpace?: TextureSpace,\n        textureSize?: number\n    );\n    constructor(...args: [GradientOptions] | [number?, number?, number?, number?, TextureSpace?, number?])\n    {\n        let options = ensureGradientOptions(args);\n\n        const defaults = options.type === 'radial' ? FillGradient.defaultRadialOptions : FillGradient.defaultLinearOptions;\n\n        options = { ...defaults, ...definedProps(options) };\n\n        this._textureSize = options.textureSize;\n        this._wrapMode = options.wrapMode;\n\n        if (options.type === 'radial')\n        {\n            this.center = options.center;\n            this.outerCenter = options.outerCenter ?? this.center;\n            this.innerRadius = options.innerRadius;\n            this.outerRadius = options.outerRadius;\n            this.scale = options.scale;\n            this.rotation = options.rotation;\n        }\n        else\n        {\n            this.start = options.start;\n            this.end = options.end;\n        }\n\n        this.textureSpace = options.textureSpace;\n\n        this.type = options.type;\n        options.colorStops.forEach((stop) =>\n        {\n            this.addColorStop(stop.offset, stop.color);\n        });\n    }\n\n    /**\n     * Adds a color stop to the gradient\n     * @param offset - Position of the stop (0-1)\n     * @param color - Color of the stop\n     * @returns This gradient instance for chaining\n     */\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n\n        return this;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        let { x: x0, y: y0 } = this.start;\n        let { x: x1, y: y1 } = this.end;\n\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n\n        // Determine flip based on original dx/dy and swap coordinates if necessary\n        const flip = dx < 0 || dy < 0;\n\n        if (this._wrapMode === 'clamp-to-edge')\n        {\n            if (dx < 0)\n            {\n                const temp = x0;\n\n                x0 = x1;\n                x1 = temp;\n                dx *= -1;\n            }\n            if (dy < 0)\n            {\n                const temp = y0;\n\n                y0 = y1;\n                y1 = temp;\n                dy *= -1;\n            }\n        }\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n\n        const { canvas, context } = getCanvas(defaultSize, 1);\n\n        const gradient = !flip\n            ? context.createLinearGradient(0, 0, this._textureSize, 0)\n            : context.createLinearGradient(this._textureSize, 0, 0, 0);\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, defaultSize, 1);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n        const angle = Math.atan2(dy, dx);\n\n        // little offset to stop the uvs from flowing over the edge..\n        // this matrix is inverted when used in the graphics\n        // add a tiny off set to prevent uv bleeding..\n        const m = new Matrix();\n\n        m.scale((dist / defaultSize), 1);\n        m.rotate(angle);\n        m.translate(x0, y0);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n        this.transform = m;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildGradient(): void\n    {\n        if (!this.texture) this._tick++;\n        if (this.type === 'linear')\n        {\n            this.buildLinearGradient();\n        }\n        else\n        {\n            this.buildRadialGradient();\n        }\n    }\n\n    /**\n     * Builds the internal texture and transform for the radial gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildRadialGradient(): void\n    {\n        if (this.texture) return;\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n        const { canvas, context } = getCanvas(defaultSize, defaultSize);\n\n        const { x: x0, y: y0 } = this.center;\n        const { x: x1, y: y1 } = this.outerCenter;\n\n        const r0 = this.innerRadius;\n        const r1 = this.outerRadius;\n\n        const ox = x1 - r1;\n        const oy = y1 - r1;\n\n        const scale = defaultSize / (r1 * 2);\n\n        const cx = (x0 - ox) * scale;\n        const cy = (y0 - oy) * scale;\n\n        const gradient = context.createRadialGradient(\n            cx,\n            cy,\n            r0 * scale,\n            (x1 - ox) * scale,\n            (y1 - oy) * scale,\n            r1 * scale\n        );\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = colorStops[colorStops.length - 1].color;\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        context.fillStyle = gradient;\n\n        // First translate to center\n        context.translate(cx, cy);\n\n        // Then apply rotation\n        context.rotate(this.rotation);\n\n        // Then scale2\n        context.scale(1, this.scale);\n\n        // Finally translate back, taking scale into account\n        context.translate(-cx, -cy);\n\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        const m = new Matrix();\n\n        // this matrix is inverted when used in the graphics\n        m.scale(1 / scale, 1 / scale);\n        m.translate(ox, oy);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n\n        this.transform = m;\n    }\n\n    /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture = null;\n        this.transform = null;\n        this.colorStops = [];\n        this.start = null;\n        this.end = null;\n        this.center = null;\n        this.outerCenter = null;\n    }\n\n    /**\n     * Returns a unique key for this gradient instance.\n     * This key is used for caching and texture management.\n     * @returns {string} Unique key for the gradient\n     */\n    public get styleKey(): string\n    {\n        return `fill-gradient-${this.uid}-${this._tick}`;\n    }\n}\n\nfunction addColorStops(gradient: CanvasGradient, colorStops: { offset: number, color: string }[]): void\n{\n    for (let i = 0; i < colorStops.length; i++)\n    {\n        const stop = colorStops[i];\n\n        gradient.addColorStop(stop.offset, stop.color);\n    }\n}\n\nfunction getCanvas(width: number, height: number): CanvasAndContext\n{\n    const canvas = DOMAdapter.get().createCanvas(width, height);\n    const context = canvas.getContext('2d');\n\n    return { canvas, context };\n}\n\n/**\n * Helper function to ensure consistent handling of gradient options.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureGradientOptions({\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 100 },\n *     textureSpace: 'local'\n * });\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureGradientOptions([0, 0, 100, 100, 'local']);\n * @param args - Arguments passed to gradient constructor\n * @returns Normalized gradient options object\n * @internal\n */\nfunction ensureGradientOptions(\n    args: any[],\n): GradientOptions\n{\n    let options = (args[0] ?? {}) as GradientOptions;\n\n    // @deprecated\n    if (typeof options === 'number' || args[1])\n    {\n        // #if _DEBUG\n        deprecation('8.5.2', `use options object instead`);\n        // #endif\n\n        options = {\n            type: 'linear',\n            start: { x: args[0], y: args[1] },\n            end: { x: args[2], y: args[3] },\n            textureSpace: args[4] as 'global' | 'local',\n            textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n        };\n    }\n\n    return options;\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    if (!build.build(rect, points))\n    {\n        return;\n    }\n\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const texture = data.image;\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const points: number[] = [];\n        const build = shapeBuilders[shape.type];\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        if (!build.build(shape, points))\n        {\n            return;\n        }\n\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        let topology: Topology = 'triangle-list';\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        if (holeBuilder.build(holePrimitive, holePoints))\n        {\n            holeArrays.push(holePoints);\n        }\n    }\n\n    return holeArrays;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: DefaultBatcher;\n    public instructions = new InstructionSet();\n\n    public init(maxTextures: number)\n    {\n        this.batcher = new DefaultBatcher({\n            maxTextures,\n        });\n\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n\n    public destroy()\n    {\n        this.batcher.destroy();\n        this.instructions.destroy();\n\n        this.batcher = null;\n        this.instructions = null;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @category rendering\n * @advanced\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @category rendering\n * @advanced\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuContextHash');\n        renderer.renderableGC.addManagedHash(this, '_graphicsDataContextHash');\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    /**\n     * Returns the render data for a given GraphicsContext.\n     * @param context - The GraphicsContext to get the render data for.\n     * @internal\n     */\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    /**\n     * Updates the GPU context for a given GraphicsContext.\n     * If the context is dirty, it will rebuild the batches and geometry data.\n     * @param context - The GraphicsContext to update.\n     * @returns The updated GpuGraphicsContext.\n     * @internal\n     */\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n            else\n            {\n                gpuContext.isBatchable = true;\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    /**\n     * Returns the GpuGraphicsContext for a given GraphicsContext.\n     * If it does not exist, it will initialize a new one.\n     * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n     * @returns The GpuGraphicsContext for the given GraphicsContext.\n     * @internal\n     */\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData, {\n            maxTextures: this._renderer.limits.maxBatchableTextures,\n        });\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                batch.textures.textures,\n                batch.textures.count,\n                this._renderer.limits.maxBatchableTextures\n            );\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n", "import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n", "/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n\n        this.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const meshData = this._getMeshData(mesh);\n\n        if (mesh.didViewUpdate)\n        {\n            meshData.indexSize = mesh._geometry.indices?.length;\n            meshData.vertexSize = mesh._geometry.positions?.length;\n        }\n\n        if (meshData.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: 0,\n            vertexSize: 0,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n", "import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n", "/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n", "import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n", "import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n", "var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n", "var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n", "var wgsl = \"\\nstruct ParticleUniforms {\\n  uTranslationMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uRound:f32,\\n  uResolution:vec2<f32>,\\n};\\n\\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\\n{\\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n   if(uniforms.uRound == 1.0) {\\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\\n   }\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        (this.renderer as null) = null;\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n", "import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n", "import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n", "import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n", "import { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public currentKey: string;\n\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        const text = this.renderable as Text;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    public destroy()\n    {\n        const { canvasText } = this._renderer;\n        const refCount = canvasText.getReferenceCount(this.currentKey);\n\n        if (refCount > 0)\n        {\n            canvasText.decreaseReferenceCount(this.currentKey);\n        }\n        else if (this.texture)\n        {\n            canvasText.returnTexture(this.texture);\n        }\n\n        this._renderer.runners.resolutionChange.remove(this);\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text.styleKey;\n\n        if (gpuText.currentKey !== newKey) return true;\n\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(text);\n            }\n            text._didTextUpdate = false;\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n        batchableText.currentKey = text.styleKey;\n\n        updateTextBounds(batchableText, text);\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText(this._renderer);\n\n        batchableText.currentKey = '--';\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n\n        return batchableText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n * @category scene\n * @standard\n */\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @category scene\n * @standard\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport class FillPattern implements CanvasPattern\n{\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    public readonly uid: number = uid('fillPattern');\n    /**\n     * Internal tick counter to track changes in the pattern.\n     * This is used to invalidate the pattern when the texture or transform changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** @internal */\n    public _texture: Texture;\n    /** The transform matrix applied to the pattern */\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    /**\n     * Sets the transform for the pattern\n     * @param transform - The transform matrix to apply to the pattern.\n     * If not provided, the pattern will use the default transform.\n     */\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._tick++;\n    }\n\n    /** Internal texture used to render the gradient */\n    public get texture()\n    {\n        return this._texture;\n    }\n    public set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        this._texture = value;\n        this._tick++;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `fill-pattern-${this.uid}-${this._tick}`;\n    }\n\n    /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture.destroy(true);\n        this.texture = null;\n    }\n}\n", "import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n/**\n * Parses an SVG path data string and builds a GraphicsPath object from the commands.\n * This function handles all standard SVG path commands including moves, lines, curves and arcs.\n * It maintains state for the current position and subpaths to properly handle relative commands\n * and path closures.\n *\n * Supported SVG commands:\n * - M/m: Move to absolute/relative\n * - L/l: Line to absolute/relative\n * - H/h: Horizontal line absolute/relative\n * - V/v: Vertical line absolute/relative\n * - C/c: Cubic bezier curve absolute/relative\n * - S/s: Smooth cubic bezier curve absolute/relative\n * - Q/q: Quadratic bezier curve absolute/relative\n * - T/t: Smooth quadratic bezier curve absolute/relative\n * - A/a: Arc absolute/relative\n * - Z/z: Close path\n * @param svgPath - The SVG path data string to parse (e.g. \"M0,0 L100,100\")\n * @param path - The GraphicsPath object to build the path into\n * @returns The input path object with the SVG commands applied\n * @internal\n */\nexport function parseSVGPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    // Parse the SVG path string into an array of commands\n    const commands = parse(svgPath);\n\n    // Track subpaths for proper path closure handling\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    // Track current position for relative commands\n    let lastX = 0;\n    let lastY = 0;\n\n    // Process each command in sequence\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0]; // The command letter\n        const data = command; // The command parameters, 1-based indexed\n\n        switch (type)\n        {\n            case 'M': // Move To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm': // Move To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H': // Horizontal Line To (absolute)\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h': // Horizontal Line To (relative)\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V': // Vertical Line To (absolute)\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v': // Vertical Line To (relative)\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L': // Line To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l': // Line To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C': // Cubic Bezier Curve (absolute)\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2], // First control point\n                    data[3], data[4], // Second control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'c': // Cubic Bezier Curve (relative)\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2], // First control point\n                    lastX + data[3], lastY + data[4], // Second control point\n                    lastX + data[5], lastY + data[6] // End point\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S': // Smooth Cubic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 's': // Smooth Cubic Bezier Curve (relative)\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4], // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q': // Quadratic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'q': // Quadratic Bezier Curve (relative)\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4] // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T': // Smooth Quadratic Bezier Curve (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 't': // Smooth Quadratic Bezier Curve (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 'A': // Arc (absolute)\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'a': // Arc (relative)\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'Z': // Close Path\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    // Return to the start of the current subpath\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        // Track subpath starts for path closure\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * ```ts\n * // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n * @see {@link Rectangle} For rectangular shapes\n * @category maths\n * @standard\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const circle = new Circle();\n     * circle.x = 100;\n     *\n     * // Center circle on point\n     * circle.x = point.x;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const circle = new Circle();\n     * circle.y = 200;\n     *\n     * // Center circle on point\n     * circle.y = point.y;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const circle = new Circle(100, 100);\n     * circle.radius = 50;\n     *\n     * // Calculate area\n     * const area = Math.PI * circle.radius * circle.radius;\n     * ```\n     * @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks.\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Circle(0, 0, 50);\n     * console.log(shape.type); // 'circle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'circle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @remarks\n     * - Used for shape type checking\n     * - More efficient than instanceof\n     * - Read-only property\n     * @readonly\n     * @default 'circle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     * @see {@link ShapePrimitive} For shape interface\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance.\n     * @example\n     * ```ts\n     * // Basic circle cloning\n     * const original = new Circle(100, 100, 50);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 75;\n     *\n     * // Verify independence\n     * console.log(original.radius); // 50\n     * console.log(modified.radius); // 75\n     * ```\n     * @returns A copy of the Circle\n     * @see {@link Circle.copyFrom} For copying into existing circle\n     * @see {@link Circle.copyTo} For copying to another circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle.\n     *\n     * Uses the distance formula to determine if a point is inside the circle's radius.\n     *\n     * Commonly used for hit testing in PixiJS events and graphics.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const circle = new Circle(100, 100, 50);\n     * const isInside = circle.contains(120, 120);\n     *\n     * // Check mouse position\n     * const circle = new Circle(0, 0, 100);\n     * container.hitArea = circle;\n     * container.on('pointermove', (e) => {\n     *     // only called if pointer is within circle\n     * });\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     * @see {@link Circle.strokeContains} For checking stroke intersection\n     * @see {@link Circle.getBounds} For getting bounding box\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const circle = new Circle(100, 100, 50);\n     * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle's stroke\n     * @see {@link Circle.contains} For checking fill containment\n     * @see {@link Circle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const circle = new Circle(100, 100, 50);\n     * const bounds = circle.getBounds();\n     * // bounds: x=50, y=50, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * circle.getBounds(rect);\n     * ```\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Circle.contains} For point containment\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * target.copyFrom(source);\n     * ```\n     * @param circle - The circle to copy from\n     * @returns Returns itself\n     * @see {@link Circle.copyTo} For copying to another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * source.copyTo(target);\n     * ```\n     * @param circle - The circle to copy to\n     * @returns Returns given parameter\n     * @see {@link Circle.copyFrom} For copying from another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * ```ts\n * // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @category maths\n * @standard\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic x position\n     * const ellipse = new Ellipse();\n     * ellipse.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic y position\n     * const ellipse = new Ellipse();\n     * ellipse.y = 200;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @example\n     * ```ts\n     * // Set half width\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfWidth = 50; // Total width will be 100\n     * ```\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @example\n     * ```ts\n     * // Set half height\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfHeight = 25; // Total height will be 50\n     * ```\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Ellipse(0, 0, 50, 25);\n     * console.log(shape.type); // 'ellipse'\n     *\n     * // Use in type guards\n     * if (shape.type === 'ellipse') {\n     *     console.log(shape.halfWidth, shape.halfHeight);\n     * }\n     * ```\n     * @readonly\n     * @default 'ellipse'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Ellipse(100, 100, 50, 25);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.halfWidth *= 2;\n     * modified.halfHeight *= 2;\n     *\n     * // Verify independence\n     * console.log(original.halfWidth);  // 50\n     * console.log(modified.halfWidth);  // 100\n     * ```\n     * @returns A copy of the ellipse\n     * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse.\n     * Uses normalized coordinates and the ellipse equation to determine containment.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isInside = ellipse.contains(120, 110);\n     * ```\n     * @remarks\n     * - Uses ellipse equation (x\u00B2/a\u00B2 + y\u00B2/b\u00B2 \u2264 1)\n     * - Returns false if dimensions are 0 or negative\n     * - Normalized to center (0,0) for calculation\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     * @see {@link Ellipse.strokeContains} For checking stroke intersection\n     * @see {@link Ellipse.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @remarks\n     * - Uses normalized ellipse equations\n     * - Considers stroke alignment\n     * - Returns false if dimensions are 0\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coords are within this ellipse's stroke\n     * @see {@link Ellipse.contains} For checking fill containment\n     * @see {@link Ellipse.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const bounds = ellipse.getBounds();\n     * // bounds: x=50, y=75, width=100, height=50\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * ellipse.getBounds(rect);\n     * ```\n     * @remarks\n     * - Creates Rectangle if none provided\n     * - Top-left is (x-halfWidth, y-halfHeight)\n     * - Width is halfWidth * 2\n     * - Height is halfHeight * 2\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Ellipse.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * target.copyFrom(source);\n     * ```\n     * @param ellipse - The ellipse to copy from\n     * @returns Returns itself\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * source.copyTo(target);\n     * ```\n     * @param ellipse - The ellipse to copy to\n     * @returns Returns given parameter\n     * @see {@link Ellipse.copyFrom} For copying from another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n", "/**\n * Calculates the squared distance from a point to a line segment defined by two endpoints.\n * @param x - x coordinate of the point\n * @param y - y coordinate of the point\n * @param x1 - x coordinate of the first endpoint of the line segment\n * @param y1 - y coordinate of the first endpoint of the line segment\n * @param x2 - x coordinate of the second endpoint of the line segment\n * @param y2 - y coordinate of the second endpoint of the line segment\n * @returns The squared distance from the point to the line segment\n * @category maths\n * @internal\n */\nexport function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n", "import { deprecation } from '../../utils/logging/deprecation';\nimport { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nlet tempRect: Rectangle;\nlet tempRect2: Rectangle;\n\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * ```ts\n * // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n * ```\n * @see {@link Point} For point objects used in construction\n * @category maths\n * @standard\n */\nexport class Polygon implements ShapePrimitive\n{\n    /**\n     * An array of the points of this polygon stored as a flat array of numbers.\n     * @example\n     * ```ts\n     * // Access points directly\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n     *\n     * // Modify points\n     * polygon.points[0] = 10; // Move first x coordinate\n     * polygon.points[1] = 10; // Move first y coordinate\n     * ```\n     * @remarks\n     * - Stored as [x1, y1, x2, y2, ...]\n     * - Each pair represents a vertex\n     * - Length is always even\n     * - Can be modified directly\n     */\n    public points: number[];\n\n    /**\n     * Indicates if the polygon path is closed.\n     * @example\n     * ```ts\n     * // Create open polygon\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * polygon.closePath = false;\n     *\n     * // Check path state\n     * if (polygon.closePath) {\n     *     // Last point connects to first\n     * }\n     * ```\n     * @remarks\n     * - True by default\n     * - False after moveTo\n     * - True after closePath\n     * @default true\n     */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(shape.type); // 'polygon'\n     *\n     * // Use in type guards\n     * if (shape.type === 'polygon') {\n     *     // TypeScript knows this is a Polygon\n     *     console.log(shape.points.length);\n     * }\n     * ```\n     * @readonly\n     * @default 'polygon'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Determines whether the polygon's points are arranged in a clockwise direction.\n     * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n     *\n     * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n     *\n     * The formula sums up the cross products of adjacent vertices:\n     * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n     * The final sum divided by 2 gives the signed area - positive for clockwise.\n     * @example\n     * ```ts\n     * // Check polygon winding\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.isClockwise()); // Check direction\n     *\n     * // Use in path construction\n     * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n     * if (hole.isClockwise() === shape.isClockwise()) {\n     *     hole.points.reverse(); // Reverse for proper hole winding\n     * }\n     * ```\n     * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n     */\n    public isClockwise(): boolean\n    {\n        let area = 0;\n        const points = this.points;\n        const length = points.length;\n\n        for (let i = 0; i < length; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % length];\n            const y2 = points[(i + 3) % length];\n\n            area += (x2 - x1) * (y2 + y1);\n        }\n\n        return area < 0;\n    }\n\n    /**\n     * Checks if this polygon completely contains another polygon.\n     * Used for detecting holes in shapes, like when parsing SVG paths.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n     * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n     *\n     * outerSquare.containsPolygon(innerSquare); // Returns true\n     * innerSquare.containsPolygon(outerSquare); // Returns false\n     * ```\n     * @remarks\n     * - Uses bounds check for quick rejection\n     * - Tests all points for containment\n     * @param polygon - The polygon to test for containment\n     * @returns True if this polygon completely contains the other polygon\n     * @see {@link Polygon.contains} For single point testing\n     * @see {@link Polygon.getBounds} For bounds calculation\n     */\n    public containsPolygon(polygon: Polygon): boolean\n    {\n    // Quick early-out: bounds check\n        const thisBounds = this.getBounds(tempRect);\n        const otherBounds = polygon.getBounds(tempRect2);\n\n        if (!thisBounds.containsRect(otherBounds))\n        {\n            return false; // If bounds aren't contained, the polygon cannot be a hole\n        }\n\n        // Full point containment check\n        const points = polygon.points;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            // Combine bounds and polygon checks for efficiency\n            if (!this.contains(x, y))\n            {\n                return false;\n            }\n        }\n\n        return true; // All points are contained within bounds and polygon\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.points[0] = 10; // Modify first x coordinate\n     * ```\n     * @returns A copy of the polygon\n     * @see {@link Polygon.copyFrom} For copying into existing polygon\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * Uses raycasting algorithm for point-in-polygon testing.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isInside = polygon.contains(25, 25); // true\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this polygon\n     * @see {@link Polygon.strokeContains} For checking stroke intersection\n     * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n     * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n     * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this polygon's stroke\n     * @see {@link Polygon.contains} For checking fill containment\n     * @see {@link Polygon.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const bounds = polygon.getBounds();\n     * // bounds: x=0, y=0, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * polygon.getBounds(rect);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Polygon.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * target.copyFrom(source);\n     * ```\n     * @param polygon - The polygon to copy from\n     * @returns Returns itself\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * source.copyTo(target);\n     * ```\n     * @param polygon - The polygon to copy to\n     * @returns Returns given parameter\n     * @see {@link Polygon.copyFrom} For copying from another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastX); // 300\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the last vertex\n     * @see {@link Polygon.lastY} For last Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastY); // 400\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the last vertex\n     * @see {@link Polygon.lastX} For last X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n     */\n    get x(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.lastX is deprecated, please use Polygon.lastX instead.');\n        // #endif\n\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n     */\n    get y(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.y is deprecated, please use Polygon.lastY instead.');\n        // #endif\n\n        return this.points[this.points.length - 1];\n    }\n    /**\n     * Get the first X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.x); // 0\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the first vertex\n     * @see {@link Polygon.startY} For first Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startX(): number\n    {\n        return this.points[0];\n    }\n\n    /**\n     * Get the first Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.y); // 0\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the first vertex\n     * @see {@link Polygon.startX} For first X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startY(): number\n    {\n        return this.points[1];\n    }\n}\n\n", "import { type SHAPE_PRIMITIVE } from '../misc/const';\nimport { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n * ```\n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n * @see {@link Rectangle} For non-rounded rectangles\n * @category maths\n * @standard\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new RoundedRectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new RoundedRectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new RoundedRectangle();\n     * rect.width = 200; // Total width will be 200\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new RoundedRectangle();\n     * rect.height = 150; // Total height will be 150\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const rect = new RoundedRectangle(0, 0, 200, 150);\n     * rect.radius = 20;\n     *\n     * // Clamp to maximum safe radius\n     * rect.radius = Math.min(rect.width, rect.height) / 2;\n     *\n     * // Create pill shape\n     * rect.radius = rect.height / 2;\n     * ```\n     * @remarks\n     * - Automatically clamped to half of smallest dimension\n     * - Common values: 0-20 for UI elements\n     * - Higher values create more rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n     * console.log(shape.type); // 'roundedRectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'roundedRectangle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @readonly\n     * @default 'roundedRectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const bounds = rect.getBounds();\n     * // bounds: x=100, y=100, width=200, height=150\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @remarks\n     * - Rectangle matches outer dimensions\n     * - Ignores corner radius\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link RoundedRectangle.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 30;\n     * modified.width *= 2;\n     *\n     * // Verify independence\n     * console.log(original.radius);  // 20\n     * console.log(modified.radius);  // 30\n     * ```\n     * @returns A copy of the rounded rectangle\n     * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new RoundedRectangle()\n     *     .copyFrom(source)\n     *     .getBounds(rect);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new RoundedRectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check corner radius\n     * const corner = rect.contains(100, 100); // false if within corner curve\n     * ```\n     * @remarks\n     * - Returns false if width/height is 0 or negative\n     * - Handles rounded corners with radius check\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rounded Rectangle\n     * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n     * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link RoundedRectangle.contains} For checking fill containment\n     * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param cp2x\n * @param cp2y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n", "// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n", "/**\n * @param points\n * @param x\n * @param y\n * @param radius\n * @param start\n * @param end\n * @param clockwise\n * @param steps\n * @internal\n */\nexport function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n", "import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n * @internal\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n", "import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\n/**\n * @param points\n * @param px\n * @param py\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param xAxisRotation\n * @param largeArcFlag\n * @param sweepFlag\n * @internal\n */\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n", "import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Data structure for points with optional radius.\n * @category scene\n * @standard\n */\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n", "// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { parseSVGPath } from '../svg/parseSVGPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n     * When true, any closed shape that is fully contained within another shape will become\n     * a hole in that shape during filling operations.\n     *\n     * This follows SVG's non-zero fill rule where:\n     * 1. Shapes are analyzed to find containment relationships\n     * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n     * 3. Multiple nested holes are supported\n     *\n     * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n     * When false, all shapes are filled independently without checking for holes.\n     */\n    public checkForHoles: boolean;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     * @param signed\n     */\n    constructor(instructions?: string | PathInstruction[], signed = false)\n    {\n        this.checkForHoles = signed;\n\n        if (typeof instructions === 'string')\n        {\n            parseSVGPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        newGraphicsPath2D.checkForHoles = this.checkForHoles;\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n", "/**\n * Parses a float value from an SVG element's attribute.\n * This is commonly used for parsing numeric attributes like coordinates, dimensions,\n * and other measurements from SVG elements.\n * @param svg - The SVG element to get the attribute from\n * @param id - The name of the attribute to parse (e.g. 'x', 'y', 'width', etc)\n * @param defaultValue - The value to return if the attribute doesn't exist or can't be parsed\n * @returns The parsed float value, or the default value if parsing fails\n * @example\n * // For SVG: <rect x=\"10.5\" width=\"20\"/>\n * parseSVGFloatAttribute(rectElement, 'x', 0) // Returns 10.5\n * parseSVGFloatAttribute(rectElement, 'y', 0) // Returns 0 since y is not specified\n * @internal\n */\nexport function parseSVGFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n", "import { Color } from '../../../../color/Color';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../fill/FillGradient';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\n\nimport type { Session } from './SVGParser';\n\n/**\n * Parses SVG gradient definitions and stores them in the session for later use.\n * Currently supports linear gradients and has placeholder support for radial gradients.\n * @param svg - The root SVG element to parse definitions from\n * @param session - The parsing session to store definitions in\n * @internal\n */\nexport function parseSVGDefinitions(svg: SVGElement, session: Session): void\n{\n    // Find all <defs> elements in the SVG\n    const definitions = svg.querySelectorAll('defs');\n\n    // Process each <defs> element\n    for (let i = 0; i < definitions.length; i++)\n    {\n        const definition = definitions[i];\n\n        // Process each child element in the <defs>\n        for (let j = 0; j < definition.children.length; j++)\n        {\n            const child = definition.children[j];\n\n            // Handle different types of gradient definitions\n            switch (child.nodeName.toLowerCase())\n            {\n                case 'lineargradient':\n                    // Store the parsed linear gradient in the session defs using the gradient's ID\n                    session.defs[child.id] = parseLinearGradient(child as SVGElement);\n                    break;\n                case 'radialgradient':\n                    session.defs[child.id] = parseRadialGradient(child as SVGElement);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * Parses an SVG linear gradient element into a FillGradient.\n * @param child - The SVG linear gradient element to parse\n * @returns A FillGradient configured based on the SVG element\n */\nfunction parseLinearGradient(child: SVGElement): FillGradient\n{\n    // Parse the gradient vector coordinates (defaults: horizontal line from 0 to 1)\n    const x0 = parseSVGFloatAttribute(child, 'x1', 0);\n    const y0 = parseSVGFloatAttribute(child, 'y1', 0);\n    const x1 = parseSVGFloatAttribute(child, 'x2', 1);\n    const y1 = parseSVGFloatAttribute(child, 'y2', 0);\n\n    // Get the gradient coordinate system\n    const gradientUnit = child.getAttribute('gradientUnits') || 'objectBoundingBox';\n\n    // Create gradient with coordinates and space mapping\n    const gradient = new FillGradient(\n        x0,\n        y0,\n        x1,\n        y1,\n        gradientUnit === 'objectBoundingBox' ? 'local' : 'global'\n    );\n\n    // Process each gradient stop\n    for (let k = 0; k < child.children.length; k++)\n    {\n        const stop = child.children[k] as SVGElement;\n\n        // Get stop position (0-1) and color\n        const offset = parseSVGFloatAttribute(stop, 'offset', 0);\n        const color = Color.shared.setValue(stop.getAttribute('stop-color')).toNumber();\n\n        gradient.addColorStop(offset, color);\n    }\n\n    return gradient;\n}\n\n/**\n * Placeholder function for parsing SVG radial gradients.\n * Currently returns a simple horizontal linear gradient and logs a warning.\n * @param _child - The SVG radial gradient element (currently unused)\n * @returns A default linear gradient\n */\nfunction parseRadialGradient(_child: SVGElement): FillGradient\n{\n    // #if _DEBUG\n    warn('[SVG Parser] Radial gradients are not yet supported');\n    // #endif\n\n    return new FillGradient(0, 0, 1, 0);\n}\n", "/**\n * Extracts the ID from an SVG url() reference.\n *\n * This function handles all valid SVG url() formats including:\n * - url(#id)\n * - url('#id')\n * - url(\"#id\")\n * - url( #id )\n * - url( '#id' )\n * - url( \"#id\" )\n *\n * The regex pattern matches:\n * - url followed by optional whitespace\n * - opening parenthesis followed by optional whitespace\n * - optional single or double quotes with optional whitespace\n * - # followed by the ID (any chars except quotes, whitespace, or closing paren)\n * - optional single or double quotes with optional whitespace\n * - closing parenthesis\n * @param url - The SVG url() string to parse\n * @returns The extracted ID string, or empty string if no valid ID found\n * @internal\n */\nexport function extractSvgUrlId(url: string): string\n{\n    // Handle all valid SVG url() formats\n    const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n\n    return match ? match[1] : '';\n}\n", "import { Color } from '../../../../color/Color';\nimport { extractSvgUrlId } from './utils/extractSvgUrlId';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type { Session } from './SVGParser';\n\n/**\n * A map of SVG style attributes and their default values.\n * Each attribute has a type and default value used for SVG parsing.\n * - 'paint' type can be a color or gradient\n * - 'number' type is a numeric value\n * - 'string' type is a text value\n * @category scene\n * @advanced\n */\nexport const styleAttributes = {\n    // Fill properties\n    fill: { type: 'paint', default: 0 }, // Fill color/gradient\n    'fill-opacity': { type: 'number', default: 1 }, // Fill transparency\n\n    // Stroke properties\n    stroke: { type: 'paint', default: 0 }, // Stroke color/gradient\n    'stroke-width': { type: 'number', default: 1 }, // Width of stroke\n    'stroke-opacity': { type: 'number', default: 1 }, // Stroke transparency\n    'stroke-linecap': { type: 'string', default: 'butt' }, // End cap style: butt, round, square\n    'stroke-linejoin': { type: 'string', default: 'miter' }, // Join style: miter, round, bevel\n    'stroke-miterlimit': { type: 'number', default: 10 }, // Limit on miter join sharpness\n    'stroke-dasharray': { type: 'string', default: 'none' }, // Dash pattern\n    'stroke-dashoffset': { type: 'number', default: 0 }, // Offset for dash pattern\n\n    // Global properties\n    opacity: { type: 'number', default: 1 }, // Overall opacity\n};\n\n/**\n * Represents the result of parsing SVG style attributes\n * @internal\n */\nexport type StyleResult = {\n    /** The stroke style properties */\n    strokeStyle: StrokeStyle;\n    /** The fill style properties */\n    fillStyle: FillStyle;\n    /** Whether fill should be applied */\n    useFill: boolean;\n    /** Whether stroke should be applied */\n    useStroke: boolean;\n};\n\n/**\n * Parses SVG style attributes and inline styles to determine fill and stroke properties.\n * Handles both direct attributes and CSS-style declarations in the style attribute.\n * @param svg - The SVG element to parse styles from\n * @param session - The current SVG parsing session containing definitions\n * @returns An object containing the parsed fill and stroke styles\n * @internal\n */\nexport function parseSVGStyle(svg: SVGElement, session: Session): StyleResult\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    const result: StyleResult = {\n        strokeStyle,\n        fillStyle,\n        useFill: false,\n        useStroke: false,\n    };\n\n    // First parse direct style attributes\n    for (const key in styleAttributes)\n    {\n        const attribute = svg.getAttribute(key);\n\n        if (attribute)\n        {\n            parseAttribute(session, result, key, attribute.trim());\n        }\n    }\n\n    // Then parse inline styles which override direct attributes\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i].trim();\n\n            const [key, value] = stylePart.split(':');\n\n            if (styleAttributes[key as keyof typeof styleAttributes])\n            {\n                parseAttribute(session, result, key, value.trim());\n            }\n        }\n    }\n\n    return {\n        strokeStyle: result.useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: result.useFill ? (fillStyle as ConvertedFillStyle) : null,\n        useFill: result.useFill,\n        useStroke: result.useStroke,\n    };\n}\n\n/**\n * Parses a single SVG style attribute and updates the style result accordingly.\n * Handles color values, gradients, opacities and other style properties.\n * @param session - The current SVG parsing session containing definitions\n * @param result - The style result object to update\n * @param id - The attribute name/id to parse\n * @param value - The attribute value to parse\n */\nfunction parseAttribute(\n    session: Session,\n    result: StyleResult,\n    id: string,\n    value: string\n): void\n{\n    switch (id)\n    {\n        case 'stroke':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.strokeStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.strokeStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useStroke = true;\n            }\n\n            break;\n        case 'stroke-width':\n            result.strokeStyle.width = Number(value);\n            break;\n        case 'fill':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.fillStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.fillStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useFill = true;\n            }\n            break;\n        case 'fill-opacity':\n            result.fillStyle.alpha = Number(value);\n            break;\n        case 'stroke-opacity':\n            result.strokeStyle.alpha = Number(value);\n            break;\n        case 'opacity':\n            // Global opacity affects both fill and stroke\n            result.fillStyle.alpha = Number(value);\n            result.strokeStyle.alpha = Number(value);\n            break;\n    }\n}\n", "import type {\n    FillInstruction,\n    GraphicsContext,\n} from '../../GraphicsContext';\n\n/**\n * Determines if subpaths represent nested shapes or multiple holes pattern.\n * @param subpathsWithArea - Array of subpaths with their calculated areas\n * @returns True if nested pattern, false if multiple holes pattern\n * @internal\n */\nexport function checkForNestedPattern(subpathsWithArea: Array<{path: string, area: number}>): boolean\n{\n    if (subpathsWithArea.length <= 2)\n    {\n        return true;\n    }\n\n    const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);\n\n    const [largestArea, secondArea] = areas;\n    const smallestArea = areas[areas.length - 1];\n\n    const largestToSecondRatio = largestArea / secondArea;\n    const secondToSmallestRatio = secondArea / smallestArea;\n\n    // If the largest shape is significantly bigger than the second (3x+)\n    // AND the smaller shapes are similar in size (2x or less difference),\n    // it suggests multiple holes pattern rather than nested shapes\n    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2)\n    {\n        return false; // Multiple holes\n    }\n\n    return true; // Default to nested\n}\n\n/**\n * Gets fill instruction data from a graphics context.\n * @param context - The graphics context\n * @param index - Index of the fill instruction (default: 0)\n * @returns The fill instruction data\n * @throws Error if instruction at index is not a fill instruction\n * @internal\n */\nexport function getFillInstructionData(context: GraphicsContext, index: number = 0)\n{\n    const instruction = context.instructions[index];\n\n    if (!instruction || instruction.action !== 'fill')\n    {\n        throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || 'undefined'}`);\n    }\n\n    return (instruction as FillInstruction).data;\n}\n", "import { GraphicsPath } from '../../path/GraphicsPath';\n\n/**\n * Extracts individual subpaths from SVG path data by splitting on Move commands.\n * @param pathData - The SVG path data string\n * @returns Array of subpath strings\n * @internal\n */\nexport function extractSubpaths(pathData: string): string[]\n{\n    // Split on Move commands (M or m) to get individual subpaths\n    const parts = pathData.split(/(?=[Mm])/);\n    const subpaths = parts.filter((part) => part.trim().length > 0);\n\n    return subpaths;\n}\n\n/**\n * Calculates the area of a path using bounding box estimation.\n * @param pathData - The SVG path data string\n * @returns The estimated area of the path\n * @internal\n */\nexport function calculatePathArea(pathData: string): number\n{\n    const coords = pathData.match(/[-+]?[0-9]*\\.?[0-9]+/g);\n\n    if (!coords || coords.length < 4) return 0;\n\n    const numbers = coords.map(Number);\n    const xs = [];\n    const ys = [];\n\n    for (let i = 0; i < numbers.length; i += 2)\n    {\n        if (i + 1 < numbers.length)\n        {\n            xs.push(numbers[i]);\n            ys.push(numbers[i + 1]);\n        }\n    }\n\n    if (xs.length === 0 || ys.length === 0) return 0;\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    const area = (maxX - minX) * (maxY - minY);\n\n    return area;\n}\n\n/**\n * Parses SVG path data and appends instructions to a GraphicsPath.\n * @param pathData - The SVG path data string\n * @param graphicsPath - The GraphicsPath to append instructions to\n * @internal\n */\nexport function appendSVGPath(pathData: string, graphicsPath: GraphicsPath): void\n{\n    const tempPath = new GraphicsPath(pathData, false);\n\n    for (const instruction of tempPath.instructions)\n    {\n        graphicsPath.instructions.push(instruction);\n    }\n}\n", "import { warn } from '../../../../utils/logging/warn';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { parseSVGDefinitions } from './parseSVGDefinitions';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\nimport { parseSVGStyle } from './parseSVGStyle';\nimport { checkForNestedPattern } from './utils/fillOperations';\nimport { appendSVGPath, calculatePathArea, extractSubpaths } from './utils/pathOperations';\n\nimport type { FillGradient } from '../fill/FillGradient';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\n/**\n * Represents a session for SVG parsing. Contains the current state and resources needed during parsing.\n * @internal\n */\nexport interface Session\n{\n    /** The graphics context to render to */\n    context: GraphicsContext;\n    /** The current path being constructed */\n    path: GraphicsPath;\n    /** Map of definitions by id */\n    defs: Record<string, FillGradient>;\n}\n\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n * @internal\n */\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    // Convert string input to SVG element\n    if (typeof svg === 'string')\n    {\n        // eslint-disable-next-line no-restricted-globals\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    // Initialize parsing session\n    const session = {\n        context: graphicsContext,\n        defs: {},\n        path: new GraphicsPath(),\n    };\n\n    // Parse definitions (gradients, etc) first\n    parseSVGDefinitions(svg, session);\n\n    // Process all child elements except defs\n    const children = svg.children;\n\n    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i] as SVGElement;\n\n        if (child.nodeName.toLowerCase() === 'defs') continue;\n        renderChildren(child, session, fillStyle, strokeStyle);\n    }\n\n    return graphicsContext;\n}\n\n/**\n * Recursively renders SVG elements and their children.\n * Handles styling inheritance and different SVG shape types.\n * @param svg - The SVG element to render\n * @param session - The current parsing session\n * @param fillStyle - The inherited fill style\n * @param strokeStyle - The inherited stroke style\n */\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    // Parse element's style and merge with inherited styles\n    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    const noStyle = !fillStyle && !strokeStyle;\n\n    // Default to black fill if no styles specified\n    if (noStyle)\n    {\n        fillStyle = { color: 0 };\n    }\n\n    // Variables for shape attributes\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    // Handle different SVG element types\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n        {\n            d = svg.getAttribute('d') as string;\n\n            const fillRule = svg.getAttribute('fill-rule') as string;\n\n            const subpaths = extractSubpaths(d);\n            const hasExplicitEvenodd = fillRule === 'evenodd';\n            const hasMultipleSubpaths = subpaths.length > 1;\n\n            const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;\n\n            if (shouldProcessHoles)\n            {\n                const subpathsWithArea = subpaths.map((subpath) => ({\n                    path: subpath,\n                    area: calculatePathArea(subpath)\n                }));\n\n                subpathsWithArea.sort((a, b) => b.area - a.area);\n\n                // For complex cases, prefer multiple holes approach\n                const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);\n\n                if (useMultipleHolesApproach)\n                {\n                    // Multiple holes approach: first (largest) is fill, rest are holes\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isMainShape = i === 0;\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isMainShape)\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                        else\n                        {\n                            session.context.cut();\n                        }\n                    }\n                }\n                else\n                {\n                    // Nested holes approach: alternate between fill and cut\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isHole = i % 2 === 1; // Odd indices are holes\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isHole)\n                        {\n                            session.context.cut();\n                        }\n                        else\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                const useEvenoddForGraphicsPath = fillRule ? (fillRule === 'evenodd') : true;\n\n                graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);\n                session.context.path(graphicsPath);\n                if (fillStyle) session.context.fill(fillStyle);\n                if (strokeStyle) session.context.stroke(strokeStyle);\n            }\n            break;\n        }\n\n        case 'circle':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            r = parseSVGFloatAttribute(svg, 'r', 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'rect':\n            x = parseSVGFloatAttribute(svg, 'x', 0);\n            y = parseSVGFloatAttribute(svg, 'y', 0);\n            width = parseSVGFloatAttribute(svg, 'width', 0);\n            height = parseSVGFloatAttribute(svg, 'height', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'ellipse':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'line':\n            x1 = parseSVGFloatAttribute(svg, 'x1', 0);\n            y1 = parseSVGFloatAttribute(svg, 'y1', 0);\n            x2 = parseSVGFloatAttribute(svg, 'x2', 0);\n            y2 = parseSVGFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        // Group elements - just process children\n        case 'g':\n        case 'svg':\n            break;\n\n        default: {\n            // Log unsupported elements\n            warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    if (noStyle)\n    {\n        fillStyle = null;\n    }\n\n    // Recursively process child elements\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\nfunction isTexture(value: unknown): value is Texture\n{\n    return value instanceof Texture;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a Texture\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new Texture(0xff0000))\n */\nfunction handleTexture(fill: FillStyle, value: Texture, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    fill.texture = value;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    fill.textureSpace = value.textureSpace;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isTexture(value))\n    {\n        return handleTexture(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n", "/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\n/**\n * The mode for batching graphics instructions.\n *\n * It can be:\n * - 'auto': Automatically determines whether to batch based on the number of instructions.\n * - 'batch': Forces batching of all instructions.\n * - 'no-batch': Disables batching, processing each instruction individually.\n * @category scene\n * @advanced\n */\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\n/** @internal */\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @category scene\n * @standard\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    public readonly uid: number = uid('graphicsContext');\n    /**\n     * Indicates whether content is updated and have to be re-rendered.\n     * @internal\n     */\n    public dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    public batchMode: BatchMode = 'auto';\n    /** @internal */\n    public instructions: GraphicsInstructions[] = [];\n    /**\n     * Custom shader to apply to the graphics when rendering.\n     * @advanced\n     */\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n     * If only a texture is provided, it uses the texture's width and height for drawing.\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        // Every time the content is updated - we must invalidate bounds, regardless rendering `dirty` state.\n        // Bounds can be read multiple times per frame.\n        this._boundsDirty = true;\n\n        // Visual updates happen only once per frame.\n        // There is no need to dispatch an `update` in if it was already dispatched this frame.\n        if (this.dirty) return;\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * context.destroy();\n     * context.destroy(true);\n     * context.destroy({ texture: true, textureSource: true });\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.fill && 'uid' in this._fillStyle.fill\n                    ? this._fillStyle.fill.destroy()\n                    : this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.fill && 'uid' in this._strokeStyle.fill\n                    ? this._strokeStyle.fill.destroy()\n                    : this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { type Filter } from '../../filters/Filter';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * ```ts\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * ```ts\n * // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * ```ts\n * // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN font-style}\n * @category text\n * @standard\n */\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * ```ts\n * // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant | MDN font-variant}\n * @category text\n * @standard\n */\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * ```ts\n * // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN font-weight}\n * @category text\n * @standard\n */\nexport type TextStyleFontWeight =\n    | 'normal' // Standard weight (400)\n    | 'bold' // Bold weight (700)\n    | 'bolder' // Relative weight increase\n    | 'lighter' // Relative weight decrease\n    | '100' // Thin\n    | '200' // Extra Light\n    | '300' // Light\n    | '400' // Normal\n    | '500' // Medium\n    | '600' // Semi Bold\n    | '700' // Bold\n    | '800' // Extra Bold\n    | '900'; // Heavy\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * ```ts\n * // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n * ```\n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin | MDN lineJoin}\n * @category text\n * @standard\n */\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n * @category text\n * @standard\n */\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * ```ts\n * // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space | MDN white-space}\n * @see {@link TextStyle#wordWrap} For controlling text wrapping\n * @category text\n * @standard\n */\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * ```ts\n * // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n * ```\n * @category text\n * @standard\n */\nexport type TextDropShadow = {\n    /**\n     * The opacity of the drop shadow.\n     * - Range: 0 to 1\n     * - 0 = fully transparent\n     * - 1 = fully opaque\n     * @example\n     * ```ts\n     * // Set drop shadow opacity to 50%\n     * dropShadow: {\n     *    alpha: 0.5\n     * }\n     * ```\n     * @default 1\n     */\n    alpha: number;\n\n    /**\n     * The angle of the drop shadow in radians.\n     * - 0 = right\n     * - Math.PI/2 = down\n     * - Math.PI = left\n     * - Math.PI*1.5 = up\n     * @example\n     * ```ts\n     * // Set drop shadow angle to 30 degrees\n     * dropShadow: {\n     *    angle: Math.PI / 6 // 30 degrees\n     * }\n     * ```\n     * @default Math.PI/6 (30 degrees)\n     */\n    angle: number;\n\n    /**\n     * The blur radius of the shadow.\n     * - 0 = sharp shadow\n     * - Higher values = softer shadow\n     * @example\n     * ```ts\n     * // Set drop shadow blur radius to 10 pixels\n     * dropShadow: {\n     *   blur: 10\n     * }\n     * ```\n     * @default 0\n     */\n    blur: number;\n\n    /**\n     * The color of the drop shadow.\n     * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n     * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n     * @default 'black'\n     */\n    color: ColorSource;\n\n    /**\n     * The distance of the drop shadow from the text.\n     * Measured in pixels.\n     * @example\n     * ```ts\n     * // Set drop shadow distance to 5 pixels\n     * dropShadow: {\n     *   distance: 5\n     * }\n     * ```\n     * @default 5\n     */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * ```ts\n * // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n * ```\n * @see {@link TextStyle} For the main style class\n * @category text\n * @standard\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @default 'left'\n     */\n    align?: TextStyleAlign;\n    /**\n     * Whether to allow line breaks within words.\n     * Requires wordWrap to be true.\n     * @example\n     * ```ts\n     * // Enable word breaking\n     * const style = new TextStyle({\n     *    breakWords: true,\n     *    wordWrap: true,\n     *    wordWrapWidth: 200\n     * });\n     * ```\n     * @default false\n     */\n    breakWords?: boolean;\n    /**\n     * Drop shadow configuration for the text.\n     * Can be boolean or a TextDropShadow object.\n     * @default null\n     */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * Fill style for the text.\n     * Can be a color, gradient, or pattern.\n     * @default 'black'\n     */\n    fill?: FillInput;\n    /**\n     * Font family or families to use.\n     * Can be single name or array of fallbacks.\n     * @example\n     * ```ts\n     * // Single font family\n     * fontFamily: 'Arial'\n     * // Multiple font families\n     * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n     * ```\n     * @default 'Arial'\n     */\n    fontFamily?: string | string[];\n    /**\n     * Font size in pixels or as string.\n     *\n     * Equivalents are '26px','20pt','160%' or '1.6em')\n     * @example\n     * ```ts\n     * // Numeric size\n     * fontSize: 26\n     * // String size\n     * fontSize: '26px'\n     * // Percentage size\n     * fontSize: '160%' // 1.6 times the parent element's font size\n     * // Em size\n     * fontSize: '1.6em' // 1.6 times the parent element's font size\n     * @default 26\n     */\n    fontSize?: number | string;\n    /**\n     * Font style (normal, italic, oblique).\n     * @default 'normal'\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * Font variant (normal, small-caps).\n     * @default 'normal'\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * Font weight (normal, bold, bolder, lighter, 100-900).\n     * @default 'normal'\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Padding around the text.\n     *\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /**\n     * Stroke style for text outline.\n     * @default null\n     */\n    stroke?: StrokeInput;\n    /**\n     * Vertical alignment baseline.\n     * @default 'alphabetic'\n     */\n    textBaseline?: TextStyleTextBaseline;\n    /**\n     * Whether to trim transparent edges.\n     * > [!NOTE] This is an expensive operation and should only be used when necessary.\n     * @default false\n     */\n    trim?: boolean;\n    /**\n     * How to handle whitespace.\n     *\n     * It needs wordWrap to be set to true for this to have an effect.\n     * @default 'pre'\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n    /**\n     * Array of filters to apply to the text.\n     *\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default undefined\n     */\n    filters?: Filter[] | readonly Filter[];\n}\n\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n * ```ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ```\n *\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n * @category text\n * @standard\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /**\n     * Default drop shadow settings used when enabling drop shadows on text.\n     * These values are used as the base configuration when drop shadows are enabled without specific settings.\n     * @example\n     * ```ts\n     * // Customize default settings globally\n     * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n     * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n     * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n     * ```\n     */\n    public static defaultDropShadow: TextDropShadow = {\n        alpha: 1,\n        angle: Math.PI / 6,\n        blur: 0,\n        color: 'black',\n        distance: 5,\n    };\n\n    /**\n     * Unique identifier for the TextStyle class.\n     * This is used to track instances and ensure uniqueness.\n     * @internal\n     */\n    public uid = uid('textStyle');\n    /**\n     * Internal tick counter used to track updates and changes.\n     * This is incremented whenever the style is modified, allowing for efficient change detection.\n     * @internal\n     */\n    public _tick = 0;\n\n    /**\n     * Default text style settings used when creating new text objects.\n     * These values serve as the base configuration and can be customized globally.\n     * @example\n     * ```ts\n     * // Customize default text style globally\n     * TextStyle.defaultTextStyle.fontSize = 16;\n     * TextStyle.defaultTextStyle.fill = 0x333333;\n     * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n     * ```\n     */\n    public static defaultTextStyle: TextStyleOptions = {\n        align: 'left',\n        breakWords: false,\n        dropShadow:  null,\n        fill: 'black',\n        fontFamily: 'Arial',\n        fontSize: 26,\n        fontStyle: 'normal',\n        fontVariant: 'normal',\n        fontWeight: 'normal',\n        leading: 0,\n        letterSpacing: 0,\n        lineHeight: 0,\n        padding: 0,\n        stroke: null,\n        textBaseline: 'alphabetic',\n        trim: false,\n        whiteSpace: 'pre',\n        wordWrap: false,\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    /** @internal */\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    /** @internal */\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n    private _filters: readonly Filter[];\n\n    private _padding: number;\n\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n        this._tick = 0;\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n    /**\n     * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default null\n     */\n    get filters(): readonly Filter[] { return this._filters; }\n    set filters(value: Filter[]) { this._filters = Object.freeze(value); this.update(); }\n\n    /**\n     * Trim transparent borders from the text texture.\n     * > [!IMPORTANT] PERFORMANCE WARNING:\n     * > This is a costly operation as it requires scanning pixel alpha values.\n     * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n     */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /**\n     * The fill style that will be used to color the text.\n     * This can be:\n     * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n     * - A hex number like 0xff0000 for red\n     * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n     * - A FillGradient for gradient fills\n     * - A FillPattern for pattern/texture fills\n     *\n     * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n     * while gradients at any other angle are spread across the entire text body as a whole.\n     * @example\n     * // Vertical gradient applied per line\n     * const verticalGradient = new FillGradient(0, 0, 0, 1)\n     *     .addColorStop(0, 0xff0000)\n     *     .addColorStop(1, 0x0000ff);\n     *\n     * const text = new Text({\n     *     text: 'Line 1\\nLine 2',\n     *     style: { fill: verticalGradient }\n     * });\n     *\n     * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n     * @type {string|number|FillStyle|FillGradient|FillPattern}\n     */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    public update()\n    {\n        this._tick++;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this.uid}-${this._tick}`;\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            filters: this._filters ? [...this._filters] : undefined,\n        });\n    }\n\n    /**\n     * Returns the final padding for the text style, taking into account any filters applied.\n     * Used internally for correct measurements\n     * @internal\n     * @returns {number} The final padding for the text style.\n     */\n    public _getFinalPadding(): number\n    {\n        let filterPadding = 0;\n\n        if (this._filters)\n        {\n            for (let i = 0; i < this._filters.length; i++)\n            {\n                filterPadding += this._filters[i].padding;\n            }\n        }\n\n        return Math.max(this._padding, filterPadding);\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroy the text style and its textures\n     * textStyle.destroy({ texture: true, textureSource: true });\n     * textStyle.destroy(true);\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0)\n        {\n            throw new Error('Invalid fill value. Expected an array of colors for gradient fill.');\n        }\n\n        if (oldStyle.fill.length !== oldStyle.fillGradientStops.length)\n        {\n            // #if _DEBUG\n            warn('The number of fill colors must match the number of fill gradient stops.');\n            // #endif\n        }\n\n        const gradientFill = new FillGradient({\n            start: { x: 0, y: 0 },\n            end: { x: 0, y: 1 },\n            textureSpace: 'local',\n        });\n\n        const fillGradientStops = oldStyle.fillGradientStops.slice();\n        const fills: number[] = oldStyle.fill\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fillGradientStops.forEach((stop, index) =>\n        {\n            gradientFill.addColorStop(stop, fills[index]);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n", "import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\n/**\n * A utility type that represents a canvas and its rendering context.\n * @category rendering\n * @internal\n */\nexport interface CanvasAndContext\n{\n    /** The canvas element. */\n    canvas: ICanvas;\n    /** The rendering context of the canvas. */\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.resetTransform();\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport const CanvasPool = new CanvasPoolClass();\nGlobalResourceRegistry.register(CanvasPool);\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { nextPow2 } from '../../maths/misc/pow2';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\n\n// Internal canvas for measuring bounds\nlet _internalCanvas: ICanvas | null = null;\nlet _internalContext: ICanvasRenderingContext2D | null = null;\n\nfunction ensureInternalCanvas(width: number, height: number): void\n{\n    if (!_internalCanvas)\n    {\n        _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n        _internalContext = _internalCanvas.getContext('2d', { willReadFrequently: true });\n        _internalContext.globalCompositeOperation = 'copy';\n        _internalContext.globalAlpha = 1;\n    }\n\n    if (_internalCanvas.width < width || _internalCanvas.height < height)\n    {\n        // Use power-of-two dimensions for better performance\n        _internalCanvas.width = nextPow2(width);\n        _internalCanvas.height = nextPow2(height);\n    }\n}\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions\n{\n    /** The canvas to measure */\n    canvas: ICanvas;\n    /** Optional. The width to analyze (defaults to canvas.width) */\n    width?: number;\n    /** Optional. The height to analyze (defaults to canvas.height) */\n    height?: number;\n    /**\n     * Optional. The resolution at which to analyze the canvas, between 0-1.\n     * Lower values improve performance for large canvases but may be less precise.\n     * Default is 1 (full resolution).\n     */\n    resolution?: number;\n    /** Optional. The rectangle to store the result in. */\n    output?: Rectangle;\n}\n\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(\n    options: GetCanvasBoundingBoxOptions,\n): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * @param {...any} args\n * @internal\n */\nexport function getCanvasBoundingBox(...args: [GetCanvasBoundingBoxOptions] | [ICanvas, number?]): Rectangle\n{\n    let options = args[0] as GetCanvasBoundingBoxOptions;\n\n    if (!options.canvas)\n    {\n        options = { canvas: args[0] as ICanvas, resolution: args[1] };\n    }\n\n    const { canvas } = options; // canvas is correctly extracted from options\n\n    // Cap resolution at 1\n    const resolution = Math.min(options.resolution ?? 1, 1);\n    const width = options.width ?? canvas.width;\n    const height = options.height ?? canvas.height;\n    let output = options.output;\n\n    // Ensure internal canvas is large enough\n    ensureInternalCanvas(width, height);\n\n    if (!_internalContext)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    // Set up for pixel replacement (no blending)\n    _internalContext.drawImage(\n        canvas as unknown as CanvasImageSource,\n        0, 0,\n        width, height,\n        0, 0,\n        width * resolution, height * resolution\n    );\n\n    // Get the image data at full resolution\n    const imageData = _internalContext.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    _internalContext.globalCompositeOperation = 'source-over';\n    // draw the rect on the canvas\n    _internalContext.strokeRect(left, top, right - left, bottom - top);\n    _internalContext.globalCompositeOperation = 'copy';\n\n    output ??= new Rectangle();\n\n    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n\n    return output;\n}\n\n", "/**\n * tiny-lru\n *\n * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>\n * @license BSD-3-Clause\n * @version 11.4.5\n */\n/**\n * A high-performance Least Recently Used (LRU) cache implementation with optional TTL support.\n * Items are automatically evicted when the cache reaches its maximum size,\n * removing the least recently used items first. All core operations (get, set, delete) are O(1).\n *\n * @class LRU\n * @example\n * // Create a cache with max 100 items\n * const cache = new LRU(100);\n * cache.set('key1', 'value1');\n * console.log(cache.get('key1')); // 'value1'\n *\n * @example\n * // Create a cache with TTL\n * const cache = new LRU(100, 5000); // 5 second TTL\n * cache.set('key1', 'value1');\n * // After 5 seconds, key1 will be expired\n */\nclass LRU {\n\t/**\n\t * Creates a new LRU cache instance.\n\t * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.\n\t *\n\t * @constructor\n\t * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.\n\t * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.\n\t * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n\t * @example\n\t * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access\n\t * @see {@link lru} For parameter validation\n\t * @since 1.0.0\n\t */\n\tconstructor (max = 0, ttl = 0, resetTtl = false) {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.max = max;\n\t\tthis.resetTtl = resetTtl;\n\t\tthis.size = 0;\n\t\tthis.ttl = ttl;\n\t}\n\n\t/**\n\t * Removes all items from the cache.\n\t *\n\t * @method clear\n\t * @memberof LRU\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.clear();\n\t * console.log(cache.size); // 0\n\t * @since 1.0.0\n\t */\n\tclear () {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.size = 0;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes an item from the cache by key.\n\t *\n\t * @method delete\n\t * @memberof LRU\n\t * @param {string} key - The key of the item to delete.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * cache.delete('key1');\n\t * console.log(cache.has('key1')); // false\n\t * @see {@link LRU#has}\n\t * @see {@link LRU#clear}\n\t * @since 1.0.0\n\t */\n\tdelete (key) {\n\t\tif (this.has(key)) {\n\t\t\tconst item = this.items[key];\n\n\t\t\tdelete this.items[key];\n\t\t\tthis.size--;\n\n\t\t\tif (item.prev !== null) {\n\t\t\t\titem.prev.next = item.next;\n\t\t\t}\n\n\t\t\tif (item.next !== null) {\n\t\t\t\titem.next.prev = item.prev;\n\t\t\t}\n\n\t\t\tif (this.first === item) {\n\t\t\t\tthis.first = item.next;\n\t\t\t}\n\n\t\t\tif (this.last === item) {\n\t\t\t\tthis.last = item.prev;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of [key, value] pairs for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method entries\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.\n\t * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.entries()); // [['a', 1], ['b', 2]]\n\t * console.log(cache.entries(['a'])); // [['a', 1]]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#values}\n\t * @since 11.1.0\n\t */\n\tentries (keys = this.keys()) {\n\t\treturn keys.map(key => [key, this.get(key)]);\n\t}\n\n\t/**\n\t * Removes the least recently used item from the cache.\n\t *\n\t * @method evict\n\t * @memberof LRU\n\t * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('old', 'value').set('new', 'value');\n\t * cache.evict(); // Removes 'old' item\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tevict (bypass = false) {\n\t\tif (bypass || this.size > 0) {\n\t\t\tconst item = this.first;\n\n\t\t\tdelete this.items[item.key];\n\n\t\t\tif (--this.size === 0) {\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t} else {\n\t\t\t\tthis.first = item.next;\n\t\t\t\tthis.first.prev = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the expiration timestamp for a given key.\n\t *\n\t * @method expiresAt\n\t * @memberof LRU\n\t * @param {string} key - The key to check expiration for.\n\t * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.\n\t * @example\n\t * const cache = new LRU(100, 5000); // 5 second TTL\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\texpiresAt (key) {\n\t\tlet result;\n\n\t\tif (this.has(key)) {\n\t\t\tresult = this.items[key].expiry;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves a value from the cache by key. Updates the item's position to most recently used.\n\t *\n\t * @method get\n\t * @memberof LRU\n\t * @param {string} key - The key to retrieve.\n\t * @returns {*} The value associated with the key, or undefined if not found or expired.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.get('key1')); // 'value1'\n\t * console.log(cache.get('nonexistent')); // undefined\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\tget (key) {\n\t\tconst item = this.items[key];\n\n\t\tif (item !== undefined) {\n\t\t\t// Check TTL only if enabled to avoid unnecessary Date.now() calls\n\t\t\tif (this.ttl > 0) {\n\t\t\t\tif (item.expiry <= Date.now()) {\n\t\t\t\t\tthis.delete(key);\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fast LRU update without full set() overhead\n\t\t\tthis.moveToEnd(item);\n\n\t\t\treturn item.value;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t *\n\t * @method has\n\t * @memberof LRU\n\t * @param {string} key - The key to check for.\n\t * @returns {boolean} True if the key exists, false otherwise.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.has('key1')); // true\n\t * console.log(cache.has('nonexistent')); // false\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#delete}\n\t * @since 9.0.0\n\t */\n\thas (key) {\n\t\treturn key in this.items;\n\t}\n\n\t/**\n\t * Efficiently moves an item to the end of the LRU list (most recently used position).\n\t * This is an internal optimization method that avoids the overhead of the full set() operation\n\t * when only LRU position needs to be updated.\n\t *\n\t * @method moveToEnd\n\t * @memberof LRU\n\t * @param {Object} item - The cache item with prev/next pointers to reposition.\n\t * @private\n\t * @since 11.3.5\n\t */\n\tmoveToEnd (item) {\n\t\t// If already at the end, nothing to do\n\t\tif (this.last === item) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove item from current position in the list\n\t\tif (item.prev !== null) {\n\t\t\titem.prev.next = item.next;\n\t\t}\n\n\t\tif (item.next !== null) {\n\t\t\titem.next.prev = item.prev;\n\t\t}\n\n\t\t// Update first pointer if this was the first item\n\t\tif (this.first === item) {\n\t\t\tthis.first = item.next;\n\t\t}\n\n\t\t// Add item to the end\n\t\titem.prev = this.last;\n\t\titem.next = null;\n\n\t\tif (this.last !== null) {\n\t\t\tthis.last.next = item;\n\t\t}\n\n\t\tthis.last = item;\n\n\t\t// Handle edge case: if this was the only item, it's also first\n\t\tif (this.first === null) {\n\t\t\tthis.first = item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of all keys in the cache, ordered from least to most recently used.\n\t *\n\t * @method keys\n\t * @memberof LRU\n\t * @returns {string[]} Array of keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * cache.get('a'); // Move 'a' to most recent\n\t * console.log(cache.keys()); // ['b', 'a']\n\t * @see {@link LRU#values}\n\t * @see {@link LRU#entries}\n\t * @since 9.0.0\n\t */\n\tkeys () {\n\t\tconst result = [];\n\t\tlet x = this.first;\n\n\t\twhile (x !== null) {\n\t\t\tresult.push(x.key);\n\t\t\tx = x.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a value in the cache and returns any evicted item.\n\t *\n\t * @method setWithEvicted\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.\n\t * @example\n\t * const cache = new LRU(2);\n\t * cache.set('a', 1).set('b', 2);\n\t * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#evict}\n\t * @since 11.3.0\n\t */\n\tsetWithEvicted (key, value, resetTtl = this.resetTtl) {\n\t\tlet evicted = null;\n\n\t\tif (this.has(key)) {\n\t\t\tthis.set(key, value, true, resetTtl);\n\t\t} else {\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tevicted = {...this.first};\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\tlet item = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn evicted;\n\t}\n\n\t/**\n\t * Sets a value in the cache. Updates the item's position to most recently used.\n\t *\n\t * @method set\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1')\n\t *      .set('key2', 'value2')\n\t *      .set('key3', 'value3');\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tset (key, value, bypass = false, resetTtl = this.resetTtl) {\n\t\tlet item = this.items[key];\n\n\t\tif (bypass || item !== undefined) {\n\t\t\t// Existing item: update value and position\n\t\t\titem.value = value;\n\n\t\t\tif (bypass === false && resetTtl) {\n\t\t\t\titem.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;\n\t\t\t}\n\n\t\t\t// Always move to end, but the bypass parameter affects TTL reset behavior\n\t\t\tthis.moveToEnd(item);\n\t\t} else {\n\t\t\t// New item: check for eviction and create\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\titem = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of all values in the cache for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method values\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.\n\t * @returns {Array<*>} Array of values corresponding to the keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.values()); // [1, 2]\n\t * console.log(cache.values(['a'])); // [1]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#entries}\n\t * @since 11.1.0\n\t */\n\tvalues (keys = this.keys()) {\n\t\treturn keys.map(key => this.get(key));\n\t}\n}\n\n/**\n * Factory function to create a new LRU cache instance with parameter validation.\n *\n * @function lru\n * @param {number} [max=1000] - Maximum number of items to store. Must be >= 0. Use 0 for unlimited size.\n * @param {number} [ttl=0] - Time to live in milliseconds. Must be >= 0. Use 0 for no expiration.\n * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n * @returns {LRU} A new LRU cache instance.\n * @throws {TypeError} When parameters are invalid (negative numbers or wrong types).\n * @example\n * // Create cache with factory function\n * const cache = lru(100, 5000, true);\n * cache.set('key', 'value');\n *\n * @example\n * // Error handling\n * try {\n *   const cache = lru(-1); // Invalid max\n * } catch (error) {\n *   console.error(error.message); // \"Invalid max value\"\n * }\n * @see {@link LRU}\n * @since 1.0.0\n */\nfunction lru (max = 1000, ttl = 0, resetTtl = false) {\n\tif (isNaN(max) || max < 0) {\n\t\tthrow new TypeError(\"Invalid max value\");\n\t}\n\n\tif (isNaN(ttl) || ttl < 0) {\n\t\tthrow new TypeError(\"Invalid ttl value\");\n\t}\n\n\tif (typeof resetTtl !== \"boolean\") {\n\t\tthrow new TypeError(\"Invalid resetTtl value\");\n\t}\n\n\treturn new LRU(max, ttl, resetTtl);\n}export{LRU,lru};", "import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n * @internal\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n", "import { lru } from 'tiny-lru';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        /**\n         * Creates a new Intl.Segmenter object.\n         * @returns A new Intl.Segmenter object.\n         */\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @category text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n * @advanced\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @category text\n * @advanced\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|\u00C9q\u00C5';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) =>\n            {\n                const segments = segmenter.segment(s);\n                const result = [];\n\n                let i = 0;\n\n                for (const segment of segments)\n                {\n                    result[i++] = (segment.segment);\n                }\n\n                return result;\n            };\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result === undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@link TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    /** Cache for measured text metrics */\n    private static readonly _measurementCache = lru<CanvasTextMetrics>(1000);\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;\n\n        // check if we have already measured this text with the same style\n        if (CanvasTextMetrics._measurementCache.has(textKey))\n        {\n            return CanvasTextMetrics._measurementCache.get(textKey);\n        }\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // cache the measurements\n        CanvasTextMetrics._measurementCache.set(textKey, measurements);\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                // treat \\r\\n as a single new line token\n                if (char === '\\r' && nextChar === '\\n')\n                {\n                    tokens.push('\\r\\n');\n                    i++;\n                }\n                else\n                {\n                    tokens.push(char);\n                }\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\nimport type { CanvasTextMetrics } from '../CanvasTextMetrics';\n\n// 5 decimal places\nconst PRECISION = 100000;\n\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n * @internal\n */\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D,\n    textMetrics?: CanvasTextMetrics,\n    padding = 0\n): string | CanvasGradient | CanvasPattern\n{\n    // Solid color fill\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    // Basic texture fill\n    else if (!fillStyle.fill)\n    {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Pattern fill\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Gradient fill\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        const isLinear = fillGradient.type === 'linear';\n        const isLocal = fillGradient.textureSpace === 'local';\n\n        let width = 1;\n        let height = 1;\n\n        // Use text dimensions if in local space\n        if (isLocal && textMetrics)\n        {\n            width = textMetrics.width + padding;\n            height = textMetrics.height + padding;\n        }\n\n        let gradient: CanvasGradient;\n        let isNearlyVertical = false;\n\n        if (isLinear)\n        {\n            const { start, end } = fillGradient;\n\n            gradient = context.createLinearGradient(\n                start.x * width,\n                start.y * height,\n                end.x * width,\n                end.y * height\n            );\n\n            // Check if gradient is nearly vertical (10% threshold)\n            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n        }\n        else\n        {\n            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n\n            gradient = context.createRadialGradient(\n                center.x * width,\n                center.y * height,\n                innerRadius * width,\n                outerCenter.x * width,\n                outerCenter.y * height,\n                outerRadius * width\n            );\n        }\n\n        // For vertical gradients in local space, repeat gradient per text line\n        if (isNearlyVertical && isLocal && textMetrics)\n        {\n            const ratio = (textMetrics.lineHeight) / height;\n\n            for (let i = 0; i < textMetrics.lines.length; i++)\n            {\n                const start = ((i * textMetrics.lineHeight) + (padding / 2)) / height;\n\n                fillGradient.colorStops.forEach((stop) =>\n                {\n                    // Convert to global space\n                    const globalStop = start + (stop.offset * ratio);\n\n                    gradient.addColorStop(\n                        // fix to 5 decimal places to avoid floating point precision issues\n                        Math.floor(globalStop * PRECISION) / PRECISION,\n                        Color.shared.setValue(stop.color).toHex()\n                    );\n                });\n            }\n        }\n        else\n        {\n            // Standard global space gradient handling\n            fillGradient.colorStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n        }\n\n        return gradient;\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n", "import { Color } from '../../../color/Color';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\nimport { type CanvasAndContext, CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { type TextStyle } from '../TextStyle';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\n/**\n * Temporary rectangle for getting the bounding box of the text.\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Utility for generating and managing canvas-based text rendering.\n *\n * This class is responsible for rendering text to canvas elements based on provided styles,\n * measuring the resulting text dimensions, and managing the lifecycle of canvas resources.\n *\n * CanvasTextGenerator supports:\n * - Text rendering with various styles (fill, stroke, gradient, etc.)\n * - Drop shadows and letter spacing\n * - Automatic trimming of transparent pixels\n * - Canvas resource pooling\n *\n * As a singleton, it's accessed via the exported `CanvasTextGenerator` constant.\n * @example\n * ```typescript\n * // Basic usage - render text to a canvas\n * import { CanvasTextGenerator } from 'pixi.js';\n * import { TextStyle } from 'pixi.js';\n *\n * // Create a text style\n * const style = new TextStyle({\n *   fontFamily: 'Arial',\n *   fontSize: 24,\n *   fill: 0xff1010,\n *   align: 'center',\n * });\n *\n * // Get a canvas with the text rendered to it\n * const { canvasAndContext, frame } = CanvasTextGenerator.getCanvasAndContext({\n *   text: 'Hello Pixi!',\n *   style,\n *   resolution: 1\n * });\n *\n * @internal\n */\nclass CanvasTextGeneratorClass\n{\n    /**\n     * Creates a canvas with the specified text rendered to it.\n     *\n     * Generates a canvas of appropriate size, renders the text with the provided style,\n     * and returns both the canvas/context and a Rectangle representing the text bounds.\n     *\n     * When trim is enabled in the style, the frame will represent the bounds of the\n     * non-transparent pixels, which can be smaller than the full canvas.\n     * @param options - The options for generating the text canvas\n     * @param options.text - The text to render\n     * @param options.style - The style to apply to the text\n     * @param options.resolution - The resolution of the canvas (defaults to 1)\n     * @param options.padding\n     * @returns An object containing the canvas/context and the frame (bounds) of the text\n     */\n    public getCanvasAndContext(options: {text: string, style: TextStyle, resolution?: number, padding?: number})\n    {\n        const { text, style, resolution = 1 } = options;\n\n        const padding = (style as TextStyle)._getFinalPadding();\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n\n        const frame = style.trim\n            ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect })\n            : tempRect.set(0, 0, width, height);\n\n        return {\n            canvasAndContext,\n            frame\n        };\n    }\n\n    /**\n     * Returns a canvas and context to the pool.\n     *\n     * This should be called when you're done with the canvas to allow reuse\n     * and prevent memory leaks.\n     * @param canvasAndContext - The canvas and context to return to the pool\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @param text - The text to render\n     * @param style - The style of the text\n     * @param padding - The padding of the text\n     * @param resolution - The resolution of the text\n     * @param canvasAndContext - The canvas and context to render the text to\n     */\n    private _renderTextToCanvas(\n        text: string,\n        style: TextStyle,\n        padding: number,\n        resolution: number,\n        canvasAndContext: CanvasAndContext\n    ): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokePadding = (style._stroke.width * 0.5) + (padding * 2);\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     *\n     * This method handles rendering text with the correct letter spacing, using either:\n     * 1. Native letter spacing if supported by the browser\n     * 2. Manual letter spacing calculation if not natively supported\n     *\n     * For manual letter spacing, it calculates the position of each character\n     * based on its width and the desired spacing.\n     * @param text - The text to draw\n     * @param style - The text style to apply\n     * @param canvasAndContext - The canvas and context to draw to\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Whether to render the stroke (true) or fill (false)\n     * @private\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n}\n\n/** @internal */\nexport const CanvasTextGenerator = new CanvasTextGeneratorClass();\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions, type Text } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n\n            // We initially increased the frame size by a resolution factor\n            // to achieve a crisper display. Now we need to scale down the already\n            // trimmed frame to render the texture in the expected size.\n            texture.frame.scale(1 / resolution);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters as Filter[]);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n     * @param text - The Text object that needs a texture\n     * @returns A Texture instance that represents the rendered text\n     * @remarks\n     * This method performs the following:\n     * 1. Sets the appropriate resolution based on auto-resolution settings\n     * 2. Checks if a texture already exists for the text's style\n     * 3. Creates a new texture if needed or returns an existing one\n     * 4. Manages reference counting for texture reuse\n     */\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const texture = this.getTexture({\n            text: text.text,\n            style: text.style,\n            resolution: text._resolution,\n            textureStyle: text.textureStyle,\n        });\n\n        this._activeTextures[textKey] = {\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    /**\n     * Decreases the reference count for a texture associated with a text key.\n     * When the reference count reaches zero, the texture is returned to the pool.\n     * @param textKey - The unique key identifying the text style configuration\n     * @remarks\n     * This method is crucial for memory management, ensuring textures are properly\n     * cleaned up when they are no longer needed by any Text instances.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            this.returnTexture(activeTexture.texture);\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? 0;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        // Clean up active textures\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\nimport { type GraphicsGpuData } from './GraphicsPipe';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions\n{\n    /**\n     * The GraphicsContext to use, useful for reuse and optimisation\n     * If not provided, a new GraphicsContext will be created.\n     * @example\n     * ```ts\n     * const sharedContext = new GraphicsContext();\n     * const graphics1 = new Graphics({ context: sharedContext });\n     * const graphics2 = new Graphics({ context: sharedContext });\n     * ```\n     */\n    context?: GraphicsContext;\n    /**\n     * Whether or not to round the x/y position.\n     * @default false\n     * @example\n     * ```ts\n     * const graphics = new Graphics({ roundPixels: true });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'graphics';\n    /** @internal */\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * Creates a new Graphics object.\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.didViewUpdate = true;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The underlying graphics context used for drawing operations.\n     * Controls how shapes and paths are rendered.\n     * @example\n     * ```ts\n     * // Create a shared context\n     * const sharedContext = new GraphicsContext();\n     *\n     * // Create graphics objects sharing the same context\n     * const graphics1 = new Graphics();\n     * const graphics2 = new Graphics();\n     *\n     * // Assign shared context\n     * graphics1.context = sharedContext;\n     * graphics2.context = sharedContext;\n     *\n     * // Both graphics will show the same shapes\n     * sharedContext\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @see {@link GraphicsContext} For drawing operations\n     * @see {@link GraphicsOptions} For context configuration\n     */\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphics object.\n     * Returns the boundaries after all graphical operations but before any transforms.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Get bounds information\n     * const bounds = graphics.bounds;\n     * console.log(bounds.width);  // 100\n     * console.log(bounds.height); // 100\n     * ```\n     * @readonly\n     * @see {@link Bounds} For bounds operations\n     * @see {@link Container#getBounds} For transformed bounds\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * Returns true if the point lies within the Graphics object's rendered area.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Check point intersection\n     * if (graphics.containsPoint({ x: 50, y: 50 })) {\n     *     console.log('Point is inside rectangle!');\n     * }\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is inside the Graphics object\n     * @see {@link Graphics#bounds} For bounding box checks\n     * @see {@link PointData} For point data structure\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @example\n     * ```ts\n     * // Destroy the graphics and its context\n     * graphics.destroy();\n     * graphics.destroy(true);\n     * graphics.destroy({ context: true, texture: true, textureSource: true });\n     * ```\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context.\n     * The fill style can be a color, gradient, pattern, or a complex style object.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics\n     *     .setFillStyle({ color: 0xff0000 }) // Red fill\n     *     .rect(0, 0, 100, 100)\n     *     .fill();\n     *\n     * // Gradient fill\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setFillStyle(gradient)\n     *     .circle(100, 100, 50)\n     *     .fill();\n     *\n     * // Pattern fill\n     * const pattern = new FillPattern(texture);\n     * graphics\n     *     .setFillStyle({\n     *         fill: pattern,\n     *         alpha: 0.5\n     *     })\n     *     .rect(0, 0, 200, 200)\n     *     .fill();\n     * ```\n     * @param {FillInput} args - The fill style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context.\n     * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color stroke\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 2,\n     *         color: 0x000000\n     *     })\n     *     .rect(0, 0, 100, 100)\n     *     .stroke();\n     *\n     * // Complex stroke style\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 4,\n     *         color: 0xff0000,\n     *         alpha: 0.5,\n     *         join: 'round',\n     *         cap: 'round',\n     *         alignment: 0.5\n     *     })\n     *     .circle(100, 100, 50)\n     *     .stroke();\n     *\n     * // Gradient stroke\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 10,\n     *         fill: gradient\n     *     })\n     *     .poly([0,0, 100,50, 0,100])\n     *     .stroke();\n     * ```\n     * @param {StrokeInput} args - The stroke style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link FillPattern} For pattern strokes\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style or specified style.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Fill with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill('red'); // Red fill\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .fill(myTexture); // Fill with texture\n     *\n     * // Fill with complex style\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({\n     *         color: 0x00ff00,\n     *         alpha: 0.5,\n     *         texture: myTexture,\n     *         matrix: new Matrix()\n     *     });\n     *\n     * // Fill with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill(gradient);\n     * ```\n     * @param {FillInput} style - The style to fill the path with. Can be:\n     * - A ColorSource\n     * - A gradient\n     * - A pattern\n     * - A complex style object\n     * If omitted, uses current fill style.\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style or specified style.\n     * Outlines the shape using the stroke settings.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Stroke with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0xff0000\n     *     }); // 2px red stroke\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .stroke(myTexture); // Fill with texture\n     *\n     * // Stroke with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .stroke({\n     *         width: 4,\n     *         fill: gradient,\n     *         alignment: 0.5,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n     * - A stroke style object with width, color, etc.\n     * - A gradient\n     * - A pattern\n     * If omitted, uses current stroke style.\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link setStrokeStyle} For setting default stroke style\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n     * including basic textures, tinted textures, and textures with custom dimensions.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic texture drawing\n     * graphics.texture(myTexture);\n     *\n     * // Tinted texture with position\n     * graphics.texture(myTexture, 0xff0000); // Red tint\n     *\n     * // Texture with custom position and dimensions\n     * graphics\n     *     .texture(\n     *         myTexture,    // texture\n     *         0xffffff,     // white tint\n     *         100, 100,     // position\n     *         200, 150      // dimensions\n     *     );\n     * ```\n     * Basic texture drawing:\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current Graphics for chaining.\n     *\n     * Extended texture drawing:\n     * @param texture - The Texture object to use.\n     *        tint - A ColorSource to tint the texture (defaults to white).\n     *        dx - The x-coordinate for the texture placement.\n     *        dy - The y-coordinate for the texture placement.\n     *        dw - The width to draw the texture (defaults to texture width).\n     *        dh - The height to draw the texture (defaults to texture height).\n     * @returns The instance of the current Graphics for chaining.\n     * @see {@link Texture} For texture creation\n     * @see {@link FillPattern} For pattern fills\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .circle(150, 150, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .beginPath() // Starts a new path\n     *     .circle(250, 150, 50)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for chaining\n     * @see {@link Graphics#moveTo} For starting a new subpath\n     * @see {@link Graphics#closePath} For closing the current path\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path.\n     *\n     * If a hole is not completely in a shape, it will fail to cut correctly.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw outer circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *     .circle(100, 100, 25) // Inner circle\n     *     .cut() // Cuts out the inner circle from the outer circle\n     * ```\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @example\n     * ```ts\n     * // Draw a simple arc (quarter circle)\n     * const graphics = new Graphics();\n     * graphics\n     *     .arc(100, 100, 50, 0, Math.PI/2)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Draw a full circle using an arc\n     * graphics\n     *     .arc(200, 200, 30, 0, Math.PI * 2)\n     *     .stroke({ color: 0x00ff00 });\n     *\n     * // Draw a counterclockwise arc\n     * graphics\n     *     .arc(150, 150, 40, Math.PI, 0, true)\n     *     .stroke({ width: 2, color: 0x0000ff });\n     * ```\n     * @param x - The x-coordinate of the arc's center\n     * @param y - The y-coordinate of the arc's center\n     * @param radius - The arc's radius (must be positive)\n     * @param startAngle - The starting point of the arc, in radians\n     * @param endAngle - The end point of the arc, in radians\n     * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n     *                          If false (default), draws clockwise.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing complete circles\n     * @see {@link Graphics#arcTo} For drawing arcs between points\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path that connects two points using a radius.\n     * The arc is drawn between the current point and the specified end point,\n     * using the given control point to determine the curve of the arc.\n     * @example\n     * ```ts\n     * // Draw a simple curved corner\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a rounded rectangle using arcTo\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n     *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n     *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n     *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x1 - The x-coordinate of the control point\n     * @param y1 - The y-coordinate of the control point\n     * @param x2 - The x-coordinate of the end point\n     * @param y2 - The y-coordinate of the end point\n     * @param radius - The radius of the arc in pixels (must be positive)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For drawing arcs using center point and angles\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n     * @example\n     * ```ts\n     * // Draw a simple elliptical arc\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(100, 100)\n     *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a complex path with rotated elliptical arc\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcToSvg(\n     *         60,    // rx\n     *         30,    // ry\n     *         45,    // x-axis rotation (45 degrees)\n     *         1,     // large arc flag\n     *         0,     // sweep flag\n     *         250,   // end x\n     *         200    // end y\n     *     )\n     *     .stroke({ width: 4, color: 0x00ff00 });\n     *\n     * // Chain multiple arcs for complex shapes\n     * graphics\n     *     .moveTo(300, 100)\n     *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n     *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param rx - The x-radius of the ellipse (must be non-negative)\n     * @param ry - The y-radius of the ellipse (must be non-negative)\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n     * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n     * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n     *                    a positive angle direction (1) or negative (0)\n     * @param x - The x-coordinate of the arc's end point\n     * @param y - The y-coordinate of the arc's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For simple circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     * @see {@link Graphics#svg} For parsing complete SVG paths\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic B\u00E9zier curve to the path, from the current point to the specified end point.\n     * The curve is influenced by two control points that define its shape and curvature.\n     * @example\n     * ```ts\n     * // Draw a simple curved line\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .bezierCurveTo(\n     *         100, 25,   // First control point\n     *         150, 75,   // Second control point\n     *         200, 50    // End point\n     *     )\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .bezierCurveTo(\n     *         100, 150,\n     *         200, 250,\n     *         250, 200,\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({ width: 4, color: 0x0000ff });\n     * ```\n     * @param cp1x - The x-coordinate of the first control point\n     * @param cp1y - The y-coordinate of the first control point\n     * @param cp2x - The x-coordinate of the second control point\n     * @param cp2y - The y-coordinate of the second control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start point.\n     *\n     * This is useful for completing shapes and ensuring they are properly closed for fills.\n     * @example\n     * ```ts\n     * // Create a triangle with closed path\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .closePath()\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path\n     * @see {@link Graphics#fill} For filling closed paths\n     * @see {@link Graphics#stroke} For stroking paths\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic ellipse\n     * graphics\n     *     .ellipse(100, 100, 50, 30)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw an ellipse with stroke\n     * graphics\n     *     .ellipse(200, 100, 70, 40)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the center of the ellipse\n     * @param y - The y-coordinate of the center of the ellipse\n     * @param radiusX - The horizontal radius of the ellipse\n     * @param radiusY - The vertical radius of the ellipse\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing perfect circles\n     * @see {@link Graphics#arc} For drawing partial circular arcs\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape at the specified location with the given radius.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a circle with gradient fill\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *           { offset: 0, color: 0xff0000 }, // Red at start\n     *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *           { offset: 1, color: 0x0000ff }, // Blue at end\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(250, 100, 40)\n     *     .fill({ fill: gradient });\n     * ```\n     * @param x - The x-coordinate of the center of the circle\n     * @param y - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#ellipse} For drawing ellipses\n     * @see {@link Graphics#arc} For drawing partial circles\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * This allows for reuse of complex paths and shapes across different graphics instances.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * // Create a reusable path\n     * const heartPath = new GraphicsPath()\n     *     .moveTo(0, 0)\n     *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n     *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n     *\n     * // Use the path multiple times\n     * graphics\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000 })\n     *     .translateTransform(200, 200)\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000, alpha: 0.5 });\n     * ```\n     * @param path - The `GraphicsPath` to add to the current path\n     * @returns The Graphics instance for method chaining\n     * @see {@link GraphicsPath} For creating reusable paths\n     * @see {@link Matrix} For creating transformations\n     * @see {@link Graphics#transform} For applying transformations\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line.\n     * Any subsequent drawing commands will start from this new point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a complex shape with multiple lines\n     * graphics\n     *     .moveTo(200, 50)\n     *     .lineTo(250, 50)\n     *     .lineTo(250, 100)\n     *     .lineTo(200, 100)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the line's end point\n     * @param y - The y-coordinate of the line's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#moveTo} For starting a new sub-path\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path.\n     *\n     * Moves the \"pen\" to a new location without drawing a line.\n     * Any subsequent drawing commands will start from this point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create multiple separate lines\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 50)\n     *     .moveTo(50, 100)    // Start a new line\n     *     .lineTo(100, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create disconnected shapes\n     * graphics\n     *     .moveTo(150, 50)\n     *     .rect(150, 50, 50, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .moveTo(250, 50)    // Start a new shape\n     *     .circle(250, 75, 25)\n     *     .fill({ color: 0x0000ff });\n     *\n     * // Position before curved paths\n     * graphics\n     *     .moveTo(300, 50)\n     *     .bezierCurveTo(\n     *         350, 25,   // Control point 1\n     *         400, 75,   // Control point 2\n     *         450, 50    // End point\n     *     )\n     *     .stroke({ width: 3, color: 0xff00ff });\n     * ```\n     * @param x - The x-coordinate to move to\n     * @param y - The y-coordinate to move to\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#lineTo} For drawing lines\n     * @see {@link Graphics#beginPath} For starting a completely new path\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple curve\n     * graphics\n     *     .moveTo(50, 50)\n     *     .quadraticCurveTo(100, 25, 150, 50)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .quadraticCurveTo(\n     *         150, 150,   // Control point\n     *         250, 200,   // End point\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({\n     *         width: 4,\n     *         color: 0x0000ff,\n     *         alpha: 0.7\n     *     });\n     * ```\n     * @param cpx - The x-coordinate of the control point\n     * @param cpy - The y-coordinate of the control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#bezierCurveTo} For curves with two control points\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape.\n     *\n     * This method adds a new rectangle path to the current drawing.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled rectangle\n     * graphics\n     *     .rect(50, 50, 100, 75)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Rectangle with stroke\n     * graphics\n     *     .rect(200, 50, 100, 75)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners. The corner radius can be specified to\n     * determine how rounded the corners should be.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic rounded rectangle\n     * graphics\n     *     .roundRect(50, 50, 100, 75, 15)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @param radius - The radius of the rectangle's corners (must be non-negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed.\n     *\n     * An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n     * graphics\n     *     .poly([50,50, 100,100, 0,100], true)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a polygon using point objects\n     * graphics\n     *     .poly([\n     *         { x: 200, y: 50 },\n     *         { x: 250, y: 100 },\n     *         { x: 200, y: 150 },\n     *         { x: 150, y: 100 }\n     *     ])\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Draw an open polygon with stroke\n     * graphics\n     *     .poly([300,50, 350,50, 350,100, 300,100], false)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0x0000ff,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n     *                representing the vertices of the polygon in sequence\n     * @param close - Whether to close the polygon path by connecting the last point to the first.\n     *               Default is true.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n     * making shapes like triangles, squares, pentagons, etc.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple triangle (3 sides)\n     * graphics\n     *     .regularPoly(100, 100, 50, 3)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a hexagon (6 sides) with rotation\n     * graphics\n     *     .regularPoly(\n     *         250, 100,    // center position\n     *         40,          // radius\n     *         6,           // sides\n     *         Math.PI / 6  // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Draw an octagon (8 sides) with transform\n     * const transform = new Matrix()\n     *     .scale(1.5, 1)      // stretch horizontally\n     *     .rotate(Math.PI/4); // rotate 45 degrees\n     *\n     * graphics\n     *     .regularPoly(400, 100, 30, 8, 0, transform)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @param transform - Optional Matrix to transform the polygon's shape\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     *\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic rounded triangle\n     * graphics\n     *     .roundPoly(100, 100, 50, 3, 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rounded hexagon with rotation\n     * graphics\n     *     .roundPoly(\n     *         250, 150,     // center position\n     *         40,           // radius\n     *         6,            // sides\n     *         8,            // corner radius\n     *         Math.PI / 6   // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param corner - The radius of the corner rounding (must be non-negative)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a custom shape with rounded corners\n     * graphics\n     *     .roundShape([\n     *         { x: 100, y: 100, radius: 20 },\n     *         { x: 200, y: 100, radius: 10 },\n     *         { x: 200, y: 200, radius: 15 },\n     *         { x: 100, y: 200, radius: 5 }\n     *     ], 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using quadratic curves for corners\n     * graphics\n     *     .roundShape([\n     *         { x: 250, y: 100 },\n     *         { x: 350, y: 100 },\n     *         { x: 350, y: 200 },\n     *         { x: 250, y: 200 }\n     *     ], 15, true, 0.5)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Shape with varying corner radii\n     * graphics\n     *     .roundShape([\n     *         { x: 400, y: 100, radius: 30 },\n     *         { x: 500, y: 100, radius: 5 },\n     *         { x: 450, y: 200, radius: 15 }\n     *     ], 10)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param points - An array of `RoundedPoint` representing the corners of the shape.\n     *                Each point can have its own radius or use the default.\n     *                A minimum of 3 points is required.\n     * @param radius - The default radius for corners without a specific radius defined.\n     *                Applied to any point that doesn't specify its own radius.\n     * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n     *                      of arcs, creating a different visual style. Defaults to false.\n     * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n     *                    is true. Values range from 0-1, higher values create smoother curves.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n     * radii which create external rounded corners rather than internal ones.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a rectangle with internal fillets\n     * graphics\n     *     .filletRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rectangle with external fillets\n     * graphics\n     *     .filletRect(200, 50, 100, 80, -20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param fillet - The radius of the corner fillets (can be positive or negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For standard rounded corners\n     * @see {@link Graphics#chamferRect} For angled corners\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n     * a 45-degree angle based on the chamfer size.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic chamfered rectangle\n     * graphics\n     *     .chamferRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Add transform and stroke\n     * const transform = new Matrix()\n     *     .rotate(Math.PI / 4); // 45 degrees\n     *\n     * graphics\n     *     .chamferRect(200, 50, 100, 80, 20, transform)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param chamfer - The size of the corner chamfers (must be non-zero)\n     * @param transform - Optional Matrix to transform the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For rounded corners\n     * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     *\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic 5-pointed star\n     * graphics\n     *     .star(100, 100, 5, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Star with custom inner radius\n     * graphics\n     *     .star(250, 100, 6, 50, 20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the star\n     * @param y - The y-coordinate of the center of the star\n     * @param points - The number of points on the star (must be >= 3)\n     * @param radius - The outer radius of the star (distance from center to point tips)\n     * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n     *                     If not specified, defaults to half of the outer radius\n     * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n     *                  which aligns one point straight up\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#path} For creating custom shapes\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n     * and paths defined in SVG format to be drawn within the graphics context.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .svg(`\n     *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n     *               fill=\"blue\" />\n     *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n     *               fill=\"green\" />\n     *     `)\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param svg - The SVG string to be parsed and rendered\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#path} For adding custom paths\n     * @see {@link Graphics#fill} For filling shapes after SVG parsing\n     * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save current state\n     * graphics.save();\n     *\n     * // Make temporary changes\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .setFillStyle({ color: 0xff0000 })\n     *     .circle(0, 0, 50)\n     *     .fill();\n     *\n     * // Restore to previous state\n     * graphics.restore();\n     *\n     * // Draw with original transform and styles\n     * graphics\n     *     .circle(50, 50, 30)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#save} For saving the current state\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /**\n     * Saves the current graphics state onto a stack. The state includes:\n     * - Current transformation matrix\n     * - Current fill style\n     * - Current stroke style\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save state before complex operations\n     * graphics.save();\n     *\n     * // Create transformed and styled shape\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4)\n     *     .setFillStyle({\n     *         color: 0xff0000,\n     *         alpha: 0.5\n     *     })\n     *     .rect(-25, -25, 50, 50)\n     *     .fill();\n     *\n     * // Restore to original state\n     * graphics.restore();\n     *\n     * // Continue drawing with previous state\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#restore} For restoring the saved state\n     * @see {@link Graphics#setTransform} For setting transformations\n     */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * This matrix represents all accumulated transformations including translate, scale, and rotate.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply some transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4);\n     *\n     * // Get the current transform matrix\n     * const matrix = graphics.getTransform();\n     * console.log(matrix.tx, matrix.ty); // 100, 100\n     *\n     * // Use the matrix for other operations\n     * graphics\n     *     .setTransform(matrix)\n     *     .circle(0, 0, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @returns The current transformation matrix.\n     * @see {@link Graphics#setTransform} For setting the transform matrix\n     * @see {@link Matrix} For matrix operations\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .scaleTransform(2, 2)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * // Reset transform to default state\n     * graphics\n     *     .resetTransform()\n     *     .circle(50, 50, 25) // Will draw at actual coordinates\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#getTransform} For getting the current transform\n     * @see {@link Graphics#setTransform} For setting a specific transform\n     * @see {@link Graphics#save} For saving the current transform state\n     * @see {@link Graphics#restore} For restoring a previous transform state\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Rotate 45 degrees clockwise\n     * graphics\n     *     .rotateTransform(Math.PI / 4)\n     *     .rect(-25, -25, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param angle - The angle of rotation in radians\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#scaleTransform} For scaling transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n     * and by y vertically relative to the current origin.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Uniform scaling\n     * graphics\n     *     .scaleTransform(2)  // Scale both dimensions by 2\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Non-uniform scaling\n     * graphics\n     *     .scaleTransform(0.5, 2)  // Half width, double height\n     *     .rect(100, 100, 50, 50)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x - The scale factor in the horizontal direction\n     * @param y - The scale factor in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rotateTransform} For rotation transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context.\n     *\n     * This method can either\n     * take a Matrix object or individual transform values to create a new transformation matrix.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     *\n     * graphics\n     *     .setTransform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .setTransform(\n     *         2, 0,     // scale x by 2\n     *         0, 1,     // no skew\n     *         100, 100  // translate x,y by 100\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies a transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix. This allows for complex transformations\n     * combining multiple operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .scale(2, 1)      // Scale horizontally\n     *     .rotate(Math.PI/6); // Rotate 30 degrees\n     *\n     * graphics\n     *     .transform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .transform(\n     *         1, 0.5,    // Skew horizontally\n     *         0, 1,      // No vertical skew\n     *         100, 100   // Translate\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * This affects all subsequent drawing operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic translation\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The amount to translate in the horizontal direction\n     * @param y - The amount to translate in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#setTransform} For setting absolute transformations\n     * @see {@link Graphics#transform} For applying complex transformations\n     * @see {@link Graphics#save} For saving the current transform state\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it.\n     * This includes clearing the current path, fill style, stroke style, and transformations.\n     *\n     * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n     * > Instead, they are intended to be used for static or semi-static graphics that\n     * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw some shapes\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 })\n     *     .rect(200, 100, 100, 50)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Clear all graphics\n     * graphics.clear();\n     *\n     * // Start fresh with new shapes\n     * graphics\n     *     .circle(150, 150, 30)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n     * @see {@link Graphics#save} For saving the current state\n     * @see {@link Graphics#restore} For restoring a previous state\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * Gets or sets the current fill style for the graphics context. The fill style determines\n     * how shapes are filled when using the fill() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics.fillStyle = {\n     *     color: 0xff0000,  // Red\n     *     alpha: 1\n     * };\n     *\n     * // Using gradients\n     * const gradient = new FillGradient({\n     *     end: { x: 0, y: 1 }, // Vertical gradient\n     *     stops: [\n     *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n     *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n     *     ]\n     * });\n     *\n     * graphics.fillStyle = {\n     *     fill: gradient,\n     *     alpha: 0.8\n     * };\n     *\n     * // Using patterns\n     * graphics.fillStyle = {\n     *     texture: myTexture,\n     *     alpha: 1,\n     *     matrix: new Matrix()\n     *         .scale(0.5, 0.5)\n     *         .rotate(Math.PI / 4)\n     * };\n     * ```\n     * @type {ConvertedFillStyle}\n     * @see {@link FillStyle} For all available fill style options\n     * @see {@link FillGradient} For creating gradient fills\n     * @see {@link Graphics#fill} For applying the fill to paths\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * Gets or sets the current stroke style for the graphics context. The stroke style determines\n     * how paths are outlined when using the stroke() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic stroke style\n     * graphics.strokeStyle = {\n     *     width: 2,\n     *     color: 0xff0000,\n     *     alpha: 1\n     * };\n     *\n     * // Using with gradients\n     * const gradient = new FillGradient({\n     *   end: { x: 0, y: 1 },\n     *   stops: [\n     *       { offset: 0, color: 0xff0000, alpha: 1 },\n     *       { offset: 1, color: 0x0000ff, alpha: 1 }\n     *   ]\n     * });\n     *\n     * graphics.strokeStyle = {\n     *     width: 4,\n     *     fill: gradient,\n     *     alignment: 0.5,\n     *     join: 'round',\n     *     cap: 'round'\n     * };\n     *\n     * // Complex stroke settings\n     * graphics.strokeStyle = {\n     *     width: 6,\n     *     color: 0x00ff00,\n     *     alpha: 0.5,\n     *     join: 'miter',\n     *     miterLimit: 10,\n     * };\n     * ```\n     * @see {@link StrokeStyle} For all available stroke style options\n     * @see {@link Graphics#stroke} For applying the stroke to paths\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object that copies the current graphics content.\n     * The clone can either share the same context (shallow clone) or have its own independent\n     * context (deep clone).\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create original graphics content\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a shallow clone (shared context)\n     * const shallowClone = graphics.clone();\n     *\n     * // Changes to original affect the clone\n     * graphics\n     *     .circle(200, 100, 30)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Create a deep clone (independent context)\n     * const deepClone = graphics.clone(true);\n     *\n     * // Modify deep clone independently\n     * deepClone\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 40)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @param deep - Whether to create a deep clone of the graphics object.\n     *              If false (default), the context will be shared between objects.\n     *              If true, creates an independent copy of the context.\n     * @returns A new Graphics instance with either shared or copied context\n     * @see {@link Graphics#context} For accessing the underlying graphics context\n     * @see {@link GraphicsContext} For understanding the shared context behavior\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n", "// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n", "/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/**\n * @category text\n * @advanced\n */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n", "import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @internal */\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n    textureStyle?: TextureStyle | TextureStyleOptions\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentMaxCharHeight = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n    private readonly _textureStyle?: TextureStyle;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        if (dynamicOptions.textureStyle)\n        {\n            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle\n                ? dynamicOptions.textureStyle\n                : new TextureStyle(dynamicOptions.textureStyle);\n        }\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = CanvasTextMetrics.graphemeSegmenter(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        let currentMaxCharHeight = this._currentMaxCharHeight;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += currentMaxCharHeight;\n\n                // reset the line x and height..\n                currentMaxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + currentMaxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentX = 0;\n                    currentY = 0;\n                    currentMaxCharHeight = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._currentMaxCharHeight = currentMaxCharHeight;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        if (this._textureStyle)\n        {\n            texture.source.style = this._textureStyle;\n        }\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        let removeShadow = false;\n\n        if (style.stroke && strokeThickness)\n        {\n            removeShadow = true;\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;\n\n        if (style._fill)\n        {\n            if (removeShadow)\n            {\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (removeShadow)\n        {\n            context.shadowBlur = shadowBlur;\n            context.shadowOffsetX = shadowOffsetX;\n            context.shadowOffsetY = shadowOffsetY;\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n", "import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;\n\n    const breakWords = style.wordWrap && style.breakWords;\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += adjustedLineHeight;\n    };\n\n    const checkIsOverflow = (lineWidth: number) =>\n        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                nextLine();\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);\n\n            if (addWordToNextLine)\n            {\n                nextWord(currentWord);\n                nextLine();\n            }\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n", "/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n", "import { lru } from 'tiny-lru';\nimport { Cache } from '../../assets/cache/Cache';\nimport { type TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions\n{\n    /**\n     * The name of the font. This will be used as the fontFamily in text styles to access this font.\n     * Must be unique across all installed bitmap fonts.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'MyCustomFont',\n     *     style: { fontFamily: 'Arial' }\n     * });\n     * ```\n     */\n    name?: string;\n\n    /**\n     * Characters included in the font set. You can specify individual characters or ranges.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     * @example\n     * ```ts\n     * // Different ways to specify characters\n     * BitmapFont.install({\n     *     name: 'RangeFont',\n     *     chars: [\n     *         ['a', 'z'],              // Range of characters\n     *         '0123456789',            // String of characters\n     *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n     *     ]\n     * });\n     * ```\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n     * Useful for supporting high-DPI displays.\n     * @default 1\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'HiDPIFont',\n     *     resolution: window.devicePixelRatio || 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n     * - Lower values: More compact, but may have visual artifacts\n     * - Higher values: Better quality, but uses more texture space\n     * @default 4\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'PaddedFont',\n     *     padding: 8 // More padding for better quality\n     * });\n     * ```\n     */\n    padding?: number;\n\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * - true: Faster generation, but text may have inconsistent spacing\n     * - false: Better text appearance, but slower generation\n     * @default false\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'FastFont',\n     *     skipKerning: true // Prioritize performance\n     * });\n     * ```\n     */\n    skipKerning?: boolean;\n\n    /**\n     * Style options to render the BitmapFont with.\n     * Supports all TextStyle properties including fill, stroke, and shadow effects.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'StyledFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: 'white',\n     *         stroke: { color: '#000000', width: 2 },\n     *         dropShadow: {\n     *             color: '#000000',\n     *             blur: 2,\n     *             distance: 3\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    style?: TextStyle | TextStyleOptions;\n\n    /**\n     * Optional texture style to use when creating the font textures.\n     * Controls how the font textures are rendered and filtered.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'CrispFont',\n     *     textureStyle: {\n     *         scaleMode: 'nearest',\n     *     }\n     * });\n     * ```\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n\n    /**\n     * Whether to allow overriding the fill color with a tint at runtime.\n     *\n     * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n     * allowing a single font to display multiple colors without creating separate font textures.\n     * This is memory efficient but requires the font to be rendered with white fill color.\n     *\n     * When disabled, the fill color is permanently baked into the font texture. This allows\n     * any fill color but prevents runtime tinting - each color variation requires a separate font.\n     * @default false (automatically determined based on style)\n     *\n     * **Requirements for tinting:**\n     * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n     * - No stroke effects\n     * - No drop shadows (or only black shadows)\n     * - No gradient or pattern fills\n     *\n     * **Performance considerations:**\n     * - \u2705 Enabled: One font texture, multiple colors via tinting (memory efficient)\n     * - \u274C Disabled: Separate font texture per color (higher memory usage)\n     * @example\n     * ```ts\n     * // Correct usage - white fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'TintableFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFFFFFF  // Must be white for tinting\n     *     },\n     *     dynamicFill: true\n     * });\n     *\n     * // Use the font with different colors via tinting\n     * const redText = new BitmapText({\n     *     text: 'Red Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n     * });\n     *\n     * const blueText = new BitmapText({\n     *     text: 'Blue Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Incorrect usage - colored fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'BadTintFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000  // \u274C Red fill won't tint properly\n     *     },\n     *     dynamicFill: true  // \u274C Will not work as expected\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Alternative - baked colors (no tinting)\n     * BitmapFont.install({\n     *     name: 'BakedColorFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000,  // Any color works\n     *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n     *     },\n     *     dynamicFill: false  // Color is baked in\n     * });\n     * ```\n     */\n    dynamicFill?: boolean;\n}\n\n/** @advanced */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n        textureStyle: null,\n    };\n\n    /** Cache for measured text layouts to avoid recalculating them multiple times. */\n    public readonly measureCache = lru<BitmapTextLayoutData>(1000);\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            fontFamilyKey = `${style.styleKey}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const styleCopy = Object.create(style);\n\n            // Override the lineHeight, let the BitmapFont calculate the lineHeight\n            // from the fontMetrics instead using a custom lineHeight from BitmapText parameter\n            styleCopy.lineHeight = 0;\n\n            const fnt = new DynamicBitmapFont({\n                style: styleCopy,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        const id = `${text}-${style.styleKey}-${trimEnd}`;\n\n        // Check if we have a cached layout\n        if (this.measureCache.has(id))\n        {\n            return this.measureCache.get(id);\n        }\n\n        const segments = CanvasTextMetrics.graphemeSegmenter(text);\n\n        // Generate the layout data\n        const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n\n        this.measureCache.set(id, layoutData);\n\n        return layoutData;\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false,\n            textureStyle: options.textureStyle,\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n\n    /**\n     * Determines if a style can use tinting instead of baking colors into the bitmap.\n     * Tinting is more efficient as it allows reusing the same bitmap with different colors.\n     * @param style - The text style to evaluate\n     * @returns true if the style can use tinting, false if colors must be baked in\n     * @private\n     */\n    private _canUseTintForStyle(style: TextStyle): boolean\n    {\n        // Exclude strokes, non black shadows and ensure\n        // we have a non gradient or pattern fill,\n        // and the fill color is white\n        return !style._stroke\n            && (!style.dropShadow || style.dropShadow.color === 0x000000)\n            && !style._fill.fill\n            && style._fill.color === 0xFFFFFF;\n    }\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager = new BitmapFontManagerClass();\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n", "import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n    public currentKey: string = '--';\n\n    /**\n     * Creates an instance of BatchableHTMLText.\n     * @param renderer - The renderer instance to be used.\n     */\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n    public resolutionChange()\n    {\n        const text = this.renderable as HTMLText;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(this.currentKey) === null\n            ? htmlText.returnTexturePromise(this.texturePromise)\n            : htmlText.decreaseReferenceCount(this.currentKey);\n        this._renderer.runners.resolutionChange.remove(this);\n        this.texturePromise = null;\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n", "import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n", "/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\nimport { type ImageLike } from '../../environment/ImageLike';\n\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image: ImageLike;\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n\n        this.image = DOMAdapter.get().createImage();\n    }\n\n    public destroy(): void\n    {\n        this.svgRoot.remove();\n        this.foreignObject.remove();\n        this.styleElement.remove();\n        this.domElement.remove();\n        this.image.src = '';\n        this.image.remove();\n\n        this.svgRoot = null;\n        this.foreignObject = null;\n        this.styleElement = null;\n        this.domElement = null;\n        this.image = null;\n        this.canvasAndContext = null;\n    }\n}\n", "import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n", "import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n", "import { Cache } from '../../../assets/cache/Cache';\nimport { type FontFaceCache } from '../../../assets/loader/parsers/loadWebFont';\nimport { loadFontCSS } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { entries } = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n                const promises: Promise<string>[] = [];\n\n                entries.forEach((entry) =>\n                {\n                    const url = entry.url;\n                    const faces = entry.faces;\n\n                    const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n\n                    // load each out font with the correct style\n                    promises.push(\n                        ...out.map((style) =>\n                            loadFontCSS(\n                                {\n                                    fontWeight: style.weight,\n                                    fontStyle: style.style,\n                                    fontFamily,\n                                },\n                                url,\n                            ),\n                        ),\n                    );\n                });\n                FontStylePromiseCache.set(\n                    fontFamily,\n                    Promise.all(promises).then((css) => css.join('\\n')),\n                );\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n", "import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n", "import { type ImageLike } from '../../../environment/ImageLike';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n", "import { type ImageLike } from '../../../environment/ImageLike';\n\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n", "/* eslint-disable no-restricted-globals */\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n", "import { type ImageLike } from '../../environment/ImageLike';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { type HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLText, HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n        promise: Promise<Texture>,\n    }> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    /**\n     * Increases the reference count for a texture.\n     * @param text - The HTMLText instance associated with the texture.\n     */\n    public getManagedTexture(text: HTMLText): Promise<Texture>\n    {\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Decreases the reference count for a texture.\n     * If the count reaches zero, the texture is cleaned up.\n     * @param textKey - The key associated with the HTMLText instance.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture.texture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture.texture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves to a texture for the given HTMLText options.\n     * @param options - The options for the HTMLText.\n     * @returns A promise that resolves to a Texture.\n     */\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: ImageLike | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n", "import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n", "/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n", "/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n", "import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n", "import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n", "import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n", "import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n", "import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        this._setupBindGroupsAndRender(filter, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        // BOOM!\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n\n", "import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @category environment\n * @internal\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @category environment\n * @internal\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n", "import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader\n{\n    /** The default filter settings */\n    public static defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n * @category environment\n * @advanced\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n * @category environment\n * @advanced\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n", "// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n", "/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR\n{\n    /** No clear operation. */\n    NONE = 0,\n    /** Clear the color buffer. */\n    COLOR = 16384,\n    /** Clear the stencil buffer. */\n    STENCIL = 1024,\n    /** Clear the depth buffer. */\n    DEPTH = 256,\n\n    /** Clear the color and depth buffers. */\n    COLOR_DEPTH = COLOR | DEPTH,\n    /** Clear the color and stencil buffers. */\n    COLOR_STENCIL = COLOR | STENCIL,\n    /** Clear the depth and stencil buffers. */\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    /** Clear the color, depth, and stencil buffers. */\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n", "/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```ts\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n    /** Whether to clean up global resource pools/caches */\n    releaseGlobalResources?: boolean;\n}>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    /** @internal */\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    /** @internal */\n    public readonly uid = uid('renderer');\n\n    /** @internal */\n    public _roundPixels: 0 | 1;\n\n    /** @internal */\n    public readonly runners: Runners = Object.create(null) as Runners;\n    /** @internal */\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // Check if the container is visible before proceeding with rendering\n        if (!options.container.visible)\n        {\n            return;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param options - The options to use when clearing the render target.\n     * @param options.target - The render target to clear.\n     * @param options.clearColor - The color to clear with.\n     * @param options.clear - The clear mode to use.\n     * @advanced\n     */\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @type {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n\n            this.runners.destroy.add((this.renderPipes as any)[name]);\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        if (options === true || (typeof options === 'object' && options.releaseGlobalResources))\n        {\n            GlobalResourceRegistry.release();\n        }\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     * @advanced\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support in the current environment.\n *\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGL support check\n * if (isWebGLSupported()) {\n *     console.log('WebGL is available');\n * }\n * ```\n * @param failIfMajorPerformanceCaveat - Whether to fail if there is a major performance caveat\n * @returns True if WebGL is supported\n * @category utils\n * @standard\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n", "import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support in the current environment.\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGPU support check\n * const hasWebGPU = await isWebGPUSupported();\n * console.log('WebGPU available:', hasWebGPU);\n * ```\n * @param options - The options for requesting a GPU adapter\n * @returns Promise that resolves to true if WebGPU is supported\n * @category utils\n * @standard\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n", "import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link autoDetectRenderer}.\n * @category rendering\n * @advanced\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @category rendering\n * @standard\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n", "/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n", "import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n", "import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @category utils\n * @advanced\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/**\n * The current version of PixiJS. This is automatically replaced by the build process.\n * @internal\n */\nexport const VERSION = '$_VERSION';\n", "import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @category app\n * @internal\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @category rendering\n * @internal\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n", "var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\n/** @internal */\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n", "import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *         multisample: 4\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n", "import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n", "/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n", "import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n", "import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_hash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n\n            this._managedBuffers.push(buffer);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n", "import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n", "import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n", "import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n", "import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n", "import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n", "/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n", "import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n", "import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n", "/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n", "import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n", "import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n", "import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n", "import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n", "import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n", "/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuSources');\n        renderer.renderableGC.addManagedHash(this, '_gpuSamplers');\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        renderer.renderableGC.addManagedHash(this, '_textureViewHash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (this._gpuSources[source.uid])\n        {\n            return this._gpuSources[source.uid];\n        }\n\n        return this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpuSources[source.uid] = this._gpu.device.createTexture(textureDescriptor);\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = renderer.limits.maxBatchableTextures;\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.state.set(graphicsPipe.state);\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(batcher.geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.count; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw(batch.topology, batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @category rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @category rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private readonly _tempState = State.for2d();\n\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    private _didUploadHash: Record<string, boolean> = {};\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUploadHash = {};\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        const didUpload = this._didUploadHash[shader.uid];\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, didUpload);\n\n        if (!didUpload)\n        {\n            this._didUploadHash[shader.uid] = true;\n        }\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n", "/**\n * Constants for various buffer types in Pixi\n * @category rendering\n * @advanced\n */\nexport enum BUFFER_TYPE\n{\n    /** buffer type for using as an index buffer */\n    ELEMENT_ARRAY_BUFFER = 34963,\n    /** buffer type for using attribute data */\n    ARRAY_BUFFER = 34962,\n    /** the buffer type is for uniform buffer objects */\n    UNIFORM_BUFFER = 35345,\n}\n\n", "import type { BUFFER_TYPE } from './const';\n\n/** @internal */\nexport class GlBuffer\n{\n    public buffer: WebGLBuffer;\n    public updateID: number;\n    public byteLength: number;\n    public type: number;\n\n    public _lastBindBaseLocation: number = -1;\n    public _lastBindCallId: number = -1;\n\n    constructor(buffer: WebGLBuffer, type: BUFFER_TYPE)\n    {\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this._gl = this._renderer.gl;\n\n        this._gpuBuffers = Object.create(null);\n        this._maxBindings = this._renderer.limits.maxUniformBindings;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n\n    public resetState(): void\n    {\n        this._boundBufferBases = Object.create(null);\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @category rendering\n * @advanced\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     */\n    preferWebGLVersion?: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    multiView: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @category rendering\n * @advanced\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n        /**\n         * {@link WebGLOptions.multiView}\n         * @default false\n         */\n        multiView: false\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    public multiView: boolean;\n\n    /**\n     * The canvas that the WebGL Context is rendering to.\n     * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n     * It will be rendered to and then copied to the target canvas.\n     * @readonly\n     */\n    public canvas: ICanvas;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        // TODO add to options\n        let multiView = this.multiView = options.multiView;\n\n        if (options.context && multiView)\n        {\n            // eslint-disable-next-line max-len\n            warn('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.');\n\n            multiView = false;\n        }\n\n        if (multiView)\n        {\n            this.canvas = DOMAdapter.get()\n                .createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n        }\n        else\n        {\n            this.canvas = this._renderer.view.canvas;\n        }\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    public ensureCanvasSize(targetCanvas: ICanvas): void\n    {\n        if (!this.multiView)\n        {\n            if (targetCanvas !== this.canvas)\n            {\n                warn('multiView is disabled, but targetCanvas is not the main canvas');\n            }\n\n            return;\n        }\n\n        const { canvas } = this;\n\n        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height)\n        {\n            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n\n        const canvas = this.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this.getExtensions(); // restore extensions state\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            // #endif\n        }\n    }\n}\n", "/**\n * Various GL texture/resources formats.\n * @category rendering\n * @advanced\n */\nexport enum GL_FORMATS\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\n/**\n * Various GL target types.\n * @category rendering\n * @advanced\n */\nexport enum GL_TARGETS\n{\n    TEXTURE_2D = 3553,\n    TEXTURE_CUBE_MAP = 34067,\n    TEXTURE_2D_ARRAY = 35866,\n    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,\n}\n\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @category rendering\n * @advanced\n */\nexport enum GL_WRAP_MODES\n{\n    /**\n     * The textures uvs are clamped\n     * @default 33071\n     */\n    CLAMP = 33071,\n    /**\n     * The texture uvs tile and repeat\n     * @default 10497\n     */\n    REPEAT = 10497,\n    /**\n     * The texture uvs tile and repeat with mirroring\n     * @default 33648\n     */\n    MIRRORED_REPEAT = 33648,\n}\n\n/** @internal */\nexport enum GL_TYPES\n{\n    /**\n     * 8 bits per channel for gl.RGBA\n     * @default 5121\n     */\n    UNSIGNED_BYTE = 5121,\n    /** @default 5123 */\n    UNSIGNED_SHORT = 5123,\n    /**\n     * 5 red bits, 6 green bits, 5 blue bits.\n     * @default 33635\n     */\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    /**\n     * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n     * @default 32819\n     */\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    /**\n     * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n     * @default 32820\n     */\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    /** @default 5125 */\n    UNSIGNED_INT = 5125,\n    /** @default 35899 */\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    /** @default 33640 */\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    /** @default 34042 */\n    UNSIGNED_INT_24_8 = 34042,\n    /** @default 35902 */\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    /** @default 5120 */\n    BYTE = 5120,\n    /** @default 5122 */\n    SHORT = 5122,\n    /** @default 5124 */\n    INT = 5124,\n    /** @default 5126 */\n    FLOAT = 5126,\n    /** @default 36269 */\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    /** @default 36193 */\n    HALF_FLOAT = 36193,\n}\n\n", "import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @category rendering\n * @advanced\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n\n        this._renderer.renderableGC.addManagedHash(this, '_geometryVaoHash');\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader ||= this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public resetState(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = programAttrib.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        // Can't use truthiness check to determine if divisor is set,\n                        // since 0 is a valid value for divisor\n                        const divisor = attribute.divisor ?? 1;\n\n                        gl.vertexAttribDivisor(location, divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     * @returns This instance of the geometry system.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[topology || geometry.topology];\n\n        instanceCount ??= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n        this._geometryVaoHash = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @category rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n * @advanced\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @category rendering\n * @advanced\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { checkMaxIfStatementsInShader } from '../../batcher/gl/utils/checkMaxIfStatementsInShader';\nimport { type System } from '../shared/system/System';\n\nimport type { WebGLRenderer } from './WebGLRenderer';\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the GL rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGlRenderer();\n * await renderer.init();\n *\n * console.log(renderer.limits.maxTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GlLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    /** The maximum number of uniform bindings */\n    public maxUniformBindings: number;\n\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        const gl = this._renderer.gl;\n\n        // step 1: first check max textures the GPU can handle.\n        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        // step 2: check the maximum number of if statements the shader can have too..\n        this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n\n        // step 3: check the limit of uniform buffer bindings.\n        // UBs are available only in WebGL2 context, requesting within WebGL1 produces a warning.\n        const isWebGl2 = this._renderer.context.webGLVersion === 2;\n\n        this.maxUniformBindings = isWebGl2\n            ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS)\n            : 0;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        this.resetState();\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public resetState()\n    {\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n", "import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    i32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'vec2<i32>': 8,\n    'vec3<i32>': 12,\n    'vec4<i32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    const chunkSize = 16;\n\n    let size = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, chunkSize) * uboElement.data.size;\n        }\n\n        const boundary = size === 12 ? 16 : size;\n\n        uboElement.size = size;\n\n        const curOffset = offset % chunkSize;\n\n        if (curOffset > 0 && chunkSize - curOffset < boundary)\n        {\n            offset += (chunkSize - curOffset) % 16;\n        }\n        else\n        {\n            offset += (size - (curOffset % size)) % size;\n        }\n\n        uboElement.offset = offset;\n        offset += size;\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string\n{\n    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n\n    const remainder = (4 - (elementSize % 4)) % 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                ${data}[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n        }\n    `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionSTD40(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboStd40',\n        generateArraySyncSTD40,\n        uboSyncFunctionsSTD40,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @category rendering\n * @advanced\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n", "/**\n * Represents a render target.\n * @category rendering\n * @ignore\n */\nexport class GlRenderTarget\n{\n    public width = -1;\n    public height = -1;\n    public msaa = false;\n    public framebuffer: WebGLFramebuffer;\n    public resolveTargetFramebuffer: WebGLFramebuffer;\n    public msaaRenderBuffer: WebGLRenderbuffer[] = [];\n    public depthStencilRenderBuffer: WebGLRenderbuffer;\n}\n", "import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @category rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        const colorTexture = renderTarget.colorTexture;\n\n        if (colorTexture instanceof CanvasSource)\n        {\n            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil || renderTarget.depth)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n\n    public prerender(renderTarget: RenderTarget)\n    {\n        const resource = renderTarget.colorTexture.resource;\n\n        // if the render target is a canvas, ensure its size matches the source\n        if (this._renderer.context.multiView && CanvasSource.test(resource))\n        {\n            this._renderer.context.ensureCanvasSize(resource);\n        }\n    }\n\n    public postrender(renderTarget: RenderTarget)\n    {\n        // if multiView is not enabled, we don't need to do anything\n        if (!this._renderer.context.multiView) return;\n\n        // if the render target is a canvas, we need to copy the pixels from the gl canvas\n        // to the canvas target\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            const contextCanvas = this._renderer.context.canvas;\n            const canvasSource = renderTarget.colorTexture as unknown as CanvasSource;\n\n            canvasSource.context2D.drawImage(\n                contextCanvas as CanvasImageSource,\n                0, canvasSource.pixelHeight - contextCanvas.height\n            );\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n * @internal\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    const resName = shader._uniformBindMap[i][Number(j)];\n\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                const resName = shader._uniformBindMap[i][Number(j)];\n\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n", "/** @private */\nexport class IGLUniformData\n{\n    public location: WebGLUniformLocation;\n    public value: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData\n{\n    /** The shader program. */\n    public program: WebGLProgram;\n\n    /**\n     * Holds the uniform data which contains uniform locations\n     * and current uniform values used for caching and preventing unneeded GPU commands.\n     */\n    public uniformData: Record<string, any>;\n\n    /**\n     * UniformGroups holds the various upload functions for the shader. Each uniform group\n     * and program have a unique upload function generated.\n     */\n    public uniformGroups: Record<string, any>;\n\n    /** A hash that stores where UBOs are bound to on the program. */\n    public uniformBlockBindings: Record<string, any>;\n\n    /** A hash for lazily-generated uniform uploading functions. */\n    public uniformSync: Record<string, any>;\n\n    /**\n     * A place where dirty ticks are stored for groups\n     * If a tick here does not match with the Higher level Programs tick, it means\n     * we should re upload the data.\n     */\n    public uniformDirtyGroups: Record<string, any>;\n\n    /**\n     * Makes a new Pixi program.\n     * @param program - webgl program\n     * @param uniformData - uniforms\n     */\n    constructor(program: WebGLProgram, uniformData: {[key: string]: IGLUniformData})\n    {\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n\n    /** Destroys this program. */\n    public destroy(): void\n    {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n", "/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    return shader;\n}\n", "function booleanArray(size: number): Array<boolean>\n{\n    const array = new Array(size);\n\n    for (let i = 0; i < array.length; i++)\n    {\n        array[i] = false;\n    }\n\n    return array;\n}\n\n/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'float':\n            return 0;\n\n        case 'vec2':\n            return new Float32Array(2 * size);\n\n        case 'vec3':\n            return new Float32Array(3 * size);\n\n        case 'vec4':\n            return new Float32Array(4 * size);\n\n        case 'int':\n        case 'uint':\n        case 'sampler2D':\n        case 'sampler2DArray':\n            return 0;\n\n        case 'ivec2':\n            return new Int32Array(2 * size);\n\n        case 'ivec3':\n            return new Int32Array(3 * size);\n\n        case 'ivec4':\n            return new Int32Array(4 * size);\n\n        case 'uvec2':\n            return new Uint32Array(2 * size);\n\n        case 'uvec3':\n            return new Uint32Array(3 * size);\n\n        case 'uvec4':\n            return new Uint32Array(4 * size);\n\n        case 'bool':\n            return false;\n\n        case 'bvec2':\n\n            return booleanArray(2 * size);\n\n        case 'bvec3':\n            return booleanArray(3 * size);\n\n        case 'bvec4':\n            return booleanArray(4 * size);\n\n        case 'mat2':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import type { Dict } from '../../../../../utils/types';\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nlet GL_TABLE: Dict<string> = null;\n\nconst GL_TO_GLSL_TYPES: Dict<string> = {\n    FLOAT:       'float',\n    FLOAT_VEC2:  'vec2',\n    FLOAT_VEC3:  'vec3',\n    FLOAT_VEC4:  'vec4',\n\n    INT:         'int',\n    INT_VEC2:    'ivec2',\n    INT_VEC3:    'ivec3',\n    INT_VEC4:    'ivec4',\n\n    UNSIGNED_INT:         'uint',\n    UNSIGNED_INT_VEC2:    'uvec2',\n    UNSIGNED_INT_VEC3:    'uvec3',\n    UNSIGNED_INT_VEC4:    'uvec4',\n\n    BOOL:        'bool',\n    BOOL_VEC2:   'bvec2',\n    BOOL_VEC3:   'bvec3',\n    BOOL_VEC4:   'bvec4',\n\n    FLOAT_MAT2:  'mat2',\n    FLOAT_MAT3:  'mat3',\n    FLOAT_MAT4:  'mat4',\n\n    SAMPLER_2D:              'sampler2D',\n    INT_SAMPLER_2D:          'sampler2D',\n    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',\n    SAMPLER_CUBE:              'samplerCube',\n    INT_SAMPLER_CUBE:          'samplerCube',\n    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',\n    SAMPLER_2D_ARRAY:              'sampler2DArray',\n    INT_SAMPLER_2D_ARRAY:          'sampler2DArray',\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',\n};\n\nconst GLSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    float: 'float32',\n    vec2: 'float32x2',\n    vec3: 'float32x3',\n    vec4: 'float32x4',\n\n    int: 'sint32',\n    ivec2: 'sint32x2',\n    ivec3: 'sint32x3',\n    ivec4: 'sint32x4',\n\n    uint: 'uint32',\n    uvec2: 'uint32x2',\n    uvec3: 'uint32x3',\n    uvec4: 'uint32x4',\n\n    bool: 'uint32',\n    bvec2: 'uint32x2',\n    bvec3: 'uint32x3',\n    bvec4: 'uint32x4',\n};\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapType(gl: any, type: number): string\n{\n    if (!GL_TABLE)\n    {\n        const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n\n        GL_TABLE = {};\n\n        for (let i = 0; i < typeNames.length; ++i)\n        {\n            const tn = typeNames[i];\n\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n        }\n    }\n\n    return GL_TABLE[type];\n}\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat\n{\n    const typeValue = mapType(gl, type);\n\n    return GLSL_TO_VERTEX_TYPES[typeValue] || 'float32';\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { mapGlToVertexFormat } from './mapType';\n\nimport type { Attribute } from '../../../shared/geometry/Geometry';\n\n/**\n * This interface represents the extracted attribute data from a WebGL program.\n * It extends the `Attribute` interface but omits the `buffer` property.\n * It includes an optional `location` property that indicates where the shader location is for this attribute.\n * @category rendering\n * @advanced\n */\nexport interface ExtractedAttributeData extends Omit<Attribute, 'buffer'>\n{\n    /** set where the shader location is for this attribute */\n    location?: number;\n}\n\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @param sortAttributes\n * @returns {object} the attribute data for this program\n */\nexport function extractAttributesFromGlProgram(\n    program: WebGLProgram,\n    gl: WebGLRenderingContextBase,\n    sortAttributes = false\n): Record<string, ExtractedAttributeData>\n{\n    const attributes: {[key: string]: ExtractedAttributeData} = {};\n\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let i = 0; i < totalAttributes; i++)\n    {\n        const attribData = gl.getActiveAttrib(program, i);\n\n        // ignore the default ones!\n        if (attribData.name.startsWith('gl_'))\n        {\n            continue;\n        }\n\n        const format = mapGlToVertexFormat(gl, attribData.type);\n\n        attributes[attribData.name] = {\n            location: 0, // set further down..\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    const keys = Object.keys(attributes);\n\n    if (sortAttributes)\n    {\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = i;\n\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n\n        gl.linkProgram(program);\n    }\n    else\n    {\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n        }\n    }\n\n    return attributes;\n}\n", "import type { GlUniformBlockData } from '../GlProgram';\n\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>\n{\n    // if uniform buffer data is not supported, early out\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n\n    const uniformBlocks: Record<string, GlUniformBlockData> = {};\n\n    // const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\n    for (let i = 0; i < totalUniformsBlocks; i++)\n    {\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n\n        uniformBlocks[name] = {\n            name,\n            index: uniformBlockIndex,\n            size,\n        };\n    }\n\n    return uniformBlocks;\n}\n", "import { defaultValue } from './defaultValue';\nimport { mapType } from './mapType';\n\nimport type { GlUniformData } from '../GlProgram';\n\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {[key: string]: GlUniformData}\n{\n    const uniforms: {[key: string]: GlUniformData} = {};\n\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < totalUniforms; i++)\n    {\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, '');\n\n        const isArray = !!(uniformData.name.match(/\\[.*?\\]$/));\n\n        const type = mapType(gl, uniformData.type);\n\n        uniforms[name] = {\n            name,\n            index: i,\n            type,\n            size: uniformData.size,\n            isArray,\n            value: defaultValue(type, uniformData.size),\n        };\n    }\n\n    return uniforms;\n}\n", "/**\n * will log a shader error highlighting the lines with the error\n * also will add numbers along the side.\n * @param gl - the WebGLContext\n * @param shader - the shader to log errors for\n */\nfunction logPrettyShaderError(gl: WebGLRenderingContext, shader: WebGLShader): void\n{\n    const shaderSrc = gl.getShaderSource(shader)\n        .split('\\n')\n        .map((line, index) => `${index}: ${line}`);\n\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split('\\n');\n\n    const dedupe: Record<number, boolean> = {};\n\n    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, '$1')))\n        .filter((n) =>\n        {\n            if (n && !dedupe[n])\n            {\n                dedupe[n] = true;\n\n                return true;\n            }\n\n            return false;\n        });\n\n    const logArgs = [''];\n\n    lineNumbers.forEach((number) =>\n    {\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');\n    });\n\n    const fragmentSourceToLog = shaderSrc\n        .join('\\n');\n\n    logArgs[0] = fragmentSourceToLog;\n\n    console.error(shaderLog);\n\n    // eslint-disable-next-line no-console\n    console.groupCollapsed('click to view full shader code');\n    console.warn(...logArgs);\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n}\n\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram,\n    vertexShader: WebGLShader,\n    fragmentShader: WebGLShader\n): void\n{\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, vertexShader);\n        }\n\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, fragmentShader);\n        }\n\n        console.error('PixiJS Error: Could not initialize shader.');\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('PixiJS Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\n/** @internal */\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\n/** @internal */\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    /** @internal */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    /** @internal */\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_programDataHash');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n        this._shaderSyncFunctions = null;\n        this._activeProgram = null;\n        (this._renderer as null) = null;\n        this._gl = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n\n    public resetState(): void\n    {\n        this._activeProgram = null;\n    }\n}\n", "// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport type { UNIFORM_TYPES } from '../../../shared/shader/types';\n\n/** @internal */\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n};\n\n/** @internal */\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `gl.uniform1fv(location, v);`,\n    'vec2<f32>': `gl.uniform2fv(location, v);`,\n    'vec3<f32>': `gl.uniform3fv(location, v);`,\n    'vec4<f32>': `gl.uniform4fv(location, v);`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    'vec2<i32>': `gl.uniform2iv(location, v);`,\n    'vec3<i32>': `gl.uniform3iv(location, v);`,\n    'vec4<i32>': `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    'vec2<u32>': `gl.uniform2iv(location, v);`,\n    'vec3<u32>': `gl.uniform3iv(location, v);`,\n    'vec4<u32>': `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    'vec2<bool>': `gl.uniform2iv(location, v);`,\n    'vec3<bool>': `gl.uniform3iv(location, v);`,\n    'vec4<bool>': `gl.uniform4iv(location, v);`,\n};\n", "// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param group\n * @param uniformData\n * @internal\n */\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @category rendering\n * @advanced\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @type {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n * @internal\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n\n    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());\n\n    if (isWebGl2)\n    {\n        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n    }\n    else\n    {\n        const ext = gl.getExtension('EXT_blend_minmax');\n\n        if (ext)\n        {\n            blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n            blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n        }\n    }\n\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport { State } from '../../shared/state/State';\nimport { type WebGLRenderer } from '../WebGLRenderer';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @category rendering\n * @advanced\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @type {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @type {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    /**\n     * Whether to invert the front face when rendering\n     * This is used for render textures where the Y-coordinate is flipped\n     * @default false\n     */\n    private _invertFrontFace: boolean = false;\n    private _glFrontFace: boolean;\n    private _cullFace: boolean;\n    private _frontFaceDirty: boolean;\n    private _frontFace: boolean;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n\n        // listen for when the renderTarget changes\n        // as rendering to textures means we need to invert the front face\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        this._invertFrontFace = !renderTarget.isRoot;\n\n        // mini optimization to avoid setting the front face if culling is disabled\n        if (this._cullFace)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n        else\n        {\n            // if culling is disabled, we need to set the front face dirty\n            this._frontFaceDirty = true;\n        }\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        // Reset face culling variables\n\n        this.resetState();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state ||= this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff >>= 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state ||= this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this._cullFace = value;\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n\n        if (this._cullFace && this._frontFaceDirty)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this._frontFace = value;\n        this._frontFaceDirty = false;\n        // If invertFrontFace is true, we invert the face direction\n        const faceMode = this._invertFrontFace ? !value : value;\n\n        if (this._glFrontFace !== faceMode)\n        {\n            this._glFrontFace = faceMode;\n            this.gl.frontFace(this.gl[faceMode ? 'CW' : 'CCW']);\n        }\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    /** Resets all the logic and disables the VAOs. */\n    public resetState(): void\n    {\n        this._glFrontFace = false;\n        this._frontFace = false;\n        this._cullFace = false;\n        this._frontFaceDirty = false;\n        this._invertFrontFace = false;\n\n        this.gl.frontFace(this.gl.CCW);\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n", "import { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @category rendering\n * @ignore\n */\nexport class GlTexture\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n}\n", "import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadBufferImageResource = {\n\n    id: 'buffer',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                source.width,\n                source.height,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\n/** @internal */\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n", "import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth && glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n", "import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n", "/** @internal */\nexport const scaleModeToGlFilter = {\n    linear: 9729,\n    nearest: 9728,\n};\n\n/** @internal */\nexport const mipmapScaleModeToGlFilter = {\n    linear: {\n        linear: 9987,\n        nearest: 9985,\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984,\n    }\n};\n\n/** @internal */\nexport const wrapModeToGlAddress = {\n    'clamp-to-edge': 33071,\n    repeat: 10497,\n    'mirror-repeat': 33648,\n};\n\n/** @internal */\nexport const compareModeToGlCompare = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519,\n};\n\n", "import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\n/**\n * @param style\n * @param gl\n * @param mipmaps\n * @param anisotropicExt\n * @param glFunctionName\n * @param firstParam\n * @param forceClamp\n * @param firstCreation\n * @internal\n */\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n", "import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n", "import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    private _premultiplyAlpha = false;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_glTextures');\n        this._renderer.renderableGC.addManagedHash(this, '_glSamplers');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n        this._premultiplyAlpha = false;\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source ||= Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        if (this._premultiplyAlpha !== premultipliedAlpha)\n        {\n            this._premultiplyAlpha = premultipliedAlpha;\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n        }\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n        this._glTextures = null;\n        this._glSamplers = null;\n        this._boundTextures = null;\n        this._boundSamplers = null;\n        this._mapFormatToInternalFormat = null;\n        this._mapFormatToType = null;\n        this._mapFormatToFormat = null;\n        (this._uploads as null) = null;\n        (this._renderer as null) = null;\n    }\n\n    public resetState(): void\n    {\n        this._activeTextureLocation = -1;\n        this._boundTextures.fill(Texture.EMPTY.source);\n        this._boundSamplers = Object.create(null);\n\n        const gl = this._gl;\n\n        this._premultiplyAlpha = false;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);\n    }\n}\n\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * Interface for creating Application plugins. Any plugin that's usable for Application must implement these methods.\n *\n * To create a plugin:\n * 1. Create a class that implements this interface\n * 2. Add the required static extension property\n * 3. Register the plugin using extensions.add()\n * @example\n * ```ts\n * import { ApplicationPlugin, ExtensionType, extensions } from 'pixi.js';\n *\n * class MyPlugin {\n *    // Required: Declare the extension type\n *    public static extension = ExtensionType.Application;\n *\n *    // Required: Implement init method\n *    public static init(options: Partial<ApplicationOptions>): void {\n *        // Add properties/methods to the Application instance (this)\n *        Object.defineProperty(this, 'myFeature', {\n *            value: () => console.log('My feature!'),\n *        });\n *\n *        // Use options if needed\n *        console.log('Plugin initialized with:', options);\n *    }\n *\n *    // Required: Implement destroy method\n *    public static destroy(): void {\n *        // Clean up any resources\n *        console.log('Plugin destroyed');\n *    }\n * }\n *\n * // Register the plugin\n * extensions.add(MyPlugin);\n *\n * // Usage in application\n * const app = new Application();\n * await app.init();\n * app.myFeature(); // Output: \"My feature!\"\n * ```\n * > [!IMPORTANT]\n * > - Plugins are initialized in the order they are added\n * > - Plugins are destroyed in reverse order\n * > - The `this` context in both methods refers to the Application instance\n * @see {@link ExtensionType} For different types of extensions\n * @see {@link extensions} For the extension registration system\n * @see {@link ApplicationOptions} For available application options\n * @category app\n * @advanced\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link Application#init} method.\n * These options configure how your PixiJS application behaves.\n * @category app\n * @standard\n * @example\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * // Initialize with common options\n * await app.init({\n *    // Rendering options\n *    width: 800,                    // Canvas width\n *    height: 600,                   // Canvas height\n *    backgroundColor: 0x1099bb,     // Background color\n *    antialias: true,              // Enable antialiasing\n *    resolution: window.devicePixelRatio, // Screen resolution\n *\n *    // Performance options\n *    autoStart: true,              // Auto-starts the render loop\n *    sharedTicker: true,           // Use shared ticker for better performance\n *\n *    // Automatic resize options\n *    resizeTo: window,             // Auto-resize to window\n *    autoDensity: true,           // Adjust for device pixel ratio\n *\n *    // Advanced options\n *    preference: 'webgl',         // Renderer preference ('webgl' or 'webgpu')\n *    powerPreference: 'high-performance' // GPU power preference\n * });\n * ```\n * @see {@link WebGLOptions} For resize-related options\n * @see {@link WebGPUOptions} For resize-related options\n * @see {@link TickerPlugin} For ticker-related options\n * @see {@link ResizePlugin} For resize-related options\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * The Application class is the main entry point for creating a PixiJS application. It handles the setup of all core\n * components needed to start rendering and managing your game or interactive experience.\n *\n * Key features:\n * - Automatically creates and manages the renderer\n * - Provides a stage (root container) for your display objects\n * - Handles canvas creation and management\n * - Supports plugins for extending functionality\n *   - {@link ResizePlugin} for automatic resizing\n *   - {@link TickerPlugin} for managing frame updates\n *   - {@link CullerPlugin} for culling off-screen objects\n * @example\n * ```js\n * import { Assets, Application, Sprite } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n *\n * // Initialize with options\n * await app.init({\n *     width: 800,           // Canvas width\n *     height: 600,          // Canvas height\n *     backgroundColor: 0x1099bb, // Background color\n *     antialias: true,     // Enable antialiasing\n *     resolution: 1,       // Resolution / device pixel ratio\n *     preference: 'webgl', // or 'webgpu' // Renderer preference\n * });\n *\n * // Add the canvas to your webpage\n * document.body.appendChild(app.canvas);\n *\n * // Start adding content to your application\n * const texture - await Assets.load('your-image.png');\n * const sprite = new Sprite(texture);\n * app.stage.addChild(sprite);\n * ```\n * > [!IMPORTANT] From PixiJS v8.0.0, the application must be initialized using the async `init()` method\n * > rather than passing options to the constructor.\n * @category app\n * @standard\n * @see {@link ApplicationOptions} For all available initialization options\n * @see {@link Container} For information about the stage container\n * @see {@link Renderer} For details about the rendering system\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @internal\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /**\n     * The root display container for your application.\n     * All visual elements should be added to this container or its children.\n     * @example\n     * ```js\n     * // Create a sprite and add it to the stage\n     * const sprite = Sprite.from('image.png');\n     * app.stage.addChild(sprite);\n     *\n     * // Create a container for grouping objects\n     * const container = new Container();\n     * app.stage.addChild(container);\n     * ```\n     */\n    public stage: Container = new Container();\n\n    /**\n     * The renderer instance that handles all drawing operations.\n     *\n     * Unless specified, it will automatically create a WebGL renderer if available.\n     * If WebGPU is available and the `preference` is set to `webgpu`, it will create a WebGPU renderer.\n     * @example\n     * ```js\n     * // Create a new application\n     * const app = new Application();\n     * await app.init({\n     *     width: 800,\n     *     height: 600,\n     *     preference: 'webgl', // or 'webgpu'\n     * });\n     *\n     * // Access renderer properties\n     * console.log(app.renderer.width, app.renderer.height);\n     * ```\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * Initializes the PixiJS application with the specified options.\n     *\n     * This method must be called after creating a new Application instance.\n     * @param options - Configuration options for the application and renderer\n     * @returns A promise that resolves when initialization is complete\n     * @example\n     * ```js\n     * const app = new Application();\n     *\n     * // Initialize with custom options\n     * await app.init({\n     *     width: 800,\n     *     height: 600,\n     *     backgroundColor: 0x1099bb,\n     *     preference: 'webgl', // or 'webgpu'\n     * });\n     * ```\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /**\n     * Renders the current stage to the screen.\n     *\n     * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call\n     * this method directly as rendering is handled automatically.\n     *\n     * Only use this method if you've disabled the {@link TickerPlugin} or need custom\n     * render timing control.\n     * @example\n     * ```js\n     * // Example 1: Default setup (TickerPlugin handles rendering)\n     * const app = new Application();\n     * await app.init();\n     * // No need to call render() - TickerPlugin handles it\n     *\n     * // Example 2: Custom rendering loop (if TickerPlugin is disabled)\n     * const app = new Application();\n     * await app.init({ autoStart: false }); // Disable automatic rendering\n     *\n     * function animate() {\n     *     app.render();\n     *     requestAnimationFrame(animate);\n     * }\n     * animate();\n     * ```\n     */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element. This is the HTML element\n     * that displays your application's graphics.\n     * @readonly\n     * @type {HTMLCanvasElement}\n     * @example\n     * ```js\n     * // Create a new application\n     * const app = new Application();\n     * // Initialize the application\n     * await app.init({...});\n     * // Add canvas to the page\n     * document.body.appendChild(app.canvas);\n     *\n     * // Access the canvas directly\n     * console.log(app.canvas); // HTMLCanvasElement\n     * ```\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @type {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     * @see {@link Application#canvas}\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. This represents the visible area of your application.\n     *\n     * It's commonly used for:\n     * - Setting filter areas for full-screen effects\n     * - Defining hit areas for screen-wide interaction\n     * - Determining the visible bounds of your application\n     * @readonly\n     * @example\n     * ```js\n     * // Use as filter area for a full-screen effect\n     * const blurFilter = new BlurFilter();\n     * sprite.filterArea = app.screen;\n     *\n     * // Use as hit area for screen-wide interaction\n     * const screenSprite = new Sprite();\n     * screenSprite.hitArea = app.screen;\n     *\n     * // Get screen dimensions\n     * console.log(app.screen.width, app.screen.height);\n     * ```\n     * @see {@link Rectangle} For all available properties and methods\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     *\n     * This method should be called when you want to completely\n     * clean up the application and free all associated memory.\n     * @param rendererDestroyOptions - Options for destroying the renderer:\n     *  - `false` or `undefined`: Preserves the canvas element (default)\n     *  - `true`: Removes the canvas element\n     *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal\n     * @param options - Options for destroying the application:\n     *  - `false` or `undefined`: Basic cleanup (default)\n     *  - `true`: Complete cleanup including children\n     *  - Detailed options object:\n     *    - `children`: Remove children\n     *    - `texture`: Destroy textures\n     *    - `textureSource`: Destroy texture sources\n     *    - `context`: Destroy WebGL context\n     * @example\n     * ```js\n     * // Basic cleanup\n     * app.destroy();\n     *\n     * // Remove canvas and do complete cleanup\n     * app.destroy(true, true);\n     *\n     * // Remove canvas with explicit options\n     * app.destroy({ removeView: true }, true);\n     *\n     * // Detailed cleanup with specific options\n     * app.destroy(\n     *     { removeView: true },\n     *     {\n     *         children: true,\n     *         texture: true,\n     *         textureSource: true,\n     *         context: true\n     *     }\n     * );\n     * ```\n     * > [!WARNING] After calling destroy, the application instance should no longer be used.\n     * > All properties will be null and further operations will throw errors.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n", "import { groupD8 } from '../../maths/matrix/groupD8';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont. Used when loading or creating bitmap fonts from existing textures and data.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     // Font data containing character metrics and layout info\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *             // ... other characters\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         // Optional distance field info for MSDF/SDF fonts\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     // Array of textures containing the font glyphs\n *     textures: [\n *         Texture.from('font.png')\n *     ]\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontOptions\n{\n    /**\n     * The bitmap font data containing character metrics, layout information,\n     * and font properties. This includes character positions, dimensions,\n     * kerning data, and general font settings.\n     */\n    data: BitmapFontData;\n\n    /**\n     * Array of textures containing the font glyphs. Each texture corresponds\n     * to a page in the font data. For simple fonts this is typically just\n     * one texture, but complex fonts may split glyphs across multiple textures.\n     */\n    textures: Texture[];\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * This class handles both pre-loaded bitmap fonts and dynamically generated ones.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     textures: [Texture.from('font.png')]\n * });\n *\n * // Install a font for global use\n * BitmapFont.install({\n *     name: 'MyCustomFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ffffff',\n *         stroke: { color: '#000000', width: 2 }\n *     }\n * });\n *\n * // Uninstall when no longer needed\n * BitmapFont.uninstall('MyCustomFont');\n * ```\n * @category text\n * @standard\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /**\n     * The URL from which the font was loaded, if applicable.\n     * This is useful for tracking font sources and reloading.\n     * @example\n     * ```ts\n     * console.log(font.url); // 'fonts/myFont.fnt'\n     * ```\n     */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n                rotate: textureRotate,\n            } = textures[charData.page];\n\n            // Transform character coordinates based on texture rotation\n            const frame = groupD8.transformRectCoords(\n                charData,\n                textureFrame,\n                textureRotate,\n                new Rectangle()\n            );\n\n            const texture = new Texture({\n                frame,\n                orig: new Rectangle(0, 0, charData.width, charData.height),\n                source: textureSource,\n                rotate: textureRotate,\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates and installs a bitmap font with the specified options.\n     * The font will be cached and available for use in BitmapText objects.\n     * @param options - Setup options for font generation\n     * @returns Installed font instance\n     * @example\n     * ```ts\n     * // Install a basic font\n     * BitmapFont.install({\n     *     name: 'Title',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: '#ffffff'\n     *     }\n     * });\n     *\n     * // Install with advanced options\n     * BitmapFont.install({\n     *     name: 'Custom',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: '#00ff00',\n     *         stroke: { color: '#000000', width: 2 }\n     *     },\n     *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n     *     resolution: 2,\n     *     padding: 4,\n     *     textureStyle: {\n     *         scaleMode: 'nearest'\n     *     }\n     * });\n     * ```\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * This frees up memory and resources associated with the font.\n     * @param name - The name of the bitmap font to uninstall\n     * @example\n     * ```ts\n     * // Remove a font when it's no longer needed\n     * BitmapFont.uninstall('MyCustomFont');\n     *\n     * // Clear multiple fonts\n     * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n     * ```\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\n/** @internal */\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/** @internal */\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\n/** @internal */\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n", "import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { CacheParser } from '../../../assets/cache/CacheParser';\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParserAdvanced } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/**\n * simple loader plugin for loading in bitmap fonts!\n * @category assets\n * @internal\n */\nexport const bitmapFontCachePlugin = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheBitmapFont',\n    },\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n} satisfies CacheParser<BitmapFont>;\n\n/**\n * Loader plugin for loading bitmap fonts.\n * It supports both XML and text formats, and can handle distance field fonts.\n * @category assets\n * @advanced\n */\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadBitmapFont',\n    id: 'bitmap-font',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        // if we have a distance field - we can assume this is a signed distance field font\n        // and we should use force linear filtering and no alpha premultiply\n        const textureOptions = (bitmapFontData.distanceField) ? {\n            scaleMode: 'linear',\n            alphaMode: 'premultiply-alpha-on-upload',\n            autoGenerateMipmaps: false,\n            resolution: 1,\n        } : {};\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url.src]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} satisfies LoaderParserAdvanced<string, BitmapFont, BitmapFont>;\n", "import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * The BackgroundLoader handles loading assets passively in the background to prepare them for future use.\n * It loads one asset at a time to minimize impact on application performance.\n *\n * Key features:\n * - Sequential loading of assets\n * - Automatic pause when high-priority loads occur\n * - Configurable concurrency\n * @example\n * ```ts\n * import { Assets } from 'pixi.js';\n *\n * // Background load level assets while in menu\n * Assets.backgroundLoad([\n *     'level1/background.png',\n *     'level1/sprites.json',\n *     'level1/music.mp3'\n * ]);\n *\n * // Assets will be instantly available when needed\n * const assets = await Assets.load([\n *     'level1/background.png',\n *     'level1/sprites.json'\n * ]);\n *\n * // Background load bundles\n * Assets.backgroundLoadBundle('level2');\n *\n * // Later, instant access\n * const level2 = await Assets.loadBundle('level2');\n * ```\n * > [!NOTE] You typically do not need to use this class directly. Use the main {@link Assets.backgroundLoad} API instead.\n * @remarks\n * - Background loading is automatically paused when `Assets.load()` is called\n * - Assets are loaded sequentially to minimize performance impact\n * - Assets are cached as they complete loading\n * - No progress tracking is available for background loading\n * @see {@link Assets.backgroundLoad} For the main background loading API\n * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n * @category assets\n * @advanced\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /**\n     * Should the loader log to the console.\n     * @advanced\n     */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds assets to the background loading queue. Assets are loaded one at a time to minimize\n     * performance impact.\n     * @param assetUrls - Array of resolved assets to load in the background\n     * @example\n     * ```ts\n     * // Add assets to background load queue\n     * backgroundLoader.add([\n     *     { src: 'images/level1/bg.png' },\n     *     { src: 'images/level1/characters.json' }\n     * ]);\n     *\n     * // Assets will load sequentially in the background\n     * // The loader automatically pauses when high-priority loads occur\n     * // e.g. Assets.load() is called\n     * ```\n     * @remarks\n     * - Assets are loaded one at a time to minimize performance impact\n     * - Loading automatically pauses when Assets.load() is called\n     * - No progress tracking is available for background loading\n     * - Assets are cached as they complete loading\n     * @internal\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Controls the active state of the background loader. When active, the loader will\n     * continue processing its queue. When inactive, loading is paused.\n     * @returns Whether the background loader is currently active\n     * @example\n     * ```ts\n     * // Pause background loading\n     * backgroundLoader.active = false;\n     *\n     * // Resume background loading\n     * backgroundLoader.active = true;\n     *\n     * // Check current state\n     * console.log(backgroundLoader.active); // true/false\n     *\n     * // Common use case: Pause during intensive operations\n     * backgroundLoader.active = false;  // Pause background loading\n     * ... // Perform high-priority tasks\n     * backgroundLoader.active = true;   // Resume background loading\n     * ```\n     * @remarks\n     * - Setting to true resumes loading immediately\n     * - Setting to false pauses after current asset completes\n     * - Background loading is automatically paused during `Assets.load()`\n     * - Assets already being loaded will complete even when set to false\n     */\n    public get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @category assets\n * @internal\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n", "/**\n * @param imageData\n * @internal\n */\nexport async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            // eslint-disable-next-line no-restricted-globals\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (_e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @category assets\n * @internal\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @category assets\n * @internal\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n", "/* eslint-disable no-restricted-globals */\nconst inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\n/**\n * @param mimeType\n * @internal\n */\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @category assets\n * @internal\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @category assets\n * @internal\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @category assets\n * @internal\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @category assets\n * @internal\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Loader\n{\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.parser || data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.parser || data.loadParser];\n\n                // #if _DEBUG\n                if (data.loadParser)\n                {\n                    warn(\n                        `[Assets] \"loadParser\" is deprecated, use \"parser\" instead for ${url}`\n                    );\n                }\n                // #endif\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    warn(\n                        `[Assets] specified load parser \"${data.parser || data.loadParser}\" not found while loading ${url}`\n                    );\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: (progress: number) => void,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name || parser.id)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name && !parser.id)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser should have an id`);\n                    // #endif\n                }\n                else if (hash[parser.name] || hash[parser.id])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser id conflict \"${parser.id}\"`);\n                    // #endif\n                }\n\n                // add both name and id to the hash\n                hash[parser.name] = parser;\n                if (parser.id) hash[parser.id] = parser;\n\n                return hash;\n            }, {} as Record<string, LoaderParser>);\n    }\n}\n", "/**\n * @param url\n * @param mimes\n * @internal\n */\nexport function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n", "import { path } from '../../utils/path';\n\n/**\n * @param url\n * @param extension\n * @internal\n */\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadJson',\n    id: 'json',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @category assets\n * @advanced\n */\nexport const loadTxt = {\n\n    /** used for deprecation purposes */\n    name: 'loadTxt',\n    id: 'text',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Cache for font faces\n * @internal\n */\nexport interface FontFaceCache\n{\n    entries: {url: string, faces: FontFace[]}[]\n}\n\n/**\n * Data for loading a font\n * @category assets\n * @advanced\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @category assets\n * @internal\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @category assets\n * @advanced\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadWebFont',\n    id: 'web-font',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            if (Cache.has(`${name}-and-url`))\n            {\n                const cached = Cache.get<FontFaceCache>(`${name}-and-url`);\n\n                // If the URL is already cached, we just add the new font faces to the existing cache\n                cached.entries.push({ url, faces: fontFaces });\n            }\n            else\n            {\n                Cache.set<FontFaceCache>(`${name}-and-url`, {\n                    entries: [{ url, faces: fontFaces }],\n                });\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        const fonts = Array.isArray(font) ? font : [font];\n\n        // you can only load 1 family at a time, so we can use the first one\n        const fontFamily = fonts[0].family;\n        const cached = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n\n        // find the entry that contains the font faces we want to remove\n        const entry = cached.entries.find((f) => f.faces.some((t) => fonts.indexOf(t) !== -1));\n\n        // remove the font faces from the cache\n        entry.faces = entry.faces.filter((f) => fonts.indexOf(f) === -1);\n\n        // if faces are empty, remove the entry\n        if (entry.faces.length === 0)\n        {\n            cached.entries = cached.entries.filter((f) => f !== entry);\n        }\n\n        // finally remove the font faces from the FontFaceSet\n        fonts.forEach((t) =>\n        {\n            DOMAdapter.get().getFontFaceSet().delete(t);\n        });\n\n        // Clean up cache if no entries remain\n        if (cached.entries.length === 0)\n        {\n            Cache.remove(`${fontFamily}-and-url`);\n        }\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n", "import { Resolver } from '../../assets/resolver/Resolver';\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @category utils\n * @internal\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue = 1): number\n{\n    const resolution = Resolver.RETINA_PREFIX?.exec(url);\n\n    if (resolution)\n    {\n        return parseFloat(resolution[1]);\n    }\n\n    return defaultValue;\n}\n", "import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the {@link loadSvg} plugin.\n * @see loadSvg\n * @category assets\n * @advanced\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadSVG',\n    id: 'svg',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: ImageLike['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const image = DOMAdapter.get().createImage();\n\n    image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    // convert to canvas...\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    // Ensure canvas dimensions are integers to prevent edge trimming\n    const canvasWidth = Math.ceil(width * resolution);\n    const canvasHeight = Math.ceil(height * resolution);\n\n    const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);\n    const context = canvas.getContext('2d');\n\n    // Improve rendering quality for decimal resolutions\n    context.imageSmoothingEnabled = true;\n    context.imageSmoothingQuality = 'high';\n\n    // Draw image with exact scaled dimensions to prevent trimming\n    context.drawImage(image as CanvasImageSource, 0, 0, width * resolution, height * resolution);\n\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n", "import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\n/** @internal */\nclass WorkerManagerClass\n{\n    /**\n     * Hash map storing resolve/reject functions for pending worker requests.\n     * Keyed by UUID to match responses with their corresponding promises.\n     */\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    /** Pool of available workers ready for use */\n    private readonly _workerPool: Worker[];\n    /** Queue of pending work items waiting for available workers */\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n\n    /** Whether the worker manager has been initialized */\n    private _initialized = false;\n\n    /** Current number of created workers (used to enforce MAX_WORKERS limit) */\n    private _createdWorkers = 0;\n    /** Cached promise for ImageBitmap support check */\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    /**\n     * Checks if ImageBitmap is supported in the current environment.\n     *\n     * This method uses a dedicated worker to test ImageBitmap support\n     * and caches the result for subsequent calls.\n     * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise\n     */\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    /**\n     * Loads an image as an ImageBitmap using a web worker.\n     * @param src - The source URL or path of the image to load\n     * @param asset - Optional resolved asset containing additional texture source options\n     * @returns Promise that resolves to the loaded ImageBitmap\n     * @example\n     * ```typescript\n     * const bitmap = await WorkerManager.loadImageBitmap('image.png');\n     * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);\n     * ```\n     */\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    /**\n     * Initializes the worker pool if not already initialized.\n     * Currently a no-op but reserved for future initialization logic.\n     */\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    /**\n     * Gets an available worker from the pool or creates a new one if needed.\n     *\n     * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).\n     * Each worker is configured with a message handler for processing results.\n     * @returns Available worker or undefined if pool is at capacity and no workers are free\n     */\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    /**\n     * Returns a worker to the pool after completing a task.\n     * @param worker - The worker to return to the pool\n     */\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    /**\n     * Handles completion of a worker task by resolving or rejecting the corresponding promise.\n     * @param data - Result data from the worker containing uuid, data, and optional error\n     */\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    /**\n     * Executes a task using the worker pool system.\n     *\n     * Queues the task and processes it when a worker becomes available.\n     * @param id - Identifier for the type of task to run\n     * @param args - Arguments to pass to the worker\n     * @returns Promise that resolves with the worker's result\n     */\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    /**\n     * Processes the next item in the queue if workers are available.\n     *\n     * This method is called after worker initialization and when workers\n     * complete tasks to continue processing the queue.\n     */\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n\n    /**\n     * Resets the worker manager, terminating all workers and clearing the queue.\n     *\n     * This method:\n     * - Terminates all active workers\n     * - Rejects all pending promises with an error\n     * - Clears all internal state\n     * - Resets initialization flags\n     *\n     * This should be called when the worker manager is no longer needed\n     * to prevent memory leaks and ensure proper cleanup.\n     * @example\n     * ```typescript\n     * // Clean up when shutting down\n     * WorkerManager.reset();\n     * ```\n     */\n    public reset(): void\n    {\n        // Terminate all workers\n        this._workerPool.forEach((worker) => worker.terminate());\n        this._workerPool.length = 0;\n\n        // Reject pending promises\n        Object.values(this._resolveHash).forEach(({ reject }) =>\n        {\n            reject?.(new Error('WorkerManager destroyed'));\n        });\n        this._resolveHash = {};\n        this._queue.length = 0;\n\n        this._initialized = false;\n        this._createdWorkers = 0;\n    }\n}\n\n/**\n * Manages a pool of web workers for loading ImageBitmap objects asynchronously.\n *\n * This class provides a thread-safe way to load images using web workers,\n * automatically managing worker creation, pooling, and cleanup. It supports\n * checking ImageBitmap support and queuing multiple load requests.\n *\n * > [!IMPORTANT] You should not need to use this class directly\n * > However, you can call `WorkerManager.reset()` to clean up all workers when they are no longer needed.\n * @category Assets\n * @advanced\n */\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link loadTextures} plugin.\n * @see loadTextures\n * @category assets\n * @advanced\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @category assets\n * @advanced\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    /** used for deprecation purposes */\n    name: 'loadTextures',\n    id: 'texture',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve, reject) =>\n            {\n                src = DOMAdapter.get().createImage();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                    src.onerror = reject;\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n", "/* eslint-disable no-restricted-globals */\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { testVideoFormat } from '../../../detections/utils/testVideoFormat';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst potentialVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nlet validVideoExtensions: string[];\nlet validVideoMIMEs: string[];\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @category assets\n * @advanced\n */\nexport function crossOrigin(element: ImageLike | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n * @internal\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @category assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\ntype LoadVideoData = VideoSourceOptions & {\n    mime?: string;\n};\n\n/**\n * Get the supported video extensions and MIME types based on the browser's capabilities.\n * This function checks the potential video extensions against the browser's supported formats.\n * @returns An object containing valid video extensions and MIME types.\n * @internal\n */\nfunction getBrowserSupportedVideoExtensions()\n{\n    const supportedExtensions: string[] = [];\n    const supportedMimes: string[] = [];\n\n    for (const ext of potentialVideoExtensions)\n    {\n        const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;\n\n        if (testVideoFormat(mimeType))\n        {\n            supportedExtensions.push(ext);\n            if (!supportedMimes.includes(mimeType))\n            {\n                supportedMimes.push(mimeType);\n            }\n        }\n    }\n\n    return {\n        validVideoExtensions: supportedExtensions,\n        validVideoMime: supportedMimes\n    };\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Assets.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @category assets\n * @advanced\n */\nexport const loadVideoTextures = {\n\n    /** used for deprecation purposes */\n    name: 'loadVideo',\n    id: 'video',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        if (!validVideoExtensions || !validVideoMIMEs)\n        {\n            const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();\n\n            validVideoExtensions = ve;\n            validVideoMIMEs = vm;\n        }\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<LoadVideoData>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: LoadVideoData = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (options.mime)\n        {\n            mime = options.mime;\n        }\n        else if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            if (options.preload && !options.autoPlay)\n            {\n                videoElement.load();\n            }\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, LoadVideoData>;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @category assets\n * @internal\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @category assets\n * @internal\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n", "/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * ```ts\n * // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n * ```\n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n * @category assets\n * @standard\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @advanced\n * @category assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n * @category assets\n * @standard\n */\nexport interface AssetInitOptions\n{\n    /**\n     * Base path prepended to all asset URLs. Useful for CDN hosting.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/'\n     * });\n     *\n     * // Now you can load assets like this:\n     * // Will load from: https://my-cdn.com/assets/images/sprite.png\n     * const texture = await Assets.load('images/sprite.png');\n     * ```\n     */\n    basePath?: string;\n\n    /**\n     * URL parameters to append to all asset URLs.\n     * Useful for cache-busting or version control.\n     * @example\n     * ```ts\n     * // As a string\n     * await Assets.init({\n     *     defaultSearchParams: 'version=1.0.0'\n     * });\n     *\n     * // As an object\n     * await Assets.init({\n     *     defaultSearchParams: {\n     *         version: '1.0.0',\n     *         t: Date.now()\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * A manifest defining all your application's assets.\n     * Can be a URL to a JSON file or a manifest object.\n     * @example\n     * ```ts\n     * // Using a manifest object\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}'\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Using a URL to manifest\n     * await Assets.init({\n     *     manifest: 'assets/manifest.json'\n     * });\n     *\n     * // loading a bundle from the manifest\n     * await Assets.loadBundle('game-screen');\n     *\n     * // load individual assets from the manifest\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * Configure texture loading preferences.\n     * Useful for optimizing asset delivery based on device capabilities.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     texturePreference: {\n     *         // Prefer high-res textures on retina displays\n     *         resolution: window.devicePixelRatio,\n     *\n     *         // Prefer modern formats, fallback to traditional\n     *         format: ['avif', 'webp', 'png']\n     *     }\n     * });\n     * ```\n     */\n    texturePreference?: {\n        /** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n        resolution?: number | number[];\n\n        /** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * Skip browser format detection for faster initialization.\n     * Only use if you know exactly what formats your target browsers support.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     skipDetections: true,\n     *     texturePreference: {\n     *         format: ['webp', 'png'] // Must explicitly set formats\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    skipDetections?: boolean;\n\n    /**\n     * Override how bundle IDs are generated and resolved.\n     *\n     * This allows you to customize how assets are grouped and accessed via bundles and allow for\n     * multiple bundles to share the same asset keys.\n     * @advanced\n     * @example\n     * ```ts\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'bunny1',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny.png',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'bunny2',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny-2.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * const bundleIdentifier: BundleIdentifierOptions = {\n     *     connector: ':',\n     * };\n     *\n     * await Assets.init({ manifest, basePath, bundleIdentifier });\n     *\n     * const resources = await Assets.loadBundle('bunny1');\n     * const resources2 = await Assets.loadBundle('bunny2');\n     *\n     * console.log(resources.character === resources2.character); // false\n     * ```\n     */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /**\n     * Optional preferences for asset loading behavior.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *         parseAsGraphicsContext: false\n     *     }\n     * });\n     * ```\n     */\n    preferences?: Partial<AssetsPreferences>;\n}\n\n/** @internal */\nexport class AssetsClass\n{\n    /**\n     * The URL resolver for assets. Maps various asset keys and URLs to their final loadable form.\n     * @advanced\n     */\n    public resolver: Resolver;\n    /**\n     *  The loader responsible for loading all assets. Handles different file types\n     * and transformations.\n     * @advanced\n     */\n    public loader: Loader;\n    /**\n     * The global cache for all loaded assets. Manages storage and retrieval of\n     * processed assets.\n     * @example\n     * ```ts\n     * // Check if an asset is cached\n     * if (Assets.cache.has('myTexture')) {\n     *     const texture = Assets.cache.get('myTexture');\n     * }\n     * ```\n     * @see {@link Cache} For detailed cache documentation\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Initializes the Assets class with configuration options. While not required,\n     * calling this before loading assets is recommended to set up default behaviors.\n     * @param options - Configuration options for the Assets system\n     * @example\n     * ```ts\n     * // Basic initialization (optional as Assets.load will call this automatically)\n     * await Assets.init();\n     *\n     * // With CDN configuration\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/',\n     *     defaultSearchParams: { version: '1.0.0' }\n     * });\n     *\n     * // With manifest and preferences\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}',\n     *                     data: { scaleMode: SCALE_MODES.NEAREST }\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     },\n     *     // Optimize for device capabilities\n     *     texturePreference: {\n     *         resolution: window.devicePixelRatio,\n     *         format: ['webp', 'png']\n     *     },\n     *     // Set global preferences\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *     }\n     * });\n     *\n     * // Load assets after initialization\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     * @remarks\n     * - Can be called only once; subsequent calls will be ignored with a warning\n     * - Format detection runs automatically unless `skipDetections` is true\n     * - The manifest can be a URL to a JSON file or an inline object\n     * @see {@link AssetInitOptions} For all available initialization options\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n    }\n\n    /**\n     * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n     * allowing you to load assets using friendly names instead of direct URLs.\n     * @param assets - The unresolved assets to add to the resolver\n     * @example\n     * ```ts\n     * // Basic usage - single asset\n     * Assets.add({\n     *     alias: 'myTexture',\n     *     src: 'assets/texture.png'\n     * });\n     * const texture = await Assets.load('myTexture');\n     *\n     * // Multiple aliases for the same asset\n     * Assets.add({\n     *     alias: ['hero', 'player'],\n     *     src: 'hero.png'\n     * });\n     * const hero1 = await Assets.load('hero');\n     * const hero2 = await Assets.load('player'); // Same texture\n     *\n     * // Multiple format support\n     * Assets.add({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     * Assets.add({\n     *     alias: 'character',\n     *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n     * });\n     *\n     * // With texture options\n     * Assets.add({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: { scaleMode: 'nearest' }\n     * });\n     *\n     * // Multiple assets at once\n     * Assets.add([\n     *     { alias: 'bg', src: 'background.png' },\n     *     { alias: 'music', src: 'music.mp3' },\n     *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n     * ]);\n     * ```\n     * @remarks\n     * - Assets are resolved when loaded, not when added\n     * - Multiple formats use the best available format for the browser\n     * - Adding with same alias overwrites previous definition\n     * - The `data` property is passed to the asset loader\n     * @see {@link Resolver} For details on asset resolution\n     * @see {@link LoaderParser} For asset-specific data options\n     * @advanced\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads one or more assets and returns a promise that resolves with the loaded content.\n     * Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching.\n     * @param urls - Single URL/alias or array of URLs/aliases to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with loaded asset(s)\n     * @example\n     * ```ts\n     * // Load a single asset\n     * const texture = await Assets.load('images/sprite.png');\n     *\n     * // Load using an alias\n     * const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' });\n     *\n     * // Load multiple assets\n     * const assets = await Assets.load([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'fonts/game.fnt'\n     * ]);\n     * console.log(assets['images/background.png']); // Access by URL\n     *\n     * // Load with progress tracking\n     * const textures = await Assets.load(['sprite1.png', 'sprite2.png'],\n     *     (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`)\n     * );\n     *\n     * // Load with format preference\n     * const characterTexture = await Assets.load({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     *\n     * // Load with custom options\n     * const spriteTexture = await Assets.load({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: {\n     *         scaleMode: SCALE_MODES.NEAREST,\n     *         mipmap: MIPMAP_MODES.ON\n     *     }\n     * });\n     *\n     * // Load with a specific loader, can be useful if your asset does not have an extension\n     * const image = await Assets.load({\n     *    alias: 'imageWithoutExtension',\n     *    src: 'images/imageWithoutExtension',\n     *    parser: 'texture' // Use the JSON loader\n     * });\n     * ```\n     * @remarks\n     * - Assets are cached automatically to prevent duplicate loading\n     * - URLs are resolved to the best format for the current browser\n     * - Asset types are detected automatically based on file extension\n     * - Progress callback receives values from 0.0 to 1.0\n     * - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension.\n     * @throws {Error} If the asset cannot be loaded or parsed\n     * @see {@link Assets.add} For registering assets with aliases\n     * @see {@link Assets.backgroundLoad} For loading assets in the background\n     * @see {@link Assets.unload} For releasing loaded assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n     * assets into logical groups, such as game levels or UI screens.\n     * @param bundleId - Unique identifier for the bundle\n     * @param assets - Assets to include in the bundle\n     * @example\n     * ```ts\n     * // Add a bundle using array format\n     * Assets.addBundle('animals', [\n     *     { alias: 'bunny', src: 'bunny.png' },\n     *     { alias: 'chicken', src: 'chicken.png' },\n     *     { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     *\n     * // Add a bundle using object format\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * // Add a bundle with advanced options\n     * Assets.addBundle('ui', [\n     *     {\n     *         alias: 'button',\n     *         src: 'button.{webp,png}',\n     *         data: { scaleMode: 'nearest' }\n     *     },\n     *     {\n     *         alias: ['logo', 'brand'],  // Multiple aliases\n     *         src: 'logo.svg',\n     *         data: { resolution: 2 }\n     *     }\n     * ]);\n     *\n     * // Load the bundle\n     * await Assets.loadBundle('animals');\n     *\n     * // Use the loaded assets\n     * const bunny = Sprite.from('bunny');\n     * const chicken = Sprite.from('chicken');\n     * ```\n     * @remarks\n     * - Bundle IDs must be unique\n     * - Assets in bundles are not loaded until `loadBundle` is called\n     * - Bundles can be background loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be loaded individually using their aliases\n     * @see {@link Assets.loadBundle} For loading bundles\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n     * that can be loaded together.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with the loaded bundle assets\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * // Initialize with manifest\n     * await Assets.init({ manifest });\n     *\n     * // Or add bundles programmatically\n     * Assets.addBundle('load-screen', [...]);\n     * Assets.loadBundle('load-screen');\n     *\n     * // Load a single bundle\n     * await Assets.loadBundle('load-screen');\n     * const bg = Sprite.from('background'); // Uses alias from bundle\n     *\n     * // Load multiple bundles\n     * await Assets.loadBundle([\n     *     'load-screen',\n     *     'game-screen'\n     * ]);\n     *\n     * // Load with progress tracking\n     * await Assets.loadBundle('game-screen', (progress) => {\n     *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n     * });\n     * ```\n     * @remarks\n     * - Bundle assets are cached automatically\n     * - Bundles can be pre-loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be accessed by their aliases\n     * - Progress callback receives values from 0.0 to 1.0\n     * @throws {Error} If the bundle ID doesn't exist in the manifest\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n            const values = Object.values(resolveResult);\n            const totalAssetsToLoad = [...new Set(values.flat())] as ResolvedAsset[];\n\n            total += totalAssetsToLoad.length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n     * continue, making them instantly available when needed later.\n     *\n     * Background loading is useful for:\n     * - Preloading game levels while in a menu\n     * - Loading non-critical assets during gameplay\n     * - Reducing visible loading screens\n     * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n     * @example\n     * ```ts\n     * // Basic background loading\n     * Assets.backgroundLoad('images/level2-assets.png');\n     *\n     * // Background load multiple assets\n     * Assets.backgroundLoad([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png',\n     *     'images/background.png'\n     * ]);\n     *\n     * // Later, when you need the assets\n     * const textures = await Assets.load([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png'\n     * ]); // Resolves immediately if background loading completed\n     * ```\n     * @remarks\n     * - Background loading happens one asset at a time to avoid blocking the main thread\n     * - Loading can be interrupted safely by calling `Assets.load()`\n     * - Assets are cached as they complete loading\n     * - No progress tracking is available for background loading\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n     * predefined bundles of assets.\n     *\n     * Perfect for:\n     * - Preloading level bundles during gameplay\n     * - Loading UI assets during splash screens\n     * - Preparing assets for upcoming game states\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *               name: 'home',\n     *               assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/home-bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'logo',\n     *                     src: 'images/logo.png',\n     *                 }\n     *              ]\n     *            },\n     *            {\n     *             name: 'level-1',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/level1/bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'sprites',\n     *                     src: 'images/level1/sprites.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Load the home screen assets right away\n     * await Assets.loadBundle('home');\n     * showHomeScreen();\n     *\n     * // Start background loading while showing home screen\n     * Assets.backgroundLoadBundle('level-1');\n     *\n     * // When player starts level, load completes faster\n     * await Assets.loadBundle('level-1');\n     * hideHomeScreen();\n     * startLevel();\n     * ```\n     * @remarks\n     * - Bundle assets are loaded one at a time\n     * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n     * - Assets are cached as they complete loading\n     * - Requires bundles to be registered via manifest or `addBundle`\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.loadBundle} For immediate bundle loading\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     * @internal\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet.\n     * @param keys - The key or keys for the assets to retrieve\n     * @returns The cached asset(s) or undefined if not loaded\n     * @example\n     * ```ts\n     * // Get a single cached asset\n     * const texture = Assets.get('hero');\n     * if (texture) {\n     *     const sprite = new Sprite(texture);\n     * }\n     *\n     * // Get multiple cached assets\n     * const textures = Assets.get([\n     *     'hero',\n     *     'background',\n     *     'enemy'\n     * ]);\n     *\n     * // Safe pattern with loading fallback\n     * let texture = Assets.get('hero');\n     * if (!texture) {\n     *     texture = await Assets.load('hero');\n     * }\n     *\n     * // Working with bundles\n     * await Assets.loadBundle('game-ui');\n     * const uiAssets = Assets.get([\n     *     'button',\n     *     'panel',\n     *     'icons'\n     * ]);\n     * ```\n     * @remarks\n     * - Returns undefined if asset isn't loaded\n     * - No automatic loading - use `Assets.load()` for that\n     * - Cached assets are shared instances\n     * - Faster than `load()` for already cached assets\n     *\n     * > [!TIP]\n     * > When in doubt, use `Assets.load()` instead. It will return cached\n     * > assets instantly if they're already loaded.\n     * @see {@link Assets.load} For loading assets that aren't cached\n     * @see {@link Assets.cache} For direct cache access\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unloads assets and releases them from memory. This method ensures proper cleanup of\n     * loaded assets when they're no longer needed.\n     * @param urls - Single URL/alias or array of URLs/aliases to unload\n     * @example\n     * ```ts\n     * // Unload a single asset\n     * await Assets.unload('images/sprite.png');\n     *\n     * // Unload using an alias\n     * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n     *\n     * // Unload multiple assets\n     * await Assets.unload([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'hero'\n     * ]);\n     *\n     * // Unload and handle creation of new instances\n     * await Assets.unload('hero');\n     * const newHero = await Assets.load('hero'); // Will load fresh from source\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > Make sure assets aren't being used before unloading:\n     * > - Remove sprites using the texture\n     * > - Clear any references to the asset\n     * > - Textures will be destroyed and can't be used after unloading\n     * @throws {Error} If the asset is not found in cache\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n     * are no longer needed, such as when switching game levels.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n     * @example\n     * ```ts\n     * // Define and load a bundle\n     * Assets.addBundle('level-1', {\n     *     background: 'level1/bg.png',\n     *     sprites: 'level1/sprites.json',\n     *     music: 'level1/music.mp3'\n     * });\n     *\n     * // Load the bundle\n     * const level1 = await Assets.loadBundle('level-1');\n     *\n     * // Use the assets\n     * const background = Sprite.from(level1.background);\n     *\n     * // When done with the level, unload everything\n     * await Assets.unloadBundle('level-1');\n     * // background sprite is now invalid!\n     *\n     * // Unload multiple bundles\n     * await Assets.unloadBundle([\n     *     'level-1',\n     *     'level-2',\n     *     'ui-elements'\n     * ]);\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > - All assets in the bundle will be destroyed\n     * > - Bundle needs to be reloaded to use assets again\n     * > - Make sure no sprites or other objects are using the assets\n     * @throws {Error} If the bundle is not found\n     * @see {@link Assets.addBundle} For adding bundles\n     * @see {@link Assets.loadBundle} For loading bundles\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /**\n     * All the detection parsers currently added to the Assets class.\n     * @advanced\n     */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * Sets global preferences for asset loading behavior. This method configures how assets\n     * are loaded and processed across all parsers.\n     * @param preferences - Asset loading preferences\n     * @example\n     * ```ts\n     * // Basic preferences\n     * Assets.setPreferences({\n     *     crossOrigin: 'anonymous',\n     *     parseAsGraphicsContext: false\n     * });\n     * ```\n     * @remarks\n     * Preferences are applied to all compatible parsers and affect future asset loading.\n     * Common preferences include:\n     * - `crossOrigin`: CORS setting for loaded assets\n     * - `preferWorkers`: Whether to use web workers for loading textures\n     * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n     * @see {@link AssetsPreferences} For all available preferences\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * ```typescript\n * import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n * ```\n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n * @see {@link AssetInitOptions} For initialization options\n * @see {@link AssetsPreferences} For advanced preferences\n * @see {@link BackgroundLoader} For background loading capabilities\n * @see {@link AssetsManifest} For manifest-based asset management\n * @see {@link Loader} For the underlying loading system\n * @see {@link Cache} For the caching system\n * @see {@link Resolver} For URL resolution details\n * @category assets\n * @class\n * @standard\n */\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nin vec2 vFilterUv;\\n\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\n\\nuniform vec4 uInputClamp;\\nuniform highp vec4 uInputSize;\\nuniform mat2 uRotation;\\nuniform vec2 uScale;\\n\\nvoid main()\\n{\\n    vec4 map = texture(uMapTexture, vFilterUv);\\n    \\n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \\n\\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=displacement.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\nout vec2 vFilterUv;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( void )\\n{\\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\\n}\\n\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n    vFilterUv = getFilterCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=displacement.vert.mjs.map\n", "var source = \"\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct DisplacementUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uScale:vec2<f32>,\\n  uRotation:mat2x2<f32>\\n};\\n\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n@group(1) @binding(2) var uMapSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\\n\\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \\n   \\n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=displacement.wgsl.mjs.map\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Filter } from '../../Filter';\nimport fragment from './displacement.frag';\nimport vertex from './displacement.vert';\nimport source from './displacement.wgsl';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { FilterOptions } from '../../Filter';\nimport type { FilterSystem } from '../../FilterSystem';\n\n/**\n * Configuration options for the DisplacementFilter.\n *\n * A displacement filter uses a sprite's texture as a displacement map,\n * moving pixels of the target based on the color values of corresponding\n * pixels in the displacement sprite.\n * @example\n * ```ts\n * const options: DisplacementFilterOptions = {\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * };\n *\n * const filter = new DisplacementFilter(options);\n * ```\n * @category filters\n * @standard\n */\nexport interface DisplacementFilterOptions extends FilterOptions\n{\n    /**\n     * The sprite whose texture will be used as the displacement map.\n     * Red channel = horizontal displacement\n     * Green channel = vertical displacement\n     * @example\n     * ```ts\n     * const displacementSprite = new Sprite(texture);\n     * const filter = new DisplacementFilter({ sprite: displacementSprite });\n     * ```\n     */\n    sprite: Sprite;\n\n    /**\n     * The scale of the displacement effect. Can be a single number for uniform\n     * scaling or a point-like object for separate x/y scaling.\n     * @default 20\n     * @example\n     * ```ts\n     * // Uniform scaling\n     * new DisplacementFilter({ sprite, scale: 20 });\n     * // Separate scaling\n     * new DisplacementFilter({ sprite, scale: { x: 10, y: 15 } });\n     * ```\n     */\n    scale?: number | PointData;\n}\n\n/**\n * A filter that applies a displacement map effect using a sprite's texture.\n *\n * The DisplacementFilter uses another texture (from a sprite) as a displacement map,\n * where the red and green channels of each pixel in the map determine how the corresponding\n * pixel in the filtered object should be offset:\n * - Red channel controls horizontal displacement\n * - Green channel controls vertical displacement\n *\n * Common use cases:\n * - Creating ripple or wave effects\n * - Distorting images dynamically\n * - Implementing heat haze effects\n * - Creating transition effects\n * @example\n * ```ts\n * import { Sprite, DisplacementFilter } from 'pixi.js';\n *\n * // Create a sprite to use as the displacement map\n * const displacementSprite = Sprite.from('displacement-map.png');\n *\n * // Create and configure the filter\n * const displacementFilter = new DisplacementFilter({\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * });\n *\n * // Apply to any display object\n * container.filters = [displacementFilter];\n * ```\n * @category filters\n * @author Vico: vicocotea\n * @standard\n * @noInheritDoc\n */\nexport class DisplacementFilter extends Filter\n{\n    private readonly _sprite: Sprite;\n\n    /**\n     * @param {Sprite | DisplacementFilterOptions} options - The sprite or options object.\n     * @param {Sprite} options.sprite - The texture used for the displacement map.\n     * @param {number | PointData} options.scale - The scale of the displacement.\n     */\n    constructor(options: Sprite | DisplacementFilterOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(sprite: Sprite, scale?: number | PointData);\n    constructor(...args: [Sprite | DisplacementFilterOptions] | [Sprite, (number | PointData)?])\n    {\n        let options = args[0];\n\n        if (options instanceof Sprite)\n        {\n            // #if _DEBUG\n            if (args[1])\n            {\n                deprecation(v8_0_0, 'DisplacementFilter now uses options object instead of params. {sprite, scale}');\n            }\n            // #endif\n\n            options = { sprite: options, scale: args[1] };\n        }\n\n        const { sprite, scale: scaleOption, ...rest } = options;\n\n        let scale = scaleOption ?? 20;\n\n        // check if is a number or a point\n        if (typeof scale === 'number')\n        {\n            scale = new Point(scale, scale);\n        }\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uScale: { value: scale, type: 'vec2<f32>' },\n            uRotation: { value: new Float32Array([0, 0, 0, 0]), type: 'mat2x2<f32>' },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'displacement-filter'\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const textureSource = sprite.texture.source;\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMapTexture: textureSource,\n                uMapSampler: textureSource.style,\n            },\n        });\n\n        this._sprite = options.sprite;\n        this._sprite.renderable = false;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - clearMode.\n     * @advanced\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        const uniforms = this.resources.filterUniforms.uniforms;\n\n        filterManager.calculateSpriteMatrix(\n            uniforms.uFilterMatrix,\n            this._sprite\n        );\n\n        // Extract rotation from world transform\n        const wt = this._sprite.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            uniforms.uRotation[0] = wt.a / lenX;\n            uniforms.uRotation[1] = wt.b / lenX;\n            uniforms.uRotation[2] = wt.c / lenY;\n            uniforms.uRotation[3] = wt.d / lenY;\n        }\n\n        this.resources.uMapTexture = this._sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * The scale of the displacement effect.\n     *\n     * Gets the current x and y scaling values used for the displacement mapping.\n     * - x: Horizontal displacement scale\n     * - y: Vertical displacement scale\n     * @returns {Point} The current scale as a Point object\n     * @example\n     * ```ts\n     * const filter = new DisplacementFilter({ sprite });\n     *\n     * // Get current scale\n     * console.log(filter.scale.x, filter.scale.y);\n     *\n     * // Update scale\n     * filter.scale.x = 100;\n     * filter.scale.y = 50;\n     * ```\n     */\n    get scale(): Point\n    {\n        return this.resources.filterUniforms.uniforms.uScale as Point;\n    }\n}\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\n\nimport type { Observer } from '../../maths/point/ObservablePoint';\n\n/**\n * Options for the {@link Transform} constructor.\n * @category utils\n * @advanced\n */\nexport interface TransformOptions\n{\n    /** The matrix to use. */\n    matrix?: Matrix;\n    /**\n     * The observer to use.\n     * @advanced\n     */\n    observer?: {_onUpdate: (transform: Transform) => void}\n}\n\n/**\n * The Transform class facilitates the manipulation of a 2D transformation matrix through\n * user-friendly properties: position, scale, rotation, skew, and pivot.\n * @example\n * ```ts\n * // Basic transform usage\n * const transform = new Transform();\n * transform.position.set(100, 100);\n * transform.rotation = Math.PI / 4; // 45 degrees\n * transform.scale.set(2, 2);\n *\n * // With pivot point\n * transform.pivot.set(50, 50);\n * transform.rotation = Math.PI; // Rotate around pivot\n *\n * // Matrix manipulation\n * const matrix = transform.matrix;\n * const position = { x: 0, y: 0 };\n * matrix.apply(position); // Transform point\n * ```\n * @remarks\n * - Manages 2D transformation properties\n * - Auto-updates matrix on changes\n * - Supports observable changes\n * - Common in display objects\n * @category utils\n * @standard\n * @see {@link Matrix} For direct matrix operations\n * @see {@link ObservablePoint} For point properties\n */\nexport class Transform\n{\n    /**\n     * The local transformation matrix.\n     * @internal\n     */\n    public _matrix: Matrix;\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * transform.position.set(100, 100);\n     *\n     * // Individual coordinate access\n     * transform.position.x = 50;\n     * transform.position.y = 75;\n     * ```\n     */\n    public position: ObservablePoint;\n\n    /**\n     * The scale factor of the object.\n     * @example\n     * ```ts\n     * // Uniform scaling\n     * transform.scale.set(2, 2);\n     *\n     * // Non-uniform scaling\n     * transform.scale.x = 2; // Stretch horizontally\n     * transform.scale.y = 0.5; // Compress vertically\n     * ```\n     */\n    public scale: ObservablePoint;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @example\n     * ```ts\n     * // Center pivot\n     * transform.pivot.set(sprite.width / 2, sprite.height / 2);\n     *\n     * // Corner rotation\n     * transform.pivot.set(0, 0);\n     * transform.rotation = Math.PI / 4; // 45 degrees\n     * ```\n     */\n    public pivot: ObservablePoint;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @example\n     * ```ts\n     * // Apply horizontal skew\n     * transform.skew.x = Math.PI / 6; // 30 degrees\n     *\n     * // Apply both skews\n     * transform.skew.set(Math.PI / 6, Math.PI / 8);\n     * ```\n     */\n    public skew: ObservablePoint;\n\n    /** The rotation amount. */\n    protected _rotation: number;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _cx: number;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     */\n    protected _sx: number;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _cy: number;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     */\n    protected _sy: number;\n\n    protected dirty = true;\n    protected observer: Observer<Transform>;\n\n    /**\n     * @param options - Options for the transform.\n     * @param options.matrix - The matrix to use.\n     * @param options.observer - The observer to use.\n     */\n    constructor({ matrix, observer }: TransformOptions = {})\n    {\n        this._matrix = matrix ?? new Matrix();\n        this.observer = observer;\n\n        this.position = new ObservablePoint(this, 0, 0);\n        this.scale = new ObservablePoint(this, 1, 1);\n        this.pivot = new ObservablePoint(this, 0, 0);\n        this.skew = new ObservablePoint(this, 0, 0);\n\n        this._rotation = 0;\n        this._cx = 1;\n        this._sx = 0;\n        this._cy = 0;\n        this._sy = 1;\n    }\n\n    /**\n     * The transformation matrix computed from the transform's properties.\n     * Combines position, scale, rotation, skew, and pivot into a single matrix.\n     * @example\n     * ```ts\n     * // Get current matrix\n     * const matrix = transform.matrix;\n     * console.log(matrix.toString());\n     * ```\n     * @readonly\n     * @see {@link Matrix} For matrix operations\n     * @see {@link Transform.setFromMatrix} For setting transform from matrix\n     */\n    get matrix(): Matrix\n    {\n        const lt = this._matrix;\n\n        if (!this.dirty) return lt;\n\n        lt.a = this._cx * this.scale.x;\n        lt.b = this._sx * this.scale.x;\n        lt.c = this._cy * this.scale.y;\n        lt.d = this._sy * this.scale.y;\n\n        lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n        lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n\n        this.dirty = false;\n\n        return lt;\n    }\n    /**\n     * Called when a value changes.\n     * @param point\n     * @internal\n     */\n    public _onUpdate(point?: ObservablePoint): void\n    {\n        this.dirty = true;\n\n        if (point === this.skew)\n        {\n            this.updateSkew();\n        }\n\n        this.observer?._onUpdate(this);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    protected updateSkew(): void\n    {\n        this._cx = Math.cos(this._rotation + this.skew.y);\n        this._sx = Math.sin(this._rotation + this.skew.y);\n        this._cy = -Math.sin(this._rotation - this.skew.x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew.x); // sin, added PI/2\n\n        this.dirty = true;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Transform `\n            + `position=(${this.position.x}, ${this.position.y}) `\n            + `rotation=${this.rotation} `\n            + `scale=(${this.scale.x}, ${this.scale.y}) `\n            + `skew=(${this.skew.x}, ${this.skew.y}) `\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     * @example\n     * ```ts\n     * // Basic matrix decomposition\n     * const transform = new Transform();\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * transform.setFromMatrix(matrix);\n     * console.log(transform.position.x); // 100\n     * console.log(transform.rotation); // ~0.785 (\u03C0/4)\n     * ```\n     * @param matrix - The matrix to decompose\n     * @see {@link Matrix#decompose} For the decomposition logic\n     * @see {@link Transform#matrix} For getting the current matrix\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n        this.dirty = true;\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * transform.rotation = Math.PI / 4; // 45 degrees\n     *\n     * // Rotate around pivot point\n     * transform.pivot.set(50, 50);\n     * transform.rotation = Math.PI; // 180 degrees around pivot\n     *\n     * // Animate rotation\n     * app.ticker.add(() => {\n     *     transform.rotation += 0.1;\n     * });\n     * ```\n     * @see {@link Transform#pivot} For rotation point\n     * @see {@link Transform#skew} For skew effects\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this.skew);\n        }\n    }\n}\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type TilingSpriteGpuData } from './TilingSpritePipe';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for creating a TilingSprite instance.\n * Defines the texture, tiling behavior, and rendering properties of the sprite.\n * @example\n * ```ts\n * // Create a basic tiling sprite with repeating texture\n * const tilingSprite = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 800,     // Width of the tiling area\n *     height: 600     // Height of the tiling area\n * });\n *\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tilePosition: { x: 0, y: 0 },\n *     tileScale: { x: 1.5, y: 1.5 }  // Scale up the texture\n *     anchor: 0.5,                    // Center anchor point\n *     roundPixels: true,              // Crisp pixel rendering\n * });\n * ```\n * @see {@link TilingSprite} For the main sprite class\n * @see {@link Texture} For texture management\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface TilingSpriteOptions extends PixiMixins.TilingSpriteOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the TilingSprite (0-1 range)\n     *\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @example\n     * ```ts\n     * // Centered anchor\n     * const sprite = new TilingSprite({ ..., anchor: 0.5 });\n     * sprite.anchor = 0.5;\n     * // Separate x/y anchor\n     * sprite.anchor = { x: 0.5, y: 0.5 };\n     * // Right-aligned anchor\n     * sprite.anchor = { x: 1, y: 0 };\n     * // Update anchor directly\n     * sprite.anchor.set(0.5, 0.5);\n     * ```\n     * @default 0\n     */\n    anchor?: PointData | number;\n    /**\n     * The offset of the tiling texture.\n     * Used to scroll or position the repeated pattern.\n     * @example\n     * ```ts\n     * // Offset the tiling pattern by 100 pixels in both x and y directions\n     * tilingSprite.tilePosition = { x: 100, y: 100 };\n     * ```\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scale of the tiling texture.\n     * Affects the size of each repeated instance of the texture.\n     * @example\n     * ```ts\n     * // Scale the texture by 1.5 in both x and y directions\n     * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n     * ```\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * Rotation of the tiling texture in radians.\n     * This controls the rotation applied to the texture before tiling.\n     * @example\n     * ```ts\n     * // Rotate the texture by 45 degrees (in radians)\n     * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n     * ```\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for tiling.\n     * This is the image that will be repeated across the sprite.\n     * @example\n     * ```ts\n     * // Use a texture from the asset cache\n     * tilingSprite.texture = Texture.from('assets/pattern.png');\n     * ```\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling area.\n     * This defines how wide the tiling sprite will be.\n     * @example\n     * ```ts\n     * // Set the width of the tiling sprite to 800 pixels\n     * tilingSprite.width = 800;\n     * ```\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling area.\n     * This defines how tall the tiling sprite will be.\n     * @example\n     * ```ts\n     * // Set the height of the tiling sprite to 600 pixels\n     * tilingSprite.height = 600;\n     * ```\n     * @default 256\n     */\n    height?: number\n    /**\n     * Whether the tiling pattern should originate from the anchor point.\n     * When true, tiling starts from the origin instead of top-left.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @example\n     * ```ts\n     * // Enable anchor-based tiling\n     * tilingSprite.applyAnchorToTexture = true;\n     * ```\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /**\n     * Whether to round the sprite's position to whole pixels.\n     * This can help with crisp rendering, especially for pixel art.\n     * When true, the sprite's position will be rounded to the nearest pixel.\n     * @example\n     * ```ts\n     * // Enable pixel rounding for crisp rendering\n     * tilingSprite.roundPixels = true;\n     * ```\n     * @default false\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface TilingSprite extends PixiMixins.TilingSprite, ViewContainer<TilingSpriteGpuData> {}\n\n/**\n * A TilingSprite is a fast and efficient way to render a repeating texture across a given area.\n * The texture can be scrolled, scaled, and rotated independently of the sprite itself.\n * @example\n * ```ts\n * // Create a simple tiling background\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n * });\n * app.stage.addChild(background);\n *\n * // Create a scrolling parallax background\n * const parallax = new TilingSprite({\n *     texture: Texture.from('clouds.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tileScale: { x: 0.5, y: 0.5 }\n * });\n *\n * // Animate the tiling position\n * app.ticker.add(() => {\n *     parallax.tilePosition.x -= 1; // Scroll left\n *     parallax.tilePosition.y -= 0.5; // Scroll up slowly\n * });\n *\n * // Create a repeating pattern with rotation\n * const pattern = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 300,\n *     height: 200,\n *     tileRotation: Math.PI / 4, // 45 degree rotation\n *     anchor: 0.5 // Center anchor point\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link TilingSpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class TilingSprite extends ViewContainer<TilingSpriteGpuData> implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite based on a source texture or image path.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create a new tiling sprite from an image path\n     * const pattern = TilingSprite.from('pattern.png');\n     * pattern.width = 300; // Set the width of the tiling area\n     * pattern.height = 200; // Set the height of the tiling area\n     *\n     * // Create from options\n     * const texture = Texture.from('pattern.png');\n     * const pattern = TilingSprite.from(texture, {\n     *     width: 300,\n     *     height: 200,\n     *     tileScale: { x: 0.5, y: 0.5 }\n     * });\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image or a texture\n     * @param options - Additional options for the tiling sprite\n     * @returns A new tiling sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /**\n     * Default options used when creating a TilingSprite instance.\n     * These values are used as fallbacks when specific options are not provided.\n     * @example\n     * ```ts\n     * // Override default options globally\n     * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n     * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n     *\n     * // Create sprite using default options\n     * const sprite = new TilingSprite();\n     * // Will use defaultPattern.png and scale 2x\n     * ```\n     * @type {TilingSpriteOptions}\n     * @see {@link TilingSpriteOptions} For all available options\n     * @see {@link TilingSprite.from} For creating sprites with custom options\n     * @see {@link Texture.EMPTY} For the default empty texture\n     */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /**\n         * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n         * local space.\n         *\n         * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n         * this, the top-left corner always gets the (0, 0) texture coordinate.\n         * @default false\n         */\n        applyAnchorToTexture: false,\n    };\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'tilingSprite';\n    /** @advanced */\n    public readonly batched = true;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @example\n     * ```ts\n     * // Enable anchor-based tiling\n     * tilingSprite.applyAnchorToTexture = true;\n     * ```\n     * @default false\n     */\n    public applyAnchorToTexture: boolean;\n    /**\n     * @see {@link TilingSpriteOptions.applyAnchorToTexture}\n     * @deprecated since 8.0.0\n     * @advanced\n     */\n    public get uvRespectAnchor(): boolean\n    {\n        deprecation(v8_0_0, 'uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n\n        return this.applyAnchorToTexture;\n    }\n    /** @advanced */\n    public set uvRespectAnchor(value: boolean)\n    {\n        deprecation(v8_0_0, 'uvRespectAnchor is deprecated, please use applyAnchorToTexture instead');\n        this.applyAnchorToTexture = value;\n    }\n\n    /** @internal */\n    public _anchor: ObservablePoint;\n    /** @internal */\n    public _tileTransform: Transform;\n    /** @internal */\n    public _texture: Texture;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {Texture | TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this.applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @type {number}\n     * @advanced\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    /** @advanced */\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The offset of the tiling texture.\n     * Used to scroll or position the repeated pattern.\n     * @example\n     * ```ts\n     * // Offset the tiling pattern by 100 pixels in both x and y directions\n     * tilingSprite.tilePosition = { x: 100, y: 100 };\n     * ```\n     * @default {x: 0, y: 0}\n     */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /**\n     * Scale of the tiling texture.\n     * Affects the size of each repeated instance of the texture.\n     * @example\n     * ```ts\n     * // Scale the texture by 1.5 in both x and y directions\n     * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n     * ```\n     * @default {x: 1, y: 1}\n     */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /**\n     * Rotation of the tiling texture in radians.\n     * This controls the rotation applied to the texture before tiling.\n     * @example\n     * ```ts\n     * // Rotate the texture by 45 degrees (in radians)\n     * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n     * ```\n     * @default 0\n     */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /**\n     * The transform object that controls the tiling texture's position, scale, and rotation.\n     * This transform is independent of the sprite's own transform properties.\n     * @example\n     * ```ts\n     * // Access transform properties directly\n     * sprite.tileTransform.position.set(100, 50);\n     * sprite.tileTransform.scale.set(2);\n     * sprite.tileTransform.rotation = Math.PI / 4;\n     *\n     * // Create smooth scrolling animation\n     * app.ticker.add(() => {\n     *     sprite.tileTransform.position.x += 1;\n     *     sprite.tileTransform.rotation += 0.01;\n     * });\n     *\n     * // Reset transform\n     * sprite.tileTransform.position.set(0);\n     * sprite.tileTransform.scale.set(1);\n     * sprite.tileTransform.rotation = 0;\n     * ```\n     * @returns {Transform} The transform object for the tiling texture\n     * @see {@link Transform} For transform operations\n     * @see {@link TilingSprite#tilePosition} For position control\n     * @see {@link TilingSprite#tileScale} For scale control\n     * @see {@link TilingSprite#tileRotation} For rotation control\n     * @advanced\n     */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture to use for tiling.\n     * This is the image that will be repeated across the sprite.\n     * @example\n     * ```ts\n     * // Use a texture from the asset cache\n     * tilingSprite.texture = Texture.from('assets/pattern.png');\n     * ```\n     * @default Texture.WHITE\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 500,\n     *     height: 300\n     * });\n     *\n     * // Adjust width dynamically\n     * sprite.width = 800; // Expands tiling area\n     *\n     * // Update on resize\n     * window.addEventListener('resize', () => {\n     *     sprite.width = app.screen.width;\n     * });\n     * ```\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     * @see {@link TilingSprite#height} For setting height\n     */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /**\n     * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 500,\n     *     height: 300\n     * });\n     *\n     * // Adjust width dynamically\n     * sprite.height = 800; // Expands tiling area\n     *\n     * // Update on resize\n     * window.addEventListener('resize', () => {\n     *     sprite.height = app.screen.height;\n     * });\n     * ```\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     * @see {@link TilingSprite#width} For setting width\n     */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting width and height separately as it only triggers one update.\n     * @example\n     * ```ts\n     * // Set specific dimensions\n     * sprite.setSize(300, 200); // Width: 300, Height: 200\n     *\n     * // Set uniform size (square)\n     * sprite.setSize(400); // Width: 400, Height: 400\n     *\n     * // Set size using object\n     * sprite.setSize({\n     *     width: 500,\n     *     height: 300\n     * });\n     * ```\n     * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link TilingSprite#width} For setting width only\n     * @see {@link TilingSprite#height} For setting height only\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a {@link Size} object.\n     * This method is more efficient than getting width and height separately as it only allocates one object.\n     * @example\n     * ```ts\n     * // Get basic size\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the TilingSprite\n     * @see {@link TilingSprite#width} For getting just the width\n     * @see {@link TilingSprite#height} For getting just the height\n     * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    /** @private */\n    protected override updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Takes into account the anchor offset when determining boundaries.\n     * @example\n     * ```ts\n     * // Create a tiling sprite\n     * const sprite = new TilingSprite({\n     *     texture: Texture.from('pattern.png'),\n     *     width: 200,\n     *     height: 100,\n     *     anchor: 0.5 // Center anchor\n     * });\n     *\n     * // Basic point check\n     * const contains = sprite.containsPoint({ x: 50, y: 25 });\n     * console.log('Point is inside:', contains);\n     *\n     * // Check with different anchors\n     * sprite.anchor.set(0); // Top-left anchor\n     * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the sprite's bounds\n     * @see {@link TilingSprite#toLocal} For converting global coordinates to local\n     * @see {@link TilingSprite#anchor} For understanding boundary calculations\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * tilingSprite.destroy();\n     * tilingSprite.destroy(true);\n     * tilingSprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HTMLTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @example\n * ```ts\n * const text: TextString = 'Hello Pixi!';\n * const text2: TextString = 12345;\n * const text3: TextString = { toString: () => 'Hello Pixi!' };\n * ```\n * @category text\n * @standard\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * This is used to allow for any text style to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyle, HTMLTextStyle } from 'pixi.js';\n * const style: AnyTextStyle = new TextStyle({ fontSize: 24 });\n * const htmlStyle: AnyTextStyle = new HTMLTextStyle({ fontSize: '24px' });\n * ```\n * @category text\n * @standard\n * @see TextStyle\n * @see HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * This is used to allow for any text style options to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyleOptions, HTMLTextStyleOptions } from 'pixi.js';\n * const styleOptions: AnyTextStyleOptions = { fontSize: 24 } as TextStyleOptions;\n * const htmlStyleOptions: AnyTextStyleOptions = { fontSize: '24px' } as HTMLTextStyleOptions;\n * ```\n * @category text\n * @standard\n * @see TextStyleOptions\n * @see HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for creating text objects in PixiJS. This interface defines the common properties\n * used across different text rendering implementations (Canvas, HTML, and Bitmap).\n * @example\n * ```ts\n * // Create basic text with minimal options\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Create text with advanced styling\n * const styledText = new Text({\n *     text: 'Styled Text',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: new FillGradient({\n *             end: { x: 1, y: 1 },\n *             stops: [\n *                 { color: 0xff0000, offset: 0 }, // Red at start\n *                 { color: 0x0000ff, offset: 1 }, // Blue at end\n *             ]\n *         }),\n *         stroke: { color: '#4a1850', width: 5 },\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6\n *         },\n *         align: 'center'\n *     },\n *     anchor: 0.5,\n *     resolution: window.devicePixelRatio\n * });\n *\n * // Create multiline text with word wrap\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will wrap onto multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30\n *     },\n *     resolution: 2,\n *     roundPixels: true\n * });\n * ```\n * @category text\n * @standard\n * @noInheritDoc\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends PixiMixins.TextOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    anchor?: PointData | number;\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     * ```\n     * @default ''\n     */\n    text?: TextString;\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    resolution?: number;\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /**\n     * Whether to round the x/y position to whole pixels.\n     * Enabling can prevent anti-aliasing of text edges but may cause slight position shifting.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Rounded Text',\n     *     roundPixels: true // Rounds position to whole pixels\n     * });\n     * @default false\n     */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see Text\n * @see BitmapText\n * @see HTMLText\n * @category text\n * @advanced\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n    TEXT_OPTIONS extends TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS> = TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n    GPU_DATA extends { destroy: () => void } = any\n> extends ViewContainer<GPU_DATA> implements View\n{\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public _anchor: ObservablePoint;\n\n    /** @internal */\n    public _resolution: number = null;\n    /** @internal */\n    public _autoResolution: boolean = true;\n\n    /** @internal */\n    public _style: TEXT_STYLE;\n    /** @internal */\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TEXT_OPTIONS,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     *\n     * // Update text dynamically\n     * text.text = 'Updated Text'; // Re-renders with new text\n     * text.text = 67890; // Updates to '67890'\n     * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n     * // Clear text\n     * text.text = ''; // Clears the text\n     * ```\n     * @default ''\n     */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     *\n     * // Update style dynamically\n     * text.style = {\n     *     fontSize: 30, // Change font size\n     *     fill: 0x00ff00, // Change color to green\n     *     align: 'right', // Change alignment to right\n     *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style ||= {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * texture.width = 200;\n     * console.log(texture.scale.x); // Scale adjusted to match width\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * texture.height = 200;\n     * console.log(texture.scale.y); // Scale adjusted to match height\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     style: { fontSize: 24 }\n     * });\n     * const size = text.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * text.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Text#width} For getting just the width\n     * @see {@link Text#height} For getting just the height\n     * @see {@link Text#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const text = new Text({\n     *    text: 'Hello Pixi!',\n     *    style: { fontSize: 24 }\n     * });\n     * text.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * text.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * text.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Text#width} For setting width only\n     * @see {@link Text#height} For setting height only\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the text's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = text.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the text's bounds\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /** @internal */\n    public override onViewUpdate()\n    {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroys the text and its style\n     * text.destroy({ style: true, texture: true, textureSource: true });\n     * text.destroy(true);\n     * text.destroy() // Destroys the text, but not its style\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this._text}:${this._style.styleKey}:${this._resolution}`;\n    }\n}\n\n/**\n * Helper function to ensure consistent handling of text options across different text classes.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureTextOptions([{\n *     text: \"Hello\",\n *     style: { fontSize: 20 }\n * }], \"Text\");\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureTextOptions([\"Hello\", { fontSize: 20 }], \"Text\");\n * @param args - Arguments passed to text constructor\n * @param name - Name of the text class (used in deprecation warning)\n * @returns Normalized text options object\n * @template TEXT_OPTIONS - The type of the text options\n * @internal\n */\nexport function ensureTextOptions<\n    TEXT_OPTIONS extends TextOptions\n>(\n    args: any[],\n    name: string\n): TEXT_OPTIONS\n{\n    let options = (args[0] ?? {}) as TEXT_OPTIONS;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as unknown as TEXT_OPTIONS;\n    }\n\n    return options;\n}\n", "import { warn } from '../../utils/logging/warn';\nimport { AbstractText, ensureTextOptions } from '../text/AbstractText';\nimport { TextStyle } from '../text/TextStyle';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { type BitmapTextGraphics } from './BitmapTextPipe';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from '../text/AbstractText';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface BitmapText extends PixiMixins.BitmapText, AbstractText<\n    TextStyle,\n    TextStyleOptions,\n    TextOptions,\n    BitmapTextGraphics\n> {}\n\n/**\n * A BitmapText object creates text using pre-rendered bitmap fonts.\n * It supports both loaded bitmap fonts (XML/FNT) and dynamically generated ones.\n *\n * To split a line you can use '\\n' in your text string, or use the `wordWrap` and\n * `wordWrapWidth` style properties.\n *\n * Key Features:\n * - High-performance text rendering using pre-generated textures\n * - Support for both pre-loaded and dynamic bitmap fonts\n * - Compatible with MSDF/SDF fonts for crisp scaling\n * - Automatic font reuse and optimization\n *\n * Performance Benefits:\n * - Faster rendering compared to Canvas/HTML text\n * - Lower memory usage for repeated characters\n * - More efficient text changes\n * - Better batching capabilities\n *\n * Limitations:\n * - Full character set support is impractical due to the number of chars (mainly affects CJK languages)\n * - Initial font generation/loading overhead\n * - Less flexible styling compared to Canvas/HTML text\n * @example\n * ```ts\n * import { BitmapText, BitmapFont } from 'pixi.js';\n *\n * // Dynamic font generation\n * const dynamicText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Pre-installed font usage\n * BitmapFont.install({\n *    name: 'myFont',\n *    style: {\n *        fontFamily: 'Arial',\n *    }\n * });\n *\n * const preinstalledText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myFont',\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Load and use external bitmap font, if the font supports MSDF/SDF then it will be used\n * const font = await Assets.load('fonts/myFont.fnt');\n *\n * const loadedFontText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myLoadedFont', // Name from .fnt file\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Multiline text with word wrap\n * const wrappedText = new BitmapText({\n *     text: 'This is a long text that will wrap automatically',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *     }\n * });\n * ```\n *\n * Font Types:\n * 1. Pre-loaded Bitmap Fonts:\n *    - Load via Asset Manager (XML/FNT formats)\n *    - Support for MSDF/SDF fonts\n *    - Create using tools like https://msdf-bmfont.donmccurdy.com/\n *\n * 2. Dynamic Bitmap Fonts:\n *    - Generated at runtime from system fonts\n *    - Automatic font reuse and optimization\n *    - Smart scaling for similar font sizes\n *\n * Font Management:\n * - Automatic font generation when needed\n * - Manual pre-installation via `BitmapFont.install`\n * - Smart font reuse to optimize memory\n * - Scale existing fonts instead of generating new ones when possible\n * @category text\n * @standard\n * @see {@link BitmapFont} For font installation and management\n * @see {@link Text} For canvas-based text rendering\n * @see {@link HTMLText} For HTML/CSS-based text rendering\n */\nexport class BitmapText extends AbstractText<\n    TextStyle,\n    TextStyleOptions,\n    TextOptions,\n    BitmapTextGraphics\n> implements View\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'bitmapText';\n\n    /**\n     * **Note:** Our docs parser struggles to properly understand the constructor signature.\n     * This is the correct signature.\n     * ```ts\n     * new BitmapText(options?: TextOptions);\n     * ```\n     * @param { TextOptions } options - The options of the bitmap text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureTextOptions(args, 'BitmapText');\n\n        options.style ??= options.style || {};\n        options.style.fill ??= 0xffffff;\n\n        super(options, TextStyle);\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);\n        const scale = bitmapMeasurement.scale;\n        const offset = bitmapMeasurement.offsetY * scale;\n\n        let width = bitmapMeasurement.width * scale;\n        let height = bitmapMeasurement.height * scale;\n\n        const stroke = this._style._stroke;\n\n        if (stroke)\n        {\n            width += stroke.width;\n            height += stroke.width;\n        }\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * (height + offset));\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * The resolution / device pixel ratio for text rendering.\n     * Unlike other text types, BitmapText resolution is managed by the BitmapFont.\n     * Individual resolution changes are not supported.\n     * @example\n     * ```ts\n     * // \u274C Incorrect: Setting resolution directly (will trigger warning)\n     * const text = new BitmapText({\n     *     text: 'Hello',\n     *     resolution: 2 // This will be ignored\n     * });\n     *\n     * // \u2705 Correct: Set resolution when installing the font\n     * BitmapFont.install({\n     *     name: 'MyFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *     },\n     *     resolution: 2 // Resolution is set here\n     * });\n     *\n     * const text = new BitmapText({\n     *     text: 'Hello',\n     *     style: {\n     *         fontFamily: 'MyFont' // Uses font's resolution\n     *     }\n     * });\n     * ```\n     * @default 1\n     * @see {@link BitmapFont.install} For setting font resolution\n     * @throws {Warning} When attempting to change resolution directly\n     * @readonly\n     */\n    override set resolution(value: number)\n    {\n        // #if _DEBUG\n        if (value !== null)\n        {\n            warn(\n            // eslint-disable-next-line max-len\n                '[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.'\n            );\n        }\n        // #endif\n    }\n\n    override get resolution(): number\n    {\n        return this._resolution;\n    }\n}\n", "import { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './dom';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n", "export const constant = {\r\n  device:{width: 720, height: 1280},\r\n  fishCount:20,\r\n  score:100,\r\n  fishInfo:{\r\n    0:{name:'fish1',hp:5,minSpeed:1,maxSpeed:6,score:5,delay:210/2},\r\n    1:{name:'fish2',hp:6,minSpeed:2,maxSpeed:7,score:6,delay:148/2},\r\n    2:{name:'fish3',hp:7,minSpeed:3,maxSpeed:8,score:7,delay:194/2},\r\n    3:{name:'fish4',hp:8,minSpeed:4,maxSpeed:9,score:8,delay:178/2},\r\n    4:{name:'fish5',hp:9,minSpeed:5,maxSpeed:10,score:9,delay:188/2},\r\n    5:{name:'fish6',hp:20,minSpeed:2,maxSpeed:6,score:13,delay:300/2},\r\n    6:{name:'fish7',hp:5,minSpeed:10,maxSpeed:15,score:10,delay:120/2},\r\n    7:{name:'fish8',hp:100,minSpeed:5,maxSpeed:10,score:100,delay:644/2},\r\n    8:{name:'fish9',hp:150,minSpeed:1,maxSpeed:3,score:200,delay:950/2},\r\n    9:{name:'fish10',hp:8,minSpeed:15,maxSpeed:20,score:15,delay:50/2},\r\n    10:{name:'fish11',hp:10,minSpeed:3,maxSpeed:8,score:7,delay:204/2},\r\n    11:{name:'fish12',hp:7,minSpeed:8,maxSpeed:12,score:12,delay:246/2},\r\n    12:{name:'fish13',hp:15,minSpeed:9,maxSpeed:13,score:18,delay:138/2},\r\n    13:{name:'fish14',hp:50,minSpeed:5,maxSpeed:10,score:20,delay:276/2},\r\n  }\r\n}", "import { Sprite } from 'pixi.js';\r\nimport { constant } from './g_variable';\r\n\r\nexport function addBackground(app) {\r\n  const background = Sprite.from('background');\r\n  background.anchor.set(0,0);\r\n  background.position.set(0,0)\r\n  background.width = constant.device.width;\r\n  background.height = constant.device.height;\r\n  app.addChild(background);\r\n\r\n}", "import { Texture, TilingSprite } from 'pixi.js';\r\nimport { constant } from './g_variable';\r\n\r\nlet overlay;\r\nexport function addWaterOverlay(app) {\r\n  const texture = Texture.from('overlay');\r\n  overlay = new TilingSprite({\r\n    texture,\r\n    width: constant.device.width,\r\n    height: constant.device.height,\r\n  });\r\n  app.addChild(overlay);\r\n}\r\n\r\nexport function animateWaterOverlay(app, time) {\r\n  const delta = time.deltaTime;\r\n  overlay.tilePosition.x += delta;\r\n  overlay.tilePosition.y -= delta;\r\n}\r\n", "import { Sprite } from 'pixi.js';\r\nimport { constant } from './g_variable';\r\n\r\nexport let bullets = [];\r\nexport function createBullet(app,startX,startY,targetX,targetY){\r\n    const dx = targetX - startX;\r\n    const dy = targetY - startY;\r\n    const length = Math.sqrt(dx * dx + dy * dy);\r\n    const bullet = Sprite.from('bullet');\r\n    bullet.anchor.set(0.5);\r\n    bullet.position.set(startX,startY);\r\n    bullet.vx = (dx / length) * 15; // \u5B50\u5F48\u901F\u5EA6 (5 \u53EF\u8ABF\u6574)\r\n    bullet.vy = (dy / length) * 15;\r\n    bullet.hit = new Set();\r\n    bullets.push(bullet);\r\n    app.addChild(bullet);\r\n    constant.score -= 1;\r\n}\r\n\r\nexport function moveBullet(app){\r\n    bullets.forEach(function(item,index){\r\n        item.x += item.vx;\r\n        item.y += item.vy;\r\n        //const bounds = item.getBounds();\r\n        //console.log(bounds.x,bounds.y,bounds.width,bounds.height)\r\n        if(item.x > constant.device.width || item.x < 0 || item.y > constant.device.height || item.y < 0){\r\n            item.destroy();    \r\n            app.removeChild(item);\r\n            bullets.splice(index,1);\r\n        }\r\n    })\r\n}\r\n\r\n", "import { BitmapFont, BitmapText, Texture } from \"pixi.js\";\r\n\r\nexport function initNumber(app,string,font,fontsize,posX,posY) {\r\n    const label = new BitmapText({\r\n      text: string.toString(),\r\n      style: {\r\n        fontFamily: font.toString(),\r\n        fontSize: fontsize,\r\n        fill: '#ffffff',\r\n      },\r\n    });\r\n    label.x = posX;\r\n    label.y = posY;\r\n    label.anchor.set(0.5,0.5);\r\n    app.addChild(label);\r\n    \r\n\r\n    label.setNumber = function(num){\r\n      label.text = num.toString();    \r\n    }\r\n\r\n    label.setPosition = function(posX,posY){\r\n      label.x = posX;\r\n      label.y = posY;\r\n    }\r\n\r\n    label.setOpacity = function(num){\r\n      label.alpha = num;\r\n    }\r\n    return label\r\n}\r\n\r\n\r\n", "import { Sprite, DisplacementFilter} from 'pixi.js';\r\nimport { constant } from './g_variable';\r\nimport { bullets } from './bullet';\r\nimport { initNumber } from './number';\r\n\r\nimport Matter from 'matter-js';\r\nconst { Engine, Render, Runner, Bodies, World, Events } = Matter;\r\nimport gsap from 'gsap';\r\n\r\nconst engine = Engine.create();\r\nconst world = engine.world;\r\n\r\nlet fish = null;\r\nlet random_posX = null;\r\nlet random_posY = null;\r\nlet random_angle = null;\r\nlet radius = null;\r\nlet dx = null;\r\nlet dy = null;\r\nlet speed = null;\r\nlet border_delay = 100;\r\nlet fishes = [];\r\nlet fishLabel = null;\r\nlet fishLabelArray = [];\r\nexport function addFish(app,state) {\r\n  //const fishArray = [\"fish14\",\"fish2\",\"fish3\",\"fish4\",\"fish5\"];\r\n  \r\n  let random_fish = Math.floor(Math.random() * Object.keys(constant.fishInfo).length);\r\n  if(state == \"init\"){\r\n    random_posX = Math.floor(Math.random() * (constant.device.width + 1));\r\n    random_posY = Math.floor(Math.random() * (constant.device.height + 1));\r\n  }\r\n  else if(state == \"new\"){//\u65B0\u7684\u9B5A\u8981\u5728\u87A2\u5E55\u5916\u91CD\u751F\r\n    random_posX = Math.floor(Math.random() * 101) - 200;\r\n    random_posY = Math.floor(Math.random() * 101) - 200;\r\n  }\r\n  random_angle = Math.floor(Math.random() * 361);\r\n  radius = random_angle * Math.PI / 180;\r\n  dx = Math.cos(radius);\r\n  dy = Math.sin(radius);\r\n  speed = Math.floor(Math.random() * (constant.fishInfo[random_fish].maxSpeed - constant.fishInfo[random_fish].minSpeed + 1)) + constant.fishInfo[random_fish].minSpeed;\r\n  fish = Sprite.from(constant.fishInfo[random_fish].name);\r\n  fish.anchor.set(0.5,0.5);\r\n  fish.position.set(random_posX,random_posY)\r\n  fish.angle = random_angle;\r\n  fish.dx = dx;\r\n  fish.dy = dy;\r\n  fish.speed = speed;\r\n  fish.hp = constant.fishInfo[random_fish].hp;\r\n  fish.score = constant.fishInfo[random_fish].score;\r\n  fish.delay = constant.fishInfo[random_fish].delay;\r\n  app.addChild(fish);\r\n  fishes.push(fish);\r\n  \r\n  \r\n  fishLabel = initNumber(app,10,\"dummy_font2\",40,fish.x,fish.y);\r\n  fishLabel.setOpacity(0);\r\n  fishLabel.setNumber(constant.fishInfo[random_fish].score);\r\n  fishLabelArray.push(fishLabel);\r\n  \r\n  const sprite = Sprite.from('displacement');\r\n    sprite.texture.source.addressMode = 'repeat';\r\n    const filter = new DisplacementFilter({\r\n      sprite,\r\n      scale: 50,\r\n    });\r\n  \r\n    fish.filters = [filter];\r\n}\r\nexport function runFish(app){\r\n  fishes.forEach(function(item,index){\r\n    item.x -= item.dx * item.speed;\r\n    item.y -= item.dy * item.speed;\r\n\r\n    if(item.x > constant.device.width + item.delay){\r\n      item.x = 0 - item.delay;\r\n    }\r\n    if(item.x < 0 - item.delay){\r\n      item.x = constant.device.width + item.delay;\r\n    }\r\n    if(item.y > constant.device.height + item.delay){\r\n      item.y = 0 - item.delay;\r\n    }\r\n    if(item.y < 0 - item.delay){\r\n      item.y = constant.device.height + item.delay;\r\n    }\r\n    fishLabelArray[index].setPosition(item.x,item.y)\r\n  })\r\n\r\n  bullets.forEach((bullet, bi) => {\r\n    const bBounds = bullet.getBounds();\r\n    fishes.forEach((fish, fi) => {\r\n      const fBounds = fish.getBounds();\r\n      if (\r\n        bBounds.x < fBounds.x + fBounds.width &&   // \u5B50\u5F48\u5DE6\u908A < \u9B5A\u53F3\u908A\r\n        bBounds.x + bBounds.width > fBounds.x &&  // \u5B50\u5F48\u53F3\u908A > \u9B5A\u5DE6\u908A\r\n        bBounds.y < fBounds.y + fBounds.height && // \u5B50\u5F48\u4E0A\u908A < \u9B5A\u4E0B\u908A\r\n        bBounds.y + bBounds.height > fBounds.y    // \u5B50\u5F48\u4E0B\u908A > \u9B5A\u4E0A\u908A\r\n      ) {\r\n        if(bullet.hit.has(fi))return//\u6253\u4E2D\u9B5A\u5C31\u7528add\u7D00\u9304\u9019\u500B\u5B50\u5F48\u6253\u4E2D\u7684\u9B5A\u662F\u54EA\u7A2E\u5728\u7528has\u5224\u5B9A\u5B50\u5F48\u662F\u5426\u91CD\u8907\u64CA\u4E2D\r\n        //console.log(`\u5B50\u5F48 ${bi} \u64CA\u4E2D \u9B5A ${fi}`);\r\n        bullet.hit.add(fi);\r\n        fish.hp--;\r\n        hitEffect(fish)\r\n        if(fish.hp == 0){\r\n          constant.score += fish.score;\r\n          fishLabelArray[fi].setOpacity(255);\r\n          gsap.to(fishLabelArray[fi],{\r\n            alpha:0,\r\n            duration:2,\r\n            ease:\"power2.out\",\r\n          })\r\n\r\n          gsap.to(fish,{\r\n            alpha:0,\r\n            duration:2,\r\n            ease:\"power2.out\",\r\n            onComplete:() => fishDestroy(fish,app)\r\n          })\r\n          fishes.splice(fi,1);\r\n          fishLabelArray.splice(fi,1);\r\n          \r\n        }\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction hitEffect(fish){\r\n  fish.tint = 0xff0000;\r\n  setTimeout(function(){\r\n    fish.tint = 0xffffff;\r\n  },100)\r\n}\r\n\r\nfunction fishDestroy(fish,app){\r\n  fish.destroy();\r\n  app.removeChild(fish);\r\n}\r\n\r\nexport function createNewFish(app){\r\n  if(fishes.length < constant.fishCount){\r\n    addFish(app,\"new\");\r\n  }\r\n}", "function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * GSAP 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _config = {\n  autoSleep: 120,\n  force3D: \"auto\",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: \"\"\n  }\n},\n    _defaults = {\n  duration: .5,\n  overwrite: false,\n  delay: 0\n},\n    _suppressOverwrites,\n    _reverting,\n    _context,\n    _bigNum = 1e8,\n    _tinyNum = 1 / _bigNum,\n    _2PI = Math.PI * 2,\n    _HALF_PI = _2PI / 4,\n    _gsID = 0,\n    _sqrt = Math.sqrt,\n    _cos = Math.cos,\n    _sin = Math.sin,\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isNotFalse = function _isNotFalse(value) {\n  return value !== false;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _isFuncOrString = function _isFuncOrString(value) {\n  return _isFunction(value) || _isString(value);\n},\n    _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function () {},\n    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray,\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n    //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n    _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\n    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/,\n    _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi,\n    // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i,\n    _globalTimeline,\n    _win,\n    _coreInitted,\n    _doc,\n    _globals = {},\n    _installScope = {},\n    _coreReady,\n    _install = function _install(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n},\n    _missingPlugin = function _missingPlugin(property, value) {\n  return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n},\n    _warn = function _warn(message, suppress) {\n  return !suppress && console.warn(message);\n},\n    _addGlobal = function _addGlobal(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n},\n    _emptyFunc = function _emptyFunc() {\n  return 0;\n},\n    _startAtRevertConfig = {\n  suppressEvents: true,\n  isStart: true,\n  kill: false\n},\n    _revertConfigNoKill = {\n  suppressEvents: true,\n  kill: false\n},\n    _revertConfig = {\n  suppressEvents: true\n},\n    _reservedProps = {},\n    _lazyTweens = [],\n    _lazyLookup = {},\n    _lastRenderedFrame,\n    _plugins = {},\n    _effects = {},\n    _nextGCFrame = 30,\n    _harnessPlugins = [],\n    _callbackNames = \"\",\n    _harness = function _harness(targets) {\n  var target = targets[0],\n      harnessPlugin,\n      i;\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\n\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n    i = _harnessPlugins.length;\n\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n    harnessPlugin = _harnessPlugins[i];\n  }\n\n  i = targets.length;\n\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n\n  return targets;\n},\n    _getCache = function _getCache(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n},\n    _getProperty = function _getProperty(target, property, v) {\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n},\n    _forEachName = function _forEachName(names, func) {\n  return (names = names.split(\",\")).forEach(func) || names;\n},\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _roundPrecise = function _roundPrecise(value) {\n  return Math.round(value * 10000000) / 10000000 || 0;\n},\n    // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n  var operator = value.charAt(0),\n      end = parseFloat(value.substr(2));\n  start = parseFloat(start);\n  return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n},\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n  var l = toFind.length,\n      i = 0;\n\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n\n  return i < l;\n},\n    _lazyRender = function _lazyRender() {\n  var l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n},\n    _isRevertWorthy = function _isRevertWorthy(animation) {\n  return !!(animation._initted || animation._startAt || animation.add);\n},\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n  _lazyTweens.length && !_reverting && _lazyRender();\n  animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));\n  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n},\n    _numericIfPossible = function _numericIfPossible(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n  return function (obj, defaults) {\n    for (var p in defaults) {\n      p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n    }\n  };\n},\n    _merge = function _merge(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n\n  return base;\n},\n    _mergeDeep = function _mergeDeep(base, toMerge) {\n  for (var p in toMerge) {\n    p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n  }\n\n  return base;\n},\n    _copyExcluding = function _copyExcluding(obj, excluding) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n\n  return copy;\n},\n    _inheritDefaults = function _inheritDefaults(vars) {\n  var parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n\n  return vars;\n},\n    _arraysMatch = function _arraysMatch(a1, a2) {\n  var i = a1.length,\n      match = i === a2.length;\n\n  while (match && i-- && a1[i] === a2[i]) {}\n\n  return i < 0;\n},\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = parent[lastProp],\n      t;\n\n  if (sortBy) {\n    t = child[sortBy];\n\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n},\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = child._prev,\n      next = child._next;\n\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n\n  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n},\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n  child._act = 0;\n},\n    _uncache = function _uncache(animation, child) {\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n    var a = animation;\n\n    while (a) {\n      a._dirty = 1;\n      a = a.parent;\n    }\n  }\n\n  return animation;\n},\n    _recacheAncestors = function _recacheAncestors(animation) {\n  var parent = animation.parent;\n\n  while (parent && parent.parent) {\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n\n  return animation;\n},\n    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n},\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n},\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n},\n    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n  var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));\n  return tTime && whole === tTime ? whole - 1 : whole;\n},\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n},\n    _setEnd = function _setEnd(animation) {\n  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n},\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n  var parent = animation._dp;\n\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n    _setEnd(animation);\n\n    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n  }\n\n  return animation;\n},\n\n/*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/\n_postAddChecks = function _postAddChecks(timeline, child) {\n  var t;\n\n  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n\n\n  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n    //in case any of the ancestors had completed but should now be enabled...\n    if (timeline._dur < timeline.duration()) {\n      t = timeline;\n\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n\n        t = t._dp;\n      }\n    }\n\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n  }\n},\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n  _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n\n  _isFromOrFromStart(child) || (timeline._recent = child);\n  skipChecks || _postAddChecks(timeline, child);\n  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n\n  return timeline;\n},\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n},\n    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n  _initTween(tween, time, tTime);\n\n  if (!tween._initted) {\n    return 1;\n  }\n\n  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n\n    tween._lazy = [tTime, suppressEvents];\n    return 1;\n  }\n},\n    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n  var parent = _ref.parent;\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n},\n    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n  var data = _ref2.data;\n  return data === \"isFromStart\" || data === \"isStart\";\n},\n    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n  repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n\n  if (repeatDelay && tween._repeat) {\n    // in case there's a zero-duration tween that has a repeat with a repeatDelay\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n\n    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n      // if iteration changed\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n\n  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n      return;\n    }\n\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    pt = tween._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n\n      if (!suppressEvents && !_reverting) {\n        _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n},\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n  var child;\n\n  if (time > prevTime) {\n    child = animation._first;\n\n    while (child && child._start <= time) {\n      if (child.data === \"isPause\" && child._start > prevTime) {\n        return child;\n      }\n\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n\n    while (child && child._start >= time) {\n      if (child.data === \"isPause\" && child._start < prevTime) {\n        return child;\n      }\n\n      child = child._prev;\n    }\n  }\n},\n    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n  var repeat = animation._repeat,\n      dur = _roundPrecise(duration) || 0,\n      totalProgress = animation._tTime / animation._tDur;\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n  animation.parent && _setEnd(animation);\n  skipUncache || _uncache(animation.parent, animation);\n  return animation;\n},\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n},\n    _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc,\n  totalDuration: _emptyFunc\n},\n    _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n  var labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n  i,\n      offset,\n      isPercent;\n\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n    offset = position.charAt(0);\n    isPercent = position.substr(-1) === \"%\";\n    i = position.indexOf(\"=\");\n\n    if (offset === \"<\" || offset === \">\") {\n      i >= 0 && (position = position.replace(/=/, \"\"));\n      return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n    }\n\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n\n    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n\n    if (isPercent && percentAnimation) {\n      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n    }\n\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n  }\n\n  return position == null ? clippedDuration : +position;\n},\n    _createTweenType = function _createTweenType(type, params, timeline) {\n  var isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars,\n      parent;\n\n  isLegacy && (vars.duration = params[1]);\n  vars.parent = timeline;\n\n  if (type) {\n    irVars = vars;\n    parent = timeline;\n\n    while (parent && !(\"immediateRender\" in irVars)) {\n      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n  }\n\n  return new Tween(params[0], vars, params[varsIndex + 1]);\n},\n    _conditionalReturn = function _conditionalReturn(value, func) {\n  return value || value === 0 ? func(value) : func;\n},\n    _clamp = function _clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n},\n    getUnit = function getUnit(value, v) {\n  return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n},\n    // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n  return _conditionalReturn(value, function (v) {\n    return _clamp(min, max, v);\n  });\n},\n    _slice = [].slice,\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\n  return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n},\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n\n  return ar.forEach(function (value) {\n    var _accumulator;\n\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n},\n    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n},\n    selector = function selector(value) {\n  value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n  return function (v) {\n    var el = value.current || value.nativeElement || value;\n    return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n  };\n},\n    shuffle = function shuffle(a) {\n  return a.sort(function () {\n    return .5 - Math.random();\n  });\n},\n    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n\n  var vars = _isObject(v) ? v : {\n    each: v\n  },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n  ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: .5,\n      edges: .5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n\n  return function (i, target, a) {\n    var l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n\n    if (!distances) {\n      wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n      if (!wrapAt) {\n        max = -_bigNum;\n\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n\n        wrapAt < l && wrapAt--;\n      }\n\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n\n      from === \"random\" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n  };\n},\n    _roundModifier = function _roundModifier(v) {\n  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n  var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n\n  return function (raw) {\n    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n  };\n},\n    snap = function snap(snapTo, value) {\n  var isArray = _isArray(snapTo),\n      radius,\n      is2D;\n\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function (raw) {\n    var x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n},\n    random = function random(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n},\n    pipe = function pipe() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    return functions.reduce(function (v, f) {\n      return f(v);\n    }, value);\n  };\n},\n    unitize = function unitize(func, unit) {\n  return function (value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n},\n    normalize = function normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n},\n    _wrapArray = function _wrapArray(a, wrapper, value) {\n  return _conditionalReturn(value, function (index) {\n    return a[~~wrapper(index)];\n  });\n},\n    wrap = function wrap(min, max, value) {\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n    return (range + (value - min) % range) % range + min;\n  });\n},\n    wrapYoyo = function wrapYoyo(min, max, value) {\n  var range = max - min,\n      total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n    value = (total + (value - min) % total) % total || 0;\n    return min + (value > range ? total - value : value);\n  });\n},\n    _replaceRandom = function _replaceRandom(value) {\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n  var prev = 0,\n      s = \"\",\n      i,\n      nums,\n      end,\n      isArray;\n\n  while (~(i = value.indexOf(\"random(\", prev))) {\n    end = value.indexOf(\")\", i);\n    isArray = value.charAt(i + 7) === \"[\";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n\n  return s + value.substr(prev, value.length - prev);\n},\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin,\n      outRange = outMax - outMin;\n  return _conditionalReturn(value, function (value) {\n    return outMin + ((value - inMin) / inRange * outRange || 0);\n  });\n},\n    interpolate = function interpolate(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function (p) {\n    return (1 - p) * start + p * end;\n  };\n\n  if (!func) {\n    var isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n\n    progress === true && (mutate = 1) && (progress = null);\n\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n      }\n\n      l--;\n\n      func = function func(p) {\n        p *= l;\n        var i = Math.min(il, ~~p);\n        return interpolators[i](p - i);\n      };\n\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, \"get\", end[p]);\n      }\n\n      func = function func(p) {\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\n      };\n    }\n  }\n\n  return _conditionalReturn(progress, func);\n},\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n  //used for nextLabel() and previousLabel()\n  var labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n\n  return label;\n},\n    _callback = function _callback(animation, type, executeLazyFirst) {\n  var v = animation.vars,\n      callback = v[type],\n      prevContext = _context,\n      context = animation._ctx,\n      params,\n      scope,\n      result;\n\n  if (!callback) {\n    return;\n  }\n\n  params = v[type + \"Params\"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n\n  context && (_context = context);\n  result = params ? callback.apply(scope, params) : callback.call(scope);\n  _context = prevContext;\n  return result;\n},\n    _interrupt = function _interrupt(animation) {\n  _removeFromParent(animation);\n\n  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n  animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n  return animation;\n},\n    _quickTween,\n    _registerPluginQueue = [],\n    _createPlugin = function _createPlugin(config) {\n  if (!config) return;\n  config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n\n  if (_windowExists() || config.headless) {\n    // edge case: some build tools may pass in a null/undefined value\n    var name = config.name,\n        isFunc = _isFunction(config),\n        Plugin = name && !isFunc && config.init ? function () {\n      this._props = [];\n    } : config,\n        //in case someone passes in an object that's not a plugin, like CustomEase\n    instanceDefaults = {\n      init: _emptyFunc,\n      render: _renderPropTweens,\n      add: _addPropTween,\n      kill: _killPropTweensOf,\n      modifier: _addPluginModifier,\n      rawVars: 0\n    },\n        statics = {\n      targetTest: 0,\n      get: 0,\n      getSetter: _getSetter,\n      aliases: {},\n      register: 0\n    };\n\n    _wake();\n\n    if (config !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n\n\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n\n\n      _plugins[Plugin.prop = name] = Plugin;\n\n      if (config.targetTest) {\n        _harnessPlugins.push(Plugin);\n\n        _reservedProps[name] = 1;\n      }\n\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n    }\n\n    _addGlobal(name, Plugin);\n\n    config.register && config.register(gsap, Plugin, PropTween);\n  } else {\n    _registerPluginQueue.push(config);\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */\n_255 = 255,\n    _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n},\n    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n  h += h < 0 ? 1 : h > 1 ? -1 : 0;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n},\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n\n  if (!a) {\n    if (v.substr(-1) === \",\") {\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n      v = v.substr(0, v.length - 1);\n    }\n\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === \"#\") {\n      if (v.length < 6) {\n        //for shorthand like #9F0 or #9F0F (could have alpha)\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n      }\n\n      if (v.length === 9) {\n        // hex with alpha, like #fd5e53ff\n        a = parseInt(v.substr(1, 6), 16);\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n      }\n\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === \"hsl\") {\n      a = wasHSL = v.match(_strictNumExp);\n\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n        a.length > 3 && (a[3] *= 1); //cast as number\n\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf(\"=\")) {\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n\n    a = a.map(Number);\n  }\n\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n\n    a[0] = ~~(h + .5);\n    a[1] = ~~(s * 100 + .5);\n    a[2] = ~~(l * 100 + .5);\n  }\n\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n},\n    _colorOrderData = function _colorOrderData(v) {\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n  var values = [],\n      c = [],\n      i = -1;\n  v.split(_colorExp).forEach(function (v) {\n    var a = v.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n},\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n  var result = \"\",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? \"hsla(\" : \"rgba(\",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n\n  if (!colors) {\n    return s;\n  }\n\n  colors = colors.map(function (color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n  });\n\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n      l = shell.length - 1;\n\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n\n  return result + shell[l];\n},\n    _colorExp = function () {\n  var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\",\n      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n  p;\n\n  for (p in _colorLookup) {\n    s += \"|\" + p + \"\\\\b\";\n  }\n\n  return new RegExp(s + \")\", \"gi\");\n}(),\n    _hslExp = /hsl[a]?\\(/,\n    _colorStringFilter = function _colorStringFilter(a) {\n  var combined = a.join(\" \"),\n      toHSL;\n  _colorExp.lastIndex = 0;\n\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n\n    return true;\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */\n_tickerActive,\n    _ticker = function () {\n  var _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1000 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _delta,\n      _i,\n      _tick = function _tick(v) {\n    var elapsed = _getTime() - _lastUpdate,\n        manual = v === true,\n        overlap,\n        dispatch,\n        time,\n        frame;\n\n    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n    _lastUpdate += elapsed;\n    time = _lastUpdate - _startTime;\n    overlap = time - _nextTime;\n\n    if (overlap > 0 || manual) {\n      frame = ++_self.frame;\n      _delta = time - _self.time * 1000;\n      _self.time = time = time / 1000;\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n      dispatch = 1;\n    }\n\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n\n    if (dispatch) {\n      for (_i = 0; _i < _listeners.length; _i++) {\n        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n        _listeners[_i](time, _delta, frame, v);\n      }\n    }\n  };\n\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    deltaRatio: function deltaRatio(fps) {\n      return _delta / (1000 / (fps || 60));\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n          _registerPluginQueue.forEach(_createPlugin);\n        }\n\n        _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n        _id && _self.sleep();\n\n        _req = _raf || function (f) {\n          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n        };\n\n        _tickerActive = 1;\n\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n\n      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n    },\n    fps: function fps(_fps) {\n      _gap = 1000 / (_fps || 240);\n      _nextTime = _self.time * 1000 + _gap;\n    },\n    add: function add(callback, once, prioritize) {\n      var func = once ? function (t, d, f, v) {\n        callback(t, d, f, v);\n\n        _self.remove(func);\n      } : callback;\n\n      _self.remove(callback);\n\n      _listeners[prioritize ? \"unshift\" : \"push\"](func);\n\n      _wake();\n\n      return func;\n    },\n    remove: function remove(callback, i) {\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n    },\n    _listeners: _listeners\n  };\n  return _self;\n}(),\n    _wake = function _wake() {\n  return !_tickerActive && _ticker.wake();\n},\n    //also ensures the core classes are initialized.\n\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/\n_easeMap = {},\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n    _quotesExp = /[\"']/g,\n    _parseObjectInString = function _parseObjectInString(value) {\n  //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n  var obj = {},\n      split = value.substr(1, value.length - 3).split(\":\"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n\n  return obj;\n},\n    _valueInParentheses = function _valueInParentheses(value) {\n  var open = value.indexOf(\"(\") + 1,\n      close = value.indexOf(\")\"),\n      nested = value.indexOf(\"(\", open);\n  return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n},\n    _configEaseFromString = function _configEaseFromString(name) {\n  //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n  var split = (name + \"\").split(\"(\"),\n      ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n},\n    _invertEase = function _invertEase(ease) {\n  return function (p) {\n    return 1 - ease(1 - p);\n  };\n},\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n  var child = timeline._first,\n      ease;\n\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n\n    child = child._next;\n  }\n},\n    _parseEase = function _parseEase(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n},\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut(p) {\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n\n  var ease = {\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut\n  },\n      lowercaseName;\n\n  _forEachName(names, function (name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n    }\n  });\n\n  return ease;\n},\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n  return function (p) {\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n  };\n},\n    _configElastic = function _configElastic(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = function easeOut(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  p2 = _2PI / p2; //precalculate to optimize\n\n  ease.config = function (amplitude, period) {\n    return _configElastic(type, amplitude, period);\n  };\n\n  return ease;\n},\n    _configBack = function _configBack(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n\n  var easeOut = function easeOut(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  ease.config = function (overshoot) {\n    return _configBack(type, overshoot);\n  };\n\n  return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function (name, i) {\n  var power = i < 5 ? i + 1 : i;\n\n  _insertEase(name + \",Power\" + (power - 1), i ? function (p) {\n    return Math.pow(p, power);\n  } : function (p) {\n    return p;\n  }, function (p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function (p) {\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n\n(function (n, c) {\n  var n1 = 1 / c,\n      n2 = 2 * n1,\n      n3 = 2.5 * n1,\n      easeOut = function easeOut(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n  };\n\n  _insertEase(\"Bounce\", function (p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n\n_insertEase(\"Expo\", function (p) {\n  return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);\n}); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.\n\n\n_insertEase(\"Circ\", function (p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n\n_insertEase(\"Sine\", function (p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n\n    var p1 = 1 / steps,\n        p2 = steps + (immediateStart ? 0 : 1),\n        p3 = immediateStart ? 1 : 0,\n        max = 1 - _tinyNum;\n    return function (p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function (name) {\n  return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\n\n\nexport var GSCache = function GSCache(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nexport var Animation = /*#__PURE__*/function () {\n  function Animation(vars) {\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n\n    this._ts = 1;\n\n    _setDuration(this, +vars.duration, 1, 1);\n\n    this.data = vars.data;\n\n    if (_context) {\n      this._ctx = _context;\n\n      _context.data.push(this);\n    }\n\n    _tickerActive || _ticker.wake();\n  }\n\n  var _proto = Animation.prototype;\n\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n\n    return this._delay;\n  };\n\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  };\n\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    var parent = this._dp;\n\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime);\n\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n\n      while (parent && parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n      //   this._lock = 1;\n\n      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n      //}\n\n    }\n\n    return this;\n  };\n\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  };\n\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;\n  };\n\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n  };\n\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  } // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n  ;\n\n  _proto.timeScale = function timeScale(value, suppressEvents) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n    }\n\n    if (this._rts === value) {\n      return this;\n    }\n\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n    //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n\n    this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);\n\n    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n\n\n    return _recacheAncestors(this);\n  };\n\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.\n    // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);\n\n\n    if (this._ps !== value) {\n      this._ps = value;\n\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n      }\n    }\n\n    return this;\n  };\n\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n\n    return this._start;\n  };\n\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n  };\n\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp; // _dp = detached parent\n\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n\n  _proto.revert = function revert(config) {\n    if (config === void 0) {\n      config = _revertConfig;\n    }\n\n    var prevIsReverting = _reverting;\n    _reverting = config;\n\n    if (_isRevertWorthy(this)) {\n      this.timeline && this.timeline.revert(config);\n      this.totalTime(-0.01, config.suppressEvents);\n    }\n\n    this.data !== \"nested\" && config.kill !== false && this.kill();\n    _reverting = prevIsReverting;\n    return this;\n  };\n\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this,\n        time = arguments.length ? rawTime : animation.rawTime();\n\n    while (animation) {\n      time = animation._start + time / (Math.abs(animation._ts) || 1);\n      animation = animation._dp;\n    }\n\n    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n  };\n\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._repeat === -2 ? Infinity : this._repeat;\n  };\n\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      var time = this._time;\n      this._rDelay = value;\n\n      _onUpdateTotalDuration(this);\n\n      return time ? this.time(time) : this;\n    }\n\n    return this._rDelay;\n  };\n\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n\n    return this._yoyo;\n  };\n\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n    this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.\n\n    return this;\n  };\n\n  _proto.play = function play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  };\n\n  _proto.reverse = function reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  };\n\n  _proto.pause = function pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  };\n\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n\n      return this;\n    }\n\n    return this._rts < 0;\n  };\n\n  _proto.invalidate = function invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp,\n        start = this._start,\n        rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + \"Params\"] = params);\n        type === \"onUpdate\" && (this._onUpdate = callback);\n      }\n\n      return this;\n    }\n\n    return vars[type];\n  };\n\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function (resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n          _resolve = function _resolve() {\n        var _then = self.then;\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n\n  return Animation;\n}();\n\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\n\nexport var Timeline = /*#__PURE__*/function (_Animation) {\n  _inheritsLoose(Timeline, _Animation);\n\n  function Timeline(vars, position) {\n    var _this;\n\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    _this = _Animation.call(this, vars) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n    vars.reversed && _this.reverse();\n    vars.paused && _this.paused(true);\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n\n  var _proto2 = Timeline.prototype;\n\n  _proto2.to = function to(targets, vars, position) {\n    _createTweenType(0, arguments, this);\n\n    return this;\n  };\n\n  _proto2.from = function from(targets, vars, position) {\n    _createTweenType(1, arguments, this);\n\n    return this;\n  };\n\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    _createTweenType(2, arguments, this);\n\n    return this;\n  };\n\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n  } //ONLY for backward compatibility! Maybe delete?\n  ;\n\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\n        dur = this._dur,\n        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),\n        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n        time,\n        child,\n        next,\n        iteration,\n        cycleDuration,\n        prevPaused,\n        pauseTween,\n        timeScale,\n        prevStart,\n        prevIteration,\n        yoyo,\n        isYoyo;\n    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n\n      if (crossingStart) {\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\n\n          iteration = ~~prevIteration;\n\n          if (iteration && iteration === prevIteration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n\n\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1,\n              doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n\n          !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n            return this;\n          }\n\n          dur = this._dur; // in case the duration changed in the onRepeat\n\n          tDur = this._tDur;\n\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -0.0001;\n            this.render(prevTime, true);\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n          }\n\n          this._lock = 0;\n\n          if (!this._ts && !prevPaused) {\n            return this;\n          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n\n\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n      }\n\n      if (!prevTime && tTime && !suppressEvents && !prevIteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n\n        while (child) {\n          next = child._next;\n\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n\n        while (child) {\n          next = child._prev;\n\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      }\n\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n\n          _setEnd(this);\n\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n          _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n\n    _isNumber(position) || (position = _parsePosition(this, position, child));\n\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function (obj) {\n          return _this2.add(obj, position);\n        });\n        return this;\n      }\n\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n\n    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n  };\n\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n\n    if (tweens === void 0) {\n      tweens = true;\n    }\n\n    if (timelines === void 0) {\n      timelines = true;\n    }\n\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n\n    var a = [],\n        child = this._first;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.getById = function getById(id) {\n    var animations = this.getChildren(1, 1, 1),\n        i = animations.length;\n\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n\n    child.parent === this && _removeLinkedListItem(this, child);\n\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    this._forcing = 1;\n\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n    this._forcing = 0;\n    return this;\n  };\n\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = \"isPause\";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n\n    while (child) {\n      if (child._start === position && child.data === \"isPause\") {\n        _removeFromParent(child);\n      }\n\n      child = child._next;\n    }\n  };\n\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive),\n        i = tweens.length;\n\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n\n    return this;\n  };\n\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n    var a = [],\n        parsedTargets = toArray(targets),\n        child = this._first,\n        isGlobalTime = _isNumber(onlyActive),\n        // a number is interpreted as a global time. If the animation spans\n    children;\n\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  } // potential future feature - targets() on timelines\n  // targets() {\n  // \tlet result = [];\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\n  // \treturn result.filter((v, i) => result.indexOf(v) === i);\n  // }\n  ;\n\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n\n    var tl = this,\n        endTime = _parsePosition(tl, position),\n        _vars = vars,\n        startAt = _vars.startAt,\n        _onStart = _vars.onStart,\n        onStartParams = _vars.onStartParams,\n        immediateRender = _vars.immediateRender,\n        initted,\n        tween = Tween.to(tl, _setDefaults({\n      ease: vars.ease || \"none\",\n      lazy: false,\n      immediateRender: false,\n      time: endTime,\n      overwrite: \"auto\",\n      duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n\n        if (!initted) {\n          var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n          initted = 1;\n        }\n\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n      }\n    }, vars));\n\n    return immediateRender ? tween.render(0) : tween;\n  };\n\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n\n    var child = this._first,\n        labels = this.labels,\n        p;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n\n      child = child._next;\n    }\n\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.invalidate = function invalidate(soft) {\n    var child = this._first;\n    this._lock = 0;\n\n    while (child) {\n      child.invalidate(soft);\n      child = child._next;\n    }\n\n    return _Animation.prototype.invalidate.call(this, soft);\n  };\n\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n\n    var child = this._first,\n        next;\n\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  };\n\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0,\n        self = this,\n        child = self._last,\n        prevStart = _bigNum,\n        prev,\n        start,\n        parent;\n\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n\n    if (self._dirty) {\n      parent = self.parent;\n\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n\n        start = child._start;\n\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n\n        if (start < 0 && child._ts) {\n          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n\n      self._dirty = 0;\n    }\n\n    return self._tDur;\n  };\n\n  Timeline.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n      _lastRenderedFrame = _ticker.frame;\n    }\n\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n\n        child || _ticker.sleep();\n      }\n    }\n  };\n\n  return Timeline;\n}(Animation);\n\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\n\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; //ensure values are strings\n\n  end += \"\";\n\n  if (hasRandom = ~end.indexOf(\"random(\")) {\n    end = _replaceRandom(end);\n  }\n\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n    start = a[0];\n    end = a[1];\n  }\n\n  startNums = start.match(_complexStringNumExp) || [];\n\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === \"rgba(\") {\n      color = 1;\n    }\n\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : \",\",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n\n  pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n\n  pt.fp = funcParam;\n\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop],\n      parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n\n  if (_isString(end)) {\n    if (~end.indexOf(\"random(\")) {\n      end = _replaceRandom(end);\n    }\n\n    if (end.charAt(1) === \"=\") {\n      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n\n      if (pt || pt === 0) {\n        // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n        end = pt;\n      }\n    }\n  }\n\n  if (!optional || parsedStart !== end || _forceAllPropTweens) {\n    if (!isNaN(parsedStart * end) && end !== \"\") {\n      // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n},\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n\n  var copy = {},\n      p;\n\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n\n  return copy;\n},\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n\n      i = plugin._props.length;\n\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n\n  return plugin;\n},\n    _overwritingTween,\n    //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens,\n    _initTween = function _initTween(tween, time, tTime) {\n  var vars = tween.vars,\n      ease = vars.ease,\n      startAt = vars.startAt,\n      immediateRender = vars.immediateRender,\n      lazy = vars.lazy,\n      onUpdate = vars.onUpdate,\n      runBackwards = vars.runBackwards,\n      yoyoEase = vars.yoyoEase,\n      keyframes = vars.keyframes,\n      autoRevert = vars.autoRevert,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets,\n      autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites,\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n  tl && (!keyframes || !ease) && (ease = \"none\");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n\n  if (!tl || keyframes && !vars.stagger) {\n    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n\n    cleanVars = _copyExcluding(vars, _reservedProps);\n\n    if (prevStartAt) {\n      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n\n      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n\n      prevStartAt._lazy = 0;\n    }\n\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: \"isStart\",\n        overwrite: false,\n        parent: parent,\n        immediateRender: true,\n        lazy: !prevStartAt && _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate && function () {\n          return _callback(tween, \"onUpdate\");\n        },\n        stagger: 0\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n\n\n      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n\n      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n\n      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n\n      if (immediateRender) {\n        if (dur && time <= 0 && tTime <= 0) {\n          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n          time && (tween._zTime = time);\n          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n        }\n      }\n    } else if (runBackwards && dur) {\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n      if (!prevStartAt) {\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n\n        p = _setDefaults({\n          overwrite: false,\n          data: \"isFromStart\",\n          //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n          immediateRender: immediateRender,\n          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n          stagger: 0,\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n\n        tween._startAt._sat = tween; // used in globalTime()\n\n        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n        tween._zTime = time;\n\n        if (!immediateRender) {\n          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n\n    tween._pt = tween._ptCache = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n        plugin._props.forEach(function (name) {\n          ptLookup[name] = pt;\n        });\n\n        plugin.priority && (hasPriority = 1);\n      }\n\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n\n\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n  }\n\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n\n  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n},\n    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],\n      pt,\n      rootPT,\n      lookup,\n      i;\n\n  if (!ptCache) {\n    ptCache = tween._ptCache[property] = [];\n    lookup = tween._ptLookup;\n    i = tween._targets.length;\n\n    while (i--) {\n      pt = lookup[i][property];\n\n      if (pt && pt.d && pt.d._pt) {\n        // it's a plugin, so find the nested PropTween\n        pt = pt.d._pt;\n\n        while (pt && pt.p !== property && pt.fp !== property) {\n          // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n          pt = pt._next;\n        }\n      }\n\n      if (!pt) {\n        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n\n        tween.vars[property] = \"+=0\";\n\n        _initTween(tween, time);\n\n        _forceAllPropTweens = 0;\n        return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\n      }\n\n      ptCache.push(pt);\n    }\n  }\n\n  i = ptCache.length;\n\n  while (i--) {\n    rootPT = ptCache[i];\n    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n\n    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n    pt.c = value - pt.s;\n    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n\n    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n  }\n},\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n\n  if (!propertyAliases) {\n    return vars;\n  }\n\n  copy = _merge({}, vars);\n\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(\",\");\n      i = aliases.length;\n\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n\n  return copy;\n},\n    // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n  var ease = obj.ease || easeEach || \"power1.inOut\",\n      p,\n      a;\n\n  if (_isArray(obj)) {\n    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n\n    obj.forEach(function (value, i) {\n      return a.push({\n        t: i / (obj.length - 1) * 100,\n        v: value,\n        e: ease\n      });\n    });\n  } else {\n    for (p in obj) {\n      a = allProps[p] || (allProps[p] = []);\n      p === \"ease\" || a.push({\n        t: parseFloat(prop),\n        v: obj[p],\n        e: ease\n      });\n    }\n  }\n},\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n},\n    _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\",\n    _staggerPropsToSkip = {};\n\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function (name) {\n  return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nexport var Tween = /*#__PURE__*/function (_Animation2) {\n  _inheritsLoose(Tween, _Animation2);\n\n  function Tween(targets, vars, position, skipInherit) {\n    var _this3;\n\n    if (typeof vars === \"number\") {\n      position.duration = vars;\n      vars = position;\n      position = null;\n    }\n\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n    var _this3$vars = _this3.vars,\n        duration = _this3$vars.duration,\n        delay = _this3$vars.delay,\n        immediateRender = _this3$vars.immediateRender,\n        stagger = _this3$vars.stagger,\n        overwrite = _this3$vars.overwrite,\n        keyframes = _this3$vars.keyframes,\n        defaults = _this3$vars.defaults,\n        scrollTrigger = _this3$vars.scrollTrigger,\n        yoyoEase = _this3$vars.yoyoEase,\n        parent = vars.parent || _globalTimeline,\n        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets),\n        tl,\n        i,\n        copy,\n        l,\n        p,\n        curTarget,\n        staggerFunc,\n        staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n\n    _this3._overwrite = overwrite;\n\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: \"nested\",\n        defaults: defaults || {},\n        targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n\n      tl.kill();\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\n      tl._start = 0;\n\n      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n        l = parsedTargets.length;\n        staggerFunc = stagger && distribute(stagger);\n\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n\n        for (i = 0; i < l; i++) {\n          copy = _copyExcluding(vars, _staggerPropsToSkip);\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n\n          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n          tl._ease = _easeMap.none;\n        }\n\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n      } else if (keyframes) {\n        _inheritDefaults(_setDefaults(tl.vars.defaults, {\n          ease: \"none\"\n        }));\n\n        tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n        var time = 0,\n            a,\n            kf,\n            v;\n\n        if (_isArray(keyframes)) {\n          keyframes.forEach(function (frame) {\n            return tl.to(parsedTargets, frame, \">\");\n          });\n          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n        } else {\n          copy = {};\n\n          for (p in keyframes) {\n            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n          }\n\n          for (p in copy) {\n            a = copy[p].sort(function (a, b) {\n              return a.t - b.t;\n            });\n            time = 0;\n\n            for (i = 0; i < a.length; i++) {\n              kf = a[i];\n              v = {\n                ease: kf.e,\n                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n              };\n              v[p] = kf.v;\n              tl.to(parsedTargets, v, time);\n              time += v.duration;\n            }\n          }\n\n          tl.duration() < duration && tl.to({}, {\n            duration: duration - tl.duration()\n          }); // in case keyframes didn't go to 100%\n        }\n      }\n\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = _assertThisInitialized(_this3);\n\n      _globalTimeline.killTweensOf(parsedTargets);\n\n      _overwritingTween = 0;\n    }\n\n    _addToTimeline(parent, _assertThisInitialized(_this3), position);\n\n    vars.reversed && _this3.reverse();\n    vars.paused && _this3.paused(true);\n\n    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n\n      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n\n    }\n\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n\n  var _proto3 = Tween.prototype;\n\n  _proto3.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._tDur,\n        dur = this._dur,\n        isNegative = totalTime < 0,\n        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        time,\n        pt,\n        iteration,\n        cycleDuration,\n        prevIteration,\n        isYoyo,\n        ratio,\n        timeline,\n        yoyoEase;\n\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {\n      // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && isNegative) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\n\n          iteration = ~~prevIteration;\n\n          if (iteration && iteration === prevIteration) {\n            time = dur;\n            iteration--;\n          } else if (time > dur) {\n            time = dur;\n          }\n        }\n\n        isYoyo = this._yoyo && iteration & 1;\n\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n        if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          this._tTime = tTime;\n          return this;\n        }\n\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {\n            // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n\n            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n\n      if (!this._initted) {\n        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n\n          return this;\n        }\n\n        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\n          return this;\n        }\n\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n        this._lazy = 0;\n      }\n\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n\n      if (!prevTime && tTime && !suppressEvents && !prevIteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      pt = this._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n      if (this._onUpdate && !suppressEvents) {\n        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n\n        _callback(this, \"onUpdate\");\n      }\n\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n\n  _proto3.invalidate = function invalidate(soft) {\n    // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n    (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate(soft);\n    return _Animation2.prototype.invalidate.call(this, soft);\n  };\n\n  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n    _tickerActive || _ticker.wake();\n    this._ts || this.play();\n    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),\n        ratio;\n    this._initted || _initTween(this, time);\n    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n    // if (_isObject(property)) { // performance optimization\n    // \tfor (p in property) {\n    // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n    // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    // \t\t}\n    // \t}\n    // } else {\n\n    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n      return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    } //}\n\n\n    _alignPlayhead(this, 0);\n\n    this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n    return this.render(0);\n  };\n\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = \"all\";\n    }\n\n    if (!targets && (!vars || vars === \"all\")) {\n      this._lazy = this._pt = 0;\n      this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);\n      return this;\n    }\n\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n\n      return this;\n    }\n\n    var parsedTargets = this._targets,\n        killingTargets = targets ? toArray(targets) : parsedTargets,\n        propTweenLookup = this._ptLookup,\n        firstPT = this._pt,\n        overwrittenProps,\n        curLookup,\n        curOverwriteProps,\n        props,\n        p,\n        pt,\n        i;\n\n    if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === \"all\" && (this._pt = 0);\n      return _interrupt(this);\n    }\n\n    overwrittenProps = this._op = this._op || [];\n\n    if (vars !== \"all\") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n\n        _forEachName(vars, function (name) {\n          return p[name] = 1;\n        });\n\n        vars = p;\n      }\n\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n\n    i = parsedTargets.length;\n\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n\n        if (vars === \"all\") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n\n          if (pt) {\n            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, \"_pt\");\n            }\n\n            delete curLookup[p];\n          }\n\n          if (curOverwriteProps !== \"all\") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n\n    return this;\n  };\n\n  Tween.to = function to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  };\n\n  Tween.from = function from(targets, vars) {\n    return _createTweenType(1, arguments);\n  };\n\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n  };\n\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n    return _createTweenType(2, arguments);\n  };\n\n  Tween.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  };\n\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n\n  return Tween;\n}(Animation);\n\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n\n\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function (name) {\n  Tween[name] = function () {\n    var tl = new Timeline(),\n        params = _slice.call(arguments, 0);\n\n    params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _setterPlain = function _setterPlain(target, property, value) {\n  return target[property] = value;\n},\n    _setterFunc = function _setterFunc(target, property, value) {\n  return target[property](value);\n},\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n  return target[property](data.fp, value);\n},\n    _setterAttribute = function _setterAttribute(target, property, value) {\n  return target.setAttribute(property, value);\n},\n    _getSetter = function _getSetter(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n},\n    _renderPlain = function _renderPlain(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n},\n    _renderBoolean = function _renderBoolean(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n},\n    _renderComplexString = function _renderComplexString(ratio, data) {\n  var pt = data._pt,\n      s = \"\";\n\n  if (!ratio && data.b) {\n    //b = beginning string\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    //e = ending string\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n\n      pt = pt._next;\n    }\n\n    s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n  }\n\n  data.set(data.t, data.p, s, data);\n},\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\n  var pt = data._pt;\n\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n},\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n  var pt = this._pt,\n      next;\n\n  while (pt) {\n    next = pt._next;\n    pt.p === property && pt.modifier(modifier, tween, target);\n    pt = next;\n  }\n},\n    _killPropTweensOf = function _killPropTweensOf(property) {\n  var pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, \"_pt\");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n\n    pt = next;\n  }\n\n  return !hasNonDependentRemaining;\n},\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n},\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n  var pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n\n    pt = next;\n  }\n\n  parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\n\n\nexport var PropTween = /*#__PURE__*/function () {\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n\n    if (next) {\n      next._prev = this;\n    }\n  }\n\n  var _proto4 = PropTween.prototype;\n\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n\n    this.tween = tween;\n  };\n\n  return PropTween;\n}(); //Initialization tasks\n\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function (name) {\n  return _reservedProps[name] = 1;\n});\n\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: \"root\",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n\nvar _media = [],\n    _listeners = {},\n    _emptyArray = [],\n    _lastMediaTime = 0,\n    _contextID = 0,\n    _dispatch = function _dispatch(type) {\n  return (_listeners[type] || _emptyArray).map(function (f) {\n    return f();\n  });\n},\n    _onMediaChange = function _onMediaChange() {\n  var time = Date.now(),\n      matches = [];\n\n  if (time - _lastMediaTime > 2) {\n    _dispatch(\"matchMediaInit\");\n\n    _media.forEach(function (c) {\n      var queries = c.queries,\n          conditions = c.conditions,\n          match,\n          p,\n          anyMatch,\n          toggled;\n\n      for (p in queries) {\n        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n\n        match && (anyMatch = 1);\n\n        if (match !== conditions[p]) {\n          conditions[p] = match;\n          toggled = 1;\n        }\n      }\n\n      if (toggled) {\n        c.revert();\n        anyMatch && matches.push(c);\n      }\n    });\n\n    _dispatch(\"matchMediaRevert\");\n\n    matches.forEach(function (c) {\n      return c.onMatch(c, function (func) {\n        return c.add(null, func);\n      });\n    });\n    _lastMediaTime = time;\n\n    _dispatch(\"matchMedia\");\n  }\n};\n\nvar Context = /*#__PURE__*/function () {\n  function Context(func, scope) {\n    this.selector = scope && selector(scope);\n    this.data = [];\n    this._r = []; // returned/cleanup functions\n\n    this.isReverted = false;\n    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n\n    func && this.add(func);\n  }\n\n  var _proto5 = Context.prototype;\n\n  _proto5.add = function add(name, func, scope) {\n    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n    // if (name && _isFunction(name.revert)) {\n    // \tthis.data.push(name);\n    // \treturn (name._ctx = this);\n    // }\n    if (_isFunction(name)) {\n      scope = func;\n      func = name;\n      name = _isFunction;\n    }\n\n    var self = this,\n        f = function f() {\n      var prev = _context,\n          prevSelector = self.selector,\n          result;\n      prev && prev !== self && prev.data.push(self);\n      scope && (self.selector = selector(scope));\n      _context = self;\n      result = func.apply(self, arguments);\n      _isFunction(result) && self._r.push(result);\n      _context = prev;\n      self.selector = prevSelector;\n      self.isReverted = false;\n      return result;\n    };\n\n    self.last = f;\n    return name === _isFunction ? f(self, function (func) {\n      return self.add(null, func);\n    }) : name ? self[name] = f : f;\n  };\n\n  _proto5.ignore = function ignore(func) {\n    var prev = _context;\n    _context = null;\n    func(this);\n    _context = prev;\n  };\n\n  _proto5.getTweens = function getTweens() {\n    var a = [];\n    this.data.forEach(function (e) {\n      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n    });\n    return a;\n  };\n\n  _proto5.clear = function clear() {\n    this._r.length = this.data.length = 0;\n  };\n\n  _proto5.kill = function kill(revert, matchMedia) {\n    var _this4 = this;\n\n    if (revert) {\n      (function () {\n        var tweens = _this4.getTweens(),\n            i = _this4.data.length,\n            t;\n\n        while (i--) {\n          // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n          t = _this4.data[i];\n\n          if (t.data === \"isFlip\") {\n            t.revert();\n            t.getChildren(true, true, false).forEach(function (tween) {\n              return tweens.splice(tweens.indexOf(tween), 1);\n            });\n          }\n        } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n\n\n        tweens.map(function (t) {\n          return {\n            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n            t: t\n          };\n        }).sort(function (a, b) {\n          return b.g - a.g || -Infinity;\n        }).forEach(function (o) {\n          return o.t.revert(revert);\n        }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n\n        i = _this4.data.length;\n\n        while (i--) {\n          // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\n          t = _this4.data[i];\n\n          if (t instanceof Timeline) {\n            if (t.data !== \"nested\") {\n              t.scrollTrigger && t.scrollTrigger.revert();\n              t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\n            }\n          } else {\n            !(t instanceof Tween) && t.revert && t.revert(revert);\n          }\n        }\n\n        _this4._r.forEach(function (f) {\n          return f(revert, _this4);\n        });\n\n        _this4.isReverted = true;\n      })();\n    } else {\n      this.data.forEach(function (e) {\n        return e.kill && e.kill();\n      });\n    }\n\n    this.clear();\n\n    if (matchMedia) {\n      var i = _media.length;\n\n      while (i--) {\n        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n        _media[i].id === this.id && _media.splice(i, 1);\n      }\n    }\n  } // killWithCleanup() {\n  // \tthis.kill();\n  // \tthis._r.forEach(f => f(false, this));\n  // }\n  ;\n\n  _proto5.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  return Context;\n}();\n\nvar MatchMedia = /*#__PURE__*/function () {\n  function MatchMedia(scope) {\n    this.contexts = [];\n    this.scope = scope;\n    _context && _context.data.push(this);\n  }\n\n  var _proto6 = MatchMedia.prototype;\n\n  _proto6.add = function add(conditions, func, scope) {\n    _isObject(conditions) || (conditions = {\n      matches: conditions\n    });\n    var context = new Context(0, scope || this.scope),\n        cond = context.conditions = {},\n        mq,\n        p,\n        active;\n    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n\n    this.contexts.push(context);\n    func = context.add(\"onMatch\", func);\n    context.queries = conditions;\n\n    for (p in conditions) {\n      if (p === \"all\") {\n        active = 1;\n      } else {\n        mq = _win.matchMedia(conditions[p]);\n\n        if (mq) {\n          _media.indexOf(context) < 0 && _media.push(context);\n          (cond[p] = mq.matches) && (active = 1);\n          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n        }\n      }\n    }\n\n    active && func(context, function (f) {\n      return context.add(null, f);\n    });\n    return this;\n  } // refresh() {\n  // \tlet time = _lastMediaTime,\n  // \t\tmedia = _media;\n  // \t_lastMediaTime = -1;\n  // \t_media = this.contexts;\n  // \t_onMediaChange();\n  // \t_lastMediaTime = time;\n  // \t_media = media;\n  // }\n  ;\n\n  _proto6.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  _proto6.kill = function kill(revert) {\n    this.contexts.forEach(function (c) {\n      return c.kill(revert, true);\n    });\n  };\n\n  return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args.forEach(function (config) {\n      return _createPlugin(config);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n\n    var getter = _getCache(target || {}).get,\n        format = unit ? _passThrough : _numericIfPossible;\n\n    unit === \"native\" && (unit = \"\");\n    return !target ? target : !property ? function (property, unit, uncache) {\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n\n    if (target.length > 1) {\n      var setters = target.map(function (t) {\n        return gsap.quickSetter(t, property, unit);\n      }),\n          l = setters.length;\n      return function (value) {\n        var i = l;\n\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n\n    target = target[0] || {};\n\n    var Plugin = _plugins[property],\n        cache = _getCache(target),\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\n        // in case it's an alias, like \"rotate\" for \"rotation\".\n    setter = Plugin ? function (value) {\n      var p = new Plugin();\n      _quickTween._pt = 0;\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p.render(1, p);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n\n    return Plugin ? setter : function (value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  quickTo: function quickTo(target, property, vars) {\n    var _setDefaults2;\n\n    var tween = gsap.to(target, _setDefaults((_setDefaults2 = {}, _setDefaults2[property] = \"+=0.1\", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})),\n        func = function func(value, start, startIsRelative) {\n      return tween.resetTo(property, value, start, startIsRelative);\n    };\n\n    func.tween = tween;\n    return func;\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref3) {\n    var name = _ref3.name,\n        effect = _ref3.effect,\n        plugins = _ref3.plugins,\n        defaults = _ref3.defaults,\n        extendTimeline = _ref3.extendTimeline;\n    (plugins || \"\").split(\",\").forEach(function (pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n    });\n\n    _effects[name] = function (targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    };\n\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    var tl = new Timeline(vars),\n        child,\n        next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n    _globalTimeline.remove(tl);\n\n    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n\n    while (child) {\n      next = child._next;\n\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n\n      child = next;\n    }\n\n    _addToTimeline(_globalTimeline, tl, 0);\n\n    return tl;\n  },\n  context: function context(func, scope) {\n    return func ? new Context(func, scope) : _context;\n  },\n  matchMedia: function matchMedia(scope) {\n    return new MatchMedia(scope);\n  },\n  matchMediaRefresh: function matchMediaRefresh() {\n    return _media.forEach(function (c) {\n      var cond = c.conditions,\n          found,\n          p;\n\n      for (p in cond) {\n        if (cond[p]) {\n          cond[p] = false;\n          found = 1;\n        }\n      }\n\n      found && c.revert();\n    }) || _onMediaChange();\n  },\n  addEventListener: function addEventListener(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n  },\n  removeEventListener: function removeEventListener(type, callback) {\n    var a = _listeners[type],\n        i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n  },\n  utils: {\n    wrap: wrap,\n    wrapYoyo: wrapYoyo,\n    distribute: distribute,\n    random: random,\n    snap: snap,\n    normalize: normalize,\n    getUnit: getUnit,\n    clamp: clamp,\n    splitColor: splitColor,\n    toArray: toArray,\n    selector: selector,\n    mapRange: mapRange,\n    pipe: pipe,\n    unitize: unitize,\n    interpolate: interpolate,\n    shuffle: shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween: PropTween,\n    globals: _addGlobal,\n    Tween: Tween,\n    Timeline: Timeline,\n    Animation: Animation,\n    getCache: _getCache,\n    _removeLinkedListItem: _removeLinkedListItem,\n    reverting: function reverting() {\n      return _reverting;\n    },\n    context: function context(toAdd) {\n      if (toAdd && _context) {\n        _context.data.push(toAdd);\n\n        toAdd._ctx = _context;\n      }\n\n      return _context;\n    },\n    suppressOverwrites: function suppressOverwrites(value) {\n      return _suppressOverwrites = value;\n    }\n  }\n};\n\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function (name) {\n  return _gsap[name] = Tween[name];\n});\n\n_ticker.add(Timeline.updateRoot);\n\n_quickTween = _gsap.to({}, {\n  duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\n\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n  var pt = plugin._pt;\n\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n\n  return pt;\n},\n    _addModifiers = function _addModifiers(tween, modifiers) {\n  var targets = tween._targets,\n      p,\n      i,\n      pt;\n\n  for (p in modifiers) {\n    i = targets.length;\n\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          // is a plugin\n          pt = _getPluginPropTween(pt, p);\n        }\n\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n},\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n  return {\n    name: name,\n    headless: 1,\n    rawVars: 1,\n    //don't pre-process function-based values or \"random()\" strings.\n    init: function init(target, vars, tween) {\n      tween._onInit = function (tween) {\n        var temp, p;\n\n        if (_isString(vars)) {\n          temp = {};\n\n          _forEachName(vars, function (name) {\n            return temp[name] = 1;\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n\n\n          vars = temp;\n        }\n\n        if (modifier) {\n          temp = {};\n\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n\n          vars = temp;\n        }\n\n        _addModifiers(tween, vars);\n      };\n    }\n  };\n}; //register core plugins\n\n\nexport var gsap = _gsap.registerPlugin({\n  name: \"attr\",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt, v;\n    this.tween = tween;\n\n    for (p in vars) {\n      v = target.getAttribute(p) || \"\";\n      pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n      pt.op = p;\n      pt.b = v; // record the beginning value so we can revert()\n\n      this._props.push(p);\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n\n    while (pt) {\n      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n\n      pt = pt._next;\n    }\n  }\n}, {\n  name: \"endArray\",\n  headless: 1,\n  init: function init(target, value) {\n    var i = value.length;\n\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n    }\n  }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = \"3.13.0\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0,\n    Power1 = _easeMap.Power1,\n    Power2 = _easeMap.Power2,\n    Power3 = _easeMap.Power3,\n    Power4 = _easeMap.Power4,\n    Linear = _easeMap.Linear,\n    Quad = _easeMap.Quad,\n    Cubic = _easeMap.Cubic,\n    Quart = _easeMap.Quart,\n    Quint = _easeMap.Quint,\n    Strong = _easeMap.Strong,\n    Elastic = _easeMap.Elastic,\n    Back = _easeMap.Back,\n    SteppedEase = _easeMap.SteppedEase,\n    Bounce = _easeMap.Bounce,\n    Sine = _easeMap.Sine,\n    Expo = _easeMap.Expo,\n    Circ = _easeMap.Circ;\nexport { Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ };\nexport { Tween as TweenMax, Tween as TweenLite, Timeline as TimelineMax, Timeline as TimelineLite, gsap as default, wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, selector, mapRange, pipe, unitize, interpolate, shuffle }; //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\nexport { _getProperty, _numExp, _numWithUnitExp, _isString, _isUndefined, _renderComplexString, _relExp, _setDefaults, _removeLinkedListItem, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _replaceRandom, _checkPlugin, _plugins, _ticker, _config, _roundModifier, _round, _missingPlugin, _getSetter, _getCache, _colorExp, _parseRelative };", "/*!\n * CSSPlugin 3.13.0\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { gsap, _getProperty, _numExp, _numWithUnitExp, getUnit, _isString, _isUndefined, _renderComplexString, _relExp, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _checkPlugin, _replaceRandom, _plugins, GSCache, PropTween, _config, _ticker, _round, _missingPlugin, _getSetter, _getCache, _colorExp, _parseRelative, _setDefaults, _removeLinkedListItem //for the commented-out className feature.\n} from \"./gsap-core.js\";\n\nvar _win,\n    _doc,\n    _docElement,\n    _pluginInitted,\n    _tempDiv,\n    _tempDivStyler,\n    _recentSetterPlugin,\n    _reverting,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _transformProps = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _atan2 = Math.atan2,\n    _bigNum = 1e8,\n    _capsExp = /([A-Z])/g,\n    _horizontalExp = /(left|right|width|margin|padding|x)/i,\n    _complexExp = /[\\s,\\(]\\S/,\n    _propertyAliases = {\n  autoAlpha: \"opacity,visibility\",\n  scale: \"scaleX,scaleY\",\n  alpha: \"opacity\"\n},\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n},\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n},\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n},\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n},\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n  return target.style[property] = value;\n},\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\n  return target.style.setProperty(property, value);\n},\n    _setterTransform = function _setterTransform(target, property, value) {\n  return target._gsap[property] = value;\n},\n    _setterScale = function _setterScale(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n},\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n},\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n},\n    _transformProp = \"transform\",\n    _transformOriginProp = _transformProp + \"Origin\",\n    _saveStyle = function _saveStyle(property, isNotCSS) {\n  var _this = this;\n\n  var target = this.target,\n      style = target.style,\n      cache = target._gsap;\n\n  if (property in _transformProps && style) {\n    this.tfm = this.tfm || {};\n\n    if (property !== \"transform\") {\n      property = _propertyAliases[property] || property;\n      ~property.indexOf(\",\") ? property.split(\",\").forEach(function (a) {\n        return _this.tfm[a] = _get(target, a);\n      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n\n      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n    } else {\n      return _propertyAliases.transform.split(\",\").forEach(function (p) {\n        return _saveStyle.call(_this, p, isNotCSS);\n      });\n    }\n\n    if (this.props.indexOf(_transformProp) >= 0) {\n      return;\n    }\n\n    if (cache.svg) {\n      this.svgo = target.getAttribute(\"data-svg-origin\");\n      this.props.push(_transformOriginProp, isNotCSS, \"\");\n    }\n\n    property = _transformProp;\n  }\n\n  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n},\n    _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n  if (style.translate) {\n    style.removeProperty(\"translate\");\n    style.removeProperty(\"scale\");\n    style.removeProperty(\"rotate\");\n  }\n},\n    _revertStyle = function _revertStyle() {\n  var props = this.props,\n      target = this.target,\n      style = target.style,\n      cache = target._gsap,\n      i,\n      p;\n\n  for (i = 0; i < props.length; i += 3) {\n    // stored like this: property, isNotCSS, value\n    if (!props[i + 1]) {\n      props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n    } else if (props[i + 1] === 2) {\n      // non-CSS value (function-based)\n      target[props[i]](props[i + 2]);\n    } else {\n      // non-CSS value (not function-based)\n      target[props[i]] = props[i + 2];\n    }\n  }\n\n  if (this.tfm) {\n    for (p in this.tfm) {\n      cache[p] = this.tfm[p];\n    }\n\n    if (cache.svg) {\n      cache.renderTransform();\n      target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n    }\n\n    i = _reverting();\n\n    if ((!i || !i.isStart) && !style[_transformProp]) {\n      _removeIndependentTransforms(style);\n\n      if (cache.zOrigin && style[_transformOriginProp]) {\n        style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\n\n        cache.zOrigin = 0;\n        cache.renderTransform();\n      }\n\n      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n    }\n  }\n},\n    _getStyleSaver = function _getStyleSaver(target, properties) {\n  var saver = {\n    target: target,\n    props: [],\n    revert: _revertStyle,\n    save: _saveStyle\n  };\n  target._gsap || gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n\n  properties && target.style && target.nodeType && properties.split(\",\").forEach(function (p) {\n    return saver.save(p);\n  }); // make sure it's a DOM node too.\n\n  return saver;\n},\n    _supports3D,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n\n  return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n},\n    _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"),\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n  var e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n\n  while (i-- && !(_prefixes[i] + property in s)) {}\n\n  return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n},\n    _initCore = function _initCore() {\n  if (_windowExists() && window.document) {\n    _win = window;\n    _doc = _win.document;\n    _docElement = _doc.documentElement;\n    _tempDiv = _createElement(\"div\") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement(\"div\");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + \"Origin\";\n    _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n\n    _supports3D = !!_checkPropPrefix(\"perspective\");\n    _reverting = gsap.core.reverting;\n    _pluginInitted = 1;\n  }\n},\n    _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {\n  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n  var owner = target.ownerSVGElement,\n      svg = _createElement(\"svg\", owner && owner.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"),\n      clone = target.cloneNode(true),\n      bbox;\n\n  clone.style.display = \"block\";\n  svg.appendChild(clone);\n\n  _docElement.appendChild(svg);\n\n  try {\n    bbox = clone.getBBox();\n  } catch (e) {}\n\n  svg.removeChild(clone);\n\n  _docElement.removeChild(svg);\n\n  return bbox;\n},\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n  var i = attributesArray.length;\n\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n},\n    _getBBox = function _getBBox(target) {\n  var bounds, cloned;\n\n  try {\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n  } catch (error) {\n    bounds = _getReparentedCloneBBox(target);\n    cloned = 1;\n  }\n\n  bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\n    y: +_getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n},\n    _isSVG = function _isSVG(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n},\n    //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n  if (property) {\n    var style = target.style,\n        first2Chars;\n\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n\n    if (style.removeProperty) {\n      first2Chars = property.substr(0, 2);\n\n      if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n        property = \"-\" + property;\n      }\n\n      style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n    } else {\n      //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n      style.removeAttribute(property);\n    }\n  }\n},\n    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n},\n    _nonStandardLayouts = {\n  grid: 1,\n  flex: 1\n},\n    //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0,\n      curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n  style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === \"svg\",\n      measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"),\n      amount = 100,\n      toPixels = unit === \"px\",\n      toPercent = unit === \"%\",\n      px,\n      parent,\n      cache,\n      isSVG;\n\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n\n  curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n  isSVG = target.getCTM && _isSVG(target);\n\n  if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n    px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);\n  }\n\n  style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n  parent = unit !== \"rem\" && ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n\n  if (!parent || parent === _doc || !parent.appendChild) {\n    parent = _doc.body;\n  }\n\n  cache = parent._gsap;\n\n  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {\n    return _round(curValue / cache.width * amount);\n  } else {\n    if (toPercent && (property === \"height\" || property === \"width\")) {\n      // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\n      var v = target.style[property];\n      target.style[property] = amount + unit;\n      px = target[measureProperty];\n      v ? target.style[property] = v : _removeProperty(target, property);\n    } else {\n      (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n      parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n\n      parent.appendChild(_tempDiv);\n      px = _tempDiv[measureProperty];\n      parent.removeChild(_tempDiv);\n      style.position = \"absolute\";\n    }\n\n    if (horizontal && toPercent) {\n      cache = _getCache(parent);\n      cache.time = _ticker.time;\n      cache.width = parent[measureProperty];\n    }\n  }\n\n  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n},\n    _get = function _get(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n\n  if (property in _propertyAliases && property !== \"transform\") {\n    property = _propertyAliases[property];\n\n    if (~property.indexOf(\",\")) {\n      property = property.split(\",\")[0];\n    }\n  }\n\n  if (_transformProps[property] && property !== \"transform\") {\n    value = _parseTransform(target, uncache);\n    value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n  } else {\n    value = target.style[property];\n\n    if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n    }\n  }\n\n  return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n},\n    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  if (!start || start === \"none\") {\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n    var p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === \"borderColor\") {\n      start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n    }\n  }\n\n  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      endValues;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; // ensure values are strings\n\n  end += \"\";\n\n  if (end.substring(0, 6) === \"var(--\") {\n    end = _getComputedProperty(target, end.substring(4, end.indexOf(\")\")));\n  }\n\n  if (end === \"auto\") {\n    startValue = target.style[prop];\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n  }\n\n  a = [start, end];\n\n  _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n\n\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_numWithUnitExp) || [];\n  endValues = end.match(_numWithUnitExp) || [];\n\n  if (endValues.length) {\n    while (result = _numWithUnitExp.exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n        color = 1;\n      }\n\n      if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + \"\").length);\n        endValue.charAt(1) === \"=\" && (endValue = _parseRelative(startNum, endValue) + startUnit);\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + \"\").length);\n        index = _numWithUnitExp.lastIndex - endUnit.length;\n\n        if (!endUnit) {\n          //if something like \"perspective:300\" is passed in and we must add a unit to the end\n          endUnit = endUnit || _config.units[prop] || startUnit;\n\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n\n        if (startUnit !== endUnit) {\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : \",\",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: endNum - startNum,\n          m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n        };\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n  } else {\n    pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n\n  _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _keywordToPercent = {\n  top: \"0%\",\n  bottom: \"100%\",\n  left: \"0%\",\n  right: \"100%\",\n  center: \"50%\"\n},\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n  var split = value.split(\" \"),\n      x = split[0],\n      y = split[1] || \"50%\";\n\n  if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n    //the user provided them in the wrong order, so flip them\n    value = x;\n    x = y;\n    y = value;\n  }\n\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(\" \");\n},\n    _renderClearProps = function _renderClearProps(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n\n    if (props === \"all\" || props === true) {\n      style.cssText = \"\";\n      clearTransforms = 1;\n    } else {\n      props = props.split(\",\");\n      i = props.length;\n\n      while (--i > -1) {\n        prop = props[i];\n\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n        }\n\n        _removeProperty(target, prop);\n      }\n    }\n\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n\n      if (cache) {\n        cache.svg && target.removeAttribute(\"transform\");\n        style.scale = style.rotate = style.translate = \"none\";\n\n        _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n\n\n        cache.uncache = 1;\n\n        _removeIndependentTransforms(style);\n      }\n    }\n  }\n},\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== \"isFromStart\") {\n      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n\n      plugin._props.push(property);\n\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute(\"class\", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== \"cssText\" && p !== \"length\") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute(\"class\"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== \"=\") ? endValue : startClassList.replace(new RegExp(\"(?:\\\\s|^)\" + endValue.substr(2) + \"(?![\\\\w-])\"), \"\") + ((endValue.charAt(0) === \"+\") ? \" \" + endValue.substr(2) : \"\")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, \"_pt\");\n  \t}\n  \ttarget.setAttribute(\"class\", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute(\"class\", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== \"0\") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, \"className\", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\n    _rotationalProperties = {},\n    _isNullTransform = function _isNullTransform(value) {\n  return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n},\n    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n},\n    _getMatrix = function _getMatrix(target, force2D) {\n  var cache = target._gsap || _getCache(target),\n      style = target.style,\n      matrix = _getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n\n  if (cache.svg && target.getAttribute(\"transform\")) {\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n    temp = style.display;\n    style.display = \"block\";\n    parent = target.parentNode;\n\n    if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.\n      addedToDOM = 1; //flag\n\n      nextSibling = target.nextElementSibling;\n\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n\n    }\n\n    matrix = _getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, \"display\");\n\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n},\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap,\n      matrix = matrixArray || _getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(\" \"),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\n    // \txOrigin -= bounds.x;\n    // \tyOrigin -= bounds.y;\n    // }\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\n  }\n\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n\n  if (pluginToAddPropTweensTo) {\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n  }\n\n  target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n},\n    _parseTransform = function _parseTransform(target, uncache) {\n  var cache = target._gsap || new GSCache(target);\n\n  if (\"x\" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n\n  var style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = \"px\",\n      deg = \"deg\",\n      cs = getComputedStyle(target),\n      origin = _getComputedProperty(target, _transformOriginProp) || \"0\",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n\n  if (cs.translate) {\n    // accommodate independent transforms by combining them into normal ones.\n    if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n      style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n    }\n\n    style.scale = style.rotate = style.translate = \"none\";\n  }\n\n  matrix = _getMatrix(target, cache.svg);\n\n  if (cache.svg) {\n    if (cache.uncache) {\n      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n      t2 = target.getBBox();\n      origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n      t1 = \"\";\n    } else {\n      t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n    }\n\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0]; //a11\n\n    b = matrix[1]; //a21\n\n    c = matrix[2]; //a31\n\n    d = matrix[3]; //a41\n\n    x = a12 = matrix[4];\n    y = a22 = matrix[5]; //2D matrix\n\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      } //3D matrix\n\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG; //rotationX\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      } //rotationY\n\n\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      } //rotationZ\n\n\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n\n      scaleX = _round(Math.sqrt(a * a + b * b + c * c));\n      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n\n    if (cache.svg) {\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n      t1 = target.getAttribute(\"transform\");\n      cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute(\"transform\", t1);\n    }\n  }\n\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n\n  uncache = uncache || cache.uncache;\n  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n  cache.z = z + px;\n  cache.scaleX = _round(scaleX);\n  cache.scaleY = _round(scaleY);\n  cache.rotation = _round(rotation) + deg;\n  cache.rotationX = _round(rotationX) + deg;\n  cache.rotationY = _round(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n\n  if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _config.force3D;\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n},\n    _firstTwoOnly = function _firstTwoOnly(value) {\n  return (value = value.split(\" \"))[0] + \" \" + value[1];\n},\n    //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n  var unit = getUnit(start);\n  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n},\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n  cache.z = \"0px\";\n  cache.rotationY = cache.rotationX = \"0deg\";\n  cache.force3D = 0;\n\n  _renderCSSTransforms(ratio, cache);\n},\n    _zeroDeg = \"0deg\",\n    _zeroPx = \"0px\",\n    _endParenthesis = \") \",\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n  var _ref = cache || this,\n      xPercent = _ref.xPercent,\n      yPercent = _ref.yPercent,\n      x = _ref.x,\n      y = _ref.y,\n      z = _ref.z,\n      rotation = _ref.rotation,\n      rotationY = _ref.rotationY,\n      rotationX = _ref.rotationX,\n      skewX = _ref.skewX,\n      skewY = _ref.skewY,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      transformPerspective = _ref.transformPerspective,\n      force3D = _ref.force3D,\n      target = _ref.target,\n      zOrigin = _ref.zOrigin,\n      transforms = \"\",\n      use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n\n\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n\n  if (transformPerspective !== _zeroPx) {\n    transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n  }\n\n  if (xPercent || yPercent) {\n    transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n  }\n\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n  }\n\n  if (rotation !== _zeroDeg) {\n    transforms += \"rotate(\" + rotation + _endParenthesis;\n  }\n\n  if (rotationY !== _zeroDeg) {\n    transforms += \"rotateY(\" + rotationY + _endParenthesis;\n  }\n\n  if (rotationX !== _zeroDeg) {\n    transforms += \"rotateX(\" + rotationX + _endParenthesis;\n  }\n\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n  }\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n  }\n\n  target.style[_transformProp] = transforms || \"translate(0, 0)\";\n},\n    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n  var _ref2 = cache || this,\n      xPercent = _ref2.xPercent,\n      yPercent = _ref2.yPercent,\n      x = _ref2.x,\n      y = _ref2.y,\n      rotation = _ref2.rotation,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      target = _ref2.target,\n      xOrigin = _ref2.xOrigin,\n      yOrigin = _ref2.yOrigin,\n      xOffset = _ref2.xOffset,\n      yOffset = _ref2.yOffset,\n      forceCSS = _ref2.forceCSS,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n\n  if (skewY) {\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n\n    a11 = _round(a11);\n    a21 = _round(a21);\n    a12 = _round(a12);\n    a22 = _round(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n\n  if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n    tx = _convertToUnit(target, \"x\", x, \"px\");\n    ty = _convertToUnit(target, \"y\", y, \"px\");\n  }\n\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n\n  if (xPercent || yPercent) {\n    //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n    temp = target.getBBox();\n    tx = _round(tx + xPercent / 100 * temp.width);\n    ty = _round(ty + yPercent / 100 * temp.height);\n  }\n\n  temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n  target.setAttribute(\"transform\", temp);\n  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n},\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n  var cap = 360,\n      isString = _isString(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1),\n      change = endNum - startNum,\n      finalValue = startNum + change + \"deg\",\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split(\"_\")[1];\n\n    if (direction === \"short\") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === \"cw\" && change < 0) {\n      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n    } else if (direction === \"ccw\" && change > 0) {\n      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = \"deg\";\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _assign = function _assign(target, source) {\n  // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n  for (var p in source) {\n    target[p] = source[p];\n  }\n\n  return target;\n},\n    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n  //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n  var startCache = _assign({}, target._gsap),\n      exclude = \"perspective,force3D,transformOrigin,svgOrigin\",\n      style = target.style,\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n\n  if (startCache.svg) {\n    startValue = target.getAttribute(\"transform\");\n    target.setAttribute(\"transform\", \"\");\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n\n    _removeProperty(target, _transformProp);\n\n    target.setAttribute(\"transform\", startValue);\n  } else {\n    startValue = getComputedStyle(target)[_transformProp];\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    style[_transformProp] = startValue;\n  }\n\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n      startUnit = getUnit(startValue);\n      endUnit = getUnit(endValue);\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n\n      plugin._props.push(p);\n    }\n  }\n\n  _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n\n\n_forEachName(\"padding,margin,Width,Radius\", function (name, index) {\n  var t = \"Top\",\n      r = \"Right\",\n      b = \"Bottom\",\n      l = \"Left\",\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\n    return index < 2 ? name + side : \"border\" + side + name;\n  });\n\n  _specialProps[index > 1 ? \"border\" + name : name] = function (plugin, target, property, endValue, tween) {\n    var a, vars;\n\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(function (prop) {\n        return _get(plugin, prop, property);\n      });\n      vars = a.join(\" \");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n\n    a = (endValue + \"\").split(\" \");\n    vars = {};\n    props.forEach(function (prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\n\nexport var CSSPlugin = {\n  name: \"css\",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init(target, vars, tween, index, targets) {\n    var props = this._props,\n        style = target.style,\n        startAt = tween.vars.startAt,\n        startValue,\n        endValue,\n        endNum,\n        startNum,\n        type,\n        specialProp,\n        p,\n        startUnit,\n        endUnit,\n        relative,\n        isTransformRelated,\n        transformPropTween,\n        cache,\n        smooth,\n        hasPriority,\n        inlineProps;\n    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n\n    this.styles = this.styles || _getStyleSaver(target);\n    inlineProps = this.styles.props;\n    this.tween = tween;\n\n    for (p in vars) {\n      if (p === \"autoRound\") {\n        continue;\n      }\n\n      endValue = vars[p];\n\n      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n        // plugins\n        continue;\n      }\n\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n\n      if (type === \"function\") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n\n      if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n        endValue = _replaceRandom(endValue);\n      }\n\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === \"--\") {\n        //CSS variable\n        startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n        endValue += \"\";\n        _colorExp.lastIndex = 0;\n\n        if (!_colorExp.test(startValue)) {\n          // colors don't have units\n          startUnit = getUnit(startValue);\n          endUnit = getUnit(endValue);\n        }\n\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n        props.push(p);\n        inlineProps.push(p, 0, style[p]);\n      } else if (type !== \"undefined\") {\n        if (startAt && p in startAt) {\n          // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n          startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          _isString(startValue) && ~startValue.indexOf(\"random(\") && (startValue = _replaceRandom(startValue));\n          getUnit(startValue + \"\") || startValue === \"auto\" || (startValue += _config.units[p] || getUnit(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n\n          (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n        } else {\n          startValue = _get(target, p);\n        }\n\n        startNum = parseFloat(startValue);\n        relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n\n        if (p in _propertyAliases) {\n          if (p === \"autoAlpha\") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n              //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n\n            inlineProps.push(\"visibility\", 0, style.visibility);\n\n            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n          }\n\n          if (p !== \"scale\" && p !== \"transform\") {\n            p = _propertyAliases[p];\n            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n          }\n        }\n\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n\n        if (isTransformRelated) {\n          this.styles.save(p);\n\n          if (type === \"string\" && endValue.substring(0, 6) === \"var(--\") {\n            endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(\")\")));\n            endNum = parseFloat(endValue);\n          }\n\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n\n          if (p === \"scale\") {\n            this._pt = new PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n            this._pt.u = 0;\n            props.push(\"scaleY\", p);\n            p += \"X\";\n          } else if (p === \"transformOrigin\") {\n            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n\n            continue;\n          } else if (p === \"svgOrigin\") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);\n\n            continue;\n          } else if (p === \"smoothOrigin\") {\n            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n\n            continue;\n          } else if (p === \"force3D\") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === \"transform\") {\n            _addRawTransformPTs(this, endValue, target);\n\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + \"\").substr((startNum + \"\").length);\n          endNum || (endNum = 0); // protect against NaN\n\n          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n\n          if (startUnit !== endUnit && endUnit !== \"%\") {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n          } else if (p !== \"parseTransform\") {\n            _missingPlugin(p, endValue);\n\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n        }\n\n        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === \"function\" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));\n        props.push(p);\n      }\n    }\n\n    hasPriority && _sortPropTweensByPriority(this);\n  },\n  render: function render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      var pt = data._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n    var p = _propertyAliases[property];\n    p && p.indexOf(\",\") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : _getSetter(target, property);\n  },\n  core: {\n    _removeProperty: _removeProperty,\n    _getMatrix: _getMatrix\n  }\n};\ngsap.utils.checkPrefix = _checkPropPrefix;\ngsap.core.getStyleSaver = _getStyleSaver;\n\n(function (positionAndScale, rotation, others, aliases) {\n  var all = _forEachName(positionAndScale + \",\" + rotation + \",\" + others, function (name) {\n    _transformProps[name] = 1;\n  });\n\n  _forEachName(rotation, function (name) {\n    _config.units[name] = \"deg\";\n    _rotationalProperties[name] = 1;\n  });\n\n  _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n\n  _forEachName(aliases, function (name) {\n    var split = name.split(\":\");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n\n_forEachName(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function (name) {\n  _config.units[name] = \"px\";\n});\n\ngsap.registerPlugin(CSSPlugin);\nexport { CSSPlugin as default, _getBBox, _createElement, _checkPropPrefix as checkPrefix };", "import { gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ, TweenLite, TimelineLite, TimelineMax } from \"./gsap-core.js\";\nimport { CSSPlugin } from \"./CSSPlugin.js\";\nvar gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\nexport { gsapWithCSS as gsap, gsapWithCSS as default, CSSPlugin, TweenMaxWithCSS as TweenMax, TweenLite, TimelineMax, TimelineLite, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ };", "import { Application, Assets, DisplacementFilter, Sprite, Container} from 'pixi.js';\nimport { constant } from './g_variable';\nimport { addBackground } from './addBackground';\nimport { addWaterOverlay, animateWaterOverlay } from './addWaterOverlay';\nimport { addFish, runFish, createNewFish} from './addFish';\nimport { createBullet,moveBullet } from './bullet';\nimport { initNumber } from './number';\nimport Matter from 'matter-js';\nconst { Engine, Render, Runner, Bodies, World, Events } = Matter;\n// Create a PixiJS application.\nconst app = new Application();\nconst bg_Layer = new Container();\napp.stage.addChild(bg_Layer);\nconst fish_Layer = new Container();\napp.stage.addChild(fish_Layer);\nconst bullet_Layer = new Container();\napp.stage.addChild(bullet_Layer);\nconst bg_Effect_Layer = new Container();\napp.stage.addChild(bg_Effect_Layer);\nconst label_Layer = new Container();\napp.stage.addChild(label_Layer);\n\nlet score = null;\n(async () => {\n  await setup();\n  await preload();\n  addBackground(bg_Layer);\n  addWaterOverlay(bg_Effect_Layer);\n  for(let i = 0; i < constant.fishCount; i++){\n    addFish(fish_Layer,\"init\");\n  }\n  score = initNumber(label_Layer,\"1230\",\"dummy_font2\",80,constant.device.width / 2, 50);\n  score.setNumber(constant.score);\n  app.ticker.add((time) => {\n    animateWaterOverlay(app, time);\n    runFish(fish_Layer)\n    moveBullet(bullet_Layer)\n    createNewFish(fish_Layer)\n    score.setNumber(constant.score);\n  });\n})();\n\nasync function setup() {\n  await app.init({ background: '#1099bb'});\n  app.stage.interactive = true;\n  document.body.appendChild(app.canvas);\n  //app.canvas.style.display = \"block\";\n  app.canvas.style.margin = \"auto\";\n  app.canvas.style.position = \"absolute\";\n  app.canvas.style.top = \"0\";\n  app.canvas.style.bottom = \"0\";\n  app.canvas.style.left = \"0\";\n  app.canvas.style.right = \"0\";\n  app.canvas.width = constant.device.width;\n  app.canvas.height = constant.device.height;\n  app.canvas.resolution = window.devicePixelRatio || 1;\n  app.renderer.resize(constant.device.width, constant.device.height);\n  resize();\n\n  window.addEventListener(\"resize\", function () {\n      resize();\n  });\n\n  app.stage.on('pointerup', (event) => {\n    const pos = event.data.global;\n    //console.log('X:' + pos.x + 'Y:' + pos.y);\n    createBullet(bullet_Layer,constant.device.width / 2,constant.device.height,pos.x,pos.y)\n  });\n\n  \n  \n  \n}\n\nfunction resize(){\n  const canvas = app.canvas;\n  const parent = canvas.parentNode;\n  const parentWidth = parent.clientWidth;\n  const parentHeight = parent.clientHeight;\n    \n  const scale = Math.min(parentWidth / constant.device.width, parentHeight / constant.device.height);\n    \n  canvas.style.width = `${constant.device.width * scale}px`;\n  canvas.style.height = `${constant.device.height * scale}px`;\n  canvas.style.display = \"block\";\n  canvas.style.margin = \"auto\"; // \u7F6E\u4E2D\n}\n\nasync function preload() {\n  const assets = [\n    { alias: 'background', src: 'https://pixijs.com/assets/tutorials/fish-pond/pond_background.jpg' },\n    { alias: 'fish1', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish1.png' },\n    { alias: 'fish2', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish2.png' },\n    { alias: 'fish3', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish3.png' },\n    { alias: 'fish4', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish4.png' },\n    { alias: 'fish5', src: 'https://pixijs.com/assets/tutorials/fish-pond/fish5.png' },\n    { alias: 'fish6', src: 'assets/fish6.png' },\n    { alias: 'fish7', src: 'assets/fish7.png' },\n    { alias: 'fish8', src: 'assets/fish8.png' },\n    { alias: 'fish9', src: 'assets/fish9.png' },\n    { alias: 'fish10', src: 'assets/fish10.png' },\n    { alias: 'fish11', src: 'assets/fish11.png' },\n    { alias: 'fish12', src: 'assets/fish12.png' },\n    { alias: 'fish13', src: 'assets/fish13.png' },\n    { alias: 'fish14', src: 'assets/fish14.png' },\n    { alias: 'overlay', src: 'https://pixijs.com/assets/tutorials/fish-pond/wave_overlay.png' },\n    { alias: 'displacement', src: 'https://pixijs.com/assets/tutorials/fish-pond/displacement_map.png' },\n    { alias: 'bunny', src: 'assets/bunny.png' },\n    { alias: 'bullet', src: 'assets/bullet.png' },\n    { alias: 'dummy_font2', src: 'assets/dummy_font2.fnt' },\n  ];\n  await Assets.load(assets);\n}\n\n"],
  "mappings": "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",
  "names": []
}
